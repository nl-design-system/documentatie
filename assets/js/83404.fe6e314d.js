/*! For license information please see 83404.fe6e314d.js.LICENSE.txt */
'use strict';
(self.webpackChunk_nl_design_system_website = self.webpackChunk_nl_design_system_website || []).push([
 [83404],
 {
  41973: (e, t, r) => {
   var n = r(75271);
   function s(e) {
    for (var t = 'https://reactjs.org/docs/error-decoder.html?invariant=' + e, r = 1; r < arguments.length; r++) t += '&args[]=' + encodeURIComponent(arguments[r]);
    return 'Minified React error #' + e + '; visit ' + t + ' for the full message or use the non-minified dev environment for full errors and additional helpful warnings.';
   }
   var i = Object.prototype.hasOwnProperty,
    a = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
    o = {},
    u = {};
   function l(e) {
    return !!i.call(u, e) || (!i.call(o, e) && (a.test(e) ? (u[e] = !0) : ((o[e] = !0), !1)));
   }
   function p(e, t, r, n, s, i, a) {
    (this.acceptsBooleans = 2 === t || 3 === t || 4 === t), (this.attributeName = n), (this.attributeNamespace = s), (this.mustUseProperty = r), (this.propertyName = e), (this.type = t), (this.sanitizeURL = i), (this.removeEmptyString = a);
   }
   var c = {};
   'children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style'.split(' ').forEach(function (e) {
    c[e] = new p(e, 0, !1, e, null, !1, !1);
   }),
    [
     ['acceptCharset', 'accept-charset'],
     ['className', 'class'],
     ['htmlFor', 'for'],
     ['httpEquiv', 'http-equiv'],
    ].forEach(function (e) {
     var t = e[0];
     c[t] = new p(t, 1, !1, e[1], null, !1, !1);
    }),
    ['contentEditable', 'draggable', 'spellCheck', 'value'].forEach(function (e) {
     c[e] = new p(e, 2, !1, e.toLowerCase(), null, !1, !1);
    }),
    ['autoReverse', 'externalResourcesRequired', 'focusable', 'preserveAlpha'].forEach(function (e) {
     c[e] = new p(e, 2, !1, e, null, !1, !1);
    }),
    'allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope'.split(' ').forEach(function (e) {
     c[e] = new p(e, 3, !1, e.toLowerCase(), null, !1, !1);
    }),
    ['checked', 'multiple', 'muted', 'selected'].forEach(function (e) {
     c[e] = new p(e, 3, !0, e, null, !1, !1);
    }),
    ['capture', 'download'].forEach(function (e) {
     c[e] = new p(e, 4, !1, e, null, !1, !1);
    }),
    ['cols', 'rows', 'size', 'span'].forEach(function (e) {
     c[e] = new p(e, 6, !1, e, null, !1, !1);
    }),
    ['rowSpan', 'start'].forEach(function (e) {
     c[e] = new p(e, 5, !1, e.toLowerCase(), null, !1, !1);
    });
   var h = /[\-:]([a-z])/g;
   function d(e) {
    return e[1].toUpperCase();
   }
   'accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height'.split(' ').forEach(function (e) {
    var t = e.replace(h, d);
    c[t] = new p(t, 1, !1, e, null, !1, !1);
   }),
    'xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type'.split(' ').forEach(function (e) {
     var t = e.replace(h, d);
     c[t] = new p(t, 1, !1, e, 'http://www.w3.org/1999/xlink', !1, !1);
    }),
    ['xml:base', 'xml:lang', 'xml:space'].forEach(function (e) {
     var t = e.replace(h, d);
     c[t] = new p(t, 1, !1, e, 'http://www.w3.org/XML/1998/namespace', !1, !1);
    }),
    ['tabIndex', 'crossOrigin'].forEach(function (e) {
     c[e] = new p(e, 1, !1, e.toLowerCase(), null, !1, !1);
    }),
    (c.xlinkHref = new p('xlinkHref', 1, !1, 'xlink:href', 'http://www.w3.org/1999/xlink', !0, !1)),
    ['src', 'href', 'action', 'formAction'].forEach(function (e) {
     c[e] = new p(e, 1, !1, e.toLowerCase(), null, !0, !0);
    });
   var f = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 },
    m = ['Webkit', 'ms', 'Moz', 'O'];
   Object.keys(f).forEach(function (e) {
    m.forEach(function (t) {
     (t = t + e.charAt(0).toUpperCase() + e.substring(1)), (f[t] = f[e]);
    });
   });
   var y = /["'&<>]/;
   function g(e) {
    if ('boolean' == typeof e || 'number' == typeof e) return '' + e;
    e = '' + e;
    var t = y.exec(e);
    if (t) {
     var r,
      n = '',
      s = 0;
     for (r = t.index; r < e.length; r++) {
      switch (e.charCodeAt(r)) {
       case 34:
        t = '&quot;';
        break;
       case 38:
        t = '&amp;';
        break;
       case 39:
        t = '&#x27;';
        break;
       case 60:
        t = '&lt;';
        break;
       case 62:
        t = '&gt;';
        break;
       default:
        continue;
      }
      s !== r && (n += e.substring(s, r)), (s = r + 1), (n += t);
     }
     e = s !== r ? n + e.substring(s, r) : n;
    }
    return e;
   }
   var D = /([A-Z])/g,
    x = /^ms-/,
    b = Array.isArray;
   function v(e, t) {
    return { insertionMode: e, selectedValue: t };
   }
   var E = new Map();
   function C(e, t, r) {
    if ('object' != typeof r) throw Error(s(62));
    for (var n in ((t = !0), r))
     if (i.call(r, n)) {
      var a = r[n];
      if (null != a && 'boolean' != typeof a && '' !== a) {
       if (0 === n.indexOf('--')) {
        var o = g(n);
        a = g(('' + a).trim());
       } else {
        o = n;
        var u = E.get(o);
        void 0 !== u || ((u = g(o.replace(D, '-$1').toLowerCase().replace(x, '-ms-'))), E.set(o, u)), (o = u), (a = 'number' == typeof a ? (0 === a || i.call(f, n) ? '' + a : a + 'px') : g(('' + a).trim()));
       }
       t ? ((t = !1), e.push(' style="', o, ':', a)) : e.push(';', o, ':', a);
      }
     }
    t || e.push('"');
   }
   function T(e, t, r, n) {
    switch (r) {
     case 'style':
      return void C(e, t, n);
     case 'defaultValue':
     case 'defaultChecked':
     case 'innerHTML':
     case 'suppressContentEditableWarning':
     case 'suppressHydrationWarning':
      return;
    }
    if (!(2 < r.length) || ('o' !== r[0] && 'O' !== r[0]) || ('n' !== r[1] && 'N' !== r[1]))
     if (null !== (t = c.hasOwnProperty(r) ? c[r] : null)) {
      switch (typeof n) {
       case 'function':
       case 'symbol':
        return;
       case 'boolean':
        if (!t.acceptsBooleans) return;
      }
      switch (((r = t.attributeName), t.type)) {
       case 3:
        n && e.push(' ', r, '=""');
        break;
       case 4:
        !0 === n ? e.push(' ', r, '=""') : !1 !== n && e.push(' ', r, '="', g(n), '"');
        break;
       case 5:
        isNaN(n) || e.push(' ', r, '="', g(n), '"');
        break;
       case 6:
        !isNaN(n) && 1 <= n && e.push(' ', r, '="', g(n), '"');
        break;
       default:
        t.sanitizeURL && (n = '' + n), e.push(' ', r, '="', g(n), '"');
      }
     } else if (l(r)) {
      switch (typeof n) {
       case 'function':
       case 'symbol':
        return;
       case 'boolean':
        if ('data-' !== (t = r.toLowerCase().slice(0, 5)) && 'aria-' !== t) return;
      }
      e.push(' ', r, '="', g(n), '"');
     }
   }
   function S(e, t, r) {
    if (null != t) {
     if (null != r) throw Error(s(60));
     if ('object' != typeof t || !('__html' in t)) throw Error(s(61));
     null != (t = t.__html) && e.push('' + t);
    }
   }
   function w(e, t, r, n) {
    e.push(k(r));
    var s,
     a = (r = null);
    for (s in t)
     if (i.call(t, s)) {
      var o = t[s];
      if (null != o)
       switch (s) {
        case 'children':
         r = o;
         break;
        case 'dangerouslySetInnerHTML':
         a = o;
         break;
        default:
         T(e, n, s, o);
       }
     }
    return e.push('>'), S(e, a, r), 'string' == typeof r ? (e.push(g(r)), null) : r;
   }
   var A = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/,
    F = new Map();
   function k(e) {
    var t = F.get(e);
    if (void 0 === t) {
     if (!A.test(e)) throw Error(s(65, e));
     (t = '<' + e), F.set(e, t);
    }
    return t;
   }
   function P(e, t, r, a, o) {
    switch (t) {
     case 'select':
      e.push(k('select'));
      var u = null,
       p = null;
      for (f in r)
       if (i.call(r, f)) {
        var c = r[f];
        if (null != c)
         switch (f) {
          case 'children':
           u = c;
           break;
          case 'dangerouslySetInnerHTML':
           p = c;
           break;
          case 'defaultValue':
          case 'value':
           break;
          default:
           T(e, a, f, c);
         }
       }
      return e.push('>'), S(e, p, u), u;
     case 'option':
      (p = o.selectedValue), e.push(k('option'));
      var h = (c = null),
       d = null,
       f = null;
      for (u in r)
       if (i.call(r, u)) {
        var m = r[u];
        if (null != m)
         switch (u) {
          case 'children':
           c = m;
           break;
          case 'selected':
           d = m;
           break;
          case 'dangerouslySetInnerHTML':
           f = m;
           break;
          case 'value':
           h = m;
          default:
           T(e, a, u, m);
         }
       }
      if (null != p)
       if (
        ((r =
         null !== h
          ? '' + h
          : (function (e) {
             var t = '';
             return (
              n.Children.forEach(e, function (e) {
               null != e && (t += e);
              }),
              t
             );
            })(c)),
        b(p))
       ) {
        for (a = 0; a < p.length; a++)
         if ('' + p[a] === r) {
          e.push(' selected=""');
          break;
         }
       } else '' + p === r && e.push(' selected=""');
      else d && e.push(' selected=""');
      return e.push('>'), S(e, f, c), c;
     case 'textarea':
      for (c in (e.push(k('textarea')), (f = p = u = null), r))
       if (i.call(r, c) && null != (h = r[c]))
        switch (c) {
         case 'children':
          f = h;
          break;
         case 'value':
          u = h;
          break;
         case 'defaultValue':
          p = h;
          break;
         case 'dangerouslySetInnerHTML':
          throw Error(s(91));
         default:
          T(e, a, c, h);
        }
      if ((null === u && null !== p && (u = p), e.push('>'), null != f)) {
       if (null != u) throw Error(s(92));
       if (b(f) && 1 < f.length) throw Error(s(93));
       u = '' + f;
      }
      return 'string' == typeof u && '\n' === u[0] && e.push('\n'), null !== u && e.push(g('' + u)), null;
     case 'input':
      for (p in (e.push(k('input')), (h = f = c = u = null), r))
       if (i.call(r, p) && null != (d = r[p]))
        switch (p) {
         case 'children':
         case 'dangerouslySetInnerHTML':
          throw Error(s(399, 'input'));
         case 'defaultChecked':
          h = d;
          break;
         case 'defaultValue':
          c = d;
          break;
         case 'checked':
          f = d;
          break;
         case 'value':
          u = d;
          break;
         default:
          T(e, a, p, d);
        }
      return null !== f ? T(e, a, 'checked', f) : null !== h && T(e, a, 'checked', h), null !== u ? T(e, a, 'value', u) : null !== c && T(e, a, 'value', c), e.push('/>'), null;
     case 'menuitem':
      for (var y in (e.push(k('menuitem')), r))
       if (i.call(r, y) && null != (u = r[y]))
        switch (y) {
         case 'children':
         case 'dangerouslySetInnerHTML':
          throw Error(s(400));
         default:
          T(e, a, y, u);
        }
      return e.push('>'), null;
     case 'title':
      for (m in (e.push(k('title')), (u = null), r))
       if (i.call(r, m) && null != (p = r[m]))
        switch (m) {
         case 'children':
          u = p;
          break;
         case 'dangerouslySetInnerHTML':
          throw Error(s(434));
         default:
          T(e, a, m, p);
        }
      return e.push('>'), u;
     case 'listing':
     case 'pre':
      for (h in (e.push(k(t)), (p = u = null), r))
       if (i.call(r, h) && null != (c = r[h]))
        switch (h) {
         case 'children':
          u = c;
          break;
         case 'dangerouslySetInnerHTML':
          p = c;
          break;
         default:
          T(e, a, h, c);
        }
      if ((e.push('>'), null != p)) {
       if (null != u) throw Error(s(60));
       if ('object' != typeof p || !('__html' in p)) throw Error(s(61));
       null != (r = p.__html) && ('string' == typeof r && 0 < r.length && '\n' === r[0] ? e.push('\n', r) : e.push('' + r));
      }
      return 'string' == typeof u && '\n' === u[0] && e.push('\n'), u;
     case 'area':
     case 'base':
     case 'br':
     case 'col':
     case 'embed':
     case 'hr':
     case 'img':
     case 'keygen':
     case 'link':
     case 'meta':
     case 'param':
     case 'source':
     case 'track':
     case 'wbr':
      for (var D in (e.push(k(t)), r))
       if (i.call(r, D) && null != (u = r[D]))
        switch (D) {
         case 'children':
         case 'dangerouslySetInnerHTML':
          throw Error(s(399, t));
         default:
          T(e, a, D, u);
        }
      return e.push('/>'), null;
     case 'annotation-xml':
     case 'color-profile':
     case 'font-face':
     case 'font-face-src':
     case 'font-face-uri':
     case 'font-face-format':
     case 'font-face-name':
     case 'missing-glyph':
      return w(e, r, t, a);
     case 'html':
      return 0 === o.insertionMode && e.push('<!DOCTYPE html>'), w(e, r, t, a);
     default:
      if (-1 === t.indexOf('-') && 'string' != typeof r.is) return w(e, r, t, a);
      for (d in (e.push(k(t)), (p = u = null), r))
       if (i.call(r, d) && null != (c = r[d]))
        switch (d) {
         case 'children':
          u = c;
          break;
         case 'dangerouslySetInnerHTML':
          p = c;
          break;
         case 'style':
          C(e, a, c);
          break;
         case 'suppressContentEditableWarning':
         case 'suppressHydrationWarning':
          break;
         default:
          l(d) && 'function' != typeof c && 'symbol' != typeof c && e.push(' ', d, '="', g(c), '"');
        }
      return e.push('>'), S(e, p, u), u;
    }
   }
   function I(e, t, r) {
    if ((e.push('\x3c!--$?--\x3e<template id="'), null === r)) throw Error(s(395));
    return e.push(r), e.push('"></template>');
   }
   var N = /[<\u2028\u2029]/g;
   function B(e) {
    return JSON.stringify(e).replace(N, function (e) {
     switch (e) {
      case '<':
       return '\\u003c';
      case '\u2028':
       return '\\u2028';
      case '\u2029':
       return '\\u2029';
      default:
       throw Error('escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React');
     }
    });
   }
   function _(e, t, r, n) {
    return r.generateStaticMarkup ? (e.push(g(t)), !1) : ('' === t ? (e = n) : (n && e.push('\x3c!-- --\x3e'), e.push(g(t)), (e = !0)), e);
   }
   var L = Object.assign,
    O = Symbol.for('react.element'),
    M = Symbol.for('react.portal'),
    j = Symbol.for('react.fragment'),
    R = Symbol.for('react.strict_mode'),
    q = Symbol.for('react.profiler'),
    U = Symbol.for('react.provider'),
    $ = Symbol.for('react.context'),
    H = Symbol.for('react.forward_ref'),
    z = Symbol.for('react.suspense'),
    V = Symbol.for('react.suspense_list'),
    W = Symbol.for('react.memo'),
    J = Symbol.for('react.lazy'),
    K = Symbol.for('react.scope'),
    G = Symbol.for('react.debug_trace_mode'),
    X = Symbol.for('react.legacy_hidden'),
    Y = Symbol.for('react.default_value'),
    Q = Symbol.iterator;
   function Z(e) {
    if (null == e) return null;
    if ('function' == typeof e) return e.displayName || e.name || null;
    if ('string' == typeof e) return e;
    switch (e) {
     case j:
      return 'Fragment';
     case M:
      return 'Portal';
     case q:
      return 'Profiler';
     case R:
      return 'StrictMode';
     case z:
      return 'Suspense';
     case V:
      return 'SuspenseList';
    }
    if ('object' == typeof e)
     switch (e.$$typeof) {
      case $:
       return (e.displayName || 'Context') + '.Consumer';
      case U:
       return (e._context.displayName || 'Context') + '.Provider';
      case H:
       var t = e.render;
       return (e = e.displayName) || (e = '' !== (e = t.displayName || t.name || '') ? 'ForwardRef(' + e + ')' : 'ForwardRef'), e;
      case W:
       return null !== (t = e.displayName || null) ? t : Z(e.type) || 'Memo';
      case J:
       (t = e._payload), (e = e._init);
       try {
        return Z(e(t));
       } catch (r) {}
     }
    return null;
   }
   var ee = {};
   function te(e, t) {
    if (!(e = e.contextTypes)) return ee;
    var r,
     n = {};
    for (r in e) n[r] = t[r];
    return n;
   }
   var re = null;
   function ne(e, t) {
    if (e !== t) {
     (e.context._currentValue2 = e.parentValue), (e = e.parent);
     var r = t.parent;
     if (null === e) {
      if (null !== r) throw Error(s(401));
     } else {
      if (null === r) throw Error(s(401));
      ne(e, r);
     }
     t.context._currentValue2 = t.value;
    }
   }
   function se(e) {
    (e.context._currentValue2 = e.parentValue), null !== (e = e.parent) && se(e);
   }
   function ie(e) {
    var t = e.parent;
    null !== t && ie(t), (e.context._currentValue2 = e.value);
   }
   function ae(e, t) {
    if (((e.context._currentValue2 = e.parentValue), null === (e = e.parent))) throw Error(s(402));
    e.depth === t.depth ? ne(e, t) : ae(e, t);
   }
   function oe(e, t) {
    var r = t.parent;
    if (null === r) throw Error(s(402));
    e.depth === r.depth ? ne(e, r) : oe(e, r), (t.context._currentValue2 = t.value);
   }
   function ue(e) {
    var t = re;
    t !== e && (null === t ? ie(e) : null === e ? se(t) : t.depth === e.depth ? ne(t, e) : t.depth > e.depth ? ae(t, e) : oe(t, e), (re = e));
   }
   var le = {
    isMounted: function () {
     return !1;
    },
    enqueueSetState: function (e, t) {
     null !== (e = e._reactInternals).queue && e.queue.push(t);
    },
    enqueueReplaceState: function (e, t) {
     ((e = e._reactInternals).replace = !0), (e.queue = [t]);
    },
    enqueueForceUpdate: function () {},
   };
   function pe(e, t, r, n) {
    var s = void 0 !== e.state ? e.state : null;
    (e.updater = le), (e.props = r), (e.state = s);
    var i = { queue: [], replace: !1 };
    e._reactInternals = i;
    var a = t.contextType;
    if (((e.context = 'object' == typeof a && null !== a ? a._currentValue2 : n), 'function' == typeof (a = t.getDerivedStateFromProps) && ((s = null == (a = a(r, s)) ? s : L({}, s, a)), (e.state = s)), 'function' != typeof t.getDerivedStateFromProps && 'function' != typeof e.getSnapshotBeforeUpdate && ('function' == typeof e.UNSAFE_componentWillMount || 'function' == typeof e.componentWillMount)))
     if (((t = e.state), 'function' == typeof e.componentWillMount && e.componentWillMount(), 'function' == typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), t !== e.state && le.enqueueReplaceState(e, e.state, null), null !== i.queue && 0 < i.queue.length))
      if (((t = i.queue), (a = i.replace), (i.queue = null), (i.replace = !1), a && 1 === t.length)) e.state = t[0];
      else {
       for (i = a ? t[0] : e.state, s = !0, a = a ? 1 : 0; a < t.length; a++) {
        var o = t[a];
        null != (o = 'function' == typeof o ? o.call(e, i, r, n) : o) && (s ? ((s = !1), (i = L({}, i, o))) : L(i, o));
       }
       e.state = i;
      }
     else i.queue = null;
   }
   var ce = { id: 1, overflow: '' };
   function he(e, t, r) {
    var n = e.id;
    e = e.overflow;
    var s = 32 - de(n) - 1;
    (n &= ~(1 << s)), (r += 1);
    var i = 32 - de(t) + s;
    if (30 < i) {
     var a = s - (s % 5);
     return (i = (n & ((1 << a) - 1)).toString(32)), (n >>= a), (s -= a), { id: (1 << (32 - de(t) + s)) | (r << s) | n, overflow: i + e };
    }
    return { id: (1 << i) | (r << s) | n, overflow: e };
   }
   var de = Math.clz32
     ? Math.clz32
     : function (e) {
        return 0 === (e >>>= 0) ? 32 : (31 - ((fe(e) / me) | 0)) | 0;
       },
    fe = Math.log,
    me = Math.LN2;
   var ye =
     'function' == typeof Object.is
      ? Object.is
      : function (e, t) {
         return (e === t && (0 !== e || 1 / e == 1 / t)) || (e != e && t != t);
        },
    ge = null,
    De = null,
    xe = null,
    be = null,
    ve = !1,
    Ee = !1,
    Ce = 0,
    Te = null,
    Se = 0;
   function we() {
    if (null === ge) throw Error(s(321));
    return ge;
   }
   function Ae() {
    if (0 < Se) throw Error(s(312));
    return { memoizedState: null, queue: null, next: null };
   }
   function Fe() {
    return null === be ? (null === xe ? ((ve = !1), (xe = be = Ae())) : ((ve = !0), (be = xe))) : null === be.next ? ((ve = !1), (be = be.next = Ae())) : ((ve = !0), (be = be.next)), be;
   }
   function ke() {
    (De = ge = null), (Ee = !1), (xe = null), (Se = 0), (be = Te = null);
   }
   function Pe(e, t) {
    return 'function' == typeof t ? t(e) : t;
   }
   function Ie(e, t, r) {
    if (((ge = we()), (be = Fe()), ve)) {
     var n = be.queue;
     if (((t = n.dispatch), null !== Te && void 0 !== (r = Te.get(n)))) {
      Te.delete(n), (n = be.memoizedState);
      do {
       (n = e(n, r.action)), (r = r.next);
      } while (null !== r);
      return (be.memoizedState = n), [n, t];
     }
     return [be.memoizedState, t];
    }
    return (e = e === Pe ? ('function' == typeof t ? t() : t) : void 0 !== r ? r(t) : t), (be.memoizedState = e), (e = (e = be.queue = { last: null, dispatch: null }).dispatch = Be.bind(null, ge, e)), [be.memoizedState, e];
   }
   function Ne(e, t) {
    if (((ge = we()), (t = void 0 === t ? null : t), null !== (be = Fe()))) {
     var r = be.memoizedState;
     if (null !== r && null !== t) {
      var n = r[1];
      e: if (null === n) n = !1;
      else {
       for (var s = 0; s < n.length && s < t.length; s++)
        if (!ye(t[s], n[s])) {
         n = !1;
         break e;
        }
       n = !0;
      }
      if (n) return r[0];
     }
    }
    return (e = e()), (be.memoizedState = [e, t]), e;
   }
   function Be(e, t, r) {
    if (25 <= Se) throw Error(s(301));
    if (e === ge)
     if (((Ee = !0), (e = { action: r, next: null }), null === Te && (Te = new Map()), void 0 === (r = Te.get(t)))) Te.set(t, e);
     else {
      for (t = r; null !== t.next; ) t = t.next;
      t.next = e;
     }
   }
   function _e() {
    throw Error(s(394));
   }
   function Le() {}
   var Oe = {
     readContext: function (e) {
      return e._currentValue2;
     },
     useContext: function (e) {
      return we(), e._currentValue2;
     },
     useMemo: Ne,
     useReducer: Ie,
     useRef: function (e) {
      ge = we();
      var t = (be = Fe()).memoizedState;
      return null === t ? ((e = { current: e }), (be.memoizedState = e)) : t;
     },
     useState: function (e) {
      return Ie(Pe, e);
     },
     useInsertionEffect: Le,
     useLayoutEffect: function () {},
     useCallback: function (e, t) {
      return Ne(function () {
       return e;
      }, t);
     },
     useImperativeHandle: Le,
     useEffect: Le,
     useDebugValue: Le,
     useDeferredValue: function (e) {
      return we(), e;
     },
     useTransition: function () {
      return we(), [!1, _e];
     },
     useId: function () {
      var e = De.treeContext,
       t = e.overflow;
      e = ((e = e.id) & ~(1 << (32 - de(e) - 1))).toString(32) + t;
      var r = Me;
      if (null === r) throw Error(s(404));
      return (t = Ce++), (e = ':' + r.idPrefix + 'R' + e), 0 < t && (e += 'H' + t.toString(32)), e + ':';
     },
     useMutableSource: function (e, t) {
      return we(), t(e._source);
     },
     useSyncExternalStore: function (e, t, r) {
      if (void 0 === r) throw Error(s(407));
      return r();
     },
    },
    Me = null,
    je = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;
   function Re(e) {
    return console.error(e), null;
   }
   function qe() {}
   function Ue(e, t, r, n, s, i, a, o) {
    e.allPendingTasks++, null === r ? e.pendingRootTasks++ : r.pendingTasks++;
    var u = {
     node: t,
     ping: function () {
      var t = e.pingedTasks;
      t.push(u), 1 === t.length && rt(e);
     },
     blockedBoundary: r,
     blockedSegment: n,
     abortSet: s,
     legacyContext: i,
     context: a,
     treeContext: o,
    };
    return s.add(u), u;
   }
   function $e(e, t, r, n, s, i) {
    return { status: 0, id: -1, index: t, parentFlushed: !1, chunks: [], children: [], formatContext: n, boundary: r, lastPushedText: s, textEmbedded: i };
   }
   function He(e, t) {
    if (null != (e = e.onError(t)) && 'string' != typeof e) throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof e + '" instead');
    return e;
   }
   function ze(e, t) {
    var r = e.onShellError;
    r(t), (r = e.onFatalError)(t), null !== e.destination ? ((e.status = 2), e.destination.destroy(t)) : ((e.status = 1), (e.fatalError = t));
   }
   function Ve(e, t, r, n, s) {
    for (ge = {}, De = t, Ce = 0, e = r(n, s); Ee; ) (Ee = !1), (Ce = 0), (Se += 1), (be = null), (e = r(n, s));
    return ke(), e;
   }
   function We(e, t, r, n) {
    var i = r.render(),
     a = n.childContextTypes;
    if (null != a) {
     var o = t.legacyContext;
     if ('function' != typeof r.getChildContext) n = o;
     else {
      for (var u in (r = r.getChildContext())) if (!(u in a)) throw Error(s(108, Z(n) || 'Unknown', u));
      n = L({}, o, r);
     }
     (t.legacyContext = n), Ge(e, t, i), (t.legacyContext = o);
    } else Ge(e, t, i);
   }
   function Je(e, t) {
    if (e && e.defaultProps) {
     for (var r in ((t = L({}, t)), (e = e.defaultProps))) void 0 === t[r] && (t[r] = e[r]);
     return t;
    }
    return t;
   }
   function Ke(e, t, r, n, i) {
    if ('function' == typeof r)
     if (r.prototype && r.prototype.isReactComponent) {
      i = te(r, t.legacyContext);
      var a = r.contextType;
      pe((a = new r(n, 'object' == typeof a && null !== a ? a._currentValue2 : i)), r, n, i), We(e, t, a, r);
     } else {
      i = Ve(e, t, r, n, (a = te(r, t.legacyContext)));
      var o = 0 !== Ce;
      if ('object' == typeof i && null !== i && 'function' == typeof i.render && void 0 === i.$$typeof) pe(i, r, n, a), We(e, t, i, r);
      else if (o) {
       (n = t.treeContext), (t.treeContext = he(n, 1, 0));
       try {
        Ge(e, t, i);
       } finally {
        t.treeContext = n;
       }
      } else Ge(e, t, i);
     }
    else {
     if ('string' != typeof r) {
      switch (r) {
       case X:
       case G:
       case R:
       case q:
       case j:
       case V:
        return void Ge(e, t, n.children);
       case K:
        throw Error(s(343));
       case z:
        e: {
         (r = t.blockedBoundary), (i = t.blockedSegment), (a = n.fallback), (n = n.children);
         var u = { id: null, rootSegmentID: -1, parentFlushed: !1, pendingTasks: 0, forceClientRender: !1, completedSegments: [], byteSize: 0, fallbackAbortableTasks: (o = new Set()), errorDigest: null },
          l = $e(0, i.chunks.length, u, i.formatContext, !1, !1);
         i.children.push(l), (i.lastPushedText = !1);
         var p = $e(0, 0, null, i.formatContext, !1, !1);
         (p.parentFlushed = !0), (t.blockedBoundary = u), (t.blockedSegment = p);
         try {
          if ((Ye(e, t, n), e.responseState.generateStaticMarkup || (p.lastPushedText && p.textEmbedded && p.chunks.push('\x3c!-- --\x3e')), (p.status = 1), et(u, p), 0 === u.pendingTasks)) break e;
         } catch (c) {
          (p.status = 4), (u.forceClientRender = !0), (u.errorDigest = He(e, c));
         } finally {
          (t.blockedBoundary = r), (t.blockedSegment = i);
         }
         (t = Ue(e, a, r, l, o, t.legacyContext, t.context, t.treeContext)), e.pingedTasks.push(t);
        }
        return;
      }
      if ('object' == typeof r && null !== r)
       switch (r.$$typeof) {
        case H:
         if (((n = Ve(e, t, r.render, n, i)), 0 !== Ce)) {
          (r = t.treeContext), (t.treeContext = he(r, 1, 0));
          try {
           Ge(e, t, n);
          } finally {
           t.treeContext = r;
          }
         } else Ge(e, t, n);
         return;
        case W:
         return void Ke(e, t, (r = r.type), (n = Je(r, n)), i);
        case U:
         if (((i = n.children), (r = r._context), (n = n.value), (a = r._currentValue2), (r._currentValue2 = n), (re = n = { parent: (o = re), depth: null === o ? 0 : o.depth + 1, context: r, parentValue: a, value: n }), (t.context = n), Ge(e, t, i), null === (e = re))) throw Error(s(403));
         return (n = e.parentValue), (e.context._currentValue2 = n === Y ? e.context._defaultValue : n), (e = re = e.parent), void (t.context = e);
        case $:
         return void Ge(e, t, (n = (n = n.children)(r._currentValue2)));
        case J:
         return void Ke(e, t, (r = (i = r._init)(r._payload)), (n = Je(r, n)), void 0);
       }
      throw Error(s(130, null == r ? r : typeof r, ''));
     }
     switch (
      ((a = P((i = t.blockedSegment).chunks, r, n, e.responseState, i.formatContext)),
      (i.lastPushedText = !1),
      (o = i.formatContext),
      (i.formatContext = (function (e, t, r) {
       switch (t) {
        case 'select':
         return v(1, null != r.value ? r.value : r.defaultValue);
        case 'svg':
         return v(2, null);
        case 'math':
         return v(3, null);
        case 'foreignObject':
         return v(1, null);
        case 'table':
         return v(4, null);
        case 'thead':
        case 'tbody':
        case 'tfoot':
         return v(5, null);
        case 'colgroup':
         return v(7, null);
        case 'tr':
         return v(6, null);
       }
       return 4 <= e.insertionMode || 0 === e.insertionMode ? v(1, null) : e;
      })(o, r, n)),
      Ye(e, t, a),
      (i.formatContext = o),
      r)
     ) {
      case 'area':
      case 'base':
      case 'br':
      case 'col':
      case 'embed':
      case 'hr':
      case 'img':
      case 'input':
      case 'keygen':
      case 'link':
      case 'meta':
      case 'param':
      case 'source':
      case 'track':
      case 'wbr':
       break;
      default:
       i.chunks.push('</', r, '>');
     }
     i.lastPushedText = !1;
    }
   }
   function Ge(e, t, r) {
    if (((t.node = r), 'object' == typeof r && null !== r)) {
     switch (r.$$typeof) {
      case O:
       return void Ke(e, t, r.type, r.props, r.ref);
      case M:
       throw Error(s(257));
      case J:
       var n = r._init;
       return void Ge(e, t, (r = n(r._payload)));
     }
     if (b(r)) return void Xe(e, t, r);
     if ((null === r || 'object' != typeof r ? (n = null) : (n = 'function' == typeof (n = (Q && r[Q]) || r['@@iterator']) ? n : null), n && (n = n.call(r)))) {
      if (!(r = n.next()).done) {
       var i = [];
       do {
        i.push(r.value), (r = n.next());
       } while (!r.done);
       Xe(e, t, i);
      }
      return;
     }
     throw ((e = Object.prototype.toString.call(r)), Error(s(31, '[object Object]' === e ? 'object with keys {' + Object.keys(r).join(', ') + '}' : e)));
    }
    'string' == typeof r ? ((n = t.blockedSegment).lastPushedText = _(t.blockedSegment.chunks, r, e.responseState, n.lastPushedText)) : 'number' == typeof r && ((n = t.blockedSegment).lastPushedText = _(t.blockedSegment.chunks, '' + r, e.responseState, n.lastPushedText));
   }
   function Xe(e, t, r) {
    for (var n = r.length, s = 0; s < n; s++) {
     var i = t.treeContext;
     t.treeContext = he(i, n, s);
     try {
      Ye(e, t, r[s]);
     } finally {
      t.treeContext = i;
     }
    }
   }
   function Ye(e, t, r) {
    var n = t.blockedSegment.formatContext,
     s = t.legacyContext,
     i = t.context;
    try {
     return Ge(e, t, r);
    } catch (u) {
     if ((ke(), 'object' != typeof u || null === u || 'function' != typeof u.then)) throw ((t.blockedSegment.formatContext = n), (t.legacyContext = s), (t.context = i), ue(i), u);
     r = u;
     var a = t.blockedSegment,
      o = $e(0, a.chunks.length, null, a.formatContext, a.lastPushedText, !0);
     a.children.push(o), (a.lastPushedText = !1), (e = Ue(e, t.node, t.blockedBoundary, o, t.abortSet, t.legacyContext, t.context, t.treeContext).ping), r.then(e, e), (t.blockedSegment.formatContext = n), (t.legacyContext = s), (t.context = i), ue(i);
    }
   }
   function Qe(e) {
    var t = e.blockedBoundary;
    ((e = e.blockedSegment).status = 3), tt(this, t, e);
   }
   function Ze(e, t, r) {
    var n = e.blockedBoundary;
    (e.blockedSegment.status = 3),
     null === n
      ? (t.allPendingTasks--, 2 !== t.status && ((t.status = 2), null !== t.destination && t.destination.push(null)))
      : (n.pendingTasks--,
        n.forceClientRender || ((n.forceClientRender = !0), (e = void 0 === r ? Error(s(432)) : r), (n.errorDigest = t.onError(e)), n.parentFlushed && t.clientRenderedBoundaries.push(n)),
        n.fallbackAbortableTasks.forEach(function (e) {
         return Ze(e, t, r);
        }),
        n.fallbackAbortableTasks.clear(),
        t.allPendingTasks--,
        0 === t.allPendingTasks && (n = t.onAllReady)());
   }
   function et(e, t) {
    if (0 === t.chunks.length && 1 === t.children.length && null === t.children[0].boundary) {
     var r = t.children[0];
     (r.id = t.id), (r.parentFlushed = !0), 1 === r.status && et(e, r);
    } else e.completedSegments.push(t);
   }
   function tt(e, t, r) {
    if (null === t) {
     if (r.parentFlushed) {
      if (null !== e.completedRootSegment) throw Error(s(389));
      e.completedRootSegment = r;
     }
     e.pendingRootTasks--, 0 === e.pendingRootTasks && ((e.onShellError = qe), (t = e.onShellReady)());
    } else t.pendingTasks--, t.forceClientRender || (0 === t.pendingTasks ? (r.parentFlushed && 1 === r.status && et(t, r), t.parentFlushed && e.completedBoundaries.push(t), t.fallbackAbortableTasks.forEach(Qe, e), t.fallbackAbortableTasks.clear()) : r.parentFlushed && 1 === r.status && (et(t, r), 1 === t.completedSegments.length && t.parentFlushed && e.partialBoundaries.push(t)));
    e.allPendingTasks--, 0 === e.allPendingTasks && (e = e.onAllReady)();
   }
   function rt(e) {
    if (2 !== e.status) {
     var t = re,
      r = je.current;
     je.current = Oe;
     var n = Me;
     Me = e.responseState;
     try {
      var s,
       i = e.pingedTasks;
      for (s = 0; s < i.length; s++) {
       var a = i[s],
        o = e,
        u = a.blockedSegment;
       if (0 === u.status) {
        ue(a.context);
        try {
         Ge(o, a, a.node), o.responseState.generateStaticMarkup || (u.lastPushedText && u.textEmbedded && u.chunks.push('\x3c!-- --\x3e')), a.abortSet.delete(a), (u.status = 1), tt(o, a.blockedBoundary, u);
        } catch (d) {
         if ((ke(), 'object' == typeof d && null !== d && 'function' == typeof d.then)) {
          var l = a.ping;
          d.then(l, l);
         } else {
          a.abortSet.delete(a), (u.status = 4);
          var p = a.blockedBoundary,
           c = d,
           h = He(o, c);
          if ((null === p ? ze(o, c) : (p.pendingTasks--, p.forceClientRender || ((p.forceClientRender = !0), (p.errorDigest = h), p.parentFlushed && o.clientRenderedBoundaries.push(p))), o.allPendingTasks--, 0 === o.allPendingTasks)) (0, o.onAllReady)();
         }
        }
       }
      }
      i.splice(0, s), null !== e.destination && ut(e, e.destination);
     } catch (d) {
      He(e, d), ze(e, d);
     } finally {
      (Me = n), (je.current = r), r === Oe && ue(t);
     }
    }
   }
   function nt(e, t, r) {
    switch (((r.parentFlushed = !0), r.status)) {
     case 0:
      var n = (r.id = e.nextSegmentId++);
      return (r.lastPushedText = !1), (r.textEmbedded = !1), (e = e.responseState), t.push('<template id="'), t.push(e.placeholderPrefix), (e = n.toString(16)), t.push(e), t.push('"></template>');
     case 1:
      r.status = 2;
      var i = !0;
      n = r.chunks;
      var a = 0;
      r = r.children;
      for (var o = 0; o < r.length; o++) {
       for (i = r[o]; a < i.index; a++) t.push(n[a]);
       i = st(e, t, i);
      }
      for (; a < n.length - 1; a++) t.push(n[a]);
      return a < n.length && (i = t.push(n[a])), i;
     default:
      throw Error(s(390));
    }
   }
   function st(e, t, r) {
    var n = r.boundary;
    if (null === n) return nt(e, t, r);
    if (((n.parentFlushed = !0), n.forceClientRender)) return e.responseState.generateStaticMarkup || ((n = n.errorDigest), t.push('\x3c!--$!--\x3e'), t.push('<template'), n && (t.push(' data-dgst="'), (n = g(n)), t.push(n), t.push('"')), t.push('></template>')), nt(e, t, r), (e = !!e.responseState.generateStaticMarkup || t.push('\x3c!--/$--\x3e'));
    if (0 < n.pendingTasks) {
     (n.rootSegmentID = e.nextSegmentId++), 0 < n.completedSegments.length && e.partialBoundaries.push(n);
     var i = e.responseState,
      a = i.nextSuspenseID++;
     return (i = i.boundaryPrefix + a.toString(16)), (n = n.id = i), I(t, e.responseState, n), nt(e, t, r), t.push('\x3c!--/$--\x3e');
    }
    if (n.byteSize > e.progressiveChunkSize) return (n.rootSegmentID = e.nextSegmentId++), e.completedBoundaries.push(n), I(t, e.responseState, n.id), nt(e, t, r), t.push('\x3c!--/$--\x3e');
    if ((e.responseState.generateStaticMarkup || t.push('\x3c!--$--\x3e'), 1 !== (r = n.completedSegments).length)) throw Error(s(391));
    return st(e, t, r[0]), (e = !!e.responseState.generateStaticMarkup || t.push('\x3c!--/$--\x3e'));
   }
   function it(e, t, r) {
    return (
     (function (e, t, r, n) {
      switch (r.insertionMode) {
       case 0:
       case 1:
        return e.push('<div hidden id="'), e.push(t.segmentPrefix), (t = n.toString(16)), e.push(t), e.push('">');
       case 2:
        return e.push('<svg aria-hidden="true" style="display:none" id="'), e.push(t.segmentPrefix), (t = n.toString(16)), e.push(t), e.push('">');
       case 3:
        return e.push('<math aria-hidden="true" style="display:none" id="'), e.push(t.segmentPrefix), (t = n.toString(16)), e.push(t), e.push('">');
       case 4:
        return e.push('<table hidden id="'), e.push(t.segmentPrefix), (t = n.toString(16)), e.push(t), e.push('">');
       case 5:
        return e.push('<table hidden><tbody id="'), e.push(t.segmentPrefix), (t = n.toString(16)), e.push(t), e.push('">');
       case 6:
        return e.push('<table hidden><tr id="'), e.push(t.segmentPrefix), (t = n.toString(16)), e.push(t), e.push('">');
       case 7:
        return e.push('<table hidden><colgroup id="'), e.push(t.segmentPrefix), (t = n.toString(16)), e.push(t), e.push('">');
       default:
        throw Error(s(397));
      }
     })(t, e.responseState, r.formatContext, r.id),
     st(e, t, r),
     (function (e, t) {
      switch (t.insertionMode) {
       case 0:
       case 1:
        return e.push('</div>');
       case 2:
        return e.push('</svg>');
       case 3:
        return e.push('</math>');
       case 4:
        return e.push('</table>');
       case 5:
        return e.push('</tbody></table>');
       case 6:
        return e.push('</tr></table>');
       case 7:
        return e.push('</colgroup></table>');
       default:
        throw Error(s(397));
      }
     })(t, r.formatContext)
    );
   }
   function at(e, t, r) {
    for (var n = r.completedSegments, i = 0; i < n.length; i++) ot(e, t, r, n[i]);
    if (((n.length = 0), (e = e.responseState), (n = r.id), (r = r.rootSegmentID), t.push(e.startInlineScript), e.sentCompleteBoundaryFunction ? t.push('$RC("') : ((e.sentCompleteBoundaryFunction = !0), t.push('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("')), null === n)) throw Error(s(395));
    return (r = r.toString(16)), t.push(n), t.push('","'), t.push(e.segmentPrefix), t.push(r), t.push('")<\/script>');
   }
   function ot(e, t, r, n) {
    if (2 === n.status) return !0;
    var i = n.id;
    if (-1 === i) {
     if (-1 === (n.id = r.rootSegmentID)) throw Error(s(392));
     return it(e, t, n);
    }
    return it(e, t, n), (e = e.responseState), t.push(e.startInlineScript), e.sentCompleteSegmentFunction ? t.push('$RS("') : ((e.sentCompleteSegmentFunction = !0), t.push('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("')), t.push(e.segmentPrefix), (i = i.toString(16)), t.push(i), t.push('","'), t.push(e.placeholderPrefix), t.push(i), t.push('")<\/script>');
   }
   function ut(e, t) {
    try {
     var r = e.completedRootSegment;
     if (null !== r && 0 === e.pendingRootTasks) {
      st(e, t, r), (e.completedRootSegment = null);
      var n = e.responseState.bootstrapChunks;
      for (r = 0; r < n.length - 1; r++) t.push(n[r]);
      r < n.length && t.push(n[r]);
     }
     var i,
      a = e.clientRenderedBoundaries;
     for (i = 0; i < a.length; i++) {
      var o = a[i];
      n = t;
      var u = e.responseState,
       l = o.id,
       p = o.errorDigest,
       c = o.errorMessage,
       h = o.errorComponentStack;
      if ((n.push(u.startInlineScript), u.sentClientRenderFunction ? n.push('$RX("') : ((u.sentClientRenderFunction = !0), n.push('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("')), null === l)) throw Error(s(395));
      if ((n.push(l), n.push('"'), p || c || h)) {
       n.push(',');
       var d = B(p || '');
       n.push(d);
      }
      if (c || h) {
       n.push(',');
       var f = B(c || '');
       n.push(f);
      }
      if (h) {
       n.push(',');
       var m = B(h);
       n.push(m);
      }
      if (!n.push(')<\/script>')) return (e.destination = null), i++, void a.splice(0, i);
     }
     a.splice(0, i);
     var y = e.completedBoundaries;
     for (i = 0; i < y.length; i++) if (!at(e, t, y[i])) return (e.destination = null), i++, void y.splice(0, i);
     y.splice(0, i);
     var g = e.partialBoundaries;
     for (i = 0; i < g.length; i++) {
      var D = g[i];
      e: {
       (a = e), (o = t);
       var x = D.completedSegments;
       for (u = 0; u < x.length; u++)
        if (!ot(a, o, D, x[u])) {
         u++, x.splice(0, u);
         var b = !1;
         break e;
        }
       x.splice(0, u), (b = !0);
      }
      if (!b) return (e.destination = null), i++, void g.splice(0, i);
     }
     g.splice(0, i);
     var v = e.completedBoundaries;
     for (i = 0; i < v.length; i++) if (!at(e, t, v[i])) return (e.destination = null), i++, void v.splice(0, i);
     v.splice(0, i);
    } finally {
     0 === e.allPendingTasks && 0 === e.pingedTasks.length && 0 === e.clientRenderedBoundaries.length && 0 === e.completedBoundaries.length && t.push(null);
    }
   }
   function lt(e, t) {
    try {
     var r = e.abortableTasks;
     r.forEach(function (r) {
      return Ze(r, e, t);
     }),
      r.clear(),
      null !== e.destination && ut(e, e.destination);
    } catch (n) {
     He(e, n), ze(e, n);
    }
   }
   function pt() {}
   function ct(e, t, r, n) {
    var i = !1,
     a = null,
     o = '',
     u = {
      push: function (e) {
       return null !== e && (o += e), !0;
      },
      destroy: function (e) {
       (i = !0), (a = e);
      },
     },
     l = !1;
    if (
     ((e = (function (e, t, r, n, s, i, a, o, u) {
      var l = [],
       p = new Set();
      return ((r = $e((t = { destination: null, responseState: t, progressiveChunkSize: void 0 === n ? 12800 : n, status: 0, fatalError: null, nextSegmentId: 0, allPendingTasks: 0, pendingRootTasks: 0, completedRootSegment: null, abortableTasks: p, pingedTasks: l, clientRenderedBoundaries: [], completedBoundaries: [], partialBoundaries: [], onError: void 0 === s ? Re : s, onAllReady: void 0 === i ? qe : i, onShellReady: void 0 === a ? qe : a, onShellError: void 0 === o ? qe : o, onFatalError: void 0 === u ? qe : u }), 0, null, r, !1, !1)).parentFlushed = !0), (e = Ue(t, e, null, r, p, ee, null, ce)), l.push(e), t;
     })(
      e,
      (function (e, t) {
       return { bootstrapChunks: [], startInlineScript: '<script>', placeholderPrefix: (t = void 0 === t ? '' : t) + 'P:', segmentPrefix: t + 'S:', boundaryPrefix: t + 'B:', idPrefix: t, nextSuspenseID: 0, sentCompleteSegmentFunction: !1, sentCompleteBoundaryFunction: !1, sentClientRenderFunction: !1, generateStaticMarkup: e };
      })(r, t ? t.identifierPrefix : void 0),
      { insertionMode: 1, selectedValue: null },
      1 / 0,
      pt,
      void 0,
      function () {
       l = !0;
      },
      void 0,
      void 0,
     )),
     rt(e),
     lt(e, n),
     1 === e.status)
    )
     (e.status = 2), u.destroy(e.fatalError);
    else if (2 !== e.status && null === e.destination) {
     e.destination = u;
     try {
      ut(e, u);
     } catch (p) {
      He(e, p), ze(e, p);
     }
    }
    if (i) throw a;
    if (!l) throw Error(s(426));
    return o;
   }
   (t.renderToNodeStream = function () {
    throw Error(s(207));
   }),
    (t.renderToStaticMarkup = function (e, t) {
     return ct(e, t, !0, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
    }),
    (t.renderToStaticNodeStream = function () {
     throw Error(s(208));
    }),
    (t.renderToString = function (e, t) {
     return ct(e, t, !1, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
    }),
    (t.version = '18.3.1');
  },
  2910: (e, t, r) => {
   var n = r(75271);
   function s(e) {
    for (var t = 'https://reactjs.org/docs/error-decoder.html?invariant=' + e, r = 1; r < arguments.length; r++) t += '&args[]=' + encodeURIComponent(arguments[r]);
    return 'Minified React error #' + e + '; visit ' + t + ' for the full message or use the non-minified dev environment for full errors and additional helpful warnings.';
   }
   var i = null,
    a = 0;
   function o(e, t) {
    if (0 !== t.length)
     if (512 < t.length) 0 < a && (e.enqueue(new Uint8Array(i.buffer, 0, a)), (i = new Uint8Array(512)), (a = 0)), e.enqueue(t);
     else {
      var r = i.length - a;
      r < t.length && (0 === r ? e.enqueue(i) : (i.set(t.subarray(0, r), a), e.enqueue(i), (t = t.subarray(r))), (i = new Uint8Array(512)), (a = 0)), i.set(t, a), (a += t.length);
     }
   }
   function u(e, t) {
    return o(e, t), !0;
   }
   function l(e) {
    i && 0 < a && (e.enqueue(new Uint8Array(i.buffer, 0, a)), (i = null), (a = 0));
   }
   var p = new TextEncoder();
   function c(e) {
    return p.encode(e);
   }
   function h(e) {
    return p.encode(e);
   }
   function d(e, t) {
    'function' == typeof e.error ? e.error(t) : e.close();
   }
   var f = Object.prototype.hasOwnProperty,
    m = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
    y = {},
    g = {};
   function D(e) {
    return !!f.call(g, e) || (!f.call(y, e) && (m.test(e) ? (g[e] = !0) : ((y[e] = !0), !1)));
   }
   function x(e, t, r, n, s, i, a) {
    (this.acceptsBooleans = 2 === t || 3 === t || 4 === t), (this.attributeName = n), (this.attributeNamespace = s), (this.mustUseProperty = r), (this.propertyName = e), (this.type = t), (this.sanitizeURL = i), (this.removeEmptyString = a);
   }
   var b = {};
   'children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style'.split(' ').forEach(function (e) {
    b[e] = new x(e, 0, !1, e, null, !1, !1);
   }),
    [
     ['acceptCharset', 'accept-charset'],
     ['className', 'class'],
     ['htmlFor', 'for'],
     ['httpEquiv', 'http-equiv'],
    ].forEach(function (e) {
     var t = e[0];
     b[t] = new x(t, 1, !1, e[1], null, !1, !1);
    }),
    ['contentEditable', 'draggable', 'spellCheck', 'value'].forEach(function (e) {
     b[e] = new x(e, 2, !1, e.toLowerCase(), null, !1, !1);
    }),
    ['autoReverse', 'externalResourcesRequired', 'focusable', 'preserveAlpha'].forEach(function (e) {
     b[e] = new x(e, 2, !1, e, null, !1, !1);
    }),
    'allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope'.split(' ').forEach(function (e) {
     b[e] = new x(e, 3, !1, e.toLowerCase(), null, !1, !1);
    }),
    ['checked', 'multiple', 'muted', 'selected'].forEach(function (e) {
     b[e] = new x(e, 3, !0, e, null, !1, !1);
    }),
    ['capture', 'download'].forEach(function (e) {
     b[e] = new x(e, 4, !1, e, null, !1, !1);
    }),
    ['cols', 'rows', 'size', 'span'].forEach(function (e) {
     b[e] = new x(e, 6, !1, e, null, !1, !1);
    }),
    ['rowSpan', 'start'].forEach(function (e) {
     b[e] = new x(e, 5, !1, e.toLowerCase(), null, !1, !1);
    });
   var v = /[\-:]([a-z])/g;
   function E(e) {
    return e[1].toUpperCase();
   }
   'accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height'.split(' ').forEach(function (e) {
    var t = e.replace(v, E);
    b[t] = new x(t, 1, !1, e, null, !1, !1);
   }),
    'xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type'.split(' ').forEach(function (e) {
     var t = e.replace(v, E);
     b[t] = new x(t, 1, !1, e, 'http://www.w3.org/1999/xlink', !1, !1);
    }),
    ['xml:base', 'xml:lang', 'xml:space'].forEach(function (e) {
     var t = e.replace(v, E);
     b[t] = new x(t, 1, !1, e, 'http://www.w3.org/XML/1998/namespace', !1, !1);
    }),
    ['tabIndex', 'crossOrigin'].forEach(function (e) {
     b[e] = new x(e, 1, !1, e.toLowerCase(), null, !1, !1);
    }),
    (b.xlinkHref = new x('xlinkHref', 1, !1, 'xlink:href', 'http://www.w3.org/1999/xlink', !0, !1)),
    ['src', 'href', 'action', 'formAction'].forEach(function (e) {
     b[e] = new x(e, 1, !1, e.toLowerCase(), null, !0, !0);
    });
   var C = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 },
    T = ['Webkit', 'ms', 'Moz', 'O'];
   Object.keys(C).forEach(function (e) {
    T.forEach(function (t) {
     (t = t + e.charAt(0).toUpperCase() + e.substring(1)), (C[t] = C[e]);
    });
   });
   var S = /["'&<>]/;
   function w(e) {
    if ('boolean' == typeof e || 'number' == typeof e) return '' + e;
    e = '' + e;
    var t = S.exec(e);
    if (t) {
     var r,
      n = '',
      s = 0;
     for (r = t.index; r < e.length; r++) {
      switch (e.charCodeAt(r)) {
       case 34:
        t = '&quot;';
        break;
       case 38:
        t = '&amp;';
        break;
       case 39:
        t = '&#x27;';
        break;
       case 60:
        t = '&lt;';
        break;
       case 62:
        t = '&gt;';
        break;
       default:
        continue;
      }
      s !== r && (n += e.substring(s, r)), (s = r + 1), (n += t);
     }
     e = s !== r ? n + e.substring(s, r) : n;
    }
    return e;
   }
   var A = /([A-Z])/g,
    F = /^ms-/,
    k = Array.isArray,
    P = h('<script>'),
    I = h('<\/script>'),
    N = h('<script src="'),
    B = h('<script type="module" src="'),
    _ = h('" async=""><\/script>'),
    L = /(<\/|<)(s)(cript)/gi;
   function O(e, t, r, n) {
    return t + ('s' === r ? '\\u0073' : '\\u0053') + n;
   }
   function M(e, t) {
    return { insertionMode: e, selectedValue: t };
   }
   var j = h('\x3c!-- --\x3e');
   function R(e, t, r, n) {
    return '' === t ? n : (n && e.push(j), e.push(c(w(t))), !0);
   }
   var q = new Map(),
    U = h(' style="'),
    $ = h(':'),
    H = h(';');
   function z(e, t, r) {
    if ('object' != typeof r) throw Error(s(62));
    for (var n in ((t = !0), r))
     if (f.call(r, n)) {
      var i = r[n];
      if (null != i && 'boolean' != typeof i && '' !== i) {
       if (0 === n.indexOf('--')) {
        var a = c(w(n));
        i = c(w(('' + i).trim()));
       } else {
        a = n;
        var o = q.get(a);
        void 0 !== o || ((o = h(w(a.replace(A, '-$1').toLowerCase().replace(F, '-ms-')))), q.set(a, o)), (a = o), (i = 'number' == typeof i ? (0 === i || f.call(C, n) ? c('' + i) : c(i + 'px')) : c(w(('' + i).trim())));
       }
       t ? ((t = !1), e.push(U, a, $, i)) : e.push(H, a, $, i);
      }
     }
    t || e.push(J);
   }
   var V = h(' '),
    W = h('="'),
    J = h('"'),
    K = h('=""');
   function G(e, t, r, n) {
    switch (r) {
     case 'style':
      return void z(e, t, n);
     case 'defaultValue':
     case 'defaultChecked':
     case 'innerHTML':
     case 'suppressContentEditableWarning':
     case 'suppressHydrationWarning':
      return;
    }
    if (!(2 < r.length) || ('o' !== r[0] && 'O' !== r[0]) || ('n' !== r[1] && 'N' !== r[1]))
     if (null !== (t = b.hasOwnProperty(r) ? b[r] : null)) {
      switch (typeof n) {
       case 'function':
       case 'symbol':
        return;
       case 'boolean':
        if (!t.acceptsBooleans) return;
      }
      switch (((r = c(t.attributeName)), t.type)) {
       case 3:
        n && e.push(V, r, K);
        break;
       case 4:
        !0 === n ? e.push(V, r, K) : !1 !== n && e.push(V, r, W, c(w(n)), J);
        break;
       case 5:
        isNaN(n) || e.push(V, r, W, c(w(n)), J);
        break;
       case 6:
        !isNaN(n) && 1 <= n && e.push(V, r, W, c(w(n)), J);
        break;
       default:
        t.sanitizeURL && (n = '' + n), e.push(V, r, W, c(w(n)), J);
      }
     } else if (D(r)) {
      switch (typeof n) {
       case 'function':
       case 'symbol':
        return;
       case 'boolean':
        if ('data-' !== (t = r.toLowerCase().slice(0, 5)) && 'aria-' !== t) return;
      }
      e.push(V, c(r), W, c(w(n)), J);
     }
   }
   var X = h('>'),
    Y = h('/>');
   function Q(e, t, r) {
    if (null != t) {
     if (null != r) throw Error(s(60));
     if ('object' != typeof t || !('__html' in t)) throw Error(s(61));
     null != (t = t.__html) && e.push(c('' + t));
    }
   }
   var Z = h(' selected=""');
   function ee(e, t, r, n) {
    e.push(se(r));
    var s,
     i = (r = null);
    for (s in t)
     if (f.call(t, s)) {
      var a = t[s];
      if (null != a)
       switch (s) {
        case 'children':
         r = a;
         break;
        case 'dangerouslySetInnerHTML':
         i = a;
         break;
        default:
         G(e, n, s, a);
       }
     }
    return e.push(X), Q(e, i, r), 'string' == typeof r ? (e.push(c(w(r))), null) : r;
   }
   var te = h('\n'),
    re = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/,
    ne = new Map();
   function se(e) {
    var t = ne.get(e);
    if (void 0 === t) {
     if (!re.test(e)) throw Error(s(65, e));
     (t = h('<' + e)), ne.set(e, t);
    }
    return t;
   }
   var ie = h('<!DOCTYPE html>');
   function ae(e, t, r, i, a) {
    switch (t) {
     case 'select':
      e.push(se('select'));
      var o = null,
       u = null;
      for (d in r)
       if (f.call(r, d)) {
        var l = r[d];
        if (null != l)
         switch (d) {
          case 'children':
           o = l;
           break;
          case 'dangerouslySetInnerHTML':
           u = l;
           break;
          case 'defaultValue':
          case 'value':
           break;
          default:
           G(e, i, d, l);
         }
       }
      return e.push(X), Q(e, u, o), o;
     case 'option':
      (u = a.selectedValue), e.push(se('option'));
      var p = (l = null),
       h = null,
       d = null;
      for (o in r)
       if (f.call(r, o)) {
        var m = r[o];
        if (null != m)
         switch (o) {
          case 'children':
           l = m;
           break;
          case 'selected':
           h = m;
           break;
          case 'dangerouslySetInnerHTML':
           d = m;
           break;
          case 'value':
           p = m;
          default:
           G(e, i, o, m);
         }
       }
      if (null != u)
       if (
        ((r =
         null !== p
          ? '' + p
          : (function (e) {
             var t = '';
             return (
              n.Children.forEach(e, function (e) {
               null != e && (t += e);
              }),
              t
             );
            })(l)),
        k(u))
       ) {
        for (i = 0; i < u.length; i++)
         if ('' + u[i] === r) {
          e.push(Z);
          break;
         }
       } else '' + u === r && e.push(Z);
      else h && e.push(Z);
      return e.push(X), Q(e, d, l), l;
     case 'textarea':
      for (l in (e.push(se('textarea')), (d = u = o = null), r))
       if (f.call(r, l) && null != (p = r[l]))
        switch (l) {
         case 'children':
          d = p;
          break;
         case 'value':
          o = p;
          break;
         case 'defaultValue':
          u = p;
          break;
         case 'dangerouslySetInnerHTML':
          throw Error(s(91));
         default:
          G(e, i, l, p);
        }
      if ((null === o && null !== u && (o = u), e.push(X), null != d)) {
       if (null != o) throw Error(s(92));
       if (k(d) && 1 < d.length) throw Error(s(93));
       o = '' + d;
      }
      return 'string' == typeof o && '\n' === o[0] && e.push(te), null !== o && e.push(c(w('' + o))), null;
     case 'input':
      for (u in (e.push(se('input')), (p = d = l = o = null), r))
       if (f.call(r, u) && null != (h = r[u]))
        switch (u) {
         case 'children':
         case 'dangerouslySetInnerHTML':
          throw Error(s(399, 'input'));
         case 'defaultChecked':
          p = h;
          break;
         case 'defaultValue':
          l = h;
          break;
         case 'checked':
          d = h;
          break;
         case 'value':
          o = h;
          break;
         default:
          G(e, i, u, h);
        }
      return null !== d ? G(e, i, 'checked', d) : null !== p && G(e, i, 'checked', p), null !== o ? G(e, i, 'value', o) : null !== l && G(e, i, 'value', l), e.push(Y), null;
     case 'menuitem':
      for (var y in (e.push(se('menuitem')), r))
       if (f.call(r, y) && null != (o = r[y]))
        switch (y) {
         case 'children':
         case 'dangerouslySetInnerHTML':
          throw Error(s(400));
         default:
          G(e, i, y, o);
        }
      return e.push(X), null;
     case 'title':
      for (m in (e.push(se('title')), (o = null), r))
       if (f.call(r, m) && null != (u = r[m]))
        switch (m) {
         case 'children':
          o = u;
          break;
         case 'dangerouslySetInnerHTML':
          throw Error(s(434));
         default:
          G(e, i, m, u);
        }
      return e.push(X), o;
     case 'listing':
     case 'pre':
      for (p in (e.push(se(t)), (u = o = null), r))
       if (f.call(r, p) && null != (l = r[p]))
        switch (p) {
         case 'children':
          o = l;
          break;
         case 'dangerouslySetInnerHTML':
          u = l;
          break;
         default:
          G(e, i, p, l);
        }
      if ((e.push(X), null != u)) {
       if (null != o) throw Error(s(60));
       if ('object' != typeof u || !('__html' in u)) throw Error(s(61));
       null != (r = u.__html) && ('string' == typeof r && 0 < r.length && '\n' === r[0] ? e.push(te, c(r)) : e.push(c('' + r)));
      }
      return 'string' == typeof o && '\n' === o[0] && e.push(te), o;
     case 'area':
     case 'base':
     case 'br':
     case 'col':
     case 'embed':
     case 'hr':
     case 'img':
     case 'keygen':
     case 'link':
     case 'meta':
     case 'param':
     case 'source':
     case 'track':
     case 'wbr':
      for (var g in (e.push(se(t)), r))
       if (f.call(r, g) && null != (o = r[g]))
        switch (g) {
         case 'children':
         case 'dangerouslySetInnerHTML':
          throw Error(s(399, t));
         default:
          G(e, i, g, o);
        }
      return e.push(Y), null;
     case 'annotation-xml':
     case 'color-profile':
     case 'font-face':
     case 'font-face-src':
     case 'font-face-uri':
     case 'font-face-format':
     case 'font-face-name':
     case 'missing-glyph':
      return ee(e, r, t, i);
     case 'html':
      return 0 === a.insertionMode && e.push(ie), ee(e, r, t, i);
     default:
      if (-1 === t.indexOf('-') && 'string' != typeof r.is) return ee(e, r, t, i);
      for (h in (e.push(se(t)), (u = o = null), r))
       if (f.call(r, h) && null != (l = r[h]))
        switch (h) {
         case 'children':
          o = l;
          break;
         case 'dangerouslySetInnerHTML':
          u = l;
          break;
         case 'style':
          z(e, i, l);
          break;
         case 'suppressContentEditableWarning':
         case 'suppressHydrationWarning':
          break;
         default:
          D(h) && 'function' != typeof l && 'symbol' != typeof l && e.push(V, c(h), W, c(w(l)), J);
        }
      return e.push(X), Q(e, u, o), o;
    }
   }
   var oe = h('</'),
    ue = h('>'),
    le = h('<template id="'),
    pe = h('"></template>'),
    ce = h('\x3c!--$--\x3e'),
    he = h('\x3c!--$?--\x3e<template id="'),
    de = h('"></template>'),
    fe = h('\x3c!--$!--\x3e'),
    me = h('\x3c!--/$--\x3e'),
    ye = h('<template'),
    ge = h('"'),
    De = h(' data-dgst="');
   h(' data-msg="'), h(' data-stck="');
   var xe = h('></template>');
   function be(e, t, r) {
    if ((o(e, he), null === r)) throw Error(s(395));
    return o(e, r), u(e, de);
   }
   var ve = h('<div hidden id="'),
    Ee = h('">'),
    Ce = h('</div>'),
    Te = h('<svg aria-hidden="true" style="display:none" id="'),
    Se = h('">'),
    we = h('</svg>'),
    Ae = h('<math aria-hidden="true" style="display:none" id="'),
    Fe = h('">'),
    ke = h('</math>'),
    Pe = h('<table hidden id="'),
    Ie = h('">'),
    Ne = h('</table>'),
    Be = h('<table hidden><tbody id="'),
    _e = h('">'),
    Le = h('</tbody></table>'),
    Oe = h('<table hidden><tr id="'),
    Me = h('">'),
    je = h('</tr></table>'),
    Re = h('<table hidden><colgroup id="'),
    qe = h('">'),
    Ue = h('</colgroup></table>');
   var $e = h('function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)};$RS("'),
    He = h('$RS("'),
    ze = h('","'),
    Ve = h('")<\/script>'),
    We = h('function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}};$RC("'),
    Je = h('$RC("'),
    Ke = h('","'),
    Ge = h('")<\/script>'),
    Xe = h('function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())};$RX("'),
    Ye = h('$RX("'),
    Qe = h('"'),
    Ze = h(')<\/script>'),
    et = h(','),
    tt = /[<\u2028\u2029]/g;
   function rt(e) {
    return JSON.stringify(e).replace(tt, function (e) {
     switch (e) {
      case '<':
       return '\\u003c';
      case '\u2028':
       return '\\u2028';
      case '\u2029':
       return '\\u2029';
      default:
       throw Error('escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React');
     }
    });
   }
   var nt = Object.assign,
    st = Symbol.for('react.element'),
    it = Symbol.for('react.portal'),
    at = Symbol.for('react.fragment'),
    ot = Symbol.for('react.strict_mode'),
    ut = Symbol.for('react.profiler'),
    lt = Symbol.for('react.provider'),
    pt = Symbol.for('react.context'),
    ct = Symbol.for('react.forward_ref'),
    ht = Symbol.for('react.suspense'),
    dt = Symbol.for('react.suspense_list'),
    ft = Symbol.for('react.memo'),
    mt = Symbol.for('react.lazy'),
    yt = Symbol.for('react.scope'),
    gt = Symbol.for('react.debug_trace_mode'),
    Dt = Symbol.for('react.legacy_hidden'),
    xt = Symbol.for('react.default_value'),
    bt = Symbol.iterator;
   function vt(e) {
    if (null == e) return null;
    if ('function' == typeof e) return e.displayName || e.name || null;
    if ('string' == typeof e) return e;
    switch (e) {
     case at:
      return 'Fragment';
     case it:
      return 'Portal';
     case ut:
      return 'Profiler';
     case ot:
      return 'StrictMode';
     case ht:
      return 'Suspense';
     case dt:
      return 'SuspenseList';
    }
    if ('object' == typeof e)
     switch (e.$$typeof) {
      case pt:
       return (e.displayName || 'Context') + '.Consumer';
      case lt:
       return (e._context.displayName || 'Context') + '.Provider';
      case ct:
       var t = e.render;
       return (e = e.displayName) || (e = '' !== (e = t.displayName || t.name || '') ? 'ForwardRef(' + e + ')' : 'ForwardRef'), e;
      case ft:
       return null !== (t = e.displayName || null) ? t : vt(e.type) || 'Memo';
      case mt:
       (t = e._payload), (e = e._init);
       try {
        return vt(e(t));
       } catch (r) {}
     }
    return null;
   }
   var Et = {};
   function Ct(e, t) {
    if (!(e = e.contextTypes)) return Et;
    var r,
     n = {};
    for (r in e) n[r] = t[r];
    return n;
   }
   var Tt = null;
   function St(e, t) {
    if (e !== t) {
     (e.context._currentValue = e.parentValue), (e = e.parent);
     var r = t.parent;
     if (null === e) {
      if (null !== r) throw Error(s(401));
     } else {
      if (null === r) throw Error(s(401));
      St(e, r);
     }
     t.context._currentValue = t.value;
    }
   }
   function wt(e) {
    (e.context._currentValue = e.parentValue), null !== (e = e.parent) && wt(e);
   }
   function At(e) {
    var t = e.parent;
    null !== t && At(t), (e.context._currentValue = e.value);
   }
   function Ft(e, t) {
    if (((e.context._currentValue = e.parentValue), null === (e = e.parent))) throw Error(s(402));
    e.depth === t.depth ? St(e, t) : Ft(e, t);
   }
   function kt(e, t) {
    var r = t.parent;
    if (null === r) throw Error(s(402));
    e.depth === r.depth ? St(e, r) : kt(e, r), (t.context._currentValue = t.value);
   }
   function Pt(e) {
    var t = Tt;
    t !== e && (null === t ? At(e) : null === e ? wt(t) : t.depth === e.depth ? St(t, e) : t.depth > e.depth ? Ft(t, e) : kt(t, e), (Tt = e));
   }
   var It = {
    isMounted: function () {
     return !1;
    },
    enqueueSetState: function (e, t) {
     null !== (e = e._reactInternals).queue && e.queue.push(t);
    },
    enqueueReplaceState: function (e, t) {
     ((e = e._reactInternals).replace = !0), (e.queue = [t]);
    },
    enqueueForceUpdate: function () {},
   };
   function Nt(e, t, r, n) {
    var s = void 0 !== e.state ? e.state : null;
    (e.updater = It), (e.props = r), (e.state = s);
    var i = { queue: [], replace: !1 };
    e._reactInternals = i;
    var a = t.contextType;
    if (((e.context = 'object' == typeof a && null !== a ? a._currentValue : n), 'function' == typeof (a = t.getDerivedStateFromProps) && ((s = null == (a = a(r, s)) ? s : nt({}, s, a)), (e.state = s)), 'function' != typeof t.getDerivedStateFromProps && 'function' != typeof e.getSnapshotBeforeUpdate && ('function' == typeof e.UNSAFE_componentWillMount || 'function' == typeof e.componentWillMount)))
     if (((t = e.state), 'function' == typeof e.componentWillMount && e.componentWillMount(), 'function' == typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), t !== e.state && It.enqueueReplaceState(e, e.state, null), null !== i.queue && 0 < i.queue.length))
      if (((t = i.queue), (a = i.replace), (i.queue = null), (i.replace = !1), a && 1 === t.length)) e.state = t[0];
      else {
       for (i = a ? t[0] : e.state, s = !0, a = a ? 1 : 0; a < t.length; a++) {
        var o = t[a];
        null != (o = 'function' == typeof o ? o.call(e, i, r, n) : o) && (s ? ((s = !1), (i = nt({}, i, o))) : nt(i, o));
       }
       e.state = i;
      }
     else i.queue = null;
   }
   var Bt = { id: 1, overflow: '' };
   function _t(e, t, r) {
    var n = e.id;
    e = e.overflow;
    var s = 32 - Lt(n) - 1;
    (n &= ~(1 << s)), (r += 1);
    var i = 32 - Lt(t) + s;
    if (30 < i) {
     var a = s - (s % 5);
     return (i = (n & ((1 << a) - 1)).toString(32)), (n >>= a), (s -= a), { id: (1 << (32 - Lt(t) + s)) | (r << s) | n, overflow: i + e };
    }
    return { id: (1 << i) | (r << s) | n, overflow: e };
   }
   var Lt = Math.clz32
     ? Math.clz32
     : function (e) {
        return 0 === (e >>>= 0) ? 32 : (31 - ((Ot(e) / Mt) | 0)) | 0;
       },
    Ot = Math.log,
    Mt = Math.LN2;
   var jt =
     'function' == typeof Object.is
      ? Object.is
      : function (e, t) {
         return (e === t && (0 !== e || 1 / e == 1 / t)) || (e != e && t != t);
        },
    Rt = null,
    qt = null,
    Ut = null,
    $t = null,
    Ht = !1,
    zt = !1,
    Vt = 0,
    Wt = null,
    Jt = 0;
   function Kt() {
    if (null === Rt) throw Error(s(321));
    return Rt;
   }
   function Gt() {
    if (0 < Jt) throw Error(s(312));
    return { memoizedState: null, queue: null, next: null };
   }
   function Xt() {
    return null === $t ? (null === Ut ? ((Ht = !1), (Ut = $t = Gt())) : ((Ht = !0), ($t = Ut))) : null === $t.next ? ((Ht = !1), ($t = $t.next = Gt())) : ((Ht = !0), ($t = $t.next)), $t;
   }
   function Yt() {
    (qt = Rt = null), (zt = !1), (Ut = null), (Jt = 0), ($t = Wt = null);
   }
   function Qt(e, t) {
    return 'function' == typeof t ? t(e) : t;
   }
   function Zt(e, t, r) {
    if (((Rt = Kt()), ($t = Xt()), Ht)) {
     var n = $t.queue;
     if (((t = n.dispatch), null !== Wt && void 0 !== (r = Wt.get(n)))) {
      Wt.delete(n), (n = $t.memoizedState);
      do {
       (n = e(n, r.action)), (r = r.next);
      } while (null !== r);
      return ($t.memoizedState = n), [n, t];
     }
     return [$t.memoizedState, t];
    }
    return (e = e === Qt ? ('function' == typeof t ? t() : t) : void 0 !== r ? r(t) : t), ($t.memoizedState = e), (e = (e = $t.queue = { last: null, dispatch: null }).dispatch = tr.bind(null, Rt, e)), [$t.memoizedState, e];
   }
   function er(e, t) {
    if (((Rt = Kt()), (t = void 0 === t ? null : t), null !== ($t = Xt()))) {
     var r = $t.memoizedState;
     if (null !== r && null !== t) {
      var n = r[1];
      e: if (null === n) n = !1;
      else {
       for (var s = 0; s < n.length && s < t.length; s++)
        if (!jt(t[s], n[s])) {
         n = !1;
         break e;
        }
       n = !0;
      }
      if (n) return r[0];
     }
    }
    return (e = e()), ($t.memoizedState = [e, t]), e;
   }
   function tr(e, t, r) {
    if (25 <= Jt) throw Error(s(301));
    if (e === Rt)
     if (((zt = !0), (e = { action: r, next: null }), null === Wt && (Wt = new Map()), void 0 === (r = Wt.get(t)))) Wt.set(t, e);
     else {
      for (t = r; null !== t.next; ) t = t.next;
      t.next = e;
     }
   }
   function rr() {
    throw Error(s(394));
   }
   function nr() {}
   var sr = {
     readContext: function (e) {
      return e._currentValue;
     },
     useContext: function (e) {
      return Kt(), e._currentValue;
     },
     useMemo: er,
     useReducer: Zt,
     useRef: function (e) {
      Rt = Kt();
      var t = ($t = Xt()).memoizedState;
      return null === t ? ((e = { current: e }), ($t.memoizedState = e)) : t;
     },
     useState: function (e) {
      return Zt(Qt, e);
     },
     useInsertionEffect: nr,
     useLayoutEffect: function () {},
     useCallback: function (e, t) {
      return er(function () {
       return e;
      }, t);
     },
     useImperativeHandle: nr,
     useEffect: nr,
     useDebugValue: nr,
     useDeferredValue: function (e) {
      return Kt(), e;
     },
     useTransition: function () {
      return Kt(), [!1, rr];
     },
     useId: function () {
      var e = qt.treeContext,
       t = e.overflow;
      e = ((e = e.id) & ~(1 << (32 - Lt(e) - 1))).toString(32) + t;
      var r = ir;
      if (null === r) throw Error(s(404));
      return (t = Vt++), (e = ':' + r.idPrefix + 'R' + e), 0 < t && (e += 'H' + t.toString(32)), e + ':';
     },
     useMutableSource: function (e, t) {
      return Kt(), t(e._source);
     },
     useSyncExternalStore: function (e, t, r) {
      if (void 0 === r) throw Error(s(407));
      return r();
     },
    },
    ir = null,
    ar = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;
   function or(e) {
    return console.error(e), null;
   }
   function ur() {}
   function lr(e, t, r, n, s, i, a, o) {
    e.allPendingTasks++, null === r ? e.pendingRootTasks++ : r.pendingTasks++;
    var u = {
     node: t,
     ping: function () {
      var t = e.pingedTasks;
      t.push(u), 1 === t.length && Tr(e);
     },
     blockedBoundary: r,
     blockedSegment: n,
     abortSet: s,
     legacyContext: i,
     context: a,
     treeContext: o,
    };
    return s.add(u), u;
   }
   function pr(e, t, r, n, s, i) {
    return { status: 0, id: -1, index: t, parentFlushed: !1, chunks: [], children: [], formatContext: n, boundary: r, lastPushedText: s, textEmbedded: i };
   }
   function cr(e, t) {
    if (null != (e = e.onError(t)) && 'string' != typeof e) throw Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof e + '" instead');
    return e;
   }
   function hr(e, t) {
    var r = e.onShellError;
    r(t), (r = e.onFatalError)(t), null !== e.destination ? ((e.status = 2), d(e.destination, t)) : ((e.status = 1), (e.fatalError = t));
   }
   function dr(e, t, r, n, s) {
    for (Rt = {}, qt = t, Vt = 0, e = r(n, s); zt; ) (zt = !1), (Vt = 0), (Jt += 1), ($t = null), (e = r(n, s));
    return Yt(), e;
   }
   function fr(e, t, r, n) {
    var i = r.render(),
     a = n.childContextTypes;
    if (null != a) {
     var o = t.legacyContext;
     if ('function' != typeof r.getChildContext) n = o;
     else {
      for (var u in (r = r.getChildContext())) if (!(u in a)) throw Error(s(108, vt(n) || 'Unknown', u));
      n = nt({}, o, r);
     }
     (t.legacyContext = n), gr(e, t, i), (t.legacyContext = o);
    } else gr(e, t, i);
   }
   function mr(e, t) {
    if (e && e.defaultProps) {
     for (var r in ((t = nt({}, t)), (e = e.defaultProps))) void 0 === t[r] && (t[r] = e[r]);
     return t;
    }
    return t;
   }
   function yr(e, t, r, n, i) {
    if ('function' == typeof r)
     if (r.prototype && r.prototype.isReactComponent) {
      i = Ct(r, t.legacyContext);
      var a = r.contextType;
      Nt((a = new r(n, 'object' == typeof a && null !== a ? a._currentValue : i)), r, n, i), fr(e, t, a, r);
     } else {
      i = dr(e, t, r, n, (a = Ct(r, t.legacyContext)));
      var o = 0 !== Vt;
      if ('object' == typeof i && null !== i && 'function' == typeof i.render && void 0 === i.$$typeof) Nt(i, r, n, a), fr(e, t, i, r);
      else if (o) {
       (n = t.treeContext), (t.treeContext = _t(n, 1, 0));
       try {
        gr(e, t, i);
       } finally {
        t.treeContext = n;
       }
      } else gr(e, t, i);
     }
    else {
     if ('string' != typeof r) {
      switch (r) {
       case Dt:
       case gt:
       case ot:
       case ut:
       case at:
       case dt:
        return void gr(e, t, n.children);
       case yt:
        throw Error(s(343));
       case ht:
        e: {
         (r = t.blockedBoundary), (i = t.blockedSegment), (a = n.fallback), (n = n.children);
         var u = { id: null, rootSegmentID: -1, parentFlushed: !1, pendingTasks: 0, forceClientRender: !1, completedSegments: [], byteSize: 0, fallbackAbortableTasks: (o = new Set()), errorDigest: null },
          l = pr(0, i.chunks.length, u, i.formatContext, !1, !1);
         i.children.push(l), (i.lastPushedText = !1);
         var p = pr(0, 0, null, i.formatContext, !1, !1);
         (p.parentFlushed = !0), (t.blockedBoundary = u), (t.blockedSegment = p);
         try {
          if ((xr(e, t, n), p.lastPushedText && p.textEmbedded && p.chunks.push(j), (p.status = 1), Er(u, p), 0 === u.pendingTasks)) break e;
         } catch (h) {
          (p.status = 4), (u.forceClientRender = !0), (u.errorDigest = cr(e, h));
         } finally {
          (t.blockedBoundary = r), (t.blockedSegment = i);
         }
         (t = lr(e, a, r, l, o, t.legacyContext, t.context, t.treeContext)), e.pingedTasks.push(t);
        }
        return;
      }
      if ('object' == typeof r && null !== r)
       switch (r.$$typeof) {
        case ct:
         if (((n = dr(e, t, r.render, n, i)), 0 !== Vt)) {
          (r = t.treeContext), (t.treeContext = _t(r, 1, 0));
          try {
           gr(e, t, n);
          } finally {
           t.treeContext = r;
          }
         } else gr(e, t, n);
         return;
        case ft:
         return void yr(e, t, (r = r.type), (n = mr(r, n)), i);
        case lt:
         if (((i = n.children), (r = r._context), (n = n.value), (a = r._currentValue), (r._currentValue = n), (Tt = n = { parent: (o = Tt), depth: null === o ? 0 : o.depth + 1, context: r, parentValue: a, value: n }), (t.context = n), gr(e, t, i), null === (e = Tt))) throw Error(s(403));
         return (n = e.parentValue), (e.context._currentValue = n === xt ? e.context._defaultValue : n), (e = Tt = e.parent), void (t.context = e);
        case pt:
         return void gr(e, t, (n = (n = n.children)(r._currentValue)));
        case mt:
         return void yr(e, t, (r = (i = r._init)(r._payload)), (n = mr(r, n)), void 0);
       }
      throw Error(s(130, null == r ? r : typeof r, ''));
     }
     switch (
      ((a = ae((i = t.blockedSegment).chunks, r, n, e.responseState, i.formatContext)),
      (i.lastPushedText = !1),
      (o = i.formatContext),
      (i.formatContext = (function (e, t, r) {
       switch (t) {
        case 'select':
         return M(1, null != r.value ? r.value : r.defaultValue);
        case 'svg':
         return M(2, null);
        case 'math':
         return M(3, null);
        case 'foreignObject':
         return M(1, null);
        case 'table':
         return M(4, null);
        case 'thead':
        case 'tbody':
        case 'tfoot':
         return M(5, null);
        case 'colgroup':
         return M(7, null);
        case 'tr':
         return M(6, null);
       }
       return 4 <= e.insertionMode || 0 === e.insertionMode ? M(1, null) : e;
      })(o, r, n)),
      xr(e, t, a),
      (i.formatContext = o),
      r)
     ) {
      case 'area':
      case 'base':
      case 'br':
      case 'col':
      case 'embed':
      case 'hr':
      case 'img':
      case 'input':
      case 'keygen':
      case 'link':
      case 'meta':
      case 'param':
      case 'source':
      case 'track':
      case 'wbr':
       break;
      default:
       i.chunks.push(oe, c(r), ue);
     }
     i.lastPushedText = !1;
    }
   }
   function gr(e, t, r) {
    if (((t.node = r), 'object' == typeof r && null !== r)) {
     switch (r.$$typeof) {
      case st:
       return void yr(e, t, r.type, r.props, r.ref);
      case it:
       throw Error(s(257));
      case mt:
       var n = r._init;
       return void gr(e, t, (r = n(r._payload)));
     }
     if (k(r)) return void Dr(e, t, r);
     if ((null === r || 'object' != typeof r ? (n = null) : (n = 'function' == typeof (n = (bt && r[bt]) || r['@@iterator']) ? n : null), n && (n = n.call(r)))) {
      if (!(r = n.next()).done) {
       var i = [];
       do {
        i.push(r.value), (r = n.next());
       } while (!r.done);
       Dr(e, t, i);
      }
      return;
     }
     throw ((e = Object.prototype.toString.call(r)), Error(s(31, '[object Object]' === e ? 'object with keys {' + Object.keys(r).join(', ') + '}' : e)));
    }
    'string' == typeof r ? ((n = t.blockedSegment).lastPushedText = R(t.blockedSegment.chunks, r, e.responseState, n.lastPushedText)) : 'number' == typeof r && ((n = t.blockedSegment).lastPushedText = R(t.blockedSegment.chunks, '' + r, e.responseState, n.lastPushedText));
   }
   function Dr(e, t, r) {
    for (var n = r.length, s = 0; s < n; s++) {
     var i = t.treeContext;
     t.treeContext = _t(i, n, s);
     try {
      xr(e, t, r[s]);
     } finally {
      t.treeContext = i;
     }
    }
   }
   function xr(e, t, r) {
    var n = t.blockedSegment.formatContext,
     s = t.legacyContext,
     i = t.context;
    try {
     return gr(e, t, r);
    } catch (u) {
     if ((Yt(), 'object' != typeof u || null === u || 'function' != typeof u.then)) throw ((t.blockedSegment.formatContext = n), (t.legacyContext = s), (t.context = i), Pt(i), u);
     r = u;
     var a = t.blockedSegment,
      o = pr(0, a.chunks.length, null, a.formatContext, a.lastPushedText, !0);
     a.children.push(o), (a.lastPushedText = !1), (e = lr(e, t.node, t.blockedBoundary, o, t.abortSet, t.legacyContext, t.context, t.treeContext).ping), r.then(e, e), (t.blockedSegment.formatContext = n), (t.legacyContext = s), (t.context = i), Pt(i);
    }
   }
   function br(e) {
    var t = e.blockedBoundary;
    ((e = e.blockedSegment).status = 3), Cr(this, t, e);
   }
   function vr(e, t, r) {
    var n = e.blockedBoundary;
    (e.blockedSegment.status = 3),
     null === n
      ? (t.allPendingTasks--, 2 !== t.status && ((t.status = 2), null !== t.destination && t.destination.close()))
      : (n.pendingTasks--,
        n.forceClientRender || ((n.forceClientRender = !0), (e = void 0 === r ? Error(s(432)) : r), (n.errorDigest = t.onError(e)), n.parentFlushed && t.clientRenderedBoundaries.push(n)),
        n.fallbackAbortableTasks.forEach(function (e) {
         return vr(e, t, r);
        }),
        n.fallbackAbortableTasks.clear(),
        t.allPendingTasks--,
        0 === t.allPendingTasks && (n = t.onAllReady)());
   }
   function Er(e, t) {
    if (0 === t.chunks.length && 1 === t.children.length && null === t.children[0].boundary) {
     var r = t.children[0];
     (r.id = t.id), (r.parentFlushed = !0), 1 === r.status && Er(e, r);
    } else e.completedSegments.push(t);
   }
   function Cr(e, t, r) {
    if (null === t) {
     if (r.parentFlushed) {
      if (null !== e.completedRootSegment) throw Error(s(389));
      e.completedRootSegment = r;
     }
     e.pendingRootTasks--, 0 === e.pendingRootTasks && ((e.onShellError = ur), (t = e.onShellReady)());
    } else t.pendingTasks--, t.forceClientRender || (0 === t.pendingTasks ? (r.parentFlushed && 1 === r.status && Er(t, r), t.parentFlushed && e.completedBoundaries.push(t), t.fallbackAbortableTasks.forEach(br, e), t.fallbackAbortableTasks.clear()) : r.parentFlushed && 1 === r.status && (Er(t, r), 1 === t.completedSegments.length && t.parentFlushed && e.partialBoundaries.push(t)));
    e.allPendingTasks--, 0 === e.allPendingTasks && (e = e.onAllReady)();
   }
   function Tr(e) {
    if (2 !== e.status) {
     var t = Tt,
      r = ar.current;
     ar.current = sr;
     var n = ir;
     ir = e.responseState;
     try {
      var s,
       i = e.pingedTasks;
      for (s = 0; s < i.length; s++) {
       var a = i[s],
        o = e,
        u = a.blockedSegment;
       if (0 === u.status) {
        Pt(a.context);
        try {
         gr(o, a, a.node), u.lastPushedText && u.textEmbedded && u.chunks.push(j), a.abortSet.delete(a), (u.status = 1), Cr(o, a.blockedBoundary, u);
        } catch (d) {
         if ((Yt(), 'object' == typeof d && null !== d && 'function' == typeof d.then)) {
          var l = a.ping;
          d.then(l, l);
         } else {
          a.abortSet.delete(a), (u.status = 4);
          var p = a.blockedBoundary,
           c = d,
           h = cr(o, c);
          if ((null === p ? hr(o, c) : (p.pendingTasks--, p.forceClientRender || ((p.forceClientRender = !0), (p.errorDigest = h), p.parentFlushed && o.clientRenderedBoundaries.push(p))), o.allPendingTasks--, 0 === o.allPendingTasks)) (0, o.onAllReady)();
         }
        }
       }
      }
      i.splice(0, s), null !== e.destination && Pr(e, e.destination);
     } catch (d) {
      cr(e, d), hr(e, d);
     } finally {
      (ir = n), (ar.current = r), r === sr && Pt(t);
     }
    }
   }
   function Sr(e, t, r) {
    switch (((r.parentFlushed = !0), r.status)) {
     case 0:
      var n = (r.id = e.nextSegmentId++);
      return (r.lastPushedText = !1), (r.textEmbedded = !1), (e = e.responseState), o(t, le), o(t, e.placeholderPrefix), o(t, (e = c(n.toString(16)))), u(t, pe);
     case 1:
      r.status = 2;
      var i = !0;
      n = r.chunks;
      var a = 0;
      r = r.children;
      for (var l = 0; l < r.length; l++) {
       for (i = r[l]; a < i.index; a++) o(t, n[a]);
       i = wr(e, t, i);
      }
      for (; a < n.length - 1; a++) o(t, n[a]);
      return a < n.length && (i = u(t, n[a])), i;
     default:
      throw Error(s(390));
    }
   }
   function wr(e, t, r) {
    var n = r.boundary;
    if (null === n) return Sr(e, t, r);
    if (((n.parentFlushed = !0), n.forceClientRender)) (n = n.errorDigest), u(t, fe), o(t, ye), n && (o(t, De), o(t, c(w(n))), o(t, ge)), u(t, xe), Sr(e, t, r);
    else if (0 < n.pendingTasks) {
     (n.rootSegmentID = e.nextSegmentId++), 0 < n.completedSegments.length && e.partialBoundaries.push(n);
     var i = e.responseState,
      a = i.nextSuspenseID++;
     (i = h(i.boundaryPrefix + a.toString(16))), (n = n.id = i), be(t, e.responseState, n), Sr(e, t, r);
    } else if (n.byteSize > e.progressiveChunkSize) (n.rootSegmentID = e.nextSegmentId++), e.completedBoundaries.push(n), be(t, e.responseState, n.id), Sr(e, t, r);
    else {
     if ((u(t, ce), 1 !== (r = n.completedSegments).length)) throw Error(s(391));
     wr(e, t, r[0]);
    }
    return u(t, me);
   }
   function Ar(e, t, r) {
    return (
     (function (e, t, r, n) {
      switch (r.insertionMode) {
       case 0:
       case 1:
        return o(e, ve), o(e, t.segmentPrefix), o(e, c(n.toString(16))), u(e, Ee);
       case 2:
        return o(e, Te), o(e, t.segmentPrefix), o(e, c(n.toString(16))), u(e, Se);
       case 3:
        return o(e, Ae), o(e, t.segmentPrefix), o(e, c(n.toString(16))), u(e, Fe);
       case 4:
        return o(e, Pe), o(e, t.segmentPrefix), o(e, c(n.toString(16))), u(e, Ie);
       case 5:
        return o(e, Be), o(e, t.segmentPrefix), o(e, c(n.toString(16))), u(e, _e);
       case 6:
        return o(e, Oe), o(e, t.segmentPrefix), o(e, c(n.toString(16))), u(e, Me);
       case 7:
        return o(e, Re), o(e, t.segmentPrefix), o(e, c(n.toString(16))), u(e, qe);
       default:
        throw Error(s(397));
      }
     })(t, e.responseState, r.formatContext, r.id),
     wr(e, t, r),
     (function (e, t) {
      switch (t.insertionMode) {
       case 0:
       case 1:
        return u(e, Ce);
       case 2:
        return u(e, we);
       case 3:
        return u(e, ke);
       case 4:
        return u(e, Ne);
       case 5:
        return u(e, Le);
       case 6:
        return u(e, je);
       case 7:
        return u(e, Ue);
       default:
        throw Error(s(397));
      }
     })(t, r.formatContext)
    );
   }
   function Fr(e, t, r) {
    for (var n = r.completedSegments, i = 0; i < n.length; i++) kr(e, t, r, n[i]);
    if (((n.length = 0), (e = e.responseState), (n = r.id), (r = r.rootSegmentID), o(t, e.startInlineScript), e.sentCompleteBoundaryFunction ? o(t, Je) : ((e.sentCompleteBoundaryFunction = !0), o(t, We)), null === n)) throw Error(s(395));
    return (r = c(r.toString(16))), o(t, n), o(t, Ke), o(t, e.segmentPrefix), o(t, r), u(t, Ge);
   }
   function kr(e, t, r, n) {
    if (2 === n.status) return !0;
    var i = n.id;
    if (-1 === i) {
     if (-1 === (n.id = r.rootSegmentID)) throw Error(s(392));
     return Ar(e, t, n);
    }
    return Ar(e, t, n), o(t, (e = e.responseState).startInlineScript), e.sentCompleteSegmentFunction ? o(t, He) : ((e.sentCompleteSegmentFunction = !0), o(t, $e)), o(t, e.segmentPrefix), o(t, (i = c(i.toString(16)))), o(t, ze), o(t, e.placeholderPrefix), o(t, i), u(t, Ve);
   }
   function Pr(e, t) {
    (i = new Uint8Array(512)), (a = 0);
    try {
     var r = e.completedRootSegment;
     if (null !== r && 0 === e.pendingRootTasks) {
      wr(e, t, r), (e.completedRootSegment = null);
      var n = e.responseState.bootstrapChunks;
      for (r = 0; r < n.length - 1; r++) o(t, n[r]);
      r < n.length && u(t, n[r]);
     }
     var p,
      h = e.clientRenderedBoundaries;
     for (p = 0; p < h.length; p++) {
      var d = h[p];
      n = t;
      var f = e.responseState,
       m = d.id,
       y = d.errorDigest,
       g = d.errorMessage,
       D = d.errorComponentStack;
      if ((o(n, f.startInlineScript), f.sentClientRenderFunction ? o(n, Ye) : ((f.sentClientRenderFunction = !0), o(n, Xe)), null === m)) throw Error(s(395));
      if ((o(n, m), o(n, Qe), (y || g || D) && (o(n, et), o(n, c(rt(y || '')))), (g || D) && (o(n, et), o(n, c(rt(g || '')))), D && (o(n, et), o(n, c(rt(D)))), !u(n, Ze))) return (e.destination = null), p++, void h.splice(0, p);
     }
     h.splice(0, p);
     var x = e.completedBoundaries;
     for (p = 0; p < x.length; p++) if (!Fr(e, t, x[p])) return (e.destination = null), p++, void x.splice(0, p);
     x.splice(0, p), l(t), (i = new Uint8Array(512)), (a = 0);
     var b = e.partialBoundaries;
     for (p = 0; p < b.length; p++) {
      var v = b[p];
      e: {
       (h = e), (d = t);
       var E = v.completedSegments;
       for (f = 0; f < E.length; f++)
        if (!kr(h, d, v, E[f])) {
         f++, E.splice(0, f);
         var C = !1;
         break e;
        }
       E.splice(0, f), (C = !0);
      }
      if (!C) return (e.destination = null), p++, void b.splice(0, p);
     }
     b.splice(0, p);
     var T = e.completedBoundaries;
     for (p = 0; p < T.length; p++) if (!Fr(e, t, T[p])) return (e.destination = null), p++, void T.splice(0, p);
     T.splice(0, p);
    } finally {
     l(t), 0 === e.allPendingTasks && 0 === e.pingedTasks.length && 0 === e.clientRenderedBoundaries.length && 0 === e.completedBoundaries.length && t.close();
    }
   }
   function Ir(e, t) {
    try {
     var r = e.abortableTasks;
     r.forEach(function (r) {
      return vr(r, e, t);
     }),
      r.clear(),
      null !== e.destination && Pr(e, e.destination);
    } catch (n) {
     cr(e, n), hr(e, n);
    }
   }
   (t.renderToReadableStream = function (e, t) {
    return new Promise(function (r, n) {
     var s,
      i,
      a = new Promise(function (e, t) {
       (i = e), (s = t);
      }),
      o = (function (e, t, r, n, s, i, a, o, u) {
       var l = [],
        p = new Set();
       return ((r = pr((t = { destination: null, responseState: t, progressiveChunkSize: void 0 === n ? 12800 : n, status: 0, fatalError: null, nextSegmentId: 0, allPendingTasks: 0, pendingRootTasks: 0, completedRootSegment: null, abortableTasks: p, pingedTasks: l, clientRenderedBoundaries: [], completedBoundaries: [], partialBoundaries: [], onError: void 0 === s ? or : s, onAllReady: void 0 === i ? ur : i, onShellReady: void 0 === a ? ur : a, onShellError: void 0 === o ? ur : o, onFatalError: void 0 === u ? ur : u }), 0, null, r, !1, !1)).parentFlushed = !0), (e = lr(t, e, null, r, p, Et, null, Bt)), l.push(e), t;
      })(
       e,
       (function (e, t, r, n, s) {
        (e = void 0 === e ? '' : e), (t = void 0 === t ? P : h('<script nonce="' + w(t) + '">'));
        var i = [];
        if ((void 0 !== r && i.push(t, c(('' + r).replace(L, O)), I), void 0 !== n)) for (r = 0; r < n.length; r++) i.push(N, c(w(n[r])), _);
        if (void 0 !== s) for (n = 0; n < s.length; n++) i.push(B, c(w(s[n])), _);
        return { bootstrapChunks: i, startInlineScript: t, placeholderPrefix: h(e + 'P:'), segmentPrefix: h(e + 'S:'), boundaryPrefix: e + 'B:', idPrefix: e, nextSuspenseID: 0, sentCompleteSegmentFunction: !1, sentCompleteBoundaryFunction: !1, sentClientRenderFunction: !1 };
       })(t ? t.identifierPrefix : void 0, t ? t.nonce : void 0, t ? t.bootstrapScriptContent : void 0, t ? t.bootstrapScripts : void 0, t ? t.bootstrapModules : void 0),
       (function (e) {
        return M('http://www.w3.org/2000/svg' === e ? 2 : 'http://www.w3.org/1998/Math/MathML' === e ? 3 : 0, null);
       })(t ? t.namespaceURI : void 0),
       t ? t.progressiveChunkSize : void 0,
       t ? t.onError : void 0,
       i,
       function () {
        var e = new ReadableStream(
         {
          type: 'bytes',
          pull: function (e) {
           if (1 === o.status) (o.status = 2), d(e, o.fatalError);
           else if (2 !== o.status && null === o.destination) {
            o.destination = e;
            try {
             Pr(o, e);
            } catch (t) {
             cr(o, t), hr(o, t);
            }
           }
          },
          cancel: function () {
           Ir(o);
          },
         },
         { highWaterMark: 0 },
        );
        (e.allReady = a), r(e);
       },
       function (e) {
        a.catch(function () {}), n(e);
       },
       s,
      );
     if (t && t.signal) {
      var u = t.signal,
       l = function () {
        Ir(o, u.reason), u.removeEventListener('abort', l);
       };
      u.addEventListener('abort', l);
     }
     Tr(o);
    });
   }),
    (t.version = '18.3.1');
  },
  60027: (e, t, r) => {
   var n, s;
   (n = r(41973)), (s = r(2910)), n.version, n.renderToString, (t.uS = n.renderToStaticMarkup), n.renderToNodeStream, n.renderToStaticNodeStream, s.renderToReadableStream;
  },
  20061: (e, t, r) => {
   r.d(t, { Z: () => n });
   var n = (0, r(72315).Z)('outline', 'mood-happy', 'IconMoodHappy', [
    ['path', { d: 'M12 12m-9 0a9 9 0 1 0 18 0a9 9 0 1 0 -18 0', key: 'svg-0' }],
    ['path', { d: 'M9 9l.01 0', key: 'svg-1' }],
    ['path', { d: 'M15 9l.01 0', key: 'svg-2' }],
    ['path', { d: 'M8 13a4 4 0 1 0 8 0h-8', key: 'svg-3' }],
   ]);
  },
  69244: (e, t, r) => {
   r.d(t, { Z: () => n });
   var n = (0, r(72315).Z)('outline', 'mood-sad', 'IconMoodSad', [
    ['path', { d: 'M12 12m-9 0a9 9 0 1 0 18 0a9 9 0 1 0 -18 0', key: 'svg-0' }],
    ['path', { d: 'M9 10l.01 0', key: 'svg-1' }],
    ['path', { d: 'M15 10l.01 0', key: 'svg-2' }],
    ['path', { d: 'M9.5 15.25a3.5 3.5 0 0 1 5 0', key: 'svg-3' }],
   ]);
  },
  64642: (e, t, r) => {
   r.d(t, { Z: () => Te });
   var n,
    s,
    i = Object.create,
    a = Object.defineProperty,
    o = Object.getOwnPropertyDescriptor,
    u = Object.getOwnPropertyNames,
    l = Object.getPrototypeOf,
    p = Object.prototype.hasOwnProperty,
    c = (e, t, r) => (
     (r = null != e ? i(l(e)) : {}),
     ((e, t, r, n) => {
      if ((t && 'object' == typeof t) || 'function' == typeof t) for (let s of u(t)) !p.call(e, s) && s !== r && a(e, s, { get: () => t[s], enumerable: !(n = o(t, s)) || n.enumerable });
      return e;
     })(!t && e && e.__esModule ? r : a(r, 'default', { value: e, enumerable: !0 }), e)
    ),
    h =
     ((n = (e) => {
      function t(e, t) {
       if (null == e) return {};
       var r = {};
       for (var n in e)
        if ({}.hasOwnProperty.call(e, n)) {
         if (t.includes(n)) continue;
         r[n] = e[n];
        }
       return r;
      }
      Object.defineProperty(e, '__esModule', { value: !0 });
      var r = class {
        constructor(e, t, r) {
         (this.line = void 0), (this.column = void 0), (this.index = void 0), (this.line = e), (this.column = t), (this.index = r);
        }
       },
       n = class {
        constructor(e, t) {
         (this.start = void 0), (this.end = void 0), (this.filename = void 0), (this.identifierName = void 0), (this.start = e), (this.end = t);
        }
       };
      function s(e, t) {
       let { line: n, column: s, index: i } = e;
       return new r(n, s + t, i + t);
      }
      var i = 'BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED',
       a = { ImportMetaOutsideModule: { message: 'import.meta may appear only with \'sourceType: "module"\'', code: i }, ImportOutsideModule: { message: "'import' and 'export' may appear only with 'sourceType: \"module\"'", code: i } },
       o = { ArrayPattern: 'array destructuring pattern', AssignmentExpression: 'assignment expression', AssignmentPattern: 'assignment expression', ArrowFunctionExpression: 'arrow function expression', ConditionalExpression: 'conditional expression', CatchClause: 'catch clause', ForOfStatement: 'for-of statement', ForInStatement: 'for-in statement', ForStatement: 'for-loop', FormalParameters: 'function parameter list', Identifier: 'identifier', ImportSpecifier: 'import specifier', ImportDefaultSpecifier: 'import default specifier', ImportNamespaceSpecifier: 'import namespace specifier', ObjectPattern: 'object destructuring pattern', ParenthesizedExpression: 'parenthesized expression', RestElement: 'rest element', UpdateExpression: { true: 'prefix operation', false: 'postfix operation' }, VariableDeclarator: 'variable declaration', YieldExpression: 'yield expression' },
       u = (e) => ('UpdateExpression' === e.type ? o.UpdateExpression[`${e.prefix}`] : o[e.type]),
       l = { AccessorIsGenerator: ({ kind: e }) => `A ${e}ter cannot be a generator.`, ArgumentsInClass: "'arguments' is only allowed in functions and class methods.", AsyncFunctionInSingleStatementContext: 'Async functions can only be declared at the top level or inside a block.', AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.", AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.", AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.", AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncFunction: "'await' is only allowed within async functions.", BadGetterArity: "A 'get' accessor must not have any formal parameters.", BadSetterArity: "A 'set' accessor must have exactly one formal parameter.", BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.", ConstructorClassField: "Classes may not have a field named 'constructor'.", ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.", ConstructorIsAccessor: 'Class constructor may not be an accessor.', ConstructorIsAsync: "Constructor can't be an async function.", ConstructorIsGenerator: "Constructor can't be a generator.", DeclarationMissingInitializer: ({ kind: e }) => `Missing initializer in ${e} declaration.`, DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.", DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.", DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.", DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?", DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.", DecoratorSemicolon: 'Decorators must not be followed by a semicolon.', DecoratorStaticBlock: "Decorators can't be used with a static block.", DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.', DeletePrivateField: 'Deleting a private field is not allowed.', DestructureNamedImport: 'ES2015 named imports do not destructure. Use another statement for destructuring after the import.', DuplicateConstructor: 'Duplicate constructor in the same class.', DuplicateDefaultExport: 'Only one default export allowed per module.', DuplicateExport: ({ exportName: e }) => `\`${e}\` has already been exported. Exported identifiers must be unique.`, DuplicateProto: 'Redefinition of __proto__ property.', DuplicateRegExpFlags: 'Duplicate regular expression flag.', DynamicImportPhaseRequiresImportExpressions: ({ phase: e }) => `'import.${e}(...)' can only be parsed when using the 'createImportExpressions' option.`, ElementAfterRest: 'Rest element must be last element.', EscapedCharNotAnIdentifier: 'Invalid Unicode escape.', ExportBindingIsString: ({ localName: e, exportName: t }) => `A string literal cannot be used as an exported binding without \`from\`.\n- Did you mean \`export { '${e}' as '${t}' } from 'some-module'\`?`, ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.", ForInOfLoopInitializer: ({ type: e }) => `'${'ForInStatement' === e ? 'for-in' : 'for-of'}' loop variable declaration may not have an initializer.`, ForInUsing: "For-in loop may not start with 'using' declaration.", ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.", ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.", GeneratorInSingleStatementContext: 'Generators can only be declared at the top level or inside a block.', IllegalBreakContinue: ({ type: e }) => `Unsyntactic ${'BreakStatement' === e ? 'break' : 'continue'}.`, IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.", IllegalReturn: "'return' outside of function.", ImportAttributesUseAssert: 'The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedImportAssert` parser plugin to suppress this error.', ImportBindingIsString: ({ importName: e }) => `A string literal cannot be used as an imported binding.\n- Did you mean \`import { "${e}" as foo }\`?`, ImportCallArity: '`import()` requires exactly one or two arguments.', ImportCallNotNewExpression: 'Cannot use new with import(...).', ImportCallSpreadArgument: '`...` is not allowed in `import()`.', ImportJSONBindingNotDefault: 'A JSON module can only be imported with `default`.', ImportReflectionHasAssertion: '`import module x` cannot have assertions.', ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.', IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.", InvalidBigIntLiteral: 'Invalid BigIntLiteral.', InvalidCodePoint: 'Code point out of bounds.', InvalidCoverInitializedName: 'Invalid shorthand property initializer.', InvalidDecimal: 'Invalid decimal.', InvalidDigit: ({ radix: e }) => `Expected number in radix ${e}.`, InvalidEscapeSequence: 'Bad character escape sequence.', InvalidEscapeSequenceTemplate: 'Invalid escape sequence in template.', InvalidEscapedReservedWord: ({ reservedWord: e }) => `Escape sequence in keyword ${e}.`, InvalidIdentifier: ({ identifierName: e }) => `Invalid identifier ${e}.`, InvalidLhs: ({ ancestor: e }) => `Invalid left-hand side in ${u(e)}.`, InvalidLhsBinding: ({ ancestor: e }) => `Binding invalid left-hand side in ${u(e)}.`, InvalidLhsOptionalChaining: ({ ancestor: e }) => `Invalid optional chaining in the left-hand side of ${u(e)}.`, InvalidNumber: 'Invalid number.', InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.", InvalidOrUnexpectedToken: ({ unexpected: e }) => `Unexpected character '${e}'.`, InvalidParenthesizedAssignment: 'Invalid parenthesized assignment pattern.', InvalidPrivateFieldResolution: ({ identifierName: e }) => `Private name #${e} is not defined.`, InvalidPropertyBindingPattern: 'Binding member expression.', InvalidRecordProperty: 'Only properties and spread elements are allowed in record definitions.', InvalidRestAssignmentPattern: "Invalid rest operator's argument.", LabelRedeclaration: ({ labelName: e }) => `Label '${e}' is already declared.`, LetInLexicalBinding: "'let' is disallowed as a lexically bound name.", LineTerminatorBeforeArrow: "No line break is allowed before '=>'.", MalformedRegExpFlags: 'Invalid regular expression flag.', MissingClassName: 'A class name is required.', MissingEqInAssignment: "Only '=' operator can be used for specifying default value.", MissingSemicolon: 'Missing semicolon.', MissingPlugin: ({ missingPlugin: e }) => `This experimental syntax requires enabling the parser plugin: ${e.map((e) => JSON.stringify(e)).join(', ')}.`, MissingOneOfPlugins: ({ missingPlugin: e }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${e.map((e) => JSON.stringify(e)).join(', ')}.`, MissingUnicodeEscape: 'Expecting Unicode escape sequence \\uXXXX.', MixingCoalesceWithLogical: 'Nullish coalescing operator(??) requires parens when mixing with logical operators.', ModuleAttributeDifferentFromType: 'The only accepted module attribute is `type`.', ModuleAttributeInvalidValue: 'Only string literals are allowed as module attribute values.', ModuleAttributesWithDuplicateKeys: ({ key: e }) => `Duplicate key "${e}" is not allowed in module attributes.`, ModuleExportNameHasLoneSurrogate: ({ surrogateCharCode: e }) => `An export name cannot include a lone surrogate, found '\\u${e.toString(16)}'.`, ModuleExportUndefined: ({ localName: e }) => `Export '${e}' is not defined.`, MultipleDefaultsInSwitch: 'Multiple default clauses.', NewlineAfterThrow: 'Illegal newline after throw.', NoCatchOrFinally: 'Missing catch or finally clause.', NumberIdentifier: 'Identifier directly after number.', NumericSeparatorInEscapeSequence: 'Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.', ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.", OptionalChainingNoNew: 'Constructors in/after an Optional Chain are not allowed.', OptionalChainingNoTemplate: 'Tagged Template Literals are not allowed in optionalChain.', OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.", ParamDupe: 'Argument name clash.', PatternHasAccessor: "Object pattern can't contain getter or setter.", PatternHasMethod: "Object pattern can't contain methods.", PrivateInExpectedIn: ({ identifierName: e }) => `Private names are only allowed in property accesses (\`obj.#${e}\`) or in \`in\` expressions (\`#${e} in obj\`).`, PrivateNameRedeclaration: ({ identifierName: e }) => `Duplicate private name #${e}.`, RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", RecordNoProto: "'__proto__' is not allowed in Record expressions.", RestTrailingComma: 'Unexpected trailing comma after rest element.', SloppyFunction: 'In non-strict mode code, functions can only be declared at top level or inside a block.', SloppyFunctionAnnexB: 'In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.', SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.', StaticPrototype: 'Classes may not have static property named prototype.', SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?", SuperPrivateField: "Private fields can't be accessed on super.", TrailingDecorator: 'Decorators must be attached to a class element.', TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", UnexpectedArgumentPlaceholder: 'Unexpected argument placeholder.', UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.', UnexpectedDigitAfterHash: 'Unexpected digit after hash token.', UnexpectedImportExport: "'import' and 'export' may only appear at the top level.", UnexpectedKeyword: ({ keyword: e }) => `Unexpected keyword '${e}'.`, UnexpectedLeadingDecorator: 'Leading decorators must be attached to a class declaration.', UnexpectedLexicalDeclaration: 'Lexical declaration cannot appear in a single-statement context.', UnexpectedNewTarget: '`new.target` can only be used in functions or class properties.', UnexpectedNumericSeparator: 'A numeric separator is only allowed between two digits.', UnexpectedPrivateField: 'Unexpected private name.', UnexpectedReservedWord: ({ reservedWord: e }) => `Unexpected reserved word '${e}'.`, UnexpectedSuper: "'super' is only allowed in object methods and classes.", UnexpectedToken: ({ expected: e, unexpected: t }) => `Unexpected token${t ? ` '${t}'.` : ''}${e ? `, expected "${e}"` : ''}`, UnexpectedTokenUnaryExponentiation: 'Illegal expression. Wrap left hand side or entire exponentiation in parentheses.', UnexpectedUsingDeclaration: 'Using declaration cannot appear in the top level when source type is `script`.', UnsupportedBind: 'Binding should be performed on object property.', UnsupportedDecoratorExport: 'A decorated export must export a class declaration.', UnsupportedDefaultExport: 'Only expressions, functions or classes are allowed as the `default` export.', UnsupportedImport: '`import` can only be used in `import()` or `import.meta`.', UnsupportedMetaProperty: ({ target: e, onlyValidPropertyName: t }) => `The only valid meta property for ${e} is ${e}.${t}.`, UnsupportedParameterDecorator: 'Decorators cannot be used to decorate parameters.', UnsupportedPropertyDecorator: 'Decorators cannot be used to decorate object literal properties.', UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).", UnterminatedComment: 'Unterminated comment.', UnterminatedRegExp: 'Unterminated regular expression.', UnterminatedString: 'Unterminated string constant.', UnterminatedTemplate: 'Unterminated template.', UsingDeclarationExport: 'Using declaration cannot be exported.', UsingDeclarationHasBindingPattern: 'Using declaration cannot have destructuring patterns.', VarRedeclaration: ({ identifierName: e }) => `Identifier '${e}' has already been declared.`, YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.", YieldInParameter: 'Yield expression is not allowed in formal parameters.', ZeroDigitNumericSeparator: 'Numeric separator can not be used after leading 0.' },
       p = new Set(['ArrowFunctionExpression', 'AssignmentExpression', 'ConditionalExpression', 'YieldExpression']),
       c = Object.assign({ PipeBodyIsTighter: 'Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.', PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.', PipeTopicUnbound: 'Topic reference is unbound; it must be inside a pipe body.', PipeTopicUnconfiguredToken: ({ token: e }) => `Invalid topic token ${e}. In order to use ${e} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${e}" }.`, PipeTopicUnused: 'Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.', PipeUnparenthesizedBody: ({ type: e }) => `Hack-style pipe body cannot be an unparenthesized ${u({ type: e })}; please wrap it in parentheses.` }, { PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.', PipelineBodySequenceExpression: 'Pipeline body may not be a comma-separated sequence expression.', PipelineHeadSequenceExpression: 'Pipeline head should not be a comma-separated sequence expression.', PipelineTopicUnused: 'Pipeline is in topic style but does not use topic reference.', PrimaryTopicNotAllowed: 'Topic reference was used in a lexical context without topic binding.', PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.' }),
       h = ['message'];
      function d(e, t, r) {
       Object.defineProperty(e, t, { enumerable: !1, configurable: !0, value: r });
      }
      function f({ toMessage: e, code: t, reasonCode: n, syntaxPlugin: s }) {
       let i = 'MissingPlugin' === n || 'MissingOneOfPlugins' === n;
       {
        let e = { AccessorCannotDeclareThisParameter: 'AccesorCannotDeclareThisParameter', AccessorCannotHaveTypeParameters: 'AccesorCannotHaveTypeParameters', ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: 'ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference', SetAccessorCannotHaveOptionalParameter: 'SetAccesorCannotHaveOptionalParameter', SetAccessorCannotHaveRestParameter: 'SetAccesorCannotHaveRestParameter', SetAccessorCannotHaveReturnType: 'SetAccesorCannotHaveReturnType' };
        e[n] && (n = e[n]);
       }
       return function a(o, u) {
        let l = new SyntaxError();
        return (
         (l.code = t),
         (l.reasonCode = n),
         (l.loc = o),
         (l.pos = o.index),
         (l.syntaxPlugin = s),
         i && (l.missingPlugin = u.missingPlugin),
         d(l, 'clone', function (e = {}) {
          var t;
          let { line: n, column: s, index: i } = null != (t = e.loc) ? t : o;
          return a(new r(n, s, i), Object.assign({}, u, e.details));
         }),
         d(l, 'details', u),
         Object.defineProperty(l, 'message', {
          configurable: !0,
          get() {
           let t = `${e(u)} (${o.line}:${o.column})`;
           return (this.message = t), t;
          },
          set(e) {
           Object.defineProperty(this, 'message', { value: e, writable: !0 });
          },
         }),
         l
        );
       };
      }
      function m(e, r) {
       if (Array.isArray(e)) return (t) => m(t, e[0]);
       let n = {};
       for (let s of Object.keys(e)) {
        let i = e[s],
         a = 'string' == typeof i ? { message: () => i } : 'function' == typeof i ? { message: i } : i,
         { message: o } = a,
         u = t(a, h),
         l = 'string' == typeof o ? () => o : o;
        n[s] = f(Object.assign({ code: 'BABEL_PARSER_SYNTAX_ERROR', reasonCode: s, toMessage: l }, r ? { syntaxPlugin: r } : {}, u));
       }
       return n;
      }
      var y = Object.assign({}, m(a), m(l), m({ StrictDelete: 'Deleting local variable in strict mode.', StrictEvalArguments: ({ referenceName: e }) => `Assigning to '${e}' in strict mode.`, StrictEvalArgumentsBinding: ({ bindingName: e }) => `Binding '${e}' in strict mode.`, StrictFunction: 'In strict mode code, functions can only be declared at top level or inside a block.', StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.", StrictOctalLiteral: 'Legacy octal literals are not allowed in strict mode.', StrictWith: "'with' in strict mode." }), m`pipelineOperator`(c)),
       { defineProperty: g } = Object,
       D = (e, t) => {
        e && g(e, t, { enumerable: !1, value: e[t] });
       };
      function x(e) {
       return D(e.loc.start, 'index'), D(e.loc.end, 'index'), e;
      }
      var b = class {
        constructor(e, t) {
         (this.token = void 0), (this.preserveSpace = void 0), (this.token = e), (this.preserveSpace = !!t);
        }
       },
       v = { brace: new b('{'), j_oTag: new b('<tag'), j_cTag: new b('</tag'), j_expr: new b('<tag>...</tag>', !0) };
      v.template = new b('`', !0);
      var E = !0,
       C = !0,
       T = !0,
       S = !0,
       w = !0,
       A = class {
        constructor(e, t = {}) {
         (this.label = void 0), (this.keyword = void 0), (this.beforeExpr = void 0), (this.startsExpr = void 0), (this.rightAssociative = void 0), (this.isLoop = void 0), (this.isAssign = void 0), (this.prefix = void 0), (this.postfix = void 0), (this.binop = void 0), (this.label = e), (this.keyword = t.keyword), (this.beforeExpr = !!t.beforeExpr), (this.startsExpr = !!t.startsExpr), (this.rightAssociative = !!t.rightAssociative), (this.isLoop = !!t.isLoop), (this.isAssign = !!t.isAssign), (this.prefix = !!t.prefix), (this.postfix = !!t.postfix), (this.binop = null != t.binop ? t.binop : null), (this.updateContext = null);
        }
       },
       F = new Map();
      function k(e, t = {}) {
       t.keyword = e;
       let r = j(e, t);
       return F.set(e, r), r;
      }
      function P(e, t) {
       return j(e, { beforeExpr: E, binop: t });
      }
      var I = -1,
       N = [],
       B = [],
       _ = [],
       L = [],
       O = [],
       M = [];
      function j(e, t = {}) {
       var r, n, s, i;
       return ++I, B.push(e), _.push(null != (r = t.binop) ? r : -1), L.push(null != (n = t.beforeExpr) && n), O.push(null != (s = t.startsExpr) && s), M.push(null != (i = t.prefix) && i), N.push(new A(e, t)), I;
      }
      function R(e, t = {}) {
       var r, n, s, i;
       return ++I, F.set(e, I), B.push(e), _.push(null != (r = t.binop) ? r : -1), L.push(null != (n = t.beforeExpr) && n), O.push(null != (s = t.startsExpr) && s), M.push(null != (i = t.prefix) && i), N.push(new A('name', t)), I;
      }
      var q = { bracketL: j('[', { beforeExpr: E, startsExpr: C }), bracketHashL: j('#[', { beforeExpr: E, startsExpr: C }), bracketBarL: j('[|', { beforeExpr: E, startsExpr: C }), bracketR: j(']'), bracketBarR: j('|]'), braceL: j('{', { beforeExpr: E, startsExpr: C }), braceBarL: j('{|', { beforeExpr: E, startsExpr: C }), braceHashL: j('#{', { beforeExpr: E, startsExpr: C }), braceR: j('}'), braceBarR: j('|}'), parenL: j('(', { beforeExpr: E, startsExpr: C }), parenR: j(')'), comma: j(',', { beforeExpr: E }), semi: j(';', { beforeExpr: E }), colon: j(':', { beforeExpr: E }), doubleColon: j('::', { beforeExpr: E }), dot: j('.'), question: j('?', { beforeExpr: E }), questionDot: j('?.'), arrow: j('=>', { beforeExpr: E }), template: j('template'), ellipsis: j('...', { beforeExpr: E }), backQuote: j('`', { startsExpr: C }), dollarBraceL: j('${', { beforeExpr: E, startsExpr: C }), templateTail: j('...`', { startsExpr: C }), templateNonTail: j('...${', { beforeExpr: E, startsExpr: C }), at: j('@'), hash: j('#', { startsExpr: C }), interpreterDirective: j('#!...'), eq: j('=', { beforeExpr: E, isAssign: S }), assign: j('_=', { beforeExpr: E, isAssign: S }), slashAssign: j('_=', { beforeExpr: E, isAssign: S }), xorAssign: j('_=', { beforeExpr: E, isAssign: S }), moduloAssign: j('_=', { beforeExpr: E, isAssign: S }), incDec: j('++/--', { prefix: w, postfix: !0, startsExpr: C }), bang: j('!', { beforeExpr: E, prefix: w, startsExpr: C }), tilde: j('~', { beforeExpr: E, prefix: w, startsExpr: C }), doubleCaret: j('^^', { startsExpr: C }), doubleAt: j('@@', { startsExpr: C }), pipeline: P('|>', 0), nullishCoalescing: P('??', 1), logicalOR: P('||', 1), logicalAND: P('&&', 2), bitwiseOR: P('|', 3), bitwiseXOR: P('^', 4), bitwiseAND: P('&', 5), equality: P('==/!=/===/!==', 6), lt: P('</>/<=/>=', 7), gt: P('</>/<=/>=', 7), relational: P('</>/<=/>=', 7), bitShift: P('<</>>/>>>', 8), bitShiftL: P('<</>>/>>>', 8), bitShiftR: P('<</>>/>>>', 8), plusMin: j('+/-', { beforeExpr: E, binop: 9, prefix: w, startsExpr: C }), modulo: j('%', { binop: 10, startsExpr: C }), star: j('*', { binop: 10 }), slash: P('/', 10), exponent: j('**', { beforeExpr: E, binop: 11, rightAssociative: !0 }), _in: k('in', { beforeExpr: E, binop: 7 }), _instanceof: k('instanceof', { beforeExpr: E, binop: 7 }), _break: k('break'), _case: k('case', { beforeExpr: E }), _catch: k('catch'), _continue: k('continue'), _debugger: k('debugger'), _default: k('default', { beforeExpr: E }), _else: k('else', { beforeExpr: E }), _finally: k('finally'), _function: k('function', { startsExpr: C }), _if: k('if'), _return: k('return', { beforeExpr: E }), _switch: k('switch'), _throw: k('throw', { beforeExpr: E, prefix: w, startsExpr: C }), _try: k('try'), _var: k('var'), _const: k('const'), _with: k('with'), _new: k('new', { beforeExpr: E, startsExpr: C }), _this: k('this', { startsExpr: C }), _super: k('super', { startsExpr: C }), _class: k('class', { startsExpr: C }), _extends: k('extends', { beforeExpr: E }), _export: k('export'), _import: k('import', { startsExpr: C }), _null: k('null', { startsExpr: C }), _true: k('true', { startsExpr: C }), _false: k('false', { startsExpr: C }), _typeof: k('typeof', { beforeExpr: E, prefix: w, startsExpr: C }), _void: k('void', { beforeExpr: E, prefix: w, startsExpr: C }), _delete: k('delete', { beforeExpr: E, prefix: w, startsExpr: C }), _do: k('do', { isLoop: T, beforeExpr: E }), _for: k('for', { isLoop: T }), _while: k('while', { isLoop: T }), _as: R('as', { startsExpr: C }), _assert: R('assert', { startsExpr: C }), _async: R('async', { startsExpr: C }), _await: R('await', { startsExpr: C }), _defer: R('defer', { startsExpr: C }), _from: R('from', { startsExpr: C }), _get: R('get', { startsExpr: C }), _let: R('let', { startsExpr: C }), _meta: R('meta', { startsExpr: C }), _of: R('of', { startsExpr: C }), _sent: R('sent', { startsExpr: C }), _set: R('set', { startsExpr: C }), _source: R('source', { startsExpr: C }), _static: R('static', { startsExpr: C }), _using: R('using', { startsExpr: C }), _yield: R('yield', { startsExpr: C }), _asserts: R('asserts', { startsExpr: C }), _checks: R('checks', { startsExpr: C }), _exports: R('exports', { startsExpr: C }), _global: R('global', { startsExpr: C }), _implements: R('implements', { startsExpr: C }), _intrinsic: R('intrinsic', { startsExpr: C }), _infer: R('infer', { startsExpr: C }), _is: R('is', { startsExpr: C }), _mixins: R('mixins', { startsExpr: C }), _proto: R('proto', { startsExpr: C }), _require: R('require', { startsExpr: C }), _satisfies: R('satisfies', { startsExpr: C }), _keyof: R('keyof', { startsExpr: C }), _readonly: R('readonly', { startsExpr: C }), _unique: R('unique', { startsExpr: C }), _abstract: R('abstract', { startsExpr: C }), _declare: R('declare', { startsExpr: C }), _enum: R('enum', { startsExpr: C }), _module: R('module', { startsExpr: C }), _namespace: R('namespace', { startsExpr: C }), _interface: R('interface', { startsExpr: C }), _type: R('type', { startsExpr: C }), _opaque: R('opaque', { startsExpr: C }), name: j('name', { startsExpr: C }), placeholder: j('%%', { startsExpr: !0 }), string: j('string', { startsExpr: C }), num: j('num', { startsExpr: C }), bigint: j('bigint', { startsExpr: C }), decimal: j('decimal', { startsExpr: C }), regexp: j('regexp', { startsExpr: C }), privateName: j('#name', { startsExpr: C }), eof: j('eof'), jsxName: j('jsxName'), jsxText: j('jsxText', { beforeExpr: !0 }), jsxTagStart: j('jsxTagStart', { startsExpr: !0 }), jsxTagEnd: j('jsxTagEnd') };
      function U(e) {
       return e >= 93 && e <= 133;
      }
      function $(e) {
       return e >= 58 && e <= 133;
      }
      function H(e) {
       return e >= 58 && e <= 137;
      }
      function z(e) {
       return O[e];
      }
      function V(e) {
       return e >= 129 && e <= 131;
      }
      function W(e) {
       return e >= 58 && e <= 92;
      }
      function J(e) {
       return B[e];
      }
      function K(e) {
       return _[e];
      }
      function G(e) {
       return e >= 24 && e <= 25;
      }
      function X(e) {
       return N[e];
      }
      (N[8].updateContext = (e) => {
       e.pop();
      }),
       (N[5].updateContext =
        N[7].updateContext =
        N[23].updateContext =
         (e) => {
          e.push(v.brace);
         }),
       (N[22].updateContext = (e) => {
        e[e.length - 1] === v.template ? e.pop() : e.push(v.template);
       }),
       (N[143].updateContext = (e) => {
        e.push(v.j_expr, v.j_oTag);
       });
      var Y = '\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u0870-\u0887\u0889-\u088e\u08a0-\u08c9\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c5d\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cdd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u1711\u171f-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4c\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c8a\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7cd\ua7d0\ua7d1\ua7d3\ua7d5-\ua7dc\ua7f2-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc',
       Q = '\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u0897-\u089f\u08ca-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3c\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0cf3\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ece\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u180f-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf-\u1ace\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1dff\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\u30fb\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f\uff65',
       Z = new RegExp('[' + Y + ']'),
       ee = new RegExp('[' + Y + Q + ']');
      Y = Q = null;
      var te = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191],
       re = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
      function ne(e, t) {
       let r = 65536;
       for (let n = 0, s = t.length; n < s; n += 2) {
        if (((r += t[n]), r > e)) return !1;
        if (((r += t[n + 1]), r >= e)) return !0;
       }
       return !1;
      }
      function se(e) {
       return e < 65 ? 36 === e : e <= 90 || (e < 97 ? 95 === e : e <= 122 || (e <= 65535 ? e >= 170 && Z.test(String.fromCharCode(e)) : ne(e, te)));
      }
      function ie(e) {
       return e < 48 ? 36 === e : e < 58 || (!(e < 65) && (e <= 90 || (e < 97 ? 95 === e : e <= 122 || (e <= 65535 ? e >= 170 && ee.test(String.fromCharCode(e)) : ne(e, te) || ne(e, re)))));
      }
      var ae = ['implements', 'interface', 'let', 'package', 'private', 'protected', 'public', 'static', 'yield'],
       oe = ['eval', 'arguments'],
       ue = new Set(['break', 'case', 'catch', 'continue', 'debugger', 'default', 'do', 'else', 'finally', 'for', 'function', 'if', 'return', 'switch', 'throw', 'try', 'var', 'const', 'while', 'with', 'new', 'this', 'super', 'class', 'extends', 'export', 'import', 'null', 'true', 'false', 'in', 'instanceof', 'typeof', 'void', 'delete']),
       le = new Set(ae),
       pe = new Set(oe);
      function ce(e, t) {
       return (t && 'await' === e) || 'enum' === e;
      }
      function he(e, t) {
       return ce(e, t) || le.has(e);
      }
      function de(e) {
       return pe.has(e);
      }
      function fe(e, t) {
       return he(e, t) || de(e);
      }
      var me = new Set(['break', 'case', 'catch', 'continue', 'debugger', 'default', 'do', 'else', 'finally', 'for', 'function', 'if', 'return', 'switch', 'throw', 'try', 'var', 'const', 'while', 'with', 'new', 'this', 'super', 'class', 'extends', 'export', 'import', 'null', 'true', 'false', 'in', 'instanceof', 'typeof', 'void', 'delete', 'implements', 'interface', 'let', 'package', 'private', 'protected', 'public', 'static', 'yield', 'eval', 'arguments', 'enum', 'await']),
       ye = class {
        constructor(e) {
         (this.flags = 0), (this.names = new Map()), (this.firstLexicalName = ''), (this.flags = e);
        }
       },
       ge = class {
        constructor(e, t) {
         (this.parser = void 0), (this.scopeStack = []), (this.inModule = void 0), (this.undefinedExports = new Map()), (this.parser = e), (this.inModule = t);
        }
        get inTopLevel() {
         return (1 & this.currentScope().flags) > 0;
        }
        get inFunction() {
         return (2 & this.currentVarScopeFlags()) > 0;
        }
        get allowSuper() {
         return (16 & this.currentThisScopeFlags()) > 0;
        }
        get allowDirectSuper() {
         return (32 & this.currentThisScopeFlags()) > 0;
        }
        get inClass() {
         return (64 & this.currentThisScopeFlags()) > 0;
        }
        get inClassAndNotInNonArrowFunction() {
         let e = this.currentThisScopeFlags();
         return (64 & e) > 0 && 0 == (2 & e);
        }
        get inStaticBlock() {
         for (let e = this.scopeStack.length - 1; ; e--) {
          let { flags: t } = this.scopeStack[e];
          if (128 & t) return !0;
          if (451 & t) return !1;
         }
        }
        get inNonArrowFunction() {
         return (2 & this.currentThisScopeFlags()) > 0;
        }
        get treatFunctionsAsVar() {
         return this.treatFunctionsAsVarInScope(this.currentScope());
        }
        createScope(e) {
         return new ye(e);
        }
        enter(e) {
         this.scopeStack.push(this.createScope(e));
        }
        exit() {
         return this.scopeStack.pop().flags;
        }
        treatFunctionsAsVarInScope(e) {
         return !!(130 & e.flags || (!this.parser.inModule && 1 & e.flags));
        }
        declareName(e, t, r) {
         let n = this.currentScope();
         if (8 & t || 16 & t) {
          this.checkRedeclarationInScope(n, e, t, r);
          let s = n.names.get(e) || 0;
          16 & t ? (s |= 4) : (n.firstLexicalName || (n.firstLexicalName = e), (s |= 2)), n.names.set(e, s), 8 & t && this.maybeExportDefined(n, e);
         } else if (4 & t) for (let s = this.scopeStack.length - 1; s >= 0 && ((n = this.scopeStack[s]), this.checkRedeclarationInScope(n, e, t, r), n.names.set(e, 1 | (n.names.get(e) || 0)), this.maybeExportDefined(n, e), !(387 & n.flags)); --s);
         this.parser.inModule && 1 & n.flags && this.undefinedExports.delete(e);
        }
        maybeExportDefined(e, t) {
         this.parser.inModule && 1 & e.flags && this.undefinedExports.delete(t);
        }
        checkRedeclarationInScope(e, t, r, n) {
         this.isRedeclaredInScope(e, t, r) && this.parser.raise(y.VarRedeclaration, n, { identifierName: t });
        }
        isRedeclaredInScope(e, t, r) {
         if (!(1 & r)) return !1;
         if (8 & r) return e.names.has(t);
         let n = e.names.get(t);
         return 16 & r ? (2 & n) > 0 || (!this.treatFunctionsAsVarInScope(e) && (1 & n) > 0) : ((2 & n) > 0 && !(8 & e.flags && e.firstLexicalName === t)) || (!this.treatFunctionsAsVarInScope(e) && (4 & n) > 0);
        }
        checkLocalExport(e) {
         let { name: t } = e;
         this.scopeStack[0].names.has(t) || this.undefinedExports.set(t, e.loc.start);
        }
        currentScope() {
         return this.scopeStack[this.scopeStack.length - 1];
        }
        currentVarScopeFlags() {
         for (let e = this.scopeStack.length - 1; ; e--) {
          let { flags: t } = this.scopeStack[e];
          if (387 & t) return t;
         }
        }
        currentThisScopeFlags() {
         for (let e = this.scopeStack.length - 1; ; e--) {
          let { flags: t } = this.scopeStack[e];
          if (451 & t && !(4 & t)) return t;
         }
        }
       },
       De = class extends ye {
        constructor(...e) {
         super(...e), (this.declareFunctions = new Set());
        }
       },
       xe = class extends ge {
        createScope(e) {
         return new De(e);
        }
        declareName(e, t, r) {
         let n = this.currentScope();
         if (2048 & t) return this.checkRedeclarationInScope(n, e, t, r), this.maybeExportDefined(n, e), void n.declareFunctions.add(e);
         super.declareName(e, t, r);
        }
        isRedeclaredInScope(e, t, r) {
         if (super.isRedeclaredInScope(e, t, r)) return !0;
         if (2048 & r && !e.declareFunctions.has(t)) {
          let r = e.names.get(t);
          return (4 & r) > 0 || (2 & r) > 0;
         }
         return !1;
        }
        checkLocalExport(e) {
         this.scopeStack[0].declareFunctions.has(e.name) || super.checkLocalExport(e);
        }
       },
       be = class {
        constructor() {
         (this.sawUnambiguousESM = !1), (this.ambiguousScriptDifferentAst = !1);
        }
        sourceToOffsetPos(e) {
         return e + this.startIndex;
        }
        offsetToSourcePos(e) {
         return e - this.startIndex;
        }
        hasPlugin(e) {
         if ('string' == typeof e) return this.plugins.has(e);
         {
          let [t, r] = e;
          if (!this.hasPlugin(t)) return !1;
          let n = this.plugins.get(t);
          for (let e of Object.keys(r)) if ((null == n ? void 0 : n[e]) !== r[e]) return !1;
          return !0;
         }
        }
        getPluginOption(e, t) {
         var r;
         return null == (r = this.plugins.get(e)) ? void 0 : r[t];
        }
       };
      function ve(e, t) {
       void 0 === e.trailingComments ? (e.trailingComments = t) : e.trailingComments.unshift(...t);
      }
      function Ee(e, t) {
       void 0 === e.innerComments ? (e.innerComments = t) : e.innerComments.unshift(...t);
      }
      function Ce(e, t, r) {
       let n = null,
        s = t.length;
       for (; null === n && s > 0; ) n = t[--s];
       null === n || n.start > r.start ? Ee(e, r.comments) : ve(n, r.comments);
      }
      var Te = class extends be {
        addComment(e) {
         this.filename && (e.loc.filename = this.filename);
         let { commentsLen: t } = this.state;
         this.comments.length !== t && (this.comments.length = t), this.comments.push(e), this.state.commentsLen++;
        }
        processComment(e) {
         let { commentStack: t } = this.state,
          r = t.length;
         if (0 === r) return;
         let n = r - 1,
          s = t[n];
         s.start === e.end && ((s.leadingNode = e), n--);
         let { start: i } = e;
         for (; n >= 0; n--) {
          let r = t[n],
           s = r.end;
          if (!(s > i)) {
           s === i && (r.trailingNode = e);
           break;
          }
          (r.containingNode = e), this.finalizeComment(r), t.splice(n, 1);
         }
        }
        finalizeComment(e) {
         let { comments: t } = e;
         if (null !== e.leadingNode || null !== e.trailingNode)
          null !== e.leadingNode && ve(e.leadingNode, t),
           null !== e.trailingNode &&
            (function (e, t) {
             void 0 === e.leadingComments ? (e.leadingComments = t) : e.leadingComments.unshift(...t);
            })(e.trailingNode, t);
         else {
          let { containingNode: r, start: n } = e;
          if (44 === this.input.charCodeAt(this.offsetToSourcePos(n) - 1))
           switch (r.type) {
            case 'ObjectExpression':
            case 'ObjectPattern':
            case 'RecordExpression':
             Ce(r, r.properties, e);
             break;
            case 'CallExpression':
            case 'OptionalCallExpression':
             Ce(r, r.arguments, e);
             break;
            case 'FunctionDeclaration':
            case 'FunctionExpression':
            case 'ArrowFunctionExpression':
            case 'ObjectMethod':
            case 'ClassMethod':
            case 'ClassPrivateMethod':
             Ce(r, r.params, e);
             break;
            case 'ArrayExpression':
            case 'ArrayPattern':
            case 'TupleExpression':
             Ce(r, r.elements, e);
             break;
            case 'ExportNamedDeclaration':
            case 'ImportDeclaration':
             Ce(r, r.specifiers, e);
             break;
            case 'TSEnumDeclaration':
            case 'TSEnumBody':
             Ce(r, r.members, e);
             break;
            default:
             Ee(r, t);
           }
          else Ee(r, t);
         }
        }
        finalizeRemainingComments() {
         let { commentStack: e } = this.state;
         for (let t = e.length - 1; t >= 0; t--) this.finalizeComment(e[t]);
         this.state.commentStack = [];
        }
        resetPreviousNodeTrailingComments(e) {
         let { commentStack: t } = this.state,
          { length: r } = t;
         if (0 === r) return;
         let n = t[r - 1];
         n.leadingNode === e && (n.leadingNode = null);
        }
        resetPreviousIdentifierLeadingComments(e) {
         let { commentStack: t } = this.state,
          { length: r } = t;
         0 !== r && (t[r - 1].trailingNode === e ? (t[r - 1].trailingNode = null) : r >= 2 && t[r - 2].trailingNode === e && (t[r - 2].trailingNode = null));
        }
        takeSurroundingComments(e, t, r) {
         let { commentStack: n } = this.state,
          s = n.length;
         if (0 === s) return;
         let i = s - 1;
         for (; i >= 0; i--) {
          let s = n[i],
           a = s.end;
          if (s.start === r) s.leadingNode = e;
          else if (a === t) s.trailingNode = e;
          else if (a < t) break;
         }
        }
       },
       Se = new RegExp(/\r\n|[\r\n\u2028\u2029]/.source, 'g');
      function we(e) {
       switch (e) {
        case 10:
        case 13:
        case 8232:
        case 8233:
         return !0;
        default:
         return !1;
       }
      }
      function Ae(e, t, r) {
       for (let n = t; n < r; n++) if (we(e.charCodeAt(n))) return !0;
       return !1;
      }
      var Fe = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g,
       ke = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g;
      function Pe(e) {
       switch (e) {
        case 9:
        case 11:
        case 12:
        case 32:
        case 160:
        case 5760:
        case 8192:
        case 8193:
        case 8194:
        case 8195:
        case 8196:
        case 8197:
        case 8198:
        case 8199:
        case 8200:
        case 8201:
        case 8202:
        case 8239:
        case 8287:
        case 12288:
        case 65279:
         return !0;
        default:
         return !1;
       }
      }
      var Ie = class e {
        constructor() {
         (this.flags = 1024), (this.startIndex = void 0), (this.curLine = void 0), (this.lineStart = void 0), (this.startLoc = void 0), (this.endLoc = void 0), (this.errors = []), (this.potentialArrowAt = -1), (this.noArrowAt = []), (this.noArrowParamsConversionAt = []), (this.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null }), (this.labels = []), (this.commentsLen = 0), (this.commentStack = []), (this.pos = 0), (this.type = 140), (this.value = null), (this.start = 0), (this.end = 0), (this.lastTokEndLoc = null), (this.lastTokStartLoc = null), (this.context = [v.brace]), (this.firstInvalidTemplateEscapePos = null), (this.strictErrors = new Map()), (this.tokensLength = 0);
        }
        get strict() {
         return (1 & this.flags) > 0;
        }
        set strict(e) {
         e ? (this.flags |= 1) : (this.flags &= -2);
        }
        init({ strictMode: e, sourceType: t, startIndex: n, startLine: s, startColumn: i }) {
         (this.strict = !1 !== e && (!0 === e || 'module' === t)), (this.startIndex = n), (this.curLine = s), (this.lineStart = -i), (this.startLoc = this.endLoc = new r(s, i, n));
        }
        get maybeInArrowParameters() {
         return (2 & this.flags) > 0;
        }
        set maybeInArrowParameters(e) {
         e ? (this.flags |= 2) : (this.flags &= -3);
        }
        get inType() {
         return (4 & this.flags) > 0;
        }
        set inType(e) {
         e ? (this.flags |= 4) : (this.flags &= -5);
        }
        get noAnonFunctionType() {
         return (8 & this.flags) > 0;
        }
        set noAnonFunctionType(e) {
         e ? (this.flags |= 8) : (this.flags &= -9);
        }
        get hasFlowComment() {
         return (16 & this.flags) > 0;
        }
        set hasFlowComment(e) {
         e ? (this.flags |= 16) : (this.flags &= -17);
        }
        get isAmbientContext() {
         return (32 & this.flags) > 0;
        }
        set isAmbientContext(e) {
         e ? (this.flags |= 32) : (this.flags &= -33);
        }
        get inAbstractClass() {
         return (64 & this.flags) > 0;
        }
        set inAbstractClass(e) {
         e ? (this.flags |= 64) : (this.flags &= -65);
        }
        get inDisallowConditionalTypesContext() {
         return (128 & this.flags) > 0;
        }
        set inDisallowConditionalTypesContext(e) {
         e ? (this.flags |= 128) : (this.flags &= -129);
        }
        get soloAwait() {
         return (256 & this.flags) > 0;
        }
        set soloAwait(e) {
         e ? (this.flags |= 256) : (this.flags &= -257);
        }
        get inFSharpPipelineDirectBody() {
         return (512 & this.flags) > 0;
        }
        set inFSharpPipelineDirectBody(e) {
         e ? (this.flags |= 512) : (this.flags &= -513);
        }
        get canStartJSXElement() {
         return (1024 & this.flags) > 0;
        }
        set canStartJSXElement(e) {
         e ? (this.flags |= 1024) : (this.flags &= -1025);
        }
        get containsEsc() {
         return (2048 & this.flags) > 0;
        }
        set containsEsc(e) {
         e ? (this.flags |= 2048) : (this.flags &= -2049);
        }
        get hasTopLevelAwait() {
         return (4096 & this.flags) > 0;
        }
        set hasTopLevelAwait(e) {
         e ? (this.flags |= 4096) : (this.flags &= -4097);
        }
        curPosition() {
         return new r(this.curLine, this.pos - this.lineStart, this.pos + this.startIndex);
        }
        clone() {
         let t = new e();
         return (t.flags = this.flags), (t.startIndex = this.startIndex), (t.curLine = this.curLine), (t.lineStart = this.lineStart), (t.startLoc = this.startLoc), (t.endLoc = this.endLoc), (t.errors = this.errors.slice()), (t.potentialArrowAt = this.potentialArrowAt), (t.noArrowAt = this.noArrowAt.slice()), (t.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice()), (t.topicContext = this.topicContext), (t.labels = this.labels.slice()), (t.commentsLen = this.commentsLen), (t.commentStack = this.commentStack.slice()), (t.pos = this.pos), (t.type = this.type), (t.value = this.value), (t.start = this.start), (t.end = this.end), (t.lastTokEndLoc = this.lastTokEndLoc), (t.lastTokStartLoc = this.lastTokStartLoc), (t.context = this.context.slice()), (t.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos), (t.strictErrors = this.strictErrors), (t.tokensLength = this.tokensLength), t;
        }
       },
       Ne = function (e) {
        return e >= 48 && e <= 57;
       },
       Be = { decBinOct: new Set([46, 66, 69, 79, 95, 98, 101, 111]), hex: new Set([46, 88, 95, 120]) },
       _e = { bin: (e) => 48 === e || 49 === e, oct: (e) => e >= 48 && e <= 55, dec: (e) => e >= 48 && e <= 57, hex: (e) => (e >= 48 && e <= 57) || (e >= 65 && e <= 70) || (e >= 97 && e <= 102) };
      function Le(e, t, r, n, s, i) {
       let a = r,
        o = n,
        u = s,
        l = '',
        p = null,
        c = r,
        { length: h } = t;
       for (;;) {
        if (r >= h) {
         i.unterminated(a, o, u), (l += t.slice(c, r));
         break;
        }
        let d = t.charCodeAt(r);
        if (Oe(e, d, t, r)) {
         l += t.slice(c, r);
         break;
        }
        if (92 === d) {
         l += t.slice(c, r);
         let a = Me(t, r, n, s, 'template' === e, i);
         null !== a.ch || p ? (l += a.ch) : (p = { pos: r, lineStart: n, curLine: s }), ({ pos: r, lineStart: n, curLine: s } = a), (c = r);
        } else 8232 === d || 8233 === d ? (++s, (n = ++r)) : 10 === d || 13 === d ? ('template' === e ? ((l += t.slice(c, r) + '\n'), ++r, 13 === d && 10 === t.charCodeAt(r) && ++r, ++s, (c = n = r)) : i.unterminated(a, o, u)) : ++r;
       }
       return { pos: r, str: l, firstInvalidLoc: p, lineStart: n, curLine: s, containsInvalid: !!p };
      }
      function Oe(e, t, r, n) {
       return 'template' === e ? 96 === t || (36 === t && 123 === r.charCodeAt(n + 1)) : t === ('double' === e ? 34 : 39);
      }
      function Me(e, t, r, n, s, i) {
       let a = !s;
       t++;
       let o = (e) => ({ pos: t, ch: e, lineStart: r, curLine: n }),
        u = e.charCodeAt(t++);
       switch (u) {
        case 110:
         return o('\n');
        case 114:
         return o('\r');
        case 120: {
         let s;
         return ({ code: s, pos: t } = je(e, t, r, n, 2, !1, a, i)), o(null === s ? null : String.fromCharCode(s));
        }
        case 117: {
         let s;
         return ({ code: s, pos: t } = qe(e, t, r, n, a, i)), o(null === s ? null : String.fromCodePoint(s));
        }
        case 116:
         return o('\t');
        case 98:
         return o('\b');
        case 118:
         return o('\v');
        case 102:
         return o('\f');
        case 13:
         10 === e.charCodeAt(t) && ++t;
        case 10:
         (r = t), ++n;
        case 8232:
        case 8233:
         return o('');
        case 56:
        case 57:
         if (s) return o(null);
         i.strictNumericEscape(t - 1, r, n);
        default:
         if (u >= 48 && u <= 55) {
          let a = t - 1,
           u = /^[0-7]+/.exec(e.slice(a, t + 2))[0],
           l = parseInt(u, 8);
          l > 255 && ((u = u.slice(0, -1)), (l = parseInt(u, 8))), (t += u.length - 1);
          let p = e.charCodeAt(t);
          if ('0' !== u || 56 === p || 57 === p) {
           if (s) return o(null);
           i.strictNumericEscape(a, r, n);
          }
          return o(String.fromCharCode(l));
         }
         return o(String.fromCharCode(u));
       }
      }
      function je(e, t, r, n, s, i, a, o) {
       let u,
        l = t;
       return ({ n: u, pos: t } = Re(e, t, r, n, 16, s, i, !1, o, !a)), null === u && (a ? o.invalidEscapeSequence(l, r, n) : (t = l - 1)), { code: u, pos: t };
      }
      function Re(e, t, r, n, s, i, a, o, u, l) {
       let p = t,
        c = 16 === s ? Be.hex : Be.decBinOct,
        h = 16 === s ? _e.hex : 10 === s ? _e.dec : 8 === s ? _e.oct : _e.bin,
        d = !1,
        f = 0;
       for (let m = 0, y = i ?? 1 / 0; m < y; ++m) {
        let i,
         p = e.charCodeAt(t);
        if (95 !== p || 'bail' === o) {
         if (((i = p >= 97 ? p - 97 + 10 : p >= 65 ? p - 65 + 10 : Ne(p) ? p - 48 : 1 / 0), i >= s)) {
          if (i <= 9 && l) return { n: null, pos: t };
          if (i <= 9 && u.invalidDigit(t, r, n, s)) i = 0;
          else {
           if (!a) break;
           (i = 0), (d = !0);
          }
         }
         ++t, (f = f * s + i);
        } else {
         let s = e.charCodeAt(t - 1),
          i = e.charCodeAt(t + 1);
         if (o) {
          if (Number.isNaN(i) || !h(i) || c.has(s) || c.has(i)) {
           if (l) return { n: null, pos: t };
           u.unexpectedNumericSeparator(t, r, n);
          }
         } else {
          if (l) return { n: null, pos: t };
          u.numericSeparatorInEscapeSequence(t, r, n);
         }
         ++t;
        }
       }
       return t === p || (null != i && t - p !== i) || d ? { n: null, pos: t } : { n: f, pos: t };
      }
      function qe(e, t, r, n, s, i) {
       let a;
       if (123 === e.charCodeAt(t)) {
        if ((++t, ({ code: a, pos: t } = je(e, t, r, n, e.indexOf('}', t) - t, !0, s, i)), ++t, null !== a && a > 1114111)) {
         if (!s) return { code: null, pos: t };
         i.invalidCodePoint(t, r, n);
        }
       } else ({ code: a, pos: t } = je(e, t, r, n, 4, !1, s, i));
       return { code: a, pos: t };
      }
      function Ue(e, t, n) {
       return new r(n, e - t, e);
      }
      var $e = new Set([103, 109, 115, 105, 121, 117, 100, 118]),
       He = class {
        constructor(e) {
         let t = e.startIndex || 0;
         (this.type = e.type), (this.value = e.value), (this.start = t + e.start), (this.end = t + e.end), (this.loc = new n(e.startLoc, e.endLoc));
        }
       },
       ze = class extends Te {
        constructor(e, t) {
         super(),
          (this.isLookahead = void 0),
          (this.tokens = []),
          (this.errorHandlers_readInt = { invalidDigit: (e, t, r, n) => !!(1024 & this.optionFlags) && (this.raise(y.InvalidDigit, Ue(e, t, r), { radix: n }), !0), numericSeparatorInEscapeSequence: this.errorBuilder(y.NumericSeparatorInEscapeSequence), unexpectedNumericSeparator: this.errorBuilder(y.UnexpectedNumericSeparator) }),
          (this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, { invalidEscapeSequence: this.errorBuilder(y.InvalidEscapeSequence), invalidCodePoint: this.errorBuilder(y.InvalidCodePoint) })),
          (this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
           strictNumericEscape: (e, t, r) => {
            this.recordStrictModeErrors(y.StrictNumericEscape, Ue(e, t, r));
           },
           unterminated: (e, t, r) => {
            throw this.raise(y.UnterminatedString, Ue(e - 1, t, r));
           },
          })),
          (this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
           strictNumericEscape: this.errorBuilder(y.StrictNumericEscape),
           unterminated: (e, t, r) => {
            throw this.raise(y.UnterminatedTemplate, Ue(e, t, r));
           },
          })),
          (this.state = new Ie()),
          this.state.init(e),
          (this.input = t),
          (this.length = t.length),
          (this.comments = []),
          (this.isLookahead = !1);
        }
        pushToken(e) {
         (this.tokens.length = this.state.tokensLength), this.tokens.push(e), ++this.state.tokensLength;
        }
        next() {
         this.checkKeywordEscapes(), 128 & this.optionFlags && this.pushToken(new He(this.state)), (this.state.lastTokEndLoc = this.state.endLoc), (this.state.lastTokStartLoc = this.state.startLoc), this.nextToken();
        }
        eat(e) {
         return !!this.match(e) && (this.next(), !0);
        }
        match(e) {
         return this.state.type === e;
        }
        createLookaheadState(e) {
         return { pos: e.pos, value: null, type: e.type, start: e.start, end: e.end, context: [this.curContext()], inType: e.inType, startLoc: e.startLoc, lastTokEndLoc: e.lastTokEndLoc, curLine: e.curLine, lineStart: e.lineStart, curPosition: e.curPosition };
        }
        lookahead() {
         let e = this.state;
         (this.state = this.createLookaheadState(e)), (this.isLookahead = !0), this.nextToken(), (this.isLookahead = !1);
         let t = this.state;
         return (this.state = e), t;
        }
        nextTokenStart() {
         return this.nextTokenStartSince(this.state.pos);
        }
        nextTokenStartSince(e) {
         return (Fe.lastIndex = e), Fe.test(this.input) ? Fe.lastIndex : e;
        }
        lookaheadCharCode() {
         return this.input.charCodeAt(this.nextTokenStart());
        }
        nextTokenInLineStart() {
         return this.nextTokenInLineStartSince(this.state.pos);
        }
        nextTokenInLineStartSince(e) {
         return (ke.lastIndex = e), ke.test(this.input) ? ke.lastIndex : e;
        }
        lookaheadInLineCharCode() {
         return this.input.charCodeAt(this.nextTokenInLineStart());
        }
        codePointAtPos(e) {
         let t = this.input.charCodeAt(e);
         if (55296 == (64512 & t) && ++e < this.input.length) {
          let r = this.input.charCodeAt(e);
          56320 == (64512 & r) && (t = 65536 + ((1023 & t) << 10) + (1023 & r));
         }
         return t;
        }
        setStrict(e) {
         (this.state.strict = e), e && (this.state.strictErrors.forEach(([e, t]) => this.raise(e, t)), this.state.strictErrors.clear());
        }
        curContext() {
         return this.state.context[this.state.context.length - 1];
        }
        nextToken() {
         this.skipSpace(), (this.state.start = this.state.pos), this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length ? this.finishToken(140) : this.getTokenFromCode(this.codePointAtPos(this.state.pos));
        }
        skipBlockComment(e) {
         let t;
         this.isLookahead || (t = this.state.curPosition());
         let r = this.state.pos,
          s = this.input.indexOf(e, r + 2);
         if (-1 === s) throw this.raise(y.UnterminatedComment, this.state.curPosition());
         for (this.state.pos = s + e.length, Se.lastIndex = r + 2; Se.test(this.input) && Se.lastIndex <= s; ) ++this.state.curLine, (this.state.lineStart = Se.lastIndex);
         if (this.isLookahead) return;
         let i = { type: 'CommentBlock', value: this.input.slice(r + 2, s), start: this.sourceToOffsetPos(r), end: this.sourceToOffsetPos(s + e.length), loc: new n(t, this.state.curPosition()) };
         return 128 & this.optionFlags && this.pushToken(i), i;
        }
        skipLineComment(e) {
         let t,
          r = this.state.pos;
         this.isLookahead || (t = this.state.curPosition());
         let s = this.input.charCodeAt((this.state.pos += e));
         if (this.state.pos < this.length) for (; !we(s) && ++this.state.pos < this.length; ) s = this.input.charCodeAt(this.state.pos);
         if (this.isLookahead) return;
         let i = this.state.pos,
          a = { type: 'CommentLine', value: this.input.slice(r + e, i), start: this.sourceToOffsetPos(r), end: this.sourceToOffsetPos(i), loc: new n(t, this.state.curPosition()) };
         return 128 & this.optionFlags && this.pushToken(a), a;
        }
        skipSpace() {
         let e = this.state.pos,
          t = 2048 & this.optionFlags ? [] : null;
         e: for (; this.state.pos < this.length; ) {
          let r = this.input.charCodeAt(this.state.pos);
          switch (r) {
           case 32:
           case 160:
           case 9:
            ++this.state.pos;
            break;
           case 13:
            10 === this.input.charCodeAt(this.state.pos + 1) && ++this.state.pos;
           case 10:
           case 8232:
           case 8233:
            ++this.state.pos, ++this.state.curLine, (this.state.lineStart = this.state.pos);
            break;
           case 47:
            switch (this.input.charCodeAt(this.state.pos + 1)) {
             case 42: {
              let e = this.skipBlockComment('*/');
              void 0 !== e && (this.addComment(e), null == t || t.push(e));
              break;
             }
             case 47: {
              let e = this.skipLineComment(2);
              void 0 !== e && (this.addComment(e), null == t || t.push(e));
              break;
             }
             default:
              break e;
            }
            break;
           default:
            if (Pe(r)) ++this.state.pos;
            else if (45 === r && !this.inModule && 4096 & this.optionFlags) {
             let r = this.state.pos;
             if (45 !== this.input.charCodeAt(r + 1) || 62 !== this.input.charCodeAt(r + 2) || !(0 === e || this.state.lineStart > e)) break e;
             {
              let e = this.skipLineComment(3);
              void 0 !== e && (this.addComment(e), null == t || t.push(e));
             }
            } else {
             if (60 !== r || this.inModule || !(4096 & this.optionFlags)) break e;
             {
              let e = this.state.pos;
              if (33 !== this.input.charCodeAt(e + 1) || 45 !== this.input.charCodeAt(e + 2) || 45 !== this.input.charCodeAt(e + 3)) break e;
              {
               let e = this.skipLineComment(4);
               void 0 !== e && (this.addComment(e), null == t || t.push(e));
              }
             }
            }
          }
         }
         if ((null == t ? void 0 : t.length) > 0) {
          let r = this.state.pos,
           n = { start: this.sourceToOffsetPos(e), end: this.sourceToOffsetPos(r), comments: t, leadingNode: null, trailingNode: null, containingNode: null };
          this.state.commentStack.push(n);
         }
        }
        finishToken(e, t) {
         (this.state.end = this.state.pos), (this.state.endLoc = this.state.curPosition());
         let r = this.state.type;
         (this.state.type = e), (this.state.value = t), this.isLookahead || this.updateContext(r);
        }
        replaceToken(e) {
         (this.state.type = e), this.updateContext();
        }
        readToken_numberSign() {
         if (0 === this.state.pos && this.readToken_interpreter()) return;
         let e = this.state.pos + 1,
          t = this.codePointAtPos(e);
         if (t >= 48 && t <= 57) throw this.raise(y.UnexpectedDigitAfterHash, this.state.curPosition());
         if (123 === t || (91 === t && this.hasPlugin('recordAndTuple'))) {
          if ((this.expectPlugin('recordAndTuple'), 'bar' === this.getPluginOption('recordAndTuple', 'syntaxType'))) throw this.raise(123 === t ? y.RecordExpressionHashIncorrectStartSyntaxType : y.TupleExpressionHashIncorrectStartSyntaxType, this.state.curPosition());
          (this.state.pos += 2), 123 === t ? this.finishToken(7) : this.finishToken(1);
         } else se(t) ? (++this.state.pos, this.finishToken(139, this.readWord1(t))) : 92 === t ? (++this.state.pos, this.finishToken(139, this.readWord1())) : this.finishOp(27, 1);
        }
        readToken_dot() {
         let e = this.input.charCodeAt(this.state.pos + 1);
         e >= 48 && e <= 57 ? this.readNumber(!0) : 46 === e && 46 === this.input.charCodeAt(this.state.pos + 2) ? ((this.state.pos += 3), this.finishToken(21)) : (++this.state.pos, this.finishToken(16));
        }
        readToken_slash() {
         61 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(31, 2) : this.finishOp(56, 1);
        }
        readToken_interpreter() {
         if (0 !== this.state.pos || this.length < 2) return !1;
         let e = this.input.charCodeAt(this.state.pos + 1);
         if (33 !== e) return !1;
         let t = this.state.pos;
         for (this.state.pos += 1; !we(e) && ++this.state.pos < this.length; ) e = this.input.charCodeAt(this.state.pos);
         let r = this.input.slice(t + 2, this.state.pos);
         return this.finishToken(28, r), !0;
        }
        readToken_mult_modulo(e) {
         let t = 42 === e ? 55 : 54,
          r = 1,
          n = this.input.charCodeAt(this.state.pos + 1);
         42 === e && 42 === n && (r++, (n = this.input.charCodeAt(this.state.pos + 2)), (t = 57)), 61 === n && !this.state.inType && (r++, (t = 37 === e ? 33 : 30)), this.finishOp(t, r);
        }
        readToken_pipe_amp(e) {
         let t = this.input.charCodeAt(this.state.pos + 1);
         if (t !== e) {
          if (124 === e) {
           if (62 === t) return void this.finishOp(39, 2);
           if (this.hasPlugin('recordAndTuple') && 125 === t) {
            if ('bar' !== this.getPluginOption('recordAndTuple', 'syntaxType')) throw this.raise(y.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
            return (this.state.pos += 2), void this.finishToken(9);
           }
           if (this.hasPlugin('recordAndTuple') && 93 === t) {
            if ('bar' !== this.getPluginOption('recordAndTuple', 'syntaxType')) throw this.raise(y.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
            return (this.state.pos += 2), void this.finishToken(4);
           }
          }
          61 !== t ? this.finishOp(124 === e ? 43 : 45, 1) : this.finishOp(30, 2);
         } else 61 === this.input.charCodeAt(this.state.pos + 2) ? this.finishOp(30, 3) : this.finishOp(124 === e ? 41 : 42, 2);
        }
        readToken_caret() {
         let e = this.input.charCodeAt(this.state.pos + 1);
         61 !== e || this.state.inType ? (94 === e && this.hasPlugin(['pipelineOperator', { proposal: 'hack', topicToken: '^^' }]) ? (this.finishOp(37, 2), 94 === this.input.codePointAt(this.state.pos) && this.unexpected()) : this.finishOp(44, 1)) : this.finishOp(32, 2);
        }
        readToken_atSign() {
         64 === this.input.charCodeAt(this.state.pos + 1) && this.hasPlugin(['pipelineOperator', { proposal: 'hack', topicToken: '@@' }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
        }
        readToken_plus_min(e) {
         let t = this.input.charCodeAt(this.state.pos + 1);
         t !== e ? (61 === t ? this.finishOp(30, 2) : this.finishOp(53, 1)) : this.finishOp(34, 2);
        }
        readToken_lt() {
         let { pos: e } = this.state,
          t = this.input.charCodeAt(e + 1);
         if (60 === t) return 61 === this.input.charCodeAt(e + 2) ? void this.finishOp(30, 3) : void this.finishOp(51, 2);
         61 !== t ? this.finishOp(47, 1) : this.finishOp(49, 2);
        }
        readToken_gt() {
         let { pos: e } = this.state,
          t = this.input.charCodeAt(e + 1);
         if (62 === t) {
          let t = 62 === this.input.charCodeAt(e + 2) ? 3 : 2;
          return 61 === this.input.charCodeAt(e + t) ? void this.finishOp(30, t + 1) : void this.finishOp(52, t);
         }
         61 !== t ? this.finishOp(48, 1) : this.finishOp(49, 2);
        }
        readToken_eq_excl(e) {
         let t = this.input.charCodeAt(this.state.pos + 1);
         if (61 !== t) return 61 === e && 62 === t ? ((this.state.pos += 2), void this.finishToken(19)) : void this.finishOp(61 === e ? 29 : 35, 1);
         this.finishOp(46, 61 === this.input.charCodeAt(this.state.pos + 2) ? 3 : 2);
        }
        readToken_question() {
         let e = this.input.charCodeAt(this.state.pos + 1),
          t = this.input.charCodeAt(this.state.pos + 2);
         63 === e ? (61 === t ? this.finishOp(30, 3) : this.finishOp(40, 2)) : 46 !== e || (t >= 48 && t <= 57) ? (++this.state.pos, this.finishToken(17)) : ((this.state.pos += 2), this.finishToken(18));
        }
        getTokenFromCode(e) {
         switch (e) {
          case 46:
           return void this.readToken_dot();
          case 40:
           return ++this.state.pos, void this.finishToken(10);
          case 41:
           return ++this.state.pos, void this.finishToken(11);
          case 59:
           return ++this.state.pos, void this.finishToken(13);
          case 44:
           return ++this.state.pos, void this.finishToken(12);
          case 91:
           if (this.hasPlugin('recordAndTuple') && 124 === this.input.charCodeAt(this.state.pos + 1)) {
            if ('bar' !== this.getPluginOption('recordAndTuple', 'syntaxType')) throw this.raise(y.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            (this.state.pos += 2), this.finishToken(2);
           } else ++this.state.pos, this.finishToken(0);
           return;
          case 93:
           return ++this.state.pos, void this.finishToken(3);
          case 123:
           if (this.hasPlugin('recordAndTuple') && 124 === this.input.charCodeAt(this.state.pos + 1)) {
            if ('bar' !== this.getPluginOption('recordAndTuple', 'syntaxType')) throw this.raise(y.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            (this.state.pos += 2), this.finishToken(6);
           } else ++this.state.pos, this.finishToken(5);
           return;
          case 125:
           return ++this.state.pos, void this.finishToken(8);
          case 58:
           return void (this.hasPlugin('functionBind') && 58 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(15, 2) : (++this.state.pos, this.finishToken(14)));
          case 63:
           return void this.readToken_question();
          case 96:
           return void this.readTemplateToken();
          case 48: {
           let e = this.input.charCodeAt(this.state.pos + 1);
           if (120 === e || 88 === e) return void this.readRadixNumber(16);
           if (111 === e || 79 === e) return void this.readRadixNumber(8);
           if (98 === e || 66 === e) return void this.readRadixNumber(2);
          }
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
           return void this.readNumber(!1);
          case 34:
          case 39:
           return void this.readString(e);
          case 47:
           return void this.readToken_slash();
          case 37:
          case 42:
           return void this.readToken_mult_modulo(e);
          case 124:
          case 38:
           return void this.readToken_pipe_amp(e);
          case 94:
           return void this.readToken_caret();
          case 43:
          case 45:
           return void this.readToken_plus_min(e);
          case 60:
           return void this.readToken_lt();
          case 62:
           return void this.readToken_gt();
          case 61:
          case 33:
           return void this.readToken_eq_excl(e);
          case 126:
           return void this.finishOp(36, 1);
          case 64:
           return void this.readToken_atSign();
          case 35:
           return void this.readToken_numberSign();
          case 92:
           return void this.readWord();
          default:
           if (se(e)) return void this.readWord(e);
         }
         throw this.raise(y.InvalidOrUnexpectedToken, this.state.curPosition(), { unexpected: String.fromCodePoint(e) });
        }
        finishOp(e, t) {
         let r = this.input.slice(this.state.pos, this.state.pos + t);
         (this.state.pos += t), this.finishToken(e, r);
        }
        readRegexp() {
         let e,
          t,
          r = this.state.startLoc,
          n = this.state.start + 1,
          { pos: i } = this.state;
         for (; ; ++i) {
          if (i >= this.length) throw this.raise(y.UnterminatedRegExp, s(r, 1));
          let n = this.input.charCodeAt(i);
          if (we(n)) throw this.raise(y.UnterminatedRegExp, s(r, 1));
          if (e) e = !1;
          else {
           if (91 === n) t = !0;
           else if (93 === n && t) t = !1;
           else if (47 === n && !t) break;
           e = 92 === n;
          }
         }
         let a = this.input.slice(n, i);
         ++i;
         let o = '',
          u = () => s(r, i + 2 - n);
         for (; i < this.length; ) {
          let e = this.codePointAtPos(i),
           t = String.fromCharCode(e);
          if ($e.has(e)) 118 === e ? o.includes('u') && this.raise(y.IncompatibleRegExpUVFlags, u()) : 117 === e && o.includes('v') && this.raise(y.IncompatibleRegExpUVFlags, u()), o.includes(t) && this.raise(y.DuplicateRegExpFlags, u());
          else {
           if (!ie(e) && 92 !== e) break;
           this.raise(y.MalformedRegExpFlags, u());
          }
          ++i, (o += t);
         }
         (this.state.pos = i), this.finishToken(138, { pattern: a, flags: o });
        }
        readInt(e, t, r = !1, n = !0) {
         let { n: s, pos: i } = Re(this.input, this.state.pos, this.state.lineStart, this.state.curLine, e, t, r, n, this.errorHandlers_readInt, !1);
         return (this.state.pos = i), s;
        }
        readRadixNumber(e) {
         let t = this.state.pos,
          r = this.state.curPosition(),
          n = !1;
         this.state.pos += 2;
         let i = this.readInt(e);
         null == i && this.raise(y.InvalidDigit, s(r, 2), { radix: e });
         let a = this.input.charCodeAt(this.state.pos);
         if (110 === a) ++this.state.pos, (n = !0);
         else if (109 === a) throw this.raise(y.InvalidDecimal, r);
         if (se(this.codePointAtPos(this.state.pos))) throw this.raise(y.NumberIdentifier, this.state.curPosition());
         if (n) {
          let e = this.input.slice(t, this.state.pos).replace(/[_n]/g, '');
          this.finishToken(136, e);
         } else this.finishToken(135, i);
        }
        readNumber(e) {
         let t = this.state.pos,
          r = this.state.curPosition(),
          n = !1,
          i = !1,
          a = !1,
          o = !1;
         !e && null === this.readInt(10) && this.raise(y.InvalidNumber, this.state.curPosition());
         let u = this.state.pos - t >= 2 && 48 === this.input.charCodeAt(t);
         if (u) {
          let e = this.input.slice(t, this.state.pos);
          if ((this.recordStrictModeErrors(y.StrictOctalLiteral, r), !this.state.strict)) {
           let t = e.indexOf('_');
           t > 0 && this.raise(y.ZeroDigitNumericSeparator, s(r, t));
          }
          o = u && !/[89]/.test(e);
         }
         let l = this.input.charCodeAt(this.state.pos);
         if ((46 === l && !o && (++this.state.pos, this.readInt(10), (n = !0), (l = this.input.charCodeAt(this.state.pos))), (69 === l || 101 === l) && !o && ((l = this.input.charCodeAt(++this.state.pos)), (43 === l || 45 === l) && ++this.state.pos, null === this.readInt(10) && this.raise(y.InvalidOrMissingExponent, r), (n = !0), (a = !0), (l = this.input.charCodeAt(this.state.pos))), 110 === l && ((n || u) && this.raise(y.InvalidBigIntLiteral, r), ++this.state.pos, (i = !0)), 109 === l)) {
          this.expectPlugin('decimal', this.state.curPosition()), (a || u) && this.raise(y.InvalidDecimal, r), ++this.state.pos;
          var p = !0;
         }
         if (se(this.codePointAtPos(this.state.pos))) throw this.raise(y.NumberIdentifier, this.state.curPosition());
         let c = this.input.slice(t, this.state.pos).replace(/[_mn]/g, '');
         if (i) return void this.finishToken(136, c);
         if (p) return void this.finishToken(137, c);
         let h = o ? parseInt(c, 8) : parseFloat(c);
         this.finishToken(135, h);
        }
        readCodePoint(e) {
         let { code: t, pos: r } = qe(this.input, this.state.pos, this.state.lineStart, this.state.curLine, e, this.errorHandlers_readCodePoint);
         return (this.state.pos = r), t;
        }
        readString(e) {
         let { str: t, pos: r, curLine: n, lineStart: s } = Le(34 === e ? 'double' : 'single', this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
         (this.state.pos = r + 1), (this.state.lineStart = s), (this.state.curLine = n), this.finishToken(134, t);
        }
        readTemplateContinuation() {
         this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
        }
        readTemplateToken() {
         let e = this.input[this.state.pos],
          { str: t, firstInvalidLoc: n, pos: s, curLine: i, lineStart: a } = Le('template', this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
         (this.state.pos = s + 1), (this.state.lineStart = a), (this.state.curLine = i), n && (this.state.firstInvalidTemplateEscapePos = new r(n.curLine, n.pos - n.lineStart, this.sourceToOffsetPos(n.pos))), 96 === this.input.codePointAt(s) ? this.finishToken(24, n ? null : e + t + '`') : (this.state.pos++, this.finishToken(25, n ? null : e + t + '${'));
        }
        recordStrictModeErrors(e, t) {
         let r = t.index;
         this.state.strict && !this.state.strictErrors.has(r) ? this.raise(e, t) : this.state.strictErrors.set(r, [e, t]);
        }
        readWord1(e) {
         this.state.containsEsc = !1;
         let t = '',
          r = this.state.pos,
          n = this.state.pos;
         for (void 0 !== e && (this.state.pos += e <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
          let e = this.codePointAtPos(this.state.pos);
          if (ie(e)) this.state.pos += e <= 65535 ? 1 : 2;
          else {
           if (92 !== e) break;
           {
            (this.state.containsEsc = !0), (t += this.input.slice(n, this.state.pos));
            let e = this.state.curPosition(),
             s = this.state.pos === r ? se : ie;
            if (117 !== this.input.charCodeAt(++this.state.pos)) {
             this.raise(y.MissingUnicodeEscape, this.state.curPosition()), (n = this.state.pos - 1);
             continue;
            }
            ++this.state.pos;
            let i = this.readCodePoint(!0);
            null !== i && (s(i) || this.raise(y.EscapedCharNotAnIdentifier, e), (t += String.fromCodePoint(i))), (n = this.state.pos);
           }
          }
         }
         return t + this.input.slice(n, this.state.pos);
        }
        readWord(e) {
         let t = this.readWord1(e),
          r = F.get(t);
         void 0 !== r ? this.finishToken(r, J(r)) : this.finishToken(132, t);
        }
        checkKeywordEscapes() {
         let { type: e } = this.state;
         W(e) && this.state.containsEsc && this.raise(y.InvalidEscapedReservedWord, this.state.startLoc, { reservedWord: J(e) });
        }
        raise(e, t, n = {}) {
         let s = e(t instanceof r ? t : t.loc.start, n);
         if (!(1024 & this.optionFlags)) throw s;
         return this.isLookahead || this.state.errors.push(s), s;
        }
        raiseOverwrite(e, t, n = {}) {
         let s = t instanceof r ? t : t.loc.start,
          i = s.index,
          a = this.state.errors;
         for (let r = a.length - 1; r >= 0; r--) {
          let t = a[r];
          if (t.loc.index === i) return (a[r] = e(s, n));
          if (t.loc.index < i) break;
         }
         return this.raise(e, t, n);
        }
        updateContext(e) {}
        unexpected(e, t) {
         throw this.raise(y.UnexpectedToken, e ?? this.state.startLoc, { expected: t ? J(t) : null });
        }
        expectPlugin(e, t) {
         if (this.hasPlugin(e)) return !0;
         throw this.raise(y.MissingPlugin, t ?? this.state.startLoc, { missingPlugin: [e] });
        }
        expectOnePlugin(e) {
         if (!e.some((e) => this.hasPlugin(e))) throw this.raise(y.MissingOneOfPlugins, this.state.startLoc, { missingPlugin: e });
        }
        errorBuilder(e) {
         return (t, r, n) => {
          this.raise(e, Ue(t, r, n));
         };
        }
       },
       Ve = class {
        constructor() {
         (this.privateNames = new Set()), (this.loneAccessors = new Map()), (this.undefinedPrivateNames = new Map());
        }
       },
       We = class {
        constructor(e) {
         (this.parser = void 0), (this.stack = []), (this.undefinedPrivateNames = new Map()), (this.parser = e);
        }
        current() {
         return this.stack[this.stack.length - 1];
        }
        enter() {
         this.stack.push(new Ve());
        }
        exit() {
         let e = this.stack.pop(),
          t = this.current();
         for (let [r, n] of Array.from(e.undefinedPrivateNames)) t ? t.undefinedPrivateNames.has(r) || t.undefinedPrivateNames.set(r, n) : this.parser.raise(y.InvalidPrivateFieldResolution, n, { identifierName: r });
        }
        declarePrivateName(e, t, r) {
         let { privateNames: n, loneAccessors: s, undefinedPrivateNames: i } = this.current(),
          a = n.has(e);
         if (3 & t) {
          let r = a && s.get(e);
          r ? ((a = (3 & r) == (3 & t) || (4 & r) != (4 & t)), a || s.delete(e)) : a || s.set(e, t);
         }
         a && this.parser.raise(y.PrivateNameRedeclaration, r, { identifierName: e }), n.add(e), i.delete(e);
        }
        usePrivateName(e, t) {
         let r;
         for (r of this.stack) if (r.privateNames.has(e)) return;
         r ? r.undefinedPrivateNames.set(e, t) : this.parser.raise(y.InvalidPrivateFieldResolution, t, { identifierName: e });
        }
       },
       Je = class {
        constructor(e = 0) {
         this.type = e;
        }
        canBeArrowParameterDeclaration() {
         return 2 === this.type || 1 === this.type;
        }
        isCertainlyParameterDeclaration() {
         return 3 === this.type;
        }
       },
       Ke = class extends Je {
        constructor(e) {
         super(e), (this.declarationErrors = new Map());
        }
        recordDeclarationError(e, t) {
         let r = t.index;
         this.declarationErrors.set(r, [e, t]);
        }
        clearDeclarationError(e) {
         this.declarationErrors.delete(e);
        }
        iterateErrors(e) {
         this.declarationErrors.forEach(e);
        }
       },
       Ge = class {
        constructor(e) {
         (this.parser = void 0), (this.stack = [new Je()]), (this.parser = e);
        }
        enter(e) {
         this.stack.push(e);
        }
        exit() {
         this.stack.pop();
        }
        recordParameterInitializerError(e, t) {
         let r = t.loc.start,
          { stack: n } = this,
          s = n.length - 1,
          i = n[s];
         for (; !i.isCertainlyParameterDeclaration(); ) {
          if (!i.canBeArrowParameterDeclaration()) return;
          i.recordDeclarationError(e, r), (i = n[--s]);
         }
         this.parser.raise(e, r);
        }
        recordArrowParameterBindingError(e, t) {
         let { stack: r } = this,
          n = r[r.length - 1],
          s = t.loc.start;
         if (n.isCertainlyParameterDeclaration()) this.parser.raise(e, s);
         else {
          if (!n.canBeArrowParameterDeclaration()) return;
          n.recordDeclarationError(e, s);
         }
        }
        recordAsyncArrowParametersError(e) {
         let { stack: t } = this,
          r = t.length - 1,
          n = t[r];
         for (; n.canBeArrowParameterDeclaration(); ) 2 === n.type && n.recordDeclarationError(y.AwaitBindingIdentifier, e), (n = t[--r]);
        }
        validateAsPattern() {
         let { stack: e } = this,
          t = e[e.length - 1];
         t.canBeArrowParameterDeclaration() &&
          t.iterateErrors(([t, r]) => {
           this.parser.raise(t, r);
           let n = e.length - 2,
            s = e[n];
           for (; s.canBeArrowParameterDeclaration(); ) s.clearDeclarationError(r.index), (s = e[--n]);
          });
        }
       };
      function Xe() {
       return new Je();
      }
      var Ye = class {
       constructor() {
        this.stacks = [];
       }
       enter(e) {
        this.stacks.push(e);
       }
       exit() {
        this.stacks.pop();
       }
       currentFlags() {
        return this.stacks[this.stacks.length - 1];
       }
       get hasAwait() {
        return (2 & this.currentFlags()) > 0;
       }
       get hasYield() {
        return (1 & this.currentFlags()) > 0;
       }
       get hasReturn() {
        return (4 & this.currentFlags()) > 0;
       }
       get hasIn() {
        return (8 & this.currentFlags()) > 0;
       }
      };
      function Qe(e, t) {
       return (e ? 2 : 0) | (t ? 1 : 0);
      }
      var Ze = class extends ze {
        addExtra(e, t, r, n = !0) {
         if (!e) return;
         let { extra: s } = e;
         null == s && ((s = {}), (e.extra = s)), n ? (s[t] = r) : Object.defineProperty(s, t, { enumerable: n, value: r });
        }
        isContextual(e) {
         return this.state.type === e && !this.state.containsEsc;
        }
        isUnparsedContextual(e, t) {
         let r = e + t.length;
         if (this.input.slice(e, r) === t) {
          let e = this.input.charCodeAt(r);
          return !(ie(e) || 55296 == (64512 & e));
         }
         return !1;
        }
        isLookaheadContextual(e) {
         let t = this.nextTokenStart();
         return this.isUnparsedContextual(t, e);
        }
        eatContextual(e) {
         return !!this.isContextual(e) && (this.next(), !0);
        }
        expectContextual(e, t) {
         if (!this.eatContextual(e)) {
          if (null != t) throw this.raise(t, this.state.startLoc);
          this.unexpected(null, e);
         }
        }
        canInsertSemicolon() {
         return this.match(140) || this.match(8) || this.hasPrecedingLineBreak();
        }
        hasPrecedingLineBreak() {
         return Ae(this.input, this.offsetToSourcePos(this.state.lastTokEndLoc.index), this.state.start);
        }
        hasFollowingLineBreak() {
         return Ae(this.input, this.state.end, this.nextTokenStart());
        }
        isLineTerminator() {
         return this.eat(13) || this.canInsertSemicolon();
        }
        semicolon(e = !0) {
         (e ? this.isLineTerminator() : this.eat(13)) || this.raise(y.MissingSemicolon, this.state.lastTokEndLoc);
        }
        expect(e, t) {
         this.eat(e) || this.unexpected(t, e);
        }
        tryParse(e, t = this.state.clone()) {
         let r = { node: null };
         try {
          let n = e((e = null) => {
           throw ((r.node = e), r);
          });
          if (this.state.errors.length > t.errors.length) {
           let e = this.state;
           return (this.state = t), (this.state.tokensLength = e.tokensLength), { node: n, error: e.errors[t.errors.length], thrown: !1, aborted: !1, failState: e };
          }
          return { node: n, error: null, thrown: !1, aborted: !1, failState: null };
         } catch (n) {
          let e = this.state;
          if (((this.state = t), n instanceof SyntaxError)) return { node: null, error: n, thrown: !0, aborted: !1, failState: e };
          if (n === r) return { node: r.node, error: null, thrown: !1, aborted: !0, failState: e };
          throw n;
         }
        }
        checkExpressionErrors(e, t) {
         if (!e) return !1;
         let { shorthandAssignLoc: r, doubleProtoLoc: n, privateKeyLoc: s, optionalParametersLoc: i } = e;
         if (!t) return !!(r || n || i || s);
         null != r && this.raise(y.InvalidCoverInitializedName, r), null != n && this.raise(y.DuplicateProto, n), null != s && this.raise(y.UnexpectedPrivateField, s), null != i && this.unexpected(i);
        }
        isLiteralPropertyName() {
         return H(this.state.type);
        }
        isPrivateName(e) {
         return 'PrivateName' === e.type;
        }
        getPrivateNameSV(e) {
         return e.id.name;
        }
        hasPropertyAsPrivateName(e) {
         return ('MemberExpression' === e.type || 'OptionalMemberExpression' === e.type) && this.isPrivateName(e.property);
        }
        isObjectProperty(e) {
         return 'ObjectProperty' === e.type;
        }
        isObjectMethod(e) {
         return 'ObjectMethod' === e.type;
        }
        initializeScopes(e = 'module' === this.options.sourceType) {
         let t = this.state.labels;
         this.state.labels = [];
         let r = this.exportedIdentifiers;
         this.exportedIdentifiers = new Set();
         let n = this.inModule;
         this.inModule = e;
         let s = this.scope,
          i = this.getScopeHandler();
         this.scope = new i(this, e);
         let a = this.prodParam;
         this.prodParam = new Ye();
         let o = this.classScope;
         this.classScope = new We(this);
         let u = this.expressionScope;
         return (
          (this.expressionScope = new Ge(this)),
          () => {
           (this.state.labels = t), (this.exportedIdentifiers = r), (this.inModule = n), (this.scope = s), (this.prodParam = a), (this.classScope = o), (this.expressionScope = u);
          }
         );
        }
        enterInitialScopes() {
         let e = 0;
         this.inModule && (e |= 2), this.scope.enter(1), this.prodParam.enter(e);
        }
        checkDestructuringPrivate(e) {
         let { privateKeyLoc: t } = e;
         null !== t && this.expectPlugin('destructuringPrivate', t);
        }
       },
       et = class {
        constructor() {
         (this.shorthandAssignLoc = null), (this.doubleProtoLoc = null), (this.privateKeyLoc = null), (this.optionalParametersLoc = null);
        }
       },
       tt = class {
        constructor(e, t, r) {
         (this.type = ''), (this.start = t), (this.end = 0), (this.loc = new n(r)), 64 & (null == e ? void 0 : e.optionFlags) && (this.range = [t, 0]), null != e && e.filename && (this.loc.filename = e.filename);
        }
       },
       rt = tt.prototype;
      function nt(e) {
       let { type: t, start: r, end: n, loc: s, range: i, extra: a, name: o } = e,
        u = Object.create(rt);
       return (u.type = t), (u.start = r), (u.end = n), (u.loc = s), (u.range = i), (u.extra = a), (u.name = o), 'Placeholder' === t && (u.expectedNode = e.expectedNode), u;
      }
      function st(e) {
       let { type: t, start: r, end: n, loc: s, range: i, extra: a } = e;
       if ('Placeholder' === t)
        return (function (e) {
         return nt(e);
        })(e);
       let o = Object.create(rt);
       return (o.type = t), (o.start = r), (o.end = n), (o.loc = s), (o.range = i), void 0 !== e.raw ? (o.raw = e.raw) : (o.extra = a), (o.value = e.value), o;
      }
      rt.__clone = function () {
       let e = new tt(void 0, this.start, this.loc.start),
        t = Object.keys(this);
       for (let r = 0, n = t.length; r < n; r++) {
        let n = t[r];
        'leadingComments' !== n && 'trailingComments' !== n && 'innerComments' !== n && (e[n] = this[n]);
       }
       return e;
      };
      var it = class extends Ze {
        startNode() {
         let e = this.state.startLoc;
         return new tt(this, e.index, e);
        }
        startNodeAt(e) {
         return new tt(this, e.index, e);
        }
        startNodeAtNode(e) {
         return this.startNodeAt(e.loc.start);
        }
        finishNode(e, t) {
         return this.finishNodeAt(e, t, this.state.lastTokEndLoc);
        }
        finishNodeAt(e, t, r) {
         return (e.type = t), (e.end = r.index), (e.loc.end = r), 64 & this.optionFlags && (e.range[1] = r.index), 2048 & this.optionFlags && this.processComment(e), e;
        }
        resetStartLocation(e, t) {
         (e.start = t.index), (e.loc.start = t), 64 & this.optionFlags && (e.range[0] = t.index);
        }
        resetEndLocation(e, t = this.state.lastTokEndLoc) {
         (e.end = t.index), (e.loc.end = t), 64 & this.optionFlags && (e.range[1] = t.index);
        }
        resetStartLocationFromNode(e, t) {
         this.resetStartLocation(e, t.loc.start);
        }
       },
       at = new Set(['_', 'any', 'bool', 'boolean', 'empty', 'extends', 'false', 'interface', 'mixed', 'null', 'number', 'static', 'string', 'true', 'typeof', 'void']),
       ot = m`flow`({ AmbiguousConditionalArrow: 'Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.', AmbiguousDeclareModuleKind: 'Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.', AssignReservedType: ({ reservedType: e }) => `Cannot overwrite reserved type ${e}.`, DeclareClassElement: 'The `declare` modifier can only appear on class fields.', DeclareClassFieldInitializer: 'Initializers are not allowed in fields with the `declare` modifier.', DuplicateDeclareModuleExports: 'Duplicate `declare module.exports` statement.', EnumBooleanMemberNotInitialized: ({ memberName: e, enumName: t }) => `Boolean enum members need to be initialized. Use either \`${e} = true,\` or \`${e} = false,\` in enum \`${t}\`.`, EnumDuplicateMemberName: ({ memberName: e, enumName: t }) => `Enum member names need to be unique, but the name \`${e}\` has already been used before in enum \`${t}\`.`, EnumInconsistentMemberValues: ({ enumName: e }) => `Enum \`${e}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`, EnumInvalidExplicitType: ({ invalidEnumType: e, enumName: t }) => `Enum type \`${e}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${t}\`.`, EnumInvalidExplicitTypeUnknownSupplied: ({ enumName: e }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${e}\`.`, EnumInvalidMemberInitializerPrimaryType: ({ enumName: e, memberName: t, explicitType: r }) => `Enum \`${e}\` has type \`${r}\`, so the initializer of \`${t}\` needs to be a ${r} literal.`, EnumInvalidMemberInitializerSymbolType: ({ enumName: e, memberName: t }) => `Symbol enum members cannot be initialized. Use \`${t},\` in enum \`${e}\`.`, EnumInvalidMemberInitializerUnknownType: ({ enumName: e, memberName: t }) => `The enum member initializer for \`${t}\` needs to be a literal (either a boolean, number, or string) in enum \`${e}\`.`, EnumInvalidMemberName: ({ enumName: e, memberName: t, suggestion: r }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${t}\`, consider using \`${r}\`, in enum \`${e}\`.`, EnumNumberMemberNotInitialized: ({ enumName: e, memberName: t }) => `Number enum members need to be initialized, e.g. \`${t} = 1\` in enum \`${e}\`.`, EnumStringMemberInconsistentlyInitialized: ({ enumName: e }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${e}\`.`, GetterMayNotHaveThisParam: 'A getter cannot have a `this` parameter.', ImportReflectionHasImportType: 'An `import module` declaration can not use `type` or `typeof` keyword.', ImportTypeShorthandOnlyInPureImport: 'The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.', InexactInsideExact: 'Explicit inexact syntax cannot appear inside an explicit exact object type.', InexactInsideNonObject: 'Explicit inexact syntax cannot appear in class or interface definitions.', InexactVariance: 'Explicit inexact syntax cannot have variance.', InvalidNonTypeImportInDeclareModule: 'Imports within a `declare module` body must always be `import type` or `import typeof`.', MissingTypeParamDefault: 'Type parameter declaration needs a default, since a preceding type parameter declaration has a default.', NestedDeclareModule: '`declare module` cannot be used inside another `declare module`.', NestedFlowComment: 'Cannot have a flow comment inside another flow comment.', PatternIsOptional: Object.assign({ message: 'A binding pattern parameter cannot be optional in an implementation signature.' }, { reasonCode: 'OptionalBindingPattern' }), SetterMayNotHaveThisParam: 'A setter cannot have a `this` parameter.', SpreadVariance: 'Spread properties cannot have variance.', ThisParamAnnotationRequired: 'A type annotation is required for the `this` parameter.', ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.", ThisParamMayNotBeOptional: 'The `this` parameter cannot be optional.', ThisParamMustBeFirst: 'The `this` parameter must be the first function parameter.', ThisParamNoDefault: 'The `this` parameter may not have a default value.', TypeBeforeInitializer: 'Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.', TypeCastInPattern: 'The type cast expression is expected to be wrapped with parenthesis.', UnexpectedExplicitInexactInObject: 'Explicit inexact syntax must appear at the end of an inexact object.', UnexpectedReservedType: ({ reservedType: e }) => `Unexpected reserved type ${e}.`, UnexpectedReservedUnderscore: '`_` is only allowed as a type argument to call or new.', UnexpectedSpaceBetweenModuloChecks: 'Spaces between `%` and `checks` are not allowed here.', UnexpectedSpreadType: 'Spread operator cannot appear in class or interface definitions.', UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".', UnexpectedTokenAfterTypeParameter: 'Expected an arrow function after this type parameter declaration.', UnexpectedTypeParameterBeforeAsyncArrowFunction: 'Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.', UnsupportedDeclareExportKind: ({ unsupportedExportKind: e, suggestion: t }) => `\`declare export ${e}\` is not supported. Use \`${t}\` instead.`, UnsupportedStatementInDeclareModule: 'Only declares and type imports are allowed inside declare module.', UnterminatedFlowComment: 'Unterminated flow-comment.' });
      function ut(e) {
       return 'type' === e.importKind || 'typeof' === e.importKind;
      }
      var lt = { const: 'declare export var', let: 'declare export var', type: 'export type', interface: 'export interface' },
       pt = /\*?\s*@((?:no)?flow)\b/,
       ct = m`jsx`({ AttributeIsEmpty: 'JSX attributes must only be assigned a non-empty expression.', MissingClosingTagElement: ({ openingTagName: e }) => `Expected corresponding JSX closing tag for <${e}>.`, MissingClosingTagFragment: 'Expected corresponding JSX closing tag for <>.', UnexpectedSequenceExpression: 'Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?', UnexpectedToken: ({ unexpected: e, HTMLEntity: t }) => `Unexpected token \`${e}\`. Did you mean \`${t}\` or \`{'${e}'}\`?`, UnsupportedJsxValue: 'JSX value should be either an expression or a quoted JSX text.', UnterminatedJsxContent: 'Unterminated JSX contents.', UnwrappedAdjacentJSXElements: 'Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?' });
      function ht(e) {
       return !!e && ('JSXOpeningFragment' === e.type || 'JSXClosingFragment' === e.type);
      }
      function dt(e) {
       if ('JSXIdentifier' === e.type) return e.name;
       if ('JSXNamespacedName' === e.type) return e.namespace.name + ':' + e.name.name;
       if ('JSXMemberExpression' === e.type) return dt(e.object) + '.' + dt(e.property);
       throw new Error('Node had unexpected type: ' + e.type);
      }
      var ft = class extends ye {
        constructor(...e) {
         super(...e), (this.tsNames = new Map());
        }
       },
       mt = class extends ge {
        constructor(...e) {
         super(...e), (this.importsStack = []);
        }
        createScope(e) {
         return this.importsStack.push(new Set()), new ft(e);
        }
        enter(e) {
         256 === e && this.importsStack.push(new Set()), super.enter(e);
        }
        exit() {
         let e = super.exit();
         return 256 === e && this.importsStack.pop(), e;
        }
        hasImport(e, t) {
         let r = this.importsStack.length;
         if (this.importsStack[r - 1].has(e)) return !0;
         if (!t && r > 1) for (let n = 0; n < r - 1; n++) if (this.importsStack[n].has(e)) return !0;
         return !1;
        }
        declareName(e, t, r) {
         if (4096 & t) return this.hasImport(e, !0) && this.parser.raise(y.VarRedeclaration, r, { identifierName: e }), void this.importsStack[this.importsStack.length - 1].add(e);
         let n = this.currentScope(),
          s = n.tsNames.get(e) || 0;
         if (1024 & t) return this.maybeExportDefined(n, e), void n.tsNames.set(e, 16 | s);
         super.declareName(e, t, r), 2 & t && (1 & t || (this.checkRedeclarationInScope(n, e, t, r), this.maybeExportDefined(n, e)), (s |= 1)), 256 & t && (s |= 2), 512 & t && (s |= 4), 128 & t && (s |= 8), s && n.tsNames.set(e, s);
        }
        isRedeclaredInScope(e, t, r) {
         let n = e.tsNames.get(t);
         return (2 & n) > 0 ? !(256 & r) || !!(512 & r) != (4 & n) > 0 : 128 & r && (8 & n) > 0 ? !!(2 & e.names.get(t)) && !!(1 & r) : !!(2 & r && (1 & n) > 0) || super.isRedeclaredInScope(e, t, r);
        }
        checkLocalExport(e) {
         let { name: t } = e;
         if (!this.hasImport(t)) {
          for (let e = this.scopeStack.length - 1; e >= 0; e--) {
           let r = this.scopeStack[e].tsNames.get(t);
           if ((1 & r) > 0 || (16 & r) > 0) return;
          }
          super.checkLocalExport(e);
         }
        }
       },
       yt = (e) => ('ParenthesizedExpression' === e.type ? yt(e.expression) : e),
       gt = class extends it {
        toAssignable(e, t = !1) {
         var r, n;
         let s;
         switch ((('ParenthesizedExpression' === e.type || (null != (r = e.extra) && r.parenthesized)) && ((s = yt(e)), t ? ('Identifier' === s.type ? this.expressionScope.recordArrowParameterBindingError(y.InvalidParenthesizedAssignment, e) : 'MemberExpression' !== s.type && !this.isOptionalMemberExpression(s) && this.raise(y.InvalidParenthesizedAssignment, e)) : this.raise(y.InvalidParenthesizedAssignment, e)), e.type)) {
          case 'Identifier':
          case 'ObjectPattern':
          case 'ArrayPattern':
          case 'AssignmentPattern':
          case 'RestElement':
           break;
          case 'ObjectExpression':
           e.type = 'ObjectPattern';
           for (let r = 0, n = e.properties.length, s = n - 1; r < n; r++) {
            var i;
            let n = e.properties[r],
             a = r === s;
            this.toAssignableObjectExpressionProp(n, a, t), a && 'RestElement' === n.type && null != (i = e.extra) && i.trailingCommaLoc && this.raise(y.RestTrailingComma, e.extra.trailingCommaLoc);
           }
           break;
          case 'ObjectProperty': {
           let { key: r, value: n } = e;
           this.isPrivateName(r) && this.classScope.usePrivateName(this.getPrivateNameSV(r), r.loc.start), this.toAssignable(n, t);
           break;
          }
          case 'SpreadElement':
           throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
          case 'ArrayExpression':
           (e.type = 'ArrayPattern'), this.toAssignableList(e.elements, null == (n = e.extra) ? void 0 : n.trailingCommaLoc, t);
           break;
          case 'AssignmentExpression':
           '=' !== e.operator && this.raise(y.MissingEqInAssignment, e.left.loc.end), (e.type = 'AssignmentPattern'), delete e.operator, this.toAssignable(e.left, t);
           break;
          case 'ParenthesizedExpression':
           this.toAssignable(s, t);
         }
        }
        toAssignableObjectExpressionProp(e, t, r) {
         if ('ObjectMethod' === e.type) this.raise('get' === e.kind || 'set' === e.kind ? y.PatternHasAccessor : y.PatternHasMethod, e.key);
         else if ('SpreadElement' === e.type) {
          e.type = 'RestElement';
          let n = e.argument;
          this.checkToRestConversion(n, !1), this.toAssignable(n, r), t || this.raise(y.RestTrailingComma, e);
         } else this.toAssignable(e, r);
        }
        toAssignableList(e, t, r) {
         let n = e.length - 1;
         for (let s = 0; s <= n; s++) {
          let i = e[s];
          if (i) {
           if ('SpreadElement' === i.type) {
            i.type = 'RestElement';
            let e = i.argument;
            this.checkToRestConversion(e, !0), this.toAssignable(e, r);
           } else this.toAssignable(i, r);
           'RestElement' === i.type && (s < n ? this.raise(y.RestTrailingComma, i) : t && this.raise(y.RestTrailingComma, t));
          }
         }
        }
        isAssignable(e, t) {
         switch (e.type) {
          case 'Identifier':
          case 'ObjectPattern':
          case 'ArrayPattern':
          case 'AssignmentPattern':
          case 'RestElement':
           return !0;
          case 'ObjectExpression': {
           let t = e.properties.length - 1;
           return e.properties.every((e, r) => 'ObjectMethod' !== e.type && (r === t || 'SpreadElement' !== e.type) && this.isAssignable(e));
          }
          case 'ObjectProperty':
           return this.isAssignable(e.value);
          case 'SpreadElement':
           return this.isAssignable(e.argument);
          case 'ArrayExpression':
           return e.elements.every((e) => null === e || this.isAssignable(e));
          case 'AssignmentExpression':
           return '=' === e.operator;
          case 'ParenthesizedExpression':
           return this.isAssignable(e.expression);
          case 'MemberExpression':
          case 'OptionalMemberExpression':
           return !t;
          default:
           return !1;
         }
        }
        toReferencedList(e, t) {
         return e;
        }
        toReferencedListDeep(e, t) {
         this.toReferencedList(e, t);
         for (let r of e) 'ArrayExpression' === (null == r ? void 0 : r.type) && this.toReferencedListDeep(r.elements);
        }
        parseSpread(e) {
         let t = this.startNode();
         return this.next(), (t.argument = this.parseMaybeAssignAllowIn(e, void 0)), this.finishNode(t, 'SpreadElement');
        }
        parseRestBinding() {
         let e = this.startNode();
         return this.next(), (e.argument = this.parseBindingAtom()), this.finishNode(e, 'RestElement');
        }
        parseBindingAtom() {
         switch (this.state.type) {
          case 0: {
           let e = this.startNode();
           return this.next(), (e.elements = this.parseBindingList(3, 93, 1)), this.finishNode(e, 'ArrayPattern');
          }
          case 5:
           return this.parseObjectLike(8, !0);
         }
         return this.parseIdentifier();
        }
        parseBindingList(e, t, r) {
         let n = 1 & r,
          s = [],
          i = !0;
         for (; !this.eat(e); )
          if ((i ? (i = !1) : this.expect(12), n && this.match(12))) s.push(null);
          else {
           if (this.eat(e)) break;
           if (this.match(21)) {
            let n = this.parseRestBinding();
            if (((this.hasPlugin('flow') || 2 & r) && (n = this.parseFunctionParamType(n)), s.push(n), !this.checkCommaAfterRest(t))) {
             this.expect(e);
             break;
            }
           } else {
            let e = [];
            for (this.match(26) && this.hasPlugin('decorators') && this.raise(y.UnsupportedParameterDecorator, this.state.startLoc); this.match(26); ) e.push(this.parseDecorator());
            s.push(this.parseAssignableListItem(r, e));
           }
          }
         return s;
        }
        parseBindingRestProperty(e) {
         return this.next(), (e.argument = this.parseIdentifier()), this.checkCommaAfterRest(125), this.finishNode(e, 'RestElement');
        }
        parseBindingProperty() {
         let { type: e, startLoc: t } = this.state;
         if (21 === e) return this.parseBindingRestProperty(this.startNode());
         let r = this.startNode();
         return 139 === e ? (this.expectPlugin('destructuringPrivate', t), this.classScope.usePrivateName(this.state.value, t), (r.key = this.parsePrivateName())) : this.parsePropertyName(r), (r.method = !1), this.parseObjPropValue(r, t, !1, !1, !0, !1);
        }
        parseAssignableListItem(e, t) {
         let r = this.parseMaybeDefault();
         (this.hasPlugin('flow') || 2 & e) && this.parseFunctionParamType(r);
         let n = this.parseMaybeDefault(r.loc.start, r);
         return t.length && (r.decorators = t), n;
        }
        parseFunctionParamType(e) {
         return e;
        }
        parseMaybeDefault(e, t) {
         var r;
         if ((null != e || (e = this.state.startLoc), (t = null != (r = t) ? r : this.parseBindingAtom()), !this.eat(29))) return t;
         let n = this.startNodeAt(e);
         return (n.left = t), (n.right = this.parseMaybeAssignAllowIn()), this.finishNode(n, 'AssignmentPattern');
        }
        isValidLVal(e, t, r) {
         switch (e) {
          case 'AssignmentPattern':
           return 'left';
          case 'RestElement':
           return 'argument';
          case 'ObjectProperty':
           return 'value';
          case 'ParenthesizedExpression':
           return 'expression';
          case 'ArrayPattern':
           return 'elements';
          case 'ObjectPattern':
           return 'properties';
         }
         return !1;
        }
        isOptionalMemberExpression(e) {
         return 'OptionalMemberExpression' === e.type;
        }
        checkLVal(e, t, r = 64, n = !1, s = !1, i = !1) {
         var a;
         let o = e.type;
         if (this.isObjectMethod(e)) return;
         let u = this.isOptionalMemberExpression(e);
         if (u || 'MemberExpression' === o) return u && (this.expectPlugin('optionalChainingAssign', e.loc.start), 'AssignmentExpression' !== t.type && this.raise(y.InvalidLhsOptionalChaining, e, { ancestor: t })), void (64 !== r && this.raise(y.InvalidPropertyBindingPattern, e));
         if ('Identifier' === o) {
          this.checkIdentifier(e, r, s);
          let { name: t } = e;
          return void (n && (n.has(t) ? this.raise(y.ParamDupe, e) : n.add(t)));
         }
         let l,
          p,
          c = this.isValidLVal(o, !(i || (null != (a = e.extra) && a.parenthesized)) && 'AssignmentExpression' === t.type, r);
         if (!0 === c) return;
         if (!1 === c) {
          let n = 64 === r ? y.InvalidLhs : y.InvalidLhsBinding;
          return void this.raise(n, e, { ancestor: t });
         }
         'string' == typeof c ? ((l = c), (p = 'ParenthesizedExpression' === o)) : ([l, p] = c);
         let h = 'ArrayPattern' === o || 'ObjectPattern' === o ? { type: o } : t,
          d = e[l];
         if (Array.isArray(d)) for (let f of d) f && this.checkLVal(f, h, r, n, s, p);
         else d && this.checkLVal(d, h, r, n, s, p);
        }
        checkIdentifier(e, t, r = !1) {
         this.state.strict && (r ? fe(e.name, this.inModule) : de(e.name)) && (64 === t ? this.raise(y.StrictEvalArguments, e, { referenceName: e.name }) : this.raise(y.StrictEvalArgumentsBinding, e, { bindingName: e.name })), 8192 & t && 'let' === e.name && this.raise(y.LetInLexicalBinding, e), 64 & t || this.declareNameFromIdentifier(e, t);
        }
        declareNameFromIdentifier(e, t) {
         this.scope.declareName(e.name, t, e.loc.start);
        }
        checkToRestConversion(e, t) {
         switch (e.type) {
          case 'ParenthesizedExpression':
           this.checkToRestConversion(e.expression, t);
           break;
          case 'Identifier':
          case 'MemberExpression':
           break;
          case 'ArrayExpression':
          case 'ObjectExpression':
           if (t) break;
          default:
           this.raise(y.InvalidRestAssignmentPattern, e);
         }
        }
        checkCommaAfterRest(e) {
         return !!this.match(12) && (this.raise(this.lookaheadCharCode() === e ? y.RestTrailingComma : y.ElementAfterRest, this.state.startLoc), !0);
        }
       };
      function Dt(e) {
       if (!e) throw new Error('Assert fail');
      }
      var xt = m`typescript`({ AbstractMethodHasImplementation: ({ methodName: e }) => `Method '${e}' cannot have an implementation because it is marked abstract.`, AbstractPropertyHasInitializer: ({ propertyName: e }) => `Property '${e}' cannot have an initializer because it is marked abstract.`, AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.", AccessorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.", AccessorCannotHaveTypeParameters: 'An accessor cannot have type parameters.', ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.", ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.", ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.", ConstructorHasTypeParameters: 'Type parameters cannot appear on a constructor declaration.', DeclareAccessor: ({ kind: e }) => `'declare' is not allowed in ${e}ters.`, DeclareClassFieldHasInitializer: 'Initializers are not allowed in ambient contexts.', DeclareFunctionHasImplementation: 'An implementation cannot be declared in ambient contexts.', DuplicateAccessibilityModifier: ({ modifier: e }) => 'Accessibility modifier already seen.', DuplicateModifier: ({ modifier: e }) => `Duplicate modifier: '${e}'.`, EmptyHeritageClauseType: ({ token: e }) => `'${e}' list cannot be empty.`, EmptyTypeArguments: 'Type argument list cannot be empty.', EmptyTypeParameters: 'Type parameter list cannot be empty.', ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.", ImportAliasHasImportType: "An import alias can not use 'import type'.", ImportReflectionHasImportType: 'An `import module` declaration can not use `type` modifier', IncompatibleModifiers: ({ modifiers: e }) => `'${e[0]}' modifier cannot be used with '${e[1]}' modifier.`, IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.", IndexSignatureHasAccessibility: ({ modifier: e }) => `Index signatures cannot have an accessibility modifier ('${e}').`, IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.", IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.", IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.", InitializerNotAllowedInAmbientContext: 'Initializers are not allowed in ambient contexts.', InvalidModifierOnTypeMember: ({ modifier: e }) => `'${e}' modifier cannot appear on a type member.`, InvalidModifierOnTypeParameter: ({ modifier: e }) => `'${e}' modifier cannot appear on a type parameter.`, InvalidModifierOnTypeParameterPositions: ({ modifier: e }) => `'${e}' modifier can only appear on a type parameter of a class, interface or type alias.`, InvalidModifiersOrder: ({ orderedModifiers: e }) => `'${e[0]}' modifier must precede '${e[1]}' modifier.`, InvalidPropertyAccessAfterInstantiationExpression: 'Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.', InvalidTupleMemberLabel: 'Tuple members must be labeled with a simple identifier.', MissingInterfaceName: "'interface' declarations must be followed by an identifier.", NonAbstractClassHasAbstractMethod: 'Abstract methods can only appear within an abstract class.', NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.", OptionalTypeBeforeRequired: 'A required element cannot follow an optional element.', OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.", PatternIsOptional: 'A binding pattern parameter cannot be optional in an implementation signature.', PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.", PrivateElementHasAccessibility: ({ modifier: e }) => `Private elements cannot have an accessibility modifier ('${e}').`, ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.", ReservedArrowTypeParam: 'This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.', ReservedTypeAssertion: 'This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.', SetAccessorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.", SetAccessorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.", SetAccessorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.", SingleTypeParameterWithoutTrailingComma: ({ typeParameterName: e }) => `Single type parameter ${e} should have a trailing comma. Example usage: <${e},>.`, StaticBlockCannotHaveModifier: 'Static class blocks cannot have any modifier.', TupleOptionalAfterType: 'A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).', TypeAnnotationAfterAssign: 'Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.', TypeImportCannotSpecifyDefaultAndNamed: 'A type-only import can specify a default import or named bindings, but not both.', TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.", TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.", UnexpectedParameterModifier: 'A parameter property is only allowed in a constructor implementation.', UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.", UnexpectedTypeAnnotation: 'Did not expect a type annotation here.', UnexpectedTypeCastInParameter: 'Unexpected type cast in parameter position.', UnsupportedImportTypeArgument: 'Argument in a type import must be a string literal.', UnsupportedParameterPropertyKind: 'A parameter property may not be declared using a binding pattern.', UnsupportedSignatureParameterKind: ({ type: e }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${e}.` });
      function bt(e) {
       return 'private' === e || 'public' === e || 'protected' === e;
      }
      function vt(e) {
       return 'in' === e || 'out' === e;
      }
      function Et(e) {
       if ('MemberExpression' !== e.type) return !1;
       let { computed: t, property: r } = e;
       return (!t || 'StringLiteral' === r.type || !('TemplateLiteral' !== r.type || r.expressions.length > 0)) && St(e.object);
      }
      function Ct(e, t) {
       var r;
       let { type: n } = e;
       if (null != (r = e.extra) && r.parenthesized) return !1;
       if (t) {
        if ('Literal' === n) {
         let { value: t } = e;
         if ('string' == typeof t || 'boolean' == typeof t) return !0;
        }
       } else if ('StringLiteral' === n || 'BooleanLiteral' === n) return !0;
       return !!(
        Tt(e, t) ||
        (function (e, t) {
         if ('UnaryExpression' === e.type) {
          let { operator: r, argument: n } = e;
          if ('-' === r && Tt(n, t)) return !0;
         }
         return !1;
        })(e, t) ||
        ('TemplateLiteral' === n && 0 === e.expressions.length) ||
        Et(e)
       );
      }
      function Tt(e, t) {
       return t ? 'Literal' === e.type && ('number' == typeof e.value || 'bigint' in e) : 'NumericLiteral' === e.type || 'BigIntLiteral' === e.type;
      }
      function St(e) {
       return 'Identifier' === e.type || ('MemberExpression' === e.type && !e.computed && St(e.object));
      }
      var wt = m`placeholders`({ ClassNameIsRequired: 'A class name is required.', UnexpectedSpace: 'Unexpected space in placeholder.' }),
       At = ['minimal', 'fsharp', 'hack', 'smart'],
       Ft = ['^^', '@@', '^', '%', '#'],
       kt = {
        estree: (e) =>
         class extends e {
          parse() {
           let e = x(super.parse());
           return 128 & this.optionFlags && (e.tokens = e.tokens.map(x)), e;
          }
          parseRegExpLiteral({ pattern: e, flags: t }) {
           let r = null;
           try {
            r = new RegExp(e, t);
           } catch {}
           let n = this.estreeParseLiteral(r);
           return (n.regex = { pattern: e, flags: t }), n;
          }
          parseBigIntLiteral(e) {
           let t;
           try {
            t = BigInt(e);
           } catch {
            t = null;
           }
           let r = this.estreeParseLiteral(t);
           return (r.bigint = String(r.value || e)), r;
          }
          parseDecimalLiteral(e) {
           let t = this.estreeParseLiteral(null);
           return (t.decimal = String(t.value || e)), t;
          }
          estreeParseLiteral(e) {
           return this.parseLiteral(e, 'Literal');
          }
          parseStringLiteral(e) {
           return this.estreeParseLiteral(e);
          }
          parseNumericLiteral(e) {
           return this.estreeParseLiteral(e);
          }
          parseNullLiteral() {
           return this.estreeParseLiteral(null);
          }
          parseBooleanLiteral(e) {
           return this.estreeParseLiteral(e);
          }
          directiveToStmt(e) {
           let t = e.value;
           delete e.value, (t.type = 'Literal'), (t.raw = t.extra.raw), (t.value = t.extra.expressionValue);
           let r = e;
           return (r.type = 'ExpressionStatement'), (r.expression = t), (r.directive = t.extra.rawValue), delete t.extra, r;
          }
          initFunction(e, t) {
           super.initFunction(e, t), (e.expression = !1);
          }
          checkDeclaration(e) {
           null != e && this.isObjectProperty(e) ? this.checkDeclaration(e.value) : super.checkDeclaration(e);
          }
          getObjectOrClassMethodParams(e) {
           return e.value.params;
          }
          isValidDirective(e) {
           var t;
           return 'ExpressionStatement' === e.type && 'Literal' === e.expression.type && 'string' == typeof e.expression.value && !(null != (t = e.expression.extra) && t.parenthesized);
          }
          parseBlockBody(e, t, r, n, s) {
           super.parseBlockBody(e, t, r, n, s);
           let i = e.directives.map((e) => this.directiveToStmt(e));
           (e.body = i.concat(e.body)), delete e.directives;
          }
          parsePrivateName() {
           let e = super.parsePrivateName();
           return this.getPluginOption('estree', 'classFeatures') ? this.convertPrivateNameToPrivateIdentifier(e) : e;
          }
          convertPrivateNameToPrivateIdentifier(e) {
           let t = super.getPrivateNameSV(e);
           return delete e.id, (e.name = t), (e.type = 'PrivateIdentifier'), e;
          }
          isPrivateName(e) {
           return this.getPluginOption('estree', 'classFeatures') ? 'PrivateIdentifier' === e.type : super.isPrivateName(e);
          }
          getPrivateNameSV(e) {
           return this.getPluginOption('estree', 'classFeatures') ? e.name : super.getPrivateNameSV(e);
          }
          parseLiteral(e, t) {
           let r = super.parseLiteral(e, t);
           return (r.raw = r.extra.raw), delete r.extra, r;
          }
          parseFunctionBody(e, t, r = !1) {
           super.parseFunctionBody(e, t, r), (e.expression = 'BlockStatement' !== e.body.type);
          }
          parseMethod(e, t, r, n, s, i, a = !1) {
           let o = this.startNode();
           (o.kind = e.kind), (o = super.parseMethod(o, t, r, n, s, i, a)), (o.type = 'FunctionExpression'), delete o.kind, (e.value = o);
           let { typeParameters: u } = e;
           return u && (delete e.typeParameters, (o.typeParameters = u), this.resetStartLocationFromNode(o, u)), 'ClassPrivateMethod' === i && (e.computed = !1), this.finishNode(e, 'MethodDefinition');
          }
          nameIsConstructor(e) {
           return 'Literal' === e.type ? 'constructor' === e.value : super.nameIsConstructor(e);
          }
          parseClassProperty(...e) {
           let t = super.parseClassProperty(...e);
           return this.getPluginOption('estree', 'classFeatures') && (t.type = 'PropertyDefinition'), t;
          }
          parseClassPrivateProperty(...e) {
           let t = super.parseClassPrivateProperty(...e);
           return this.getPluginOption('estree', 'classFeatures') && ((t.type = 'PropertyDefinition'), (t.computed = !1)), t;
          }
          parseObjectMethod(e, t, r, n, s) {
           let i = super.parseObjectMethod(e, t, r, n, s);
           return i && ((i.type = 'Property'), 'method' === i.kind && (i.kind = 'init'), (i.shorthand = !1)), i;
          }
          parseObjectProperty(e, t, r, n) {
           let s = super.parseObjectProperty(e, t, r, n);
           return s && ((s.kind = 'init'), (s.type = 'Property')), s;
          }
          isValidLVal(e, t, r) {
           return 'Property' === e ? 'value' : super.isValidLVal(e, t, r);
          }
          isAssignable(e, t) {
           return null != e && this.isObjectProperty(e) ? this.isAssignable(e.value, t) : super.isAssignable(e, t);
          }
          toAssignable(e, t = !1) {
           if (null != e && this.isObjectProperty(e)) {
            let { key: r, value: n } = e;
            this.isPrivateName(r) && this.classScope.usePrivateName(this.getPrivateNameSV(r), r.loc.start), this.toAssignable(n, t);
           } else super.toAssignable(e, t);
          }
          toAssignableObjectExpressionProp(e, t, r) {
           'Property' !== e.type || ('get' !== e.kind && 'set' !== e.kind) ? ('Property' === e.type && e.method ? this.raise(y.PatternHasMethod, e.key) : super.toAssignableObjectExpressionProp(e, t, r)) : this.raise(y.PatternHasAccessor, e.key);
          }
          finishCallExpression(e, t) {
           let r = super.finishCallExpression(e, t);
           var n, s;
           return 'Import' === r.callee.type && ((r.type = 'ImportExpression'), (r.source = r.arguments[0]), (r.options = null != (n = r.arguments[1]) ? n : null), (r.attributes = null != (s = r.arguments[1]) ? s : null), delete r.arguments, delete r.callee), r;
          }
          toReferencedArguments(e) {
           'ImportExpression' !== e.type && super.toReferencedArguments(e);
          }
          parseExport(e, t) {
           let r = this.state.lastTokStartLoc,
            n = super.parseExport(e, t);
           switch (n.type) {
            case 'ExportAllDeclaration':
             n.exported = null;
             break;
            case 'ExportNamedDeclaration':
             1 === n.specifiers.length && 'ExportNamespaceSpecifier' === n.specifiers[0].type && ((n.type = 'ExportAllDeclaration'), (n.exported = n.specifiers[0].exported), delete n.specifiers);
            case 'ExportDefaultDeclaration': {
             var s;
             let { declaration: e } = n;
             'ClassDeclaration' === (null == e ? void 0 : e.type) && (null == (s = e.decorators) ? void 0 : s.length) > 0 && e.start === n.start && this.resetStartLocation(n, r);
            }
           }
           return n;
          }
          parseSubscript(e, t, r, n) {
           let s = super.parseSubscript(e, t, r, n);
           if (n.optionalChainMember) {
            if ((('OptionalMemberExpression' === s.type || 'OptionalCallExpression' === s.type) && (s.type = s.type.substring(8)), n.stop)) {
             let e = this.startNodeAtNode(s);
             return (e.expression = s), this.finishNode(e, 'ChainExpression');
            }
           } else ('MemberExpression' === s.type || 'CallExpression' === s.type) && (s.optional = !1);
           return s;
          }
          isOptionalMemberExpression(e) {
           return 'ChainExpression' === e.type ? 'MemberExpression' === e.expression.type : super.isOptionalMemberExpression(e);
          }
          hasPropertyAsPrivateName(e) {
           return 'ChainExpression' === e.type && (e = e.expression), super.hasPropertyAsPrivateName(e);
          }
          isObjectProperty(e) {
           return 'Property' === e.type && 'init' === e.kind && !e.method;
          }
          isObjectMethod(e) {
           return 'Property' === e.type && (e.method || 'get' === e.kind || 'set' === e.kind);
          }
          finishNodeAt(e, t, r) {
           return x(super.finishNodeAt(e, t, r));
          }
          resetStartLocation(e, t) {
           super.resetStartLocation(e, t), x(e);
          }
          resetEndLocation(e, t = this.state.lastTokEndLoc) {
           super.resetEndLocation(e, t), x(e);
          }
         },
        jsx: (e) =>
         class extends e {
          jsxReadToken() {
           let e = '',
            t = this.state.pos;
           for (;;) {
            if (this.state.pos >= this.length) throw this.raise(ct.UnterminatedJsxContent, this.state.startLoc);
            let r = this.input.charCodeAt(this.state.pos);
            switch (r) {
             case 60:
             case 123:
              return this.state.pos === this.state.start ? void (60 === r && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(143)) : super.getTokenFromCode(r)) : ((e += this.input.slice(t, this.state.pos)), void this.finishToken(142, e));
             case 38:
              (e += this.input.slice(t, this.state.pos)), (e += this.jsxReadEntity()), (t = this.state.pos);
              break;
             default:
              we(r) ? ((e += this.input.slice(t, this.state.pos)), (e += this.jsxReadNewLine(!0)), (t = this.state.pos)) : ++this.state.pos;
            }
           }
          }
          jsxReadNewLine(e) {
           let t,
            r = this.input.charCodeAt(this.state.pos);
           return ++this.state.pos, 13 === r && 10 === this.input.charCodeAt(this.state.pos) ? (++this.state.pos, (t = e ? '\n' : '\r\n')) : (t = String.fromCharCode(r)), ++this.state.curLine, (this.state.lineStart = this.state.pos), t;
          }
          jsxReadString(e) {
           let t = '',
            r = ++this.state.pos;
           for (;;) {
            if (this.state.pos >= this.length) throw this.raise(y.UnterminatedString, this.state.startLoc);
            let n = this.input.charCodeAt(this.state.pos);
            if (n === e) break;
            38 === n ? ((t += this.input.slice(r, this.state.pos)), (t += this.jsxReadEntity()), (r = this.state.pos)) : we(n) ? ((t += this.input.slice(r, this.state.pos)), (t += this.jsxReadNewLine(!1)), (r = this.state.pos)) : ++this.state.pos;
           }
           (t += this.input.slice(r, this.state.pos++)), this.finishToken(134, t);
          }
          jsxReadEntity() {
           let e = ++this.state.pos;
           if (35 === this.codePointAtPos(this.state.pos)) {
            ++this.state.pos;
            let e = 10;
            120 === this.codePointAtPos(this.state.pos) && ((e = 16), ++this.state.pos);
            let t = this.readInt(e, void 0, !1, 'bail');
            if (null !== t && 59 === this.codePointAtPos(this.state.pos)) return ++this.state.pos, String.fromCodePoint(t);
           } else {
            let t = 0,
             r = !1;
            for (; t++ < 10 && this.state.pos < this.length && !(r = 59 === this.codePointAtPos(this.state.pos)); ) ++this.state.pos;
            if (r) {
             let t;
             if ((this.input.slice(e, this.state.pos), ++this.state.pos, t)) return t;
            }
           }
           return (this.state.pos = e), '&';
          }
          jsxReadWord() {
           let e,
            t = this.state.pos;
           do {
            e = this.input.charCodeAt(++this.state.pos);
           } while (ie(e) || 45 === e);
           this.finishToken(141, this.input.slice(t, this.state.pos));
          }
          jsxParseIdentifier() {
           let e = this.startNode();
           return this.match(141) ? (e.name = this.state.value) : W(this.state.type) ? (e.name = J(this.state.type)) : this.unexpected(), this.next(), this.finishNode(e, 'JSXIdentifier');
          }
          jsxParseNamespacedName() {
           let e = this.state.startLoc,
            t = this.jsxParseIdentifier();
           if (!this.eat(14)) return t;
           let r = this.startNodeAt(e);
           return (r.namespace = t), (r.name = this.jsxParseIdentifier()), this.finishNode(r, 'JSXNamespacedName');
          }
          jsxParseElementName() {
           let e = this.state.startLoc,
            t = this.jsxParseNamespacedName();
           if ('JSXNamespacedName' === t.type) return t;
           for (; this.eat(16); ) {
            let r = this.startNodeAt(e);
            (r.object = t), (r.property = this.jsxParseIdentifier()), (t = this.finishNode(r, 'JSXMemberExpression'));
           }
           return t;
          }
          jsxParseAttributeValue() {
           let e;
           switch (this.state.type) {
            case 5:
             return (e = this.startNode()), this.setContext(v.brace), this.next(), (e = this.jsxParseExpressionContainer(e, v.j_oTag)), 'JSXEmptyExpression' === e.expression.type && this.raise(ct.AttributeIsEmpty, e), e;
            case 143:
            case 134:
             return this.parseExprAtom();
            default:
             throw this.raise(ct.UnsupportedJsxValue, this.state.startLoc);
           }
          }
          jsxParseEmptyExpression() {
           let e = this.startNodeAt(this.state.lastTokEndLoc);
           return this.finishNodeAt(e, 'JSXEmptyExpression', this.state.startLoc);
          }
          jsxParseSpreadChild(e) {
           return this.next(), (e.expression = this.parseExpression()), this.setContext(v.j_expr), (this.state.canStartJSXElement = !0), this.expect(8), this.finishNode(e, 'JSXSpreadChild');
          }
          jsxParseExpressionContainer(e, t) {
           if (this.match(8)) e.expression = this.jsxParseEmptyExpression();
           else {
            let t = this.parseExpression();
            e.expression = t;
           }
           return this.setContext(t), (this.state.canStartJSXElement = !0), this.expect(8), this.finishNode(e, 'JSXExpressionContainer');
          }
          jsxParseAttribute() {
           let e = this.startNode();
           return this.match(5) ? (this.setContext(v.brace), this.next(), this.expect(21), (e.argument = this.parseMaybeAssignAllowIn()), this.setContext(v.j_oTag), (this.state.canStartJSXElement = !0), this.expect(8), this.finishNode(e, 'JSXSpreadAttribute')) : ((e.name = this.jsxParseNamespacedName()), (e.value = this.eat(29) ? this.jsxParseAttributeValue() : null), this.finishNode(e, 'JSXAttribute'));
          }
          jsxParseOpeningElementAt(e) {
           let t = this.startNodeAt(e);
           return this.eat(144) ? this.finishNode(t, 'JSXOpeningFragment') : ((t.name = this.jsxParseElementName()), this.jsxParseOpeningElementAfterName(t));
          }
          jsxParseOpeningElementAfterName(e) {
           let t = [];
           for (; !this.match(56) && !this.match(144); ) t.push(this.jsxParseAttribute());
           return (e.attributes = t), (e.selfClosing = this.eat(56)), this.expect(144), this.finishNode(e, 'JSXOpeningElement');
          }
          jsxParseClosingElementAt(e) {
           let t = this.startNodeAt(e);
           return this.eat(144) ? this.finishNode(t, 'JSXClosingFragment') : ((t.name = this.jsxParseElementName()), this.expect(144), this.finishNode(t, 'JSXClosingElement'));
          }
          jsxParseElementAt(e) {
           let t = this.startNodeAt(e),
            r = [],
            n = this.jsxParseOpeningElementAt(e),
            s = null;
           if (!n.selfClosing) {
            e: for (;;)
             switch (this.state.type) {
              case 143:
               if (((e = this.state.startLoc), this.next(), this.eat(56))) {
                s = this.jsxParseClosingElementAt(e);
                break e;
               }
               r.push(this.jsxParseElementAt(e));
               break;
              case 142:
               r.push(this.parseLiteral(this.state.value, 'JSXText'));
               break;
              case 5: {
               let e = this.startNode();
               this.setContext(v.brace), this.next(), this.match(21) ? r.push(this.jsxParseSpreadChild(e)) : r.push(this.jsxParseExpressionContainer(e, v.j_expr));
               break;
              }
              default:
               this.unexpected();
             }
            ht(n) && !ht(s) && null !== s ? this.raise(ct.MissingClosingTagFragment, s) : ((!ht(n) && ht(s)) || (!ht(n) && !ht(s) && dt(s.name) !== dt(n.name))) && this.raise(ct.MissingClosingTagElement, s, { openingTagName: dt(n.name) });
           }
           if ((ht(n) ? ((t.openingFragment = n), (t.closingFragment = s)) : ((t.openingElement = n), (t.closingElement = s)), (t.children = r), this.match(47))) throw this.raise(ct.UnwrappedAdjacentJSXElements, this.state.startLoc);
           return ht(n) ? this.finishNode(t, 'JSXFragment') : this.finishNode(t, 'JSXElement');
          }
          jsxParseElement() {
           let e = this.state.startLoc;
           return this.next(), this.jsxParseElementAt(e);
          }
          setContext(e) {
           let { context: t } = this.state;
           t[t.length - 1] = e;
          }
          parseExprAtom(e) {
           return this.match(143) ? this.jsxParseElement() : this.match(47) && 33 !== this.input.charCodeAt(this.state.pos) ? (this.replaceToken(143), this.jsxParseElement()) : super.parseExprAtom(e);
          }
          skipSpace() {
           this.curContext().preserveSpace || super.skipSpace();
          }
          getTokenFromCode(e) {
           let t = this.curContext();
           if (t !== v.j_expr) {
            if (t === v.j_oTag || t === v.j_cTag) {
             if (se(e)) return void this.jsxReadWord();
             if (62 === e) return ++this.state.pos, void this.finishToken(144);
             if ((34 === e || 39 === e) && t === v.j_oTag) return void this.jsxReadString(e);
            }
            if (60 === e && this.state.canStartJSXElement && 33 !== this.input.charCodeAt(this.state.pos + 1)) return ++this.state.pos, void this.finishToken(143);
            super.getTokenFromCode(e);
           } else this.jsxReadToken();
          }
          updateContext(e) {
           let { context: t, type: r } = this.state;
           if (56 === r && 143 === e) t.splice(-2, 2, v.j_cTag), (this.state.canStartJSXElement = !1);
           else if (143 === r) t.push(v.j_oTag);
           else if (144 === r) {
            let r = t[t.length - 1];
            (r === v.j_oTag && 56 === e) || r === v.j_cTag ? (t.pop(), (this.state.canStartJSXElement = t[t.length - 1] === v.j_expr)) : (this.setContext(v.j_expr), (this.state.canStartJSXElement = !0));
           } else
            this.state.canStartJSXElement = (function (e) {
             return L[e];
            })(r);
          }
         },
        flow: (e) =>
         class extends e {
          constructor(...e) {
           super(...e), (this.flowPragma = void 0);
          }
          getScopeHandler() {
           return xe;
          }
          shouldParseTypes() {
           return this.getPluginOption('flow', 'all') || 'flow' === this.flowPragma;
          }
          finishToken(e, t) {
           134 !== e && 13 !== e && 28 !== e && void 0 === this.flowPragma && (this.flowPragma = null), super.finishToken(e, t);
          }
          addComment(e) {
           if (void 0 === this.flowPragma) {
            let t = pt.exec(e.value);
            if (t)
             if ('flow' === t[1]) this.flowPragma = 'flow';
             else {
              if ('noflow' !== t[1]) throw new Error('Unexpected flow pragma');
              this.flowPragma = 'noflow';
             }
           }
           super.addComment(e);
          }
          flowParseTypeInitialiser(e) {
           let t = this.state.inType;
           (this.state.inType = !0), this.expect(e || 14);
           let r = this.flowParseType();
           return (this.state.inType = t), r;
          }
          flowParsePredicate() {
           let e = this.startNode(),
            t = this.state.startLoc;
           return this.next(), this.expectContextual(110), this.state.lastTokStartLoc.index > t.index + 1 && this.raise(ot.UnexpectedSpaceBetweenModuloChecks, t), this.eat(10) ? ((e.value = super.parseExpression()), this.expect(11), this.finishNode(e, 'DeclaredPredicate')) : this.finishNode(e, 'InferredPredicate');
          }
          flowParseTypeAndPredicateInitialiser() {
           let e = this.state.inType;
           (this.state.inType = !0), this.expect(14);
           let t = null,
            r = null;
           return this.match(54) ? ((this.state.inType = e), (r = this.flowParsePredicate())) : ((t = this.flowParseType()), (this.state.inType = e), this.match(54) && (r = this.flowParsePredicate())), [t, r];
          }
          flowParseDeclareClass(e) {
           return this.next(), this.flowParseInterfaceish(e, !0), this.finishNode(e, 'DeclareClass');
          }
          flowParseDeclareFunction(e) {
           this.next();
           let t = (e.id = this.parseIdentifier()),
            r = this.startNode(),
            n = this.startNode();
           this.match(47) ? (r.typeParameters = this.flowParseTypeParameterDeclaration()) : (r.typeParameters = null), this.expect(10);
           let s = this.flowParseFunctionTypeParams();
           return (r.params = s.params), (r.rest = s.rest), (r.this = s._this), this.expect(11), ([r.returnType, e.predicate] = this.flowParseTypeAndPredicateInitialiser()), (n.typeAnnotation = this.finishNode(r, 'FunctionTypeAnnotation')), (t.typeAnnotation = this.finishNode(n, 'TypeAnnotation')), this.resetEndLocation(t), this.semicolon(), this.scope.declareName(e.id.name, 2048, e.id.loc.start), this.finishNode(e, 'DeclareFunction');
          }
          flowParseDeclare(e, t) {
           return this.match(80) ? this.flowParseDeclareClass(e) : this.match(68) ? this.flowParseDeclareFunction(e) : this.match(74) ? this.flowParseDeclareVariable(e) : this.eatContextual(127) ? (this.match(16) ? this.flowParseDeclareModuleExports(e) : (t && this.raise(ot.NestedDeclareModule, this.state.lastTokStartLoc), this.flowParseDeclareModule(e))) : this.isContextual(130) ? this.flowParseDeclareTypeAlias(e) : this.isContextual(131) ? this.flowParseDeclareOpaqueType(e) : this.isContextual(129) ? this.flowParseDeclareInterface(e) : this.match(82) ? this.flowParseDeclareExportDeclaration(e, t) : void this.unexpected();
          }
          flowParseDeclareVariable(e) {
           return this.next(), (e.id = this.flowParseTypeAnnotatableIdentifier(!0)), this.scope.declareName(e.id.name, 5, e.id.loc.start), this.semicolon(), this.finishNode(e, 'DeclareVariable');
          }
          flowParseDeclareModule(e) {
           this.scope.enter(0), this.match(134) ? (e.id = super.parseExprAtom()) : (e.id = this.parseIdentifier());
           let t = (e.body = this.startNode()),
            r = (t.body = []);
           for (this.expect(5); !this.match(8); ) {
            let e = this.startNode();
            this.match(83) ? (this.next(), !this.isContextual(130) && !this.match(87) && this.raise(ot.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc), super.parseImport(e)) : (this.expectContextual(125, ot.UnsupportedStatementInDeclareModule), (e = this.flowParseDeclare(e, !0))), r.push(e);
           }
           this.scope.exit(), this.expect(8), this.finishNode(t, 'BlockStatement');
           let n = null,
            s = !1;
           return (
            r.forEach((e) => {
             !(function (e) {
              return 'DeclareExportAllDeclaration' === e.type || ('DeclareExportDeclaration' === e.type && (!e.declaration || ('TypeAlias' !== e.declaration.type && 'InterfaceDeclaration' !== e.declaration.type)));
             })(e)
              ? 'DeclareModuleExports' === e.type && (s && this.raise(ot.DuplicateDeclareModuleExports, e), 'ES' === n && this.raise(ot.AmbiguousDeclareModuleKind, e), (n = 'CommonJS'), (s = !0))
              : ('CommonJS' === n && this.raise(ot.AmbiguousDeclareModuleKind, e), (n = 'ES'));
            }),
            (e.kind = n || 'CommonJS'),
            this.finishNode(e, 'DeclareModule')
           );
          }
          flowParseDeclareExportDeclaration(e, t) {
           if ((this.expect(82), this.eat(65))) return this.match(68) || this.match(80) ? (e.declaration = this.flowParseDeclare(this.startNode())) : ((e.declaration = this.flowParseType()), this.semicolon()), (e.default = !0), this.finishNode(e, 'DeclareExportDeclaration');
           if (this.match(75) || this.isLet() || ((this.isContextual(130) || this.isContextual(129)) && !t)) {
            let e = this.state.value;
            throw this.raise(ot.UnsupportedDeclareExportKind, this.state.startLoc, { unsupportedExportKind: e, suggestion: lt[e] });
           }
           return this.match(74) || this.match(68) || this.match(80) || this.isContextual(131) ? ((e.declaration = this.flowParseDeclare(this.startNode())), (e.default = !1), this.finishNode(e, 'DeclareExportDeclaration')) : this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131) ? ('ExportNamedDeclaration' === (e = this.parseExport(e, null)).type && ((e.type = 'ExportDeclaration'), (e.default = !1), delete e.exportKind), (e.type = 'Declare' + e.type), e) : void this.unexpected();
          }
          flowParseDeclareModuleExports(e) {
           return this.next(), this.expectContextual(111), (e.typeAnnotation = this.flowParseTypeAnnotation()), this.semicolon(), this.finishNode(e, 'DeclareModuleExports');
          }
          flowParseDeclareTypeAlias(e) {
           this.next();
           let t = this.flowParseTypeAlias(e);
           return (t.type = 'DeclareTypeAlias'), t;
          }
          flowParseDeclareOpaqueType(e) {
           this.next();
           let t = this.flowParseOpaqueType(e, !0);
           return (t.type = 'DeclareOpaqueType'), t;
          }
          flowParseDeclareInterface(e) {
           return this.next(), this.flowParseInterfaceish(e, !1), this.finishNode(e, 'DeclareInterface');
          }
          flowParseInterfaceish(e, t) {
           if (((e.id = this.flowParseRestrictedIdentifier(!t, !0)), this.scope.declareName(e.id.name, t ? 17 : 8201, e.id.loc.start), this.match(47) ? (e.typeParameters = this.flowParseTypeParameterDeclaration()) : (e.typeParameters = null), (e.extends = []), this.eat(81)))
            do {
             e.extends.push(this.flowParseInterfaceExtends());
            } while (!t && this.eat(12));
           if (t) {
            if (((e.implements = []), (e.mixins = []), this.eatContextual(117)))
             do {
              e.mixins.push(this.flowParseInterfaceExtends());
             } while (this.eat(12));
            if (this.eatContextual(113))
             do {
              e.implements.push(this.flowParseInterfaceExtends());
             } while (this.eat(12));
           }
           e.body = this.flowParseObjectType({ allowStatic: t, allowExact: !1, allowSpread: !1, allowProto: t, allowInexact: !1 });
          }
          flowParseInterfaceExtends() {
           let e = this.startNode();
           return (e.id = this.flowParseQualifiedTypeIdentifier()), this.match(47) ? (e.typeParameters = this.flowParseTypeParameterInstantiation()) : (e.typeParameters = null), this.finishNode(e, 'InterfaceExtends');
          }
          flowParseInterface(e) {
           return this.flowParseInterfaceish(e, !1), this.finishNode(e, 'InterfaceDeclaration');
          }
          checkNotUnderscore(e) {
           '_' === e && this.raise(ot.UnexpectedReservedUnderscore, this.state.startLoc);
          }
          checkReservedType(e, t, r) {
           at.has(e) && this.raise(r ? ot.AssignReservedType : ot.UnexpectedReservedType, t, { reservedType: e });
          }
          flowParseRestrictedIdentifier(e, t) {
           return this.checkReservedType(this.state.value, this.state.startLoc, t), this.parseIdentifier(e);
          }
          flowParseTypeAlias(e) {
           return (e.id = this.flowParseRestrictedIdentifier(!1, !0)), this.scope.declareName(e.id.name, 8201, e.id.loc.start), this.match(47) ? (e.typeParameters = this.flowParseTypeParameterDeclaration()) : (e.typeParameters = null), (e.right = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(e, 'TypeAlias');
          }
          flowParseOpaqueType(e, t) {
           return this.expectContextual(130), (e.id = this.flowParseRestrictedIdentifier(!0, !0)), this.scope.declareName(e.id.name, 8201, e.id.loc.start), this.match(47) ? (e.typeParameters = this.flowParseTypeParameterDeclaration()) : (e.typeParameters = null), (e.supertype = null), this.match(14) && (e.supertype = this.flowParseTypeInitialiser(14)), (e.impltype = null), t || (e.impltype = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(e, 'OpaqueType');
          }
          flowParseTypeParameter(e = !1) {
           let t = this.state.startLoc,
            r = this.startNode(),
            n = this.flowParseVariance(),
            s = this.flowParseTypeAnnotatableIdentifier();
           return (r.name = s.name), (r.variance = n), (r.bound = s.typeAnnotation), this.match(29) ? (this.eat(29), (r.default = this.flowParseType())) : e && this.raise(ot.MissingTypeParamDefault, t), this.finishNode(r, 'TypeParameter');
          }
          flowParseTypeParameterDeclaration() {
           let e = this.state.inType,
            t = this.startNode();
           (t.params = []), (this.state.inType = !0), this.match(47) || this.match(143) ? this.next() : this.unexpected();
           let r = !1;
           do {
            let e = this.flowParseTypeParameter(r);
            t.params.push(e), e.default && (r = !0), this.match(48) || this.expect(12);
           } while (!this.match(48));
           return this.expect(48), (this.state.inType = e), this.finishNode(t, 'TypeParameterDeclaration');
          }
          flowInTopLevelContext(e) {
           if (this.curContext() === v.brace) return e();
           {
            let t = this.state.context;
            this.state.context = [t[0]];
            try {
             return e();
            } finally {
             this.state.context = t;
            }
           }
          }
          flowParseTypeParameterInstantiationInExpression() {
           if (47 === this.reScan_lt()) return this.flowParseTypeParameterInstantiation();
          }
          flowParseTypeParameterInstantiation() {
           let e = this.startNode(),
            t = this.state.inType;
           return (
            (this.state.inType = !0),
            (e.params = []),
            this.flowInTopLevelContext(() => {
             this.expect(47);
             let t = this.state.noAnonFunctionType;
             for (this.state.noAnonFunctionType = !1; !this.match(48); ) e.params.push(this.flowParseType()), this.match(48) || this.expect(12);
             this.state.noAnonFunctionType = t;
            }),
            (this.state.inType = t),
            !this.state.inType && this.curContext() === v.brace && this.reScan_lt_gt(),
            this.expect(48),
            this.finishNode(e, 'TypeParameterInstantiation')
           );
          }
          flowParseTypeParameterInstantiationCallOrNew() {
           if (47 !== this.reScan_lt()) return;
           let e = this.startNode(),
            t = this.state.inType;
           for (e.params = [], this.state.inType = !0, this.expect(47); !this.match(48); ) e.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
           return this.expect(48), (this.state.inType = t), this.finishNode(e, 'TypeParameterInstantiation');
          }
          flowParseInterfaceType() {
           let e = this.startNode();
           if ((this.expectContextual(129), (e.extends = []), this.eat(81)))
            do {
             e.extends.push(this.flowParseInterfaceExtends());
            } while (this.eat(12));
           return (e.body = this.flowParseObjectType({ allowStatic: !1, allowExact: !1, allowSpread: !1, allowProto: !1, allowInexact: !1 })), this.finishNode(e, 'InterfaceTypeAnnotation');
          }
          flowParseObjectPropertyKey() {
           return this.match(135) || this.match(134) ? super.parseExprAtom() : this.parseIdentifier(!0);
          }
          flowParseObjectTypeIndexer(e, t, r) {
           return (e.static = t), 14 === this.lookahead().type ? ((e.id = this.flowParseObjectPropertyKey()), (e.key = this.flowParseTypeInitialiser())) : ((e.id = null), (e.key = this.flowParseType())), this.expect(3), (e.value = this.flowParseTypeInitialiser()), (e.variance = r), this.finishNode(e, 'ObjectTypeIndexer');
          }
          flowParseObjectTypeInternalSlot(e, t) {
           return (e.static = t), (e.id = this.flowParseObjectPropertyKey()), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? ((e.method = !0), (e.optional = !1), (e.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e.loc.start)))) : ((e.method = !1), this.eat(17) && (e.optional = !0), (e.value = this.flowParseTypeInitialiser())), this.finishNode(e, 'ObjectTypeInternalSlot');
          }
          flowParseObjectTypeMethodish(e) {
           for (e.params = [], e.rest = null, e.typeParameters = null, e.this = null, this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), this.match(78) && ((e.this = this.flowParseFunctionTypeParam(!0)), (e.this.name = null), this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); ) e.params.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
           return this.eat(21) && (e.rest = this.flowParseFunctionTypeParam(!1)), this.expect(11), (e.returnType = this.flowParseTypeInitialiser()), this.finishNode(e, 'FunctionTypeAnnotation');
          }
          flowParseObjectTypeCallProperty(e, t) {
           let r = this.startNode();
           return (e.static = t), (e.value = this.flowParseObjectTypeMethodish(r)), this.finishNode(e, 'ObjectTypeCallProperty');
          }
          flowParseObjectType({ allowStatic: e, allowExact: t, allowSpread: r, allowProto: n, allowInexact: s }) {
           let i = this.state.inType;
           this.state.inType = !0;
           let a = this.startNode();
           (a.callProperties = []), (a.properties = []), (a.indexers = []), (a.internalSlots = []);
           let o,
            u,
            l = !1;
           for (t && this.match(6) ? (this.expect(6), (o = 9), (u = !0)) : (this.expect(5), (o = 8), (u = !1)), a.exact = u; !this.match(o); ) {
            let t = !1,
             i = null,
             o = null,
             p = this.startNode();
            if (n && this.isContextual(118)) {
             let t = this.lookahead();
             14 !== t.type && 17 !== t.type && (this.next(), (i = this.state.startLoc), (e = !1));
            }
            if (e && this.isContextual(106)) {
             let e = this.lookahead();
             14 !== e.type && 17 !== e.type && (this.next(), (t = !0));
            }
            let c = this.flowParseVariance();
            if (this.eat(0)) null != i && this.unexpected(i), this.eat(0) ? (c && this.unexpected(c.loc.start), a.internalSlots.push(this.flowParseObjectTypeInternalSlot(p, t))) : a.indexers.push(this.flowParseObjectTypeIndexer(p, t, c));
            else if (this.match(10) || this.match(47)) null != i && this.unexpected(i), c && this.unexpected(c.loc.start), a.callProperties.push(this.flowParseObjectTypeCallProperty(p, t));
            else {
             let e = 'init';
             (this.isContextual(99) || this.isContextual(104)) && H(this.lookahead().type) && ((e = this.state.value), this.next());
             let n = this.flowParseObjectTypeProperty(p, t, i, c, e, r, s ?? !u);
             null === n ? ((l = !0), (o = this.state.lastTokStartLoc)) : a.properties.push(n);
            }
            this.flowObjectTypeSemicolon(), o && !this.match(8) && !this.match(9) && this.raise(ot.UnexpectedExplicitInexactInObject, o);
           }
           this.expect(o), r && (a.inexact = l);
           let p = this.finishNode(a, 'ObjectTypeAnnotation');
           return (this.state.inType = i), p;
          }
          flowParseObjectTypeProperty(e, t, r, n, s, i, a) {
           if (this.eat(21)) return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (i ? a || this.raise(ot.InexactInsideExact, this.state.lastTokStartLoc) : this.raise(ot.InexactInsideNonObject, this.state.lastTokStartLoc), n && this.raise(ot.InexactVariance, n), null) : (i || this.raise(ot.UnexpectedSpreadType, this.state.lastTokStartLoc), null != r && this.unexpected(r), n && this.raise(ot.SpreadVariance, n), (e.argument = this.flowParseType()), this.finishNode(e, 'ObjectTypeSpreadProperty'));
           {
            (e.key = this.flowParseObjectPropertyKey()), (e.static = t), (e.proto = null != r), (e.kind = s);
            let a = !1;
            return this.match(47) || this.match(10) ? ((e.method = !0), null != r && this.unexpected(r), n && this.unexpected(n.loc.start), (e.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e.loc.start))), ('get' === s || 'set' === s) && this.flowCheckGetterSetterParams(e), !i && 'constructor' === e.key.name && e.value.this && this.raise(ot.ThisParamBannedInConstructor, e.value.this)) : ('init' !== s && this.unexpected(), (e.method = !1), this.eat(17) && (a = !0), (e.value = this.flowParseTypeInitialiser()), (e.variance = n)), (e.optional = a), this.finishNode(e, 'ObjectTypeProperty');
           }
          }
          flowCheckGetterSetterParams(e) {
           let t = 'get' === e.kind ? 0 : 1,
            r = e.value.params.length + (e.value.rest ? 1 : 0);
           e.value.this && this.raise('get' === e.kind ? ot.GetterMayNotHaveThisParam : ot.SetterMayNotHaveThisParam, e.value.this), r !== t && this.raise('get' === e.kind ? y.BadGetterArity : y.BadSetterArity, e), 'set' === e.kind && e.value.rest && this.raise(y.BadSetterRestParameter, e);
          }
          flowObjectTypeSemicolon() {
           !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
          }
          flowParseQualifiedTypeIdentifier(e, t) {
           null != e || (e = this.state.startLoc);
           let r = t || this.flowParseRestrictedIdentifier(!0);
           for (; this.eat(16); ) {
            let t = this.startNodeAt(e);
            (t.qualification = r), (t.id = this.flowParseRestrictedIdentifier(!0)), (r = this.finishNode(t, 'QualifiedTypeIdentifier'));
           }
           return r;
          }
          flowParseGenericType(e, t) {
           let r = this.startNodeAt(e);
           return (r.typeParameters = null), (r.id = this.flowParseQualifiedTypeIdentifier(e, t)), this.match(47) && (r.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(r, 'GenericTypeAnnotation');
          }
          flowParseTypeofType() {
           let e = this.startNode();
           return this.expect(87), (e.argument = this.flowParsePrimaryType()), this.finishNode(e, 'TypeofTypeAnnotation');
          }
          flowParseTupleType() {
           let e = this.startNode();
           for (e.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (e.types.push(this.flowParseType()), !this.match(3)); ) this.expect(12);
           return this.expect(3), this.finishNode(e, 'TupleTypeAnnotation');
          }
          flowParseFunctionTypeParam(e) {
           let t = null,
            r = !1,
            n = null,
            s = this.startNode(),
            i = this.lookahead(),
            a = 78 === this.state.type;
           return 14 === i.type || 17 === i.type ? (a && !e && this.raise(ot.ThisParamMustBeFirst, s), (t = this.parseIdentifier(a)), this.eat(17) && ((r = !0), a && this.raise(ot.ThisParamMayNotBeOptional, s)), (n = this.flowParseTypeInitialiser())) : (n = this.flowParseType()), (s.name = t), (s.optional = r), (s.typeAnnotation = n), this.finishNode(s, 'FunctionTypeParam');
          }
          reinterpretTypeAsFunctionTypeParam(e) {
           let t = this.startNodeAt(e.loc.start);
           return (t.name = null), (t.optional = !1), (t.typeAnnotation = e), this.finishNode(t, 'FunctionTypeParam');
          }
          flowParseFunctionTypeParams(e = []) {
           let t = null,
            r = null;
           for (this.match(78) && ((r = this.flowParseFunctionTypeParam(!0)), (r.name = null), this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); ) e.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
           return this.eat(21) && (t = this.flowParseFunctionTypeParam(!1)), { params: e, rest: t, _this: r };
          }
          flowIdentToTypeAnnotation(e, t, r) {
           switch (r.name) {
            case 'any':
             return this.finishNode(t, 'AnyTypeAnnotation');
            case 'bool':
            case 'boolean':
             return this.finishNode(t, 'BooleanTypeAnnotation');
            case 'mixed':
             return this.finishNode(t, 'MixedTypeAnnotation');
            case 'empty':
             return this.finishNode(t, 'EmptyTypeAnnotation');
            case 'number':
             return this.finishNode(t, 'NumberTypeAnnotation');
            case 'string':
             return this.finishNode(t, 'StringTypeAnnotation');
            case 'symbol':
             return this.finishNode(t, 'SymbolTypeAnnotation');
            default:
             return this.checkNotUnderscore(r.name), this.flowParseGenericType(e, r);
           }
          }
          flowParsePrimaryType() {
           let e,
            t,
            r = this.state.startLoc,
            n = this.startNode(),
            s = !1,
            i = this.state.noAnonFunctionType;
           switch (this.state.type) {
            case 5:
             return this.flowParseObjectType({ allowStatic: !1, allowExact: !1, allowSpread: !0, allowProto: !1, allowInexact: !0 });
            case 6:
             return this.flowParseObjectType({ allowStatic: !1, allowExact: !0, allowSpread: !0, allowProto: !1, allowInexact: !1 });
            case 0:
             return (this.state.noAnonFunctionType = !1), (t = this.flowParseTupleType()), (this.state.noAnonFunctionType = i), t;
            case 47: {
             let t = this.startNode();
             return (t.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), (e = this.flowParseFunctionTypeParams()), (t.params = e.params), (t.rest = e.rest), (t.this = e._this), this.expect(11), this.expect(19), (t.returnType = this.flowParseType()), this.finishNode(t, 'FunctionTypeAnnotation');
            }
            case 10: {
             let r = this.startNode();
             if ((this.next(), !this.match(11) && !this.match(21)))
              if (U(this.state.type) || this.match(78)) {
               let e = this.lookahead().type;
               s = 17 !== e && 14 !== e;
              } else s = !0;
             if (s) {
              if (((this.state.noAnonFunctionType = !1), (t = this.flowParseType()), (this.state.noAnonFunctionType = i), this.state.noAnonFunctionType || !(this.match(12) || (this.match(11) && 19 === this.lookahead().type)))) return this.expect(11), t;
              this.eat(12);
             }
             return (e = t ? this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(t)]) : this.flowParseFunctionTypeParams()), (r.params = e.params), (r.rest = e.rest), (r.this = e._this), this.expect(11), this.expect(19), (r.returnType = this.flowParseType()), (r.typeParameters = null), this.finishNode(r, 'FunctionTypeAnnotation');
            }
            case 134:
             return this.parseLiteral(this.state.value, 'StringLiteralTypeAnnotation');
            case 85:
            case 86:
             return (n.value = this.match(85)), this.next(), this.finishNode(n, 'BooleanLiteralTypeAnnotation');
            case 53:
             if ('-' === this.state.value) {
              if ((this.next(), this.match(135))) return this.parseLiteralAtNode(-this.state.value, 'NumberLiteralTypeAnnotation', n);
              if (this.match(136)) return this.parseLiteralAtNode(-this.state.value, 'BigIntLiteralTypeAnnotation', n);
              throw this.raise(ot.UnexpectedSubtractionOperand, this.state.startLoc);
             }
             return void this.unexpected();
            case 135:
             return this.parseLiteral(this.state.value, 'NumberLiteralTypeAnnotation');
            case 136:
             return this.parseLiteral(this.state.value, 'BigIntLiteralTypeAnnotation');
            case 88:
             return this.next(), this.finishNode(n, 'VoidTypeAnnotation');
            case 84:
             return this.next(), this.finishNode(n, 'NullLiteralTypeAnnotation');
            case 78:
             return this.next(), this.finishNode(n, 'ThisTypeAnnotation');
            case 55:
             return this.next(), this.finishNode(n, 'ExistsTypeAnnotation');
            case 87:
             return this.flowParseTypeofType();
            default:
             if (W(this.state.type)) {
              let e = J(this.state.type);
              return this.next(), super.createIdentifier(n, e);
             }
             if (U(this.state.type)) return this.isContextual(129) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(r, n, this.parseIdentifier());
           }
           this.unexpected();
          }
          flowParsePostfixType() {
           let e = this.state.startLoc,
            t = this.flowParsePrimaryType(),
            r = !1;
           for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
            let n = this.startNodeAt(e),
             s = this.eat(18);
            (r = r || s), this.expect(0), !s && this.match(3) ? ((n.elementType = t), this.next(), (t = this.finishNode(n, 'ArrayTypeAnnotation'))) : ((n.objectType = t), (n.indexType = this.flowParseType()), this.expect(3), r ? ((n.optional = s), (t = this.finishNode(n, 'OptionalIndexedAccessType'))) : (t = this.finishNode(n, 'IndexedAccessType')));
           }
           return t;
          }
          flowParsePrefixType() {
           let e = this.startNode();
           return this.eat(17) ? ((e.typeAnnotation = this.flowParsePrefixType()), this.finishNode(e, 'NullableTypeAnnotation')) : this.flowParsePostfixType();
          }
          flowParseAnonFunctionWithoutParens() {
           let e = this.flowParsePrefixType();
           if (!this.state.noAnonFunctionType && this.eat(19)) {
            let t = this.startNodeAt(e.loc.start);
            return (t.params = [this.reinterpretTypeAsFunctionTypeParam(e)]), (t.rest = null), (t.this = null), (t.returnType = this.flowParseType()), (t.typeParameters = null), this.finishNode(t, 'FunctionTypeAnnotation');
           }
           return e;
          }
          flowParseIntersectionType() {
           let e = this.startNode();
           this.eat(45);
           let t = this.flowParseAnonFunctionWithoutParens();
           for (e.types = [t]; this.eat(45); ) e.types.push(this.flowParseAnonFunctionWithoutParens());
           return 1 === e.types.length ? t : this.finishNode(e, 'IntersectionTypeAnnotation');
          }
          flowParseUnionType() {
           let e = this.startNode();
           this.eat(43);
           let t = this.flowParseIntersectionType();
           for (e.types = [t]; this.eat(43); ) e.types.push(this.flowParseIntersectionType());
           return 1 === e.types.length ? t : this.finishNode(e, 'UnionTypeAnnotation');
          }
          flowParseType() {
           let e = this.state.inType;
           this.state.inType = !0;
           let t = this.flowParseUnionType();
           return (this.state.inType = e), t;
          }
          flowParseTypeOrImplicitInstantiation() {
           if (132 === this.state.type && '_' === this.state.value) {
            let e = this.state.startLoc,
             t = this.parseIdentifier();
            return this.flowParseGenericType(e, t);
           }
           return this.flowParseType();
          }
          flowParseTypeAnnotation() {
           let e = this.startNode();
           return (e.typeAnnotation = this.flowParseTypeInitialiser()), this.finishNode(e, 'TypeAnnotation');
          }
          flowParseTypeAnnotatableIdentifier(e) {
           let t = e ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
           return this.match(14) && ((t.typeAnnotation = this.flowParseTypeAnnotation()), this.resetEndLocation(t)), t;
          }
          typeCastToParameter(e) {
           return (e.expression.typeAnnotation = e.typeAnnotation), this.resetEndLocation(e.expression, e.typeAnnotation.loc.end), e.expression;
          }
          flowParseVariance() {
           let e = null;
           return this.match(53) ? ((e = this.startNode()), '+' === this.state.value ? (e.kind = 'plus') : (e.kind = 'minus'), this.next(), this.finishNode(e, 'Variance')) : e;
          }
          parseFunctionBody(e, t, r = !1) {
           t ? this.forwardNoArrowParamsConversionAt(e, () => super.parseFunctionBody(e, !0, r)) : super.parseFunctionBody(e, !1, r);
          }
          parseFunctionBodyAndFinish(e, t, r = !1) {
           if (this.match(14)) {
            let t = this.startNode();
            ([t.typeAnnotation, e.predicate] = this.flowParseTypeAndPredicateInitialiser()), (e.returnType = t.typeAnnotation ? this.finishNode(t, 'TypeAnnotation') : null);
           }
           return super.parseFunctionBodyAndFinish(e, t, r);
          }
          parseStatementLike(e) {
           if (this.state.strict && this.isContextual(129)) {
            if ($(this.lookahead().type)) {
             let e = this.startNode();
             return this.next(), this.flowParseInterface(e);
            }
           } else if (this.isContextual(126)) {
            let e = this.startNode();
            return this.next(), this.flowParseEnumDeclaration(e);
           }
           let t = super.parseStatementLike(e);
           return void 0 === this.flowPragma && !this.isValidDirective(t) && (this.flowPragma = null), t;
          }
          parseExpressionStatement(e, t, r) {
           if ('Identifier' === t.type)
            if ('declare' === t.name) {
             if (this.match(80) || U(this.state.type) || this.match(68) || this.match(74) || this.match(82)) return this.flowParseDeclare(e);
            } else if (U(this.state.type)) {
             if ('interface' === t.name) return this.flowParseInterface(e);
             if ('type' === t.name) return this.flowParseTypeAlias(e);
             if ('opaque' === t.name) return this.flowParseOpaqueType(e, !1);
            }
           return super.parseExpressionStatement(e, t, r);
          }
          shouldParseExportDeclaration() {
           let { type: e } = this.state;
           return 126 === e || V(e) ? !this.state.containsEsc : super.shouldParseExportDeclaration();
          }
          isExportDefaultSpecifier() {
           let { type: e } = this.state;
           return 126 === e || V(e) ? this.state.containsEsc : super.isExportDefaultSpecifier();
          }
          parseExportDefaultExpression() {
           if (this.isContextual(126)) {
            let e = this.startNode();
            return this.next(), this.flowParseEnumDeclaration(e);
           }
           return super.parseExportDefaultExpression();
          }
          parseConditional(e, t, r) {
           if (!this.match(17)) return e;
           if (this.state.maybeInArrowParameters) {
            let t = this.lookaheadCharCode();
            if (44 === t || 61 === t || 58 === t || 41 === t) return this.setOptionalParametersError(r), e;
           }
           this.expect(17);
           let n = this.state.clone(),
            s = this.state.noArrowAt,
            i = this.startNodeAt(t),
            { consequent: a, failed: o } = this.tryParseConditionalConsequent(),
            [u, l] = this.getArrowLikeExpressions(a);
           if (o || l.length > 0) {
            let e = [...s];
            if (l.length > 0) {
             (this.state = n), (this.state.noArrowAt = e);
             for (let t = 0; t < l.length; t++) e.push(l[t].start);
             ({ consequent: a, failed: o } = this.tryParseConditionalConsequent()), ([u, l] = this.getArrowLikeExpressions(a));
            }
            o && u.length > 1 && this.raise(ot.AmbiguousConditionalArrow, n.startLoc), o && 1 === u.length && ((this.state = n), e.push(u[0].start), (this.state.noArrowAt = e), ({ consequent: a, failed: o } = this.tryParseConditionalConsequent()));
           }
           return this.getArrowLikeExpressions(a, !0), (this.state.noArrowAt = s), this.expect(14), (i.test = e), (i.consequent = a), (i.alternate = this.forwardNoArrowParamsConversionAt(i, () => this.parseMaybeAssign(void 0, void 0))), this.finishNode(i, 'ConditionalExpression');
          }
          tryParseConditionalConsequent() {
           this.state.noArrowParamsConversionAt.push(this.state.start);
           let e = this.parseMaybeAssignAllowIn(),
            t = !this.match(14);
           return this.state.noArrowParamsConversionAt.pop(), { consequent: e, failed: t };
          }
          getArrowLikeExpressions(e, t) {
           let r = [e],
            n = [];
           for (; 0 !== r.length; ) {
            let e = r.pop();
            'ArrowFunctionExpression' === e.type && 'BlockStatement' !== e.body.type ? (e.typeParameters || !e.returnType ? this.finishArrowValidation(e) : n.push(e), r.push(e.body)) : 'ConditionalExpression' === e.type && (r.push(e.consequent), r.push(e.alternate));
           }
           return t
            ? (n.forEach((e) => this.finishArrowValidation(e)), [n, []])
            : (function (e, t) {
               let r = [],
                n = [];
               for (let s = 0; s < e.length; s++) (t(e[s], s, e) ? r : n).push(e[s]);
               return [r, n];
              })(n, (e) => e.params.every((e) => this.isAssignable(e, !0)));
          }
          finishArrowValidation(e) {
           var t;
           this.toAssignableList(e.params, null == (t = e.extra) ? void 0 : t.trailingCommaLoc, !1), this.scope.enter(6), super.checkParams(e, !1, !0), this.scope.exit();
          }
          forwardNoArrowParamsConversionAt(e, t) {
           let r;
           return this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(e.start)) ? (this.state.noArrowParamsConversionAt.push(this.state.start), (r = t()), this.state.noArrowParamsConversionAt.pop()) : (r = t()), r;
          }
          parseParenItem(e, t) {
           let r = super.parseParenItem(e, t);
           if ((this.eat(17) && ((r.optional = !0), this.resetEndLocation(e)), this.match(14))) {
            let e = this.startNodeAt(t);
            return (e.expression = r), (e.typeAnnotation = this.flowParseTypeAnnotation()), this.finishNode(e, 'TypeCastExpression');
           }
           return r;
          }
          assertModuleNodeAllowed(e) {
           ('ImportDeclaration' === e.type && ('type' === e.importKind || 'typeof' === e.importKind)) || ('ExportNamedDeclaration' === e.type && 'type' === e.exportKind) || ('ExportAllDeclaration' === e.type && 'type' === e.exportKind) || super.assertModuleNodeAllowed(e);
          }
          parseExportDeclaration(e) {
           if (this.isContextual(130)) {
            e.exportKind = 'type';
            let t = this.startNode();
            return this.next(), this.match(5) ? ((e.specifiers = this.parseExportSpecifiers(!0)), super.parseExportFrom(e), null) : this.flowParseTypeAlias(t);
           }
           if (this.isContextual(131)) {
            e.exportKind = 'type';
            let t = this.startNode();
            return this.next(), this.flowParseOpaqueType(t, !1);
           }
           if (this.isContextual(129)) {
            e.exportKind = 'type';
            let t = this.startNode();
            return this.next(), this.flowParseInterface(t);
           }
           if (this.isContextual(126)) {
            e.exportKind = 'value';
            let t = this.startNode();
            return this.next(), this.flowParseEnumDeclaration(t);
           }
           return super.parseExportDeclaration(e);
          }
          eatExportStar(e) {
           return !!super.eatExportStar(e) || (!(!this.isContextual(130) || 55 !== this.lookahead().type) && ((e.exportKind = 'type'), this.next(), this.next(), !0));
          }
          maybeParseExportNamespaceSpecifier(e) {
           let { startLoc: t } = this.state,
            r = super.maybeParseExportNamespaceSpecifier(e);
           return r && 'type' === e.exportKind && this.unexpected(t), r;
          }
          parseClassId(e, t, r) {
           super.parseClassId(e, t, r), this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration());
          }
          parseClassMember(e, t, r) {
           let { startLoc: n } = this.state;
           if (this.isContextual(125)) {
            if (super.parseClassMemberFromModifier(e, t)) return;
            t.declare = !0;
           }
           super.parseClassMember(e, t, r), t.declare && ('ClassProperty' !== t.type && 'ClassPrivateProperty' !== t.type && 'PropertyDefinition' !== t.type ? this.raise(ot.DeclareClassElement, n) : t.value && this.raise(ot.DeclareClassFieldInitializer, t.value));
          }
          isIterator(e) {
           return 'iterator' === e || 'asyncIterator' === e;
          }
          readIterator() {
           let e = super.readWord1(),
            t = '@@' + e;
           (!this.isIterator(e) || !this.state.inType) && this.raise(y.InvalidIdentifier, this.state.curPosition(), { identifierName: t }), this.finishToken(132, t);
          }
          getTokenFromCode(e) {
           let t = this.input.charCodeAt(this.state.pos + 1);
           123 === e && 124 === t
            ? this.finishOp(6, 2)
            : !this.state.inType || (62 !== e && 60 !== e)
              ? this.state.inType && 63 === e
                ? 46 === t
                  ? this.finishOp(18, 2)
                  : this.finishOp(17, 1)
                : (function (e, t, r) {
                     return 64 === e && 64 === t && se(r);
                    })(e, t, this.input.charCodeAt(this.state.pos + 2))
                  ? ((this.state.pos += 2), this.readIterator())
                  : super.getTokenFromCode(e)
              : this.finishOp(62 === e ? 48 : 47, 1);
          }
          isAssignable(e, t) {
           return 'TypeCastExpression' === e.type ? this.isAssignable(e.expression, t) : super.isAssignable(e, t);
          }
          toAssignable(e, t = !1) {
           !t && 'AssignmentExpression' === e.type && 'TypeCastExpression' === e.left.type && (e.left = this.typeCastToParameter(e.left)), super.toAssignable(e, t);
          }
          toAssignableList(e, t, r) {
           for (let n = 0; n < e.length; n++) {
            let t = e[n];
            'TypeCastExpression' === (null == t ? void 0 : t.type) && (e[n] = this.typeCastToParameter(t));
           }
           super.toAssignableList(e, t, r);
          }
          toReferencedList(e, t) {
           for (let n = 0; n < e.length; n++) {
            var r;
            let s = e[n];
            s && 'TypeCastExpression' === s.type && (null == (r = s.extra) || !r.parenthesized) && (e.length > 1 || !t) && this.raise(ot.TypeCastInPattern, s.typeAnnotation);
           }
           return e;
          }
          parseArrayLike(e, t, r, n) {
           let s = super.parseArrayLike(e, t, r, n);
           return t && !this.state.maybeInArrowParameters && this.toReferencedList(s.elements), s;
          }
          isValidLVal(e, t, r) {
           return 'TypeCastExpression' === e || super.isValidLVal(e, t, r);
          }
          parseClassProperty(e) {
           return this.match(14) && (e.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(e);
          }
          parseClassPrivateProperty(e) {
           return this.match(14) && (e.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(e);
          }
          isClassMethod() {
           return this.match(47) || super.isClassMethod();
          }
          isClassProperty() {
           return this.match(14) || super.isClassProperty();
          }
          isNonstaticConstructor(e) {
           return !this.match(14) && super.isNonstaticConstructor(e);
          }
          pushClassMethod(e, t, r, n, s, i) {
           if ((t.variance && this.unexpected(t.variance.loc.start), delete t.variance, this.match(47) && (t.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(e, t, r, n, s, i), t.params && s)) {
            let e = t.params;
            e.length > 0 && this.isThisParam(e[0]) && this.raise(ot.ThisParamBannedInConstructor, t);
           } else if ('MethodDefinition' === t.type && s && t.value.params) {
            let e = t.value.params;
            e.length > 0 && this.isThisParam(e[0]) && this.raise(ot.ThisParamBannedInConstructor, t);
           }
          }
          pushClassPrivateMethod(e, t, r, n) {
           t.variance && this.unexpected(t.variance.loc.start), delete t.variance, this.match(47) && (t.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(e, t, r, n);
          }
          parseClassSuper(e) {
           if ((super.parseClassSuper(e), e.superClass && (this.match(47) || this.match(51)) && (e.superTypeParameters = this.flowParseTypeParameterInstantiationInExpression()), this.isContextual(113))) {
            this.next();
            let t = (e.implements = []);
            do {
             let e = this.startNode();
             (e.id = this.flowParseRestrictedIdentifier(!0)), this.match(47) ? (e.typeParameters = this.flowParseTypeParameterInstantiation()) : (e.typeParameters = null), t.push(this.finishNode(e, 'ClassImplements'));
            } while (this.eat(12));
           }
          }
          checkGetterSetterParams(e) {
           super.checkGetterSetterParams(e);
           let t = this.getObjectOrClassMethodParams(e);
           if (t.length > 0) {
            let r = t[0];
            this.isThisParam(r) && 'get' === e.kind ? this.raise(ot.GetterMayNotHaveThisParam, r) : this.isThisParam(r) && this.raise(ot.SetterMayNotHaveThisParam, r);
           }
          }
          parsePropertyNamePrefixOperator(e) {
           e.variance = this.flowParseVariance();
          }
          parseObjPropValue(e, t, r, n, s, i, a) {
           let o;
           e.variance && this.unexpected(e.variance.loc.start), delete e.variance, this.match(47) && !i && ((o = this.flowParseTypeParameterDeclaration()), this.match(10) || this.unexpected());
           let u = super.parseObjPropValue(e, t, r, n, s, i, a);
           return o && ((u.value || u).typeParameters = o), u;
          }
          parseFunctionParamType(e) {
           return this.eat(17) && ('Identifier' !== e.type && this.raise(ot.PatternIsOptional, e), this.isThisParam(e) && this.raise(ot.ThisParamMayNotBeOptional, e), (e.optional = !0)), this.match(14) ? (e.typeAnnotation = this.flowParseTypeAnnotation()) : this.isThisParam(e) && this.raise(ot.ThisParamAnnotationRequired, e), this.match(29) && this.isThisParam(e) && this.raise(ot.ThisParamNoDefault, e), this.resetEndLocation(e), e;
          }
          parseMaybeDefault(e, t) {
           let r = super.parseMaybeDefault(e, t);
           return 'AssignmentPattern' === r.type && r.typeAnnotation && r.right.start < r.typeAnnotation.start && this.raise(ot.TypeBeforeInitializer, r.typeAnnotation), r;
          }
          checkImportReflection(e) {
           super.checkImportReflection(e), e.module && 'value' !== e.importKind && this.raise(ot.ImportReflectionHasImportType, e.specifiers[0].loc.start);
          }
          parseImportSpecifierLocal(e, t, r) {
           (t.local = ut(e) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier()), e.specifiers.push(this.finishImportSpecifier(t, r));
          }
          isPotentialImportPhase(e) {
           if (super.isPotentialImportPhase(e)) return !0;
           if (this.isContextual(130)) {
            if (!e) return !0;
            let t = this.lookaheadCharCode();
            return 123 === t || 42 === t;
           }
           return !e && this.isContextual(87);
          }
          applyImportPhase(e, t, r, n) {
           if ((super.applyImportPhase(e, t, r, n), t)) {
            if (!r && this.match(65)) return;
            e.exportKind = 'type' === r ? r : 'value';
           } else 'type' === r && this.match(55) && this.unexpected(), (e.importKind = 'type' === r || 'typeof' === r ? r : 'value');
          }
          parseImportSpecifier(e, t, r, n, s) {
           let i = e.imported,
            a = null;
           'Identifier' === i.type && ('type' === i.name ? (a = 'type') : 'typeof' === i.name && (a = 'typeof'));
           let o = !1;
           if (this.isContextual(93) && !this.isLookaheadContextual('as')) {
            let t = this.parseIdentifier(!0);
            null === a || $(this.state.type) ? ((e.imported = i), (e.importKind = null), (e.local = this.parseIdentifier())) : ((e.imported = t), (e.importKind = a), (e.local = nt(t)));
           } else {
            if (null !== a && $(this.state.type)) (e.imported = this.parseIdentifier(!0)), (e.importKind = a);
            else {
             if (t) throw this.raise(y.ImportBindingIsString, e, { importName: i.value });
             (e.imported = i), (e.importKind = null);
            }
            this.eatContextual(93) ? (e.local = this.parseIdentifier()) : ((o = !0), (e.local = nt(e.imported)));
           }
           let u = ut(e);
           return r && u && this.raise(ot.ImportTypeShorthandOnlyInPureImport, e), (r || u) && this.checkReservedType(e.local.name, e.local.loc.start, !0), o && !r && !u && this.checkReservedWord(e.local.name, e.loc.start, !0, !0), this.finishImportSpecifier(e, 'ImportSpecifier');
          }
          parseBindingAtom() {
           return 78 === this.state.type ? this.parseIdentifier(!0) : super.parseBindingAtom();
          }
          parseFunctionParams(e, t) {
           let r = e.kind;
           'get' !== r && 'set' !== r && this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(e, t);
          }
          parseVarId(e, t) {
           super.parseVarId(e, t), this.match(14) && ((e.id.typeAnnotation = this.flowParseTypeAnnotation()), this.resetEndLocation(e.id));
          }
          parseAsyncArrowFromCallExpression(e, t) {
           if (this.match(14)) {
            let t = this.state.noAnonFunctionType;
            (this.state.noAnonFunctionType = !0), (e.returnType = this.flowParseTypeAnnotation()), (this.state.noAnonFunctionType = t);
           }
           return super.parseAsyncArrowFromCallExpression(e, t);
          }
          shouldParseAsyncArrow() {
           return this.match(14) || super.shouldParseAsyncArrow();
          }
          parseMaybeAssign(e, t) {
           var r;
           let n,
            s = null;
           if (this.hasPlugin('jsx') && (this.match(143) || this.match(47))) {
            if (((s = this.state.clone()), (n = this.tryParse(() => super.parseMaybeAssign(e, t), s)), !n.error)) return n.node;
            let { context: r } = this.state,
             i = r[r.length - 1];
            (i === v.j_oTag || i === v.j_expr) && r.pop();
           }
           if ((null != (r = n) && r.error) || this.match(47)) {
            var i, a;
            s = s || this.state.clone();
            let r,
             o = this.tryParse((n) => {
              var s;
              r = this.flowParseTypeParameterDeclaration();
              let i = this.forwardNoArrowParamsConversionAt(r, () => {
               let n = super.parseMaybeAssign(e, t);
               return this.resetStartLocationFromNode(n, r), n;
              });
              null != (s = i.extra) && s.parenthesized && n();
              let a = this.maybeUnwrapTypeCastExpression(i);
              return 'ArrowFunctionExpression' !== a.type && n(), (a.typeParameters = r), this.resetStartLocationFromNode(a, r), i;
             }, s),
             u = null;
            if (o.node && 'ArrowFunctionExpression' === this.maybeUnwrapTypeCastExpression(o.node).type) {
             if (!o.error && !o.aborted) return o.node.async && this.raise(ot.UnexpectedTypeParameterBeforeAsyncArrowFunction, r), o.node;
             u = o.node;
            }
            if (null != (i = n) && i.node) return (this.state = n.failState), n.node;
            if (u) return (this.state = o.failState), u;
            throw null != (a = n) && a.thrown ? n.error : o.thrown ? o.error : this.raise(ot.UnexpectedTokenAfterTypeParameter, r);
           }
           return super.parseMaybeAssign(e, t);
          }
          parseArrow(e) {
           if (this.match(14)) {
            let t = this.tryParse(() => {
             let t = this.state.noAnonFunctionType;
             this.state.noAnonFunctionType = !0;
             let r = this.startNode();
             return ([r.typeAnnotation, e.predicate] = this.flowParseTypeAndPredicateInitialiser()), (this.state.noAnonFunctionType = t), this.canInsertSemicolon() && this.unexpected(), this.match(19) || this.unexpected(), r;
            });
            if (t.thrown) return null;
            t.error && (this.state = t.failState), (e.returnType = t.node.typeAnnotation ? this.finishNode(t.node, 'TypeAnnotation') : null);
           }
           return super.parseArrow(e);
          }
          shouldParseArrow(e) {
           return this.match(14) || super.shouldParseArrow(e);
          }
          setArrowFunctionParameters(e, t) {
           this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(e.start)) ? (e.params = t) : super.setArrowFunctionParameters(e, t);
          }
          checkParams(e, t, r, n = !0) {
           if (!r || !this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(e.start))) {
            for (let t = 0; t < e.params.length; t++) this.isThisParam(e.params[t]) && t > 0 && this.raise(ot.ThisParamMustBeFirst, e.params[t]);
            super.checkParams(e, t, r, n);
           }
          }
          parseParenAndDistinguishExpression(e) {
           return super.parseParenAndDistinguishExpression(e && !this.state.noArrowAt.includes(this.sourceToOffsetPos(this.state.start)));
          }
          parseSubscripts(e, t, r) {
           if ('Identifier' === e.type && 'async' === e.name && this.state.noArrowAt.includes(t.index)) {
            this.next();
            let r = this.startNodeAt(t);
            (r.callee = e), (r.arguments = super.parseCallExpressionArguments(11)), (e = this.finishNode(r, 'CallExpression'));
           } else if ('Identifier' === e.type && 'async' === e.name && this.match(47)) {
            let n = this.state.clone(),
             s = this.tryParse((e) => this.parseAsyncArrowWithTypeParameters(t) || e(), n);
            if (!s.error && !s.aborted) return s.node;
            let i = this.tryParse(() => super.parseSubscripts(e, t, r), n);
            if (i.node && !i.error) return i.node;
            if (s.node) return (this.state = s.failState), s.node;
            if (i.node) return (this.state = i.failState), i.node;
            throw s.error || i.error;
           }
           return super.parseSubscripts(e, t, r);
          }
          parseSubscript(e, t, r, n) {
           if (this.match(18) && this.isLookaheadToken_lt()) {
            if (((n.optionalChainMember = !0), r)) return (n.stop = !0), e;
            this.next();
            let s = this.startNodeAt(t);
            return (s.callee = e), (s.typeArguments = this.flowParseTypeParameterInstantiationInExpression()), this.expect(10), (s.arguments = this.parseCallExpressionArguments(11)), (s.optional = !0), this.finishCallExpression(s, !0);
           }
           if (!r && this.shouldParseTypes() && (this.match(47) || this.match(51))) {
            let r = this.startNodeAt(t);
            r.callee = e;
            let s = this.tryParse(() => ((r.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew()), this.expect(10), (r.arguments = super.parseCallExpressionArguments(11)), n.optionalChainMember && (r.optional = !1), this.finishCallExpression(r, n.optionalChainMember)));
            if (s.node) return s.error && (this.state = s.failState), s.node;
           }
           return super.parseSubscript(e, t, r, n);
          }
          parseNewCallee(e) {
           super.parseNewCallee(e);
           let t = null;
           this.shouldParseTypes() && this.match(47) && (t = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), (e.typeArguments = t);
          }
          parseAsyncArrowWithTypeParameters(e) {
           let t = this.startNodeAt(e);
           if ((this.parseFunctionParams(t, !1), this.parseArrow(t))) return super.parseArrowExpression(t, void 0, !0);
          }
          readToken_mult_modulo(e) {
           let t = this.input.charCodeAt(this.state.pos + 1);
           if (42 === e && 47 === t && this.state.hasFlowComment) return (this.state.hasFlowComment = !1), (this.state.pos += 2), void this.nextToken();
           super.readToken_mult_modulo(e);
          }
          readToken_pipe_amp(e) {
           let t = this.input.charCodeAt(this.state.pos + 1);
           124 !== e || 125 !== t ? super.readToken_pipe_amp(e) : this.finishOp(9, 2);
          }
          parseTopLevel(e, t) {
           let r = super.parseTopLevel(e, t);
           return this.state.hasFlowComment && this.raise(ot.UnterminatedFlowComment, this.state.curPosition()), r;
          }
          skipBlockComment() {
           if (!this.hasPlugin('flowComments') || !this.skipFlowComment()) return super.skipBlockComment(this.state.hasFlowComment ? '*-/' : '*/');
           {
            if (this.state.hasFlowComment) throw this.raise(ot.NestedFlowComment, this.state.startLoc);
            this.hasFlowCommentCompletion();
            let e = this.skipFlowComment();
            e && ((this.state.pos += e), (this.state.hasFlowComment = !0));
           }
          }
          skipFlowComment() {
           let { pos: e } = this.state,
            t = 2;
           for (; [32, 9].includes(this.input.charCodeAt(e + t)); ) t++;
           let r = this.input.charCodeAt(t + e),
            n = this.input.charCodeAt(t + e + 1);
           return 58 === r && 58 === n ? t + 2 : 'flow-include' === this.input.slice(t + e, t + e + 12) ? t + 12 : 58 === r && 58 !== n && t;
          }
          hasFlowCommentCompletion() {
           if (-1 === this.input.indexOf('*/', this.state.pos)) throw this.raise(y.UnterminatedComment, this.state.curPosition());
          }
          flowEnumErrorBooleanMemberNotInitialized(e, { enumName: t, memberName: r }) {
           this.raise(ot.EnumBooleanMemberNotInitialized, e, { memberName: r, enumName: t });
          }
          flowEnumErrorInvalidMemberInitializer(e, t) {
           return this.raise(t.explicitType ? ('symbol' === t.explicitType ? ot.EnumInvalidMemberInitializerSymbolType : ot.EnumInvalidMemberInitializerPrimaryType) : ot.EnumInvalidMemberInitializerUnknownType, e, t);
          }
          flowEnumErrorNumberMemberNotInitialized(e, t) {
           this.raise(ot.EnumNumberMemberNotInitialized, e, t);
          }
          flowEnumErrorStringMemberInconsistentlyInitialized(e, t) {
           this.raise(ot.EnumStringMemberInconsistentlyInitialized, e, t);
          }
          flowEnumMemberInit() {
           let e = this.state.startLoc,
            t = () => this.match(12) || this.match(8);
           switch (this.state.type) {
            case 135: {
             let r = this.parseNumericLiteral(this.state.value);
             return t() ? { type: 'number', loc: r.loc.start, value: r } : { type: 'invalid', loc: e };
            }
            case 134: {
             let r = this.parseStringLiteral(this.state.value);
             return t() ? { type: 'string', loc: r.loc.start, value: r } : { type: 'invalid', loc: e };
            }
            case 85:
            case 86: {
             let r = this.parseBooleanLiteral(this.match(85));
             return t() ? { type: 'boolean', loc: r.loc.start, value: r } : { type: 'invalid', loc: e };
            }
            default:
             return { type: 'invalid', loc: e };
           }
          }
          flowEnumMemberRaw() {
           let e = this.state.startLoc;
           return { id: this.parseIdentifier(!0), init: this.eat(29) ? this.flowEnumMemberInit() : { type: 'none', loc: e } };
          }
          flowEnumCheckExplicitTypeMismatch(e, t, r) {
           let { explicitType: n } = t;
           null !== n && n !== r && this.flowEnumErrorInvalidMemberInitializer(e, t);
          }
          flowEnumMembers({ enumName: e, explicitType: t }) {
           let r = new Set(),
            n = { booleanMembers: [], numberMembers: [], stringMembers: [], defaultedMembers: [] },
            s = !1;
           for (; !this.match(8); ) {
            if (this.eat(21)) {
             s = !0;
             break;
            }
            let i = this.startNode(),
             { id: a, init: o } = this.flowEnumMemberRaw(),
             u = a.name;
            if ('' === u) continue;
            /^[a-z]/.test(u) && this.raise(ot.EnumInvalidMemberName, a, { memberName: u, suggestion: u[0].toUpperCase() + u.slice(1), enumName: e }), r.has(u) && this.raise(ot.EnumDuplicateMemberName, a, { memberName: u, enumName: e }), r.add(u);
            let l = { enumName: e, explicitType: t, memberName: u };
            switch (((i.id = a), o.type)) {
             case 'boolean':
              this.flowEnumCheckExplicitTypeMismatch(o.loc, l, 'boolean'), (i.init = o.value), n.booleanMembers.push(this.finishNode(i, 'EnumBooleanMember'));
              break;
             case 'number':
              this.flowEnumCheckExplicitTypeMismatch(o.loc, l, 'number'), (i.init = o.value), n.numberMembers.push(this.finishNode(i, 'EnumNumberMember'));
              break;
             case 'string':
              this.flowEnumCheckExplicitTypeMismatch(o.loc, l, 'string'), (i.init = o.value), n.stringMembers.push(this.finishNode(i, 'EnumStringMember'));
              break;
             case 'invalid':
              throw this.flowEnumErrorInvalidMemberInitializer(o.loc, l);
             case 'none':
              switch (t) {
               case 'boolean':
                this.flowEnumErrorBooleanMemberNotInitialized(o.loc, l);
                break;
               case 'number':
                this.flowEnumErrorNumberMemberNotInitialized(o.loc, l);
                break;
               default:
                n.defaultedMembers.push(this.finishNode(i, 'EnumDefaultedMember'));
              }
            }
            this.match(8) || this.expect(12);
           }
           return { members: n, hasUnknownMembers: s };
          }
          flowEnumStringMembers(e, t, { enumName: r }) {
           if (0 === e.length) return t;
           if (0 === t.length) return e;
           if (t.length > e.length) {
            for (let t of e) this.flowEnumErrorStringMemberInconsistentlyInitialized(t, { enumName: r });
            return t;
           }
           for (let n of t) this.flowEnumErrorStringMemberInconsistentlyInitialized(n, { enumName: r });
           return e;
          }
          flowEnumParseExplicitType({ enumName: e }) {
           if (!this.eatContextual(102)) return null;
           if (!U(this.state.type)) throw this.raise(ot.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, { enumName: e });
           let { value: t } = this.state;
           return this.next(), 'boolean' !== t && 'number' !== t && 'string' !== t && 'symbol' !== t && this.raise(ot.EnumInvalidExplicitType, this.state.startLoc, { enumName: e, invalidEnumType: t }), t;
          }
          flowEnumBody(e, t) {
           let r = t.name,
            n = t.loc.start,
            s = this.flowEnumParseExplicitType({ enumName: r });
           this.expect(5);
           let { members: i, hasUnknownMembers: a } = this.flowEnumMembers({ enumName: r, explicitType: s });
           switch (((e.hasUnknownMembers = a), s)) {
            case 'boolean':
             return (e.explicitType = !0), (e.members = i.booleanMembers), this.expect(8), this.finishNode(e, 'EnumBooleanBody');
            case 'number':
             return (e.explicitType = !0), (e.members = i.numberMembers), this.expect(8), this.finishNode(e, 'EnumNumberBody');
            case 'string':
             return (e.explicitType = !0), (e.members = this.flowEnumStringMembers(i.stringMembers, i.defaultedMembers, { enumName: r })), this.expect(8), this.finishNode(e, 'EnumStringBody');
            case 'symbol':
             return (e.members = i.defaultedMembers), this.expect(8), this.finishNode(e, 'EnumSymbolBody');
            default: {
             let t = () => ((e.members = []), this.expect(8), this.finishNode(e, 'EnumStringBody'));
             e.explicitType = !1;
             let s = i.booleanMembers.length,
              a = i.numberMembers.length,
              o = i.stringMembers.length,
              u = i.defaultedMembers.length;
             if (!(s || a || o || u)) return t();
             if (!s && !a) return (e.members = this.flowEnumStringMembers(i.stringMembers, i.defaultedMembers, { enumName: r })), this.expect(8), this.finishNode(e, 'EnumStringBody');
             if (!a && !o && s >= u) {
              for (let e of i.defaultedMembers) this.flowEnumErrorBooleanMemberNotInitialized(e.loc.start, { enumName: r, memberName: e.id.name });
              return (e.members = i.booleanMembers), this.expect(8), this.finishNode(e, 'EnumBooleanBody');
             }
             if (!s && !o && a >= u) {
              for (let e of i.defaultedMembers) this.flowEnumErrorNumberMemberNotInitialized(e.loc.start, { enumName: r, memberName: e.id.name });
              return (e.members = i.numberMembers), this.expect(8), this.finishNode(e, 'EnumNumberBody');
             }
             return this.raise(ot.EnumInconsistentMemberValues, n, { enumName: r }), t();
            }
           }
          }
          flowParseEnumDeclaration(e) {
           let t = this.parseIdentifier();
           return (e.id = t), (e.body = this.flowEnumBody(this.startNode(), t)), this.finishNode(e, 'EnumDeclaration');
          }
          jsxParseOpeningElementAfterName(e) {
           return this.shouldParseTypes() && (this.match(47) || this.match(51)) && (e.typeArguments = this.flowParseTypeParameterInstantiationInExpression()), super.jsxParseOpeningElementAfterName(e);
          }
          isLookaheadToken_lt() {
           let e = this.nextTokenStart();
           if (60 === this.input.charCodeAt(e)) {
            let t = this.input.charCodeAt(e + 1);
            return 60 !== t && 61 !== t;
           }
           return !1;
          }
          reScan_lt_gt() {
           let { type: e } = this.state;
           47 === e ? ((this.state.pos -= 1), this.readToken_lt()) : 48 === e && ((this.state.pos -= 1), this.readToken_gt());
          }
          reScan_lt() {
           let { type: e } = this.state;
           return 51 === e ? ((this.state.pos -= 2), this.finishOp(47, 1), 47) : e;
          }
          maybeUnwrapTypeCastExpression(e) {
           return 'TypeCastExpression' === e.type ? e.expression : e;
          }
         },
        typescript: (e) =>
         class extends e {
          constructor(...e) {
           super(...e), (this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ['in', 'out'], disallowedModifiers: ['const', 'public', 'private', 'protected', 'readonly', 'declare', 'abstract', 'override'], errorTemplate: xt.InvalidModifierOnTypeParameter })), (this.tsParseConstModifier = this.tsParseModifiers.bind(this, { allowedModifiers: ['const'], disallowedModifiers: ['in', 'out'], errorTemplate: xt.InvalidModifierOnTypeParameterPositions })), (this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ['in', 'out', 'const'], disallowedModifiers: ['public', 'private', 'protected', 'readonly', 'declare', 'abstract', 'override'], errorTemplate: xt.InvalidModifierOnTypeParameter }));
          }
          getScopeHandler() {
           return mt;
          }
          tsIsIdentifier() {
           return U(this.state.type);
          }
          tsTokenCanFollowModifier() {
           return this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(139) || this.isLiteralPropertyName();
          }
          tsNextTokenOnSameLineAndCanFollowModifier() {
           return this.next(), !this.hasPrecedingLineBreak() && this.tsTokenCanFollowModifier();
          }
          tsNextTokenCanFollowModifier() {
           return this.match(106) ? (this.next(), this.tsTokenCanFollowModifier()) : this.tsNextTokenOnSameLineAndCanFollowModifier();
          }
          tsParseModifier(e, t) {
           if (!U(this.state.type) && 58 !== this.state.type && 75 !== this.state.type) return;
           let r = this.state.value;
           if (e.includes(r)) {
            if (t && this.tsIsStartOfStaticBlocks()) return;
            if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) return r;
           }
          }
          tsParseModifiers({ allowedModifiers: e, disallowedModifiers: t, stopOnStartOfClassStaticBlock: r, errorTemplate: n = xt.InvalidModifierOnTypeMember }, s) {
           let i = (e, t, r, n) => {
             t === r && s[n] && this.raise(xt.InvalidModifiersOrder, e, { orderedModifiers: [r, n] });
            },
            a = (e, t, r, n) => {
             ((s[r] && t === n) || (s[n] && t === r)) && this.raise(xt.IncompatibleModifiers, e, { modifiers: [r, n] });
            };
           for (;;) {
            let { startLoc: o } = this.state,
             u = this.tsParseModifier(e.concat(t ?? []), r);
            if (!u) break;
            bt(u) ? (s.accessibility ? this.raise(xt.DuplicateAccessibilityModifier, o, { modifier: u }) : (i(o, u, u, 'override'), i(o, u, u, 'static'), i(o, u, u, 'readonly'), (s.accessibility = u))) : vt(u) ? (s[u] && this.raise(xt.DuplicateModifier, o, { modifier: u }), (s[u] = !0), i(o, u, 'in', 'out')) : (hasOwnProperty.call(s, u) ? this.raise(xt.DuplicateModifier, o, { modifier: u }) : (i(o, u, 'static', 'readonly'), i(o, u, 'static', 'override'), i(o, u, 'override', 'readonly'), i(o, u, 'abstract', 'override'), a(o, u, 'declare', 'override'), a(o, u, 'static', 'abstract')), (s[u] = !0)), null != t && t.includes(u) && this.raise(n, o, { modifier: u });
           }
          }
          tsIsListTerminator(e) {
           switch (e) {
            case 'EnumMembers':
            case 'TypeMembers':
             return this.match(8);
            case 'HeritageClauseElement':
             return this.match(5);
            case 'TupleElementTypes':
             return this.match(3);
            case 'TypeParametersOrArguments':
             return this.match(48);
           }
          }
          tsParseList(e, t) {
           let r = [];
           for (; !this.tsIsListTerminator(e); ) r.push(t());
           return r;
          }
          tsParseDelimitedList(e, t, r) {
           return (function (e) {
            if (null == e) throw new Error(`Unexpected ${e} value.`);
            return e;
           })(this.tsParseDelimitedListWorker(e, t, !0, r));
          }
          tsParseDelimitedListWorker(e, t, r, n) {
           let s = [],
            i = -1;
           for (; !this.tsIsListTerminator(e); ) {
            i = -1;
            let n = t();
            if (null == n) return;
            if ((s.push(n), !this.eat(12))) {
             if (this.tsIsListTerminator(e)) break;
             return void (r && this.expect(12));
            }
            i = this.state.lastTokStartLoc.index;
           }
           return n && (n.value = i), s;
          }
          tsParseBracketedList(e, t, r, n, s) {
           n || (r ? this.expect(0) : this.expect(47));
           let i = this.tsParseDelimitedList(e, t, s);
           return r ? this.expect(3) : this.expect(48), i;
          }
          tsParseImportType() {
           let e = this.startNode();
           return this.expect(83), this.expect(10), this.match(134) ? (e.argument = this.parseStringLiteral(this.state.value)) : (this.raise(xt.UnsupportedImportTypeArgument, this.state.startLoc), (e.argument = super.parseExprAtom())), this.eat(12) && !this.match(11) ? ((e.options = super.parseMaybeAssignAllowIn()), this.eat(12)) : (e.options = null), this.expect(11), this.eat(16) && (e.qualifier = this.tsParseEntityName(3)), this.match(47) && (e.typeParameters = this.tsParseTypeArguments()), this.finishNode(e, 'TSImportType');
          }
          tsParseEntityName(e) {
           let t;
           if (1 & e && this.match(78))
            if (2 & e) t = this.parseIdentifier(!0);
            else {
             let e = this.startNode();
             this.next(), (t = this.finishNode(e, 'ThisExpression'));
            }
           else t = this.parseIdentifier(!!(1 & e));
           for (; this.eat(16); ) {
            let r = this.startNodeAtNode(t);
            (r.left = t), (r.right = this.parseIdentifier(!!(1 & e))), (t = this.finishNode(r, 'TSQualifiedName'));
           }
           return t;
          }
          tsParseTypeReference() {
           let e = this.startNode();
           return (e.typeName = this.tsParseEntityName(1)), !this.hasPrecedingLineBreak() && this.match(47) && (e.typeParameters = this.tsParseTypeArguments()), this.finishNode(e, 'TSTypeReference');
          }
          tsParseThisTypePredicate(e) {
           this.next();
           let t = this.startNodeAtNode(e);
           return (t.parameterName = e), (t.typeAnnotation = this.tsParseTypeAnnotation(!1)), (t.asserts = !1), this.finishNode(t, 'TSTypePredicate');
          }
          tsParseThisTypeNode() {
           let e = this.startNode();
           return this.next(), this.finishNode(e, 'TSThisType');
          }
          tsParseTypeQuery() {
           let e = this.startNode();
           return this.expect(87), this.match(83) ? (e.exprName = this.tsParseImportType()) : (e.exprName = this.tsParseEntityName(3)), !this.hasPrecedingLineBreak() && this.match(47) && (e.typeParameters = this.tsParseTypeArguments()), this.finishNode(e, 'TSTypeQuery');
          }
          tsParseTypeParameter(e) {
           let t = this.startNode();
           return e(t), (t.name = this.tsParseTypeParameterName()), (t.constraint = this.tsEatThenParseType(81)), (t.default = this.tsEatThenParseType(29)), this.finishNode(t, 'TSTypeParameter');
          }
          tsTryParseTypeParameters(e) {
           if (this.match(47)) return this.tsParseTypeParameters(e);
          }
          tsParseTypeParameters(e) {
           let t = this.startNode();
           this.match(47) || this.match(143) ? this.next() : this.unexpected();
           let r = { value: -1 };
           return (t.params = this.tsParseBracketedList('TypeParametersOrArguments', this.tsParseTypeParameter.bind(this, e), !1, !0, r)), 0 === t.params.length && this.raise(xt.EmptyTypeParameters, t), -1 !== r.value && this.addExtra(t, 'trailingComma', r.value), this.finishNode(t, 'TSTypeParameterDeclaration');
          }
          tsFillSignature(e, t) {
           let r = 19 === e,
            n = 'typeAnnotation';
           (t.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier)), this.expect(10), (t.parameters = this.tsParseBindingListForSignature()), (r || this.match(e)) && (t[n] = this.tsParseTypeOrTypePredicateAnnotation(e));
          }
          tsParseBindingListForSignature() {
           let e = super.parseBindingList(11, 41, 2);
           for (let t of e) {
            let { type: e } = t;
            ('AssignmentPattern' === e || 'TSParameterProperty' === e) && this.raise(xt.UnsupportedSignatureParameterKind, t, { type: e });
           }
           return e;
          }
          tsParseTypeMemberSemicolon() {
           !this.eat(12) && !this.isLineTerminator() && this.expect(13);
          }
          tsParseSignatureMember(e, t) {
           return this.tsFillSignature(14, t), this.tsParseTypeMemberSemicolon(), this.finishNode(t, e);
          }
          tsIsUnambiguouslyIndexSignature() {
           return this.next(), !!U(this.state.type) && (this.next(), this.match(14));
          }
          tsTryParseIndexSignature(e) {
           if (!this.match(0) || !this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))) return;
           this.expect(0);
           let t = this.parseIdentifier();
           (t.typeAnnotation = this.tsParseTypeAnnotation()), this.resetEndLocation(t), this.expect(3), (e.parameters = [t]);
           let r = this.tsTryParseTypeAnnotation();
           return r && (e.typeAnnotation = r), this.tsParseTypeMemberSemicolon(), this.finishNode(e, 'TSIndexSignature');
          }
          tsParsePropertyOrMethodSignature(e, t) {
           this.eat(17) && (e.optional = !0);
           let r = e;
           if (this.match(10) || this.match(47)) {
            t && this.raise(xt.ReadonlyForMethodSignature, e);
            let n = r;
            n.kind && this.match(47) && this.raise(xt.AccessorCannotHaveTypeParameters, this.state.curPosition()), this.tsFillSignature(14, n), this.tsParseTypeMemberSemicolon();
            let s = 'parameters',
             i = 'typeAnnotation';
            if ('get' === n.kind) n[s].length > 0 && (this.raise(y.BadGetterArity, this.state.curPosition()), this.isThisParam(n[s][0]) && this.raise(xt.AccessorCannotDeclareThisParameter, this.state.curPosition()));
            else if ('set' === n.kind) {
             if (1 !== n[s].length) this.raise(y.BadSetterArity, this.state.curPosition());
             else {
              let e = n[s][0];
              this.isThisParam(e) && this.raise(xt.AccessorCannotDeclareThisParameter, this.state.curPosition()), 'Identifier' === e.type && e.optional && this.raise(xt.SetAccessorCannotHaveOptionalParameter, this.state.curPosition()), 'RestElement' === e.type && this.raise(xt.SetAccessorCannotHaveRestParameter, this.state.curPosition());
             }
             n[i] && this.raise(xt.SetAccessorCannotHaveReturnType, n[i]);
            } else n.kind = 'method';
            return this.finishNode(n, 'TSMethodSignature');
           }
           {
            let e = r;
            t && (e.readonly = !0);
            let n = this.tsTryParseTypeAnnotation();
            return n && (e.typeAnnotation = n), this.tsParseTypeMemberSemicolon(), this.finishNode(e, 'TSPropertySignature');
           }
          }
          tsParseTypeMember() {
           let e = this.startNode();
           if (this.match(10) || this.match(47)) return this.tsParseSignatureMember('TSCallSignatureDeclaration', e);
           if (this.match(77)) {
            let t = this.startNode();
            return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember('TSConstructSignatureDeclaration', e) : ((e.key = this.createIdentifier(t, 'new')), this.tsParsePropertyOrMethodSignature(e, !1));
           }
           return this.tsParseModifiers({ allowedModifiers: ['readonly'], disallowedModifiers: ['declare', 'abstract', 'private', 'protected', 'public', 'static', 'override'] }, e), this.tsTryParseIndexSignature(e) || (super.parsePropertyName(e), !e.computed && 'Identifier' === e.key.type && ('get' === e.key.name || 'set' === e.key.name) && this.tsTokenCanFollowModifier() && ((e.kind = e.key.name), super.parsePropertyName(e)), this.tsParsePropertyOrMethodSignature(e, !!e.readonly));
          }
          tsParseTypeLiteral() {
           let e = this.startNode();
           return (e.members = this.tsParseObjectTypeMembers()), this.finishNode(e, 'TSTypeLiteral');
          }
          tsParseObjectTypeMembers() {
           this.expect(5);
           let e = this.tsParseList('TypeMembers', this.tsParseTypeMember.bind(this));
           return this.expect(8), e;
          }
          tsIsStartOfMappedType() {
           return this.next(), this.eat(53) ? this.isContextual(122) : (this.isContextual(122) && this.next(), !(!this.match(0) || (this.next(), !this.tsIsIdentifier())) && (this.next(), this.match(58)));
          }
          tsParseMappedType() {
           let e = this.startNode();
           this.expect(5), this.match(53) ? ((e.readonly = this.state.value), this.next(), this.expectContextual(122)) : this.eatContextual(122) && (e.readonly = !0), this.expect(0);
           {
            let t = this.startNode();
            (t.name = this.tsParseTypeParameterName()), (t.constraint = this.tsExpectThenParseType(58)), (e.typeParameter = this.finishNode(t, 'TSTypeParameter'));
           }
           return (e.nameType = this.eatContextual(93) ? this.tsParseType() : null), this.expect(3), this.match(53) ? ((e.optional = this.state.value), this.next(), this.expect(17)) : this.eat(17) && (e.optional = !0), (e.typeAnnotation = this.tsTryParseType()), this.semicolon(), this.expect(8), this.finishNode(e, 'TSMappedType');
          }
          tsParseTupleType() {
           let e = this.startNode();
           e.elementTypes = this.tsParseBracketedList('TupleElementTypes', this.tsParseTupleElementType.bind(this), !0, !1);
           let t = !1;
           return (
            e.elementTypes.forEach((e) => {
             let { type: r } = e;
             t && 'TSRestType' !== r && 'TSOptionalType' !== r && !('TSNamedTupleMember' === r && e.optional) && this.raise(xt.OptionalTypeBeforeRequired, e), t || (t = ('TSNamedTupleMember' === r && e.optional) || 'TSOptionalType' === r);
            }),
            this.finishNode(e, 'TSTupleType')
           );
          }
          tsParseTupleElementType() {
           let e,
            t,
            r,
            n,
            s = this.state.startLoc,
            i = this.eat(21),
            { startLoc: a } = this.state,
            o = $(this.state.type) ? this.lookaheadCharCode() : null;
           if (58 === o) (e = !0), (r = !1), (t = this.parseIdentifier(!0)), this.expect(14), (n = this.tsParseType());
           else if (63 === o) {
            r = !0;
            let s = this.state.value,
             i = this.tsParseNonArrayType();
            58 === this.lookaheadCharCode() ? ((e = !0), (t = this.createIdentifier(this.startNodeAt(a), s)), this.expect(17), this.expect(14), (n = this.tsParseType())) : ((e = !1), (n = i), this.expect(17));
           } else (n = this.tsParseType()), (r = this.eat(17)), (e = this.eat(14));
           if (e) {
            let e;
            t ? ((e = this.startNodeAt(a)), (e.optional = r), (e.label = t), (e.elementType = n), this.eat(17) && ((e.optional = !0), this.raise(xt.TupleOptionalAfterType, this.state.lastTokStartLoc))) : ((e = this.startNodeAt(a)), (e.optional = r), this.raise(xt.InvalidTupleMemberLabel, n), (e.label = n), (e.elementType = this.tsParseType())), (n = this.finishNode(e, 'TSNamedTupleMember'));
           } else if (r) {
            let e = this.startNodeAt(a);
            (e.typeAnnotation = n), (n = this.finishNode(e, 'TSOptionalType'));
           }
           if (i) {
            let e = this.startNodeAt(s);
            (e.typeAnnotation = n), (n = this.finishNode(e, 'TSRestType'));
           }
           return n;
          }
          tsParseParenthesizedType() {
           let e = this.startNode();
           return this.expect(10), (e.typeAnnotation = this.tsParseType()), this.expect(11), this.finishNode(e, 'TSParenthesizedType');
          }
          tsParseFunctionOrConstructorType(e, t) {
           let r = this.startNode();
           return 'TSConstructorType' === e && ((r.abstract = !!t), t && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, r)), this.finishNode(r, e);
          }
          tsParseLiteralTypeNode() {
           let e = this.startNode();
           switch (this.state.type) {
            case 135:
            case 136:
            case 134:
            case 85:
            case 86:
             e.literal = super.parseExprAtom();
             break;
            default:
             this.unexpected();
           }
           return this.finishNode(e, 'TSLiteralType');
          }
          tsParseTemplateLiteralType() {
           {
            let e = this.startNode();
            return (e.literal = super.parseTemplate(!1)), this.finishNode(e, 'TSLiteralType');
           }
          }
          parseTemplateSubstitution() {
           return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
          }
          tsParseThisTypeOrThisTypePredicate() {
           let e = this.tsParseThisTypeNode();
           return this.isContextual(116) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(e) : e;
          }
          tsParseNonArrayType() {
           switch (this.state.type) {
            case 134:
            case 135:
            case 136:
            case 85:
            case 86:
             return this.tsParseLiteralTypeNode();
            case 53:
             if ('-' === this.state.value) {
              let e = this.startNode(),
               t = this.lookahead();
              return 135 !== t.type && 136 !== t.type && this.unexpected(), (e.literal = this.parseMaybeUnary()), this.finishNode(e, 'TSLiteralType');
             }
             break;
            case 78:
             return this.tsParseThisTypeOrThisTypePredicate();
            case 87:
             return this.tsParseTypeQuery();
            case 83:
             return this.tsParseImportType();
            case 5:
             return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
            case 0:
             return this.tsParseTupleType();
            case 10:
             return this.tsParseParenthesizedType();
            case 25:
            case 24:
             return this.tsParseTemplateLiteralType();
            default: {
             let { type: e } = this.state;
             if (U(e) || 88 === e || 84 === e) {
              let t =
               88 === e
                ? 'TSVoidKeyword'
                : 84 === e
                  ? 'TSNullKeyword'
                  : (function (e) {
                     switch (e) {
                      case 'any':
                       return 'TSAnyKeyword';
                      case 'boolean':
                       return 'TSBooleanKeyword';
                      case 'bigint':
                       return 'TSBigIntKeyword';
                      case 'never':
                       return 'TSNeverKeyword';
                      case 'number':
                       return 'TSNumberKeyword';
                      case 'object':
                       return 'TSObjectKeyword';
                      case 'string':
                       return 'TSStringKeyword';
                      case 'symbol':
                       return 'TSSymbolKeyword';
                      case 'undefined':
                       return 'TSUndefinedKeyword';
                      case 'unknown':
                       return 'TSUnknownKeyword';
                      default:
                       return;
                     }
                    })(this.state.value);
              if (void 0 !== t && 46 !== this.lookaheadCharCode()) {
               let e = this.startNode();
               return this.next(), this.finishNode(e, t);
              }
              return this.tsParseTypeReference();
             }
            }
           }
           this.unexpected();
          }
          tsParseArrayTypeOrHigher() {
           let { startLoc: e } = this.state,
            t = this.tsParseNonArrayType();
           for (; !this.hasPrecedingLineBreak() && this.eat(0); )
            if (this.match(3)) {
             let r = this.startNodeAt(e);
             (r.elementType = t), this.expect(3), (t = this.finishNode(r, 'TSArrayType'));
            } else {
             let r = this.startNodeAt(e);
             (r.objectType = t), (r.indexType = this.tsParseType()), this.expect(3), (t = this.finishNode(r, 'TSIndexedAccessType'));
            }
           return t;
          }
          tsParseTypeOperator() {
           let e = this.startNode(),
            t = this.state.value;
           return this.next(), (e.operator = t), (e.typeAnnotation = this.tsParseTypeOperatorOrHigher()), 'readonly' === t && this.tsCheckTypeAnnotationForReadOnly(e), this.finishNode(e, 'TSTypeOperator');
          }
          tsCheckTypeAnnotationForReadOnly(e) {
           switch (e.typeAnnotation.type) {
            case 'TSTupleType':
            case 'TSArrayType':
             return;
            default:
             this.raise(xt.UnexpectedReadonly, e);
           }
          }
          tsParseInferType() {
           let e = this.startNode();
           this.expectContextual(115);
           let t = this.startNode();
           return (t.name = this.tsParseTypeParameterName()), (t.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType())), (e.typeParameter = this.finishNode(t, 'TSTypeParameter')), this.finishNode(e, 'TSInferType');
          }
          tsParseConstraintForInferType() {
           if (this.eat(81)) {
            let e = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
            if (this.state.inDisallowConditionalTypesContext || !this.match(17)) return e;
           }
          }
          tsParseTypeOperatorOrHigher() {
           return (function (e) {
            return e >= 121 && e <= 123;
           })(this.state.type) && !this.state.containsEsc
            ? this.tsParseTypeOperator()
            : this.isContextual(115)
              ? this.tsParseInferType()
              : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
          }
          tsParseUnionOrIntersectionType(e, t, r) {
           let n = this.startNode(),
            s = this.eat(r),
            i = [];
           do {
            i.push(t());
           } while (this.eat(r));
           return 1 !== i.length || s ? ((n.types = i), this.finishNode(n, e)) : i[0];
          }
          tsParseIntersectionTypeOrHigher() {
           return this.tsParseUnionOrIntersectionType('TSIntersectionType', this.tsParseTypeOperatorOrHigher.bind(this), 45);
          }
          tsParseUnionTypeOrHigher() {
           return this.tsParseUnionOrIntersectionType('TSUnionType', this.tsParseIntersectionTypeOrHigher.bind(this), 43);
          }
          tsIsStartOfFunctionType() {
           return !!this.match(47) || (this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this)));
          }
          tsSkipParameterStart() {
           if (U(this.state.type) || this.match(78)) return this.next(), !0;
           if (this.match(5)) {
            let { errors: e } = this.state,
             t = e.length;
            try {
             return this.parseObjectLike(8, !0), e.length === t;
            } catch {
             return !1;
            }
           }
           if (this.match(0)) {
            this.next();
            let { errors: e } = this.state,
             t = e.length;
            try {
             return super.parseBindingList(3, 93, 1), e.length === t;
            } catch {
             return !1;
            }
           }
           return !1;
          }
          tsIsUnambiguouslyStartOfFunctionType() {
           return this.next(), !!(this.match(11) || this.match(21) || (this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(17) || this.match(29) || (this.match(11) && (this.next(), this.match(19))))));
          }
          tsParseTypeOrTypePredicateAnnotation(e) {
           return this.tsInType(() => {
            let t = this.startNode();
            this.expect(e);
            let r = this.startNode(),
             n = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
            if (n && this.match(78)) {
             let e = this.tsParseThisTypeOrThisTypePredicate();
             return 'TSThisType' === e.type ? ((r.parameterName = e), (r.asserts = !0), (r.typeAnnotation = null), (e = this.finishNode(r, 'TSTypePredicate'))) : (this.resetStartLocationFromNode(e, r), (e.asserts = !0)), (t.typeAnnotation = e), this.finishNode(t, 'TSTypeAnnotation');
            }
            let s = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
            if (!s) return n ? ((r.parameterName = this.parseIdentifier()), (r.asserts = n), (r.typeAnnotation = null), (t.typeAnnotation = this.finishNode(r, 'TSTypePredicate')), this.finishNode(t, 'TSTypeAnnotation')) : this.tsParseTypeAnnotation(!1, t);
            let i = this.tsParseTypeAnnotation(!1);
            return (r.parameterName = s), (r.typeAnnotation = i), (r.asserts = n), (t.typeAnnotation = this.finishNode(r, 'TSTypePredicate')), this.finishNode(t, 'TSTypeAnnotation');
           });
          }
          tsTryParseTypeOrTypePredicateAnnotation() {
           if (this.match(14)) return this.tsParseTypeOrTypePredicateAnnotation(14);
          }
          tsTryParseTypeAnnotation() {
           if (this.match(14)) return this.tsParseTypeAnnotation();
          }
          tsTryParseType() {
           return this.tsEatThenParseType(14);
          }
          tsParseTypePredicatePrefix() {
           let e = this.parseIdentifier();
           if (this.isContextual(116) && !this.hasPrecedingLineBreak()) return this.next(), e;
          }
          tsParseTypePredicateAsserts() {
           if (109 !== this.state.type) return !1;
           let e = this.state.containsEsc;
           return this.next(), !((!U(this.state.type) && !this.match(78)) || (e && this.raise(y.InvalidEscapedReservedWord, this.state.lastTokStartLoc, { reservedWord: 'asserts' }), 0));
          }
          tsParseTypeAnnotation(e = !0, t = this.startNode()) {
           return (
            this.tsInType(() => {
             e && this.expect(14), (t.typeAnnotation = this.tsParseType());
            }),
            this.finishNode(t, 'TSTypeAnnotation')
           );
          }
          tsParseType() {
           Dt(this.state.inType);
           let e = this.tsParseNonConditionalType();
           if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) return e;
           let t = this.startNodeAtNode(e);
           return (t.checkType = e), (t.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType())), this.expect(17), (t.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType())), this.expect(14), (t.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType())), this.finishNode(t, 'TSConditionalType');
          }
          isAbstractConstructorSignature() {
           return this.isContextual(124) && 77 === this.lookahead().type;
          }
          tsParseNonConditionalType() {
           return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType('TSFunctionType') : this.match(77) ? this.tsParseFunctionOrConstructorType('TSConstructorType') : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType('TSConstructorType', !0) : this.tsParseUnionTypeOrHigher();
          }
          tsParseTypeAssertion() {
           this.getPluginOption('typescript', 'disallowAmbiguousJSXLike') && this.raise(xt.ReservedTypeAssertion, this.state.startLoc);
           let e = this.startNode();
           return (e.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType()))), this.expect(48), (e.expression = this.parseMaybeUnary()), this.finishNode(e, 'TSTypeAssertion');
          }
          tsParseHeritageClause(e) {
           let t = this.state.startLoc,
            r = this.tsParseDelimitedList('HeritageClauseElement', () => {
             let e = this.startNode();
             return (e.expression = this.tsParseEntityName(3)), this.match(47) && (e.typeParameters = this.tsParseTypeArguments()), this.finishNode(e, 'TSExpressionWithTypeArguments');
            });
           return r.length || this.raise(xt.EmptyHeritageClauseType, t, { token: e }), r;
          }
          tsParseInterfaceDeclaration(e, t = {}) {
           if (this.hasFollowingLineBreak()) return null;
           this.expectContextual(129), t.declare && (e.declare = !0), U(this.state.type) ? ((e.id = this.parseIdentifier()), this.checkIdentifier(e.id, 130)) : ((e.id = null), this.raise(xt.MissingInterfaceName, this.state.startLoc)), (e.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers)), this.eat(81) && (e.extends = this.tsParseHeritageClause('extends'));
           let r = this.startNode();
           return (r.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this))), (e.body = this.finishNode(r, 'TSInterfaceBody')), this.finishNode(e, 'TSInterfaceDeclaration');
          }
          tsParseTypeAliasDeclaration(e) {
           return (
            (e.id = this.parseIdentifier()),
            this.checkIdentifier(e.id, 2),
            (e.typeAnnotation = this.tsInType(() => {
             if (((e.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers)), this.expect(29), this.isContextual(114) && 16 !== this.lookahead().type)) {
              let e = this.startNode();
              return this.next(), this.finishNode(e, 'TSIntrinsicKeyword');
             }
             return this.tsParseType();
            })),
            this.semicolon(),
            this.finishNode(e, 'TSTypeAliasDeclaration')
           );
          }
          tsInTopLevelContext(e) {
           if (this.curContext() === v.brace) return e();
           {
            let t = this.state.context;
            this.state.context = [t[0]];
            try {
             return e();
            } finally {
             this.state.context = t;
            }
           }
          }
          tsInType(e) {
           let t = this.state.inType;
           this.state.inType = !0;
           try {
            return e();
           } finally {
            this.state.inType = t;
           }
          }
          tsInDisallowConditionalTypesContext(e) {
           let t = this.state.inDisallowConditionalTypesContext;
           this.state.inDisallowConditionalTypesContext = !0;
           try {
            return e();
           } finally {
            this.state.inDisallowConditionalTypesContext = t;
           }
          }
          tsInAllowConditionalTypesContext(e) {
           let t = this.state.inDisallowConditionalTypesContext;
           this.state.inDisallowConditionalTypesContext = !1;
           try {
            return e();
           } finally {
            this.state.inDisallowConditionalTypesContext = t;
           }
          }
          tsEatThenParseType(e) {
           if (this.match(e)) return this.tsNextThenParseType();
          }
          tsExpectThenParseType(e) {
           return this.tsInType(() => (this.expect(e), this.tsParseType()));
          }
          tsNextThenParseType() {
           return this.tsInType(() => (this.next(), this.tsParseType()));
          }
          tsParseEnumMember() {
           let e = this.startNode();
           return (e.id = this.match(134) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(!0)), this.eat(29) && (e.initializer = super.parseMaybeAssignAllowIn()), this.finishNode(e, 'TSEnumMember');
          }
          tsParseEnumDeclaration(e, t = {}) {
           return t.const && (e.const = !0), t.declare && (e.declare = !0), this.expectContextual(126), (e.id = this.parseIdentifier()), this.checkIdentifier(e.id, e.const ? 8971 : 8459), this.expect(5), (e.members = this.tsParseDelimitedList('EnumMembers', this.tsParseEnumMember.bind(this))), this.expect(8), this.finishNode(e, 'TSEnumDeclaration');
          }
          tsParseEnumBody() {
           let e = this.startNode();
           return this.expect(5), (e.members = this.tsParseDelimitedList('EnumMembers', this.tsParseEnumMember.bind(this))), this.expect(8), this.finishNode(e, 'TSEnumBody');
          }
          tsParseModuleBlock() {
           let e = this.startNode();
           return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody((e.body = []), void 0, !0, 8), this.scope.exit(), this.finishNode(e, 'TSModuleBlock');
          }
          tsParseModuleOrNamespaceDeclaration(e, t = !1) {
           if (((e.id = this.parseIdentifier()), t || this.checkIdentifier(e.id, 1024), this.eat(16))) {
            let t = this.startNode();
            this.tsParseModuleOrNamespaceDeclaration(t, !0), (e.body = t);
           } else this.scope.enter(256), this.prodParam.enter(0), (e.body = this.tsParseModuleBlock()), this.prodParam.exit(), this.scope.exit();
           return this.finishNode(e, 'TSModuleDeclaration');
          }
          tsParseAmbientExternalModuleDeclaration(e) {
           return this.isContextual(112) ? ((e.kind = 'global'), (e.global = !0), (e.id = this.parseIdentifier())) : this.match(134) ? ((e.kind = 'module'), (e.id = super.parseStringLiteral(this.state.value))) : this.unexpected(), this.match(5) ? (this.scope.enter(256), this.prodParam.enter(0), (e.body = this.tsParseModuleBlock()), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(e, 'TSModuleDeclaration');
          }
          tsParseImportEqualsDeclaration(e, t, r) {
           (e.isExport = r || !1), (e.id = t || this.parseIdentifier()), this.checkIdentifier(e.id, 4096), this.expect(29);
           let n = this.tsParseModuleReference();
           return 'type' === e.importKind && 'TSExternalModuleReference' !== n.type && this.raise(xt.ImportAliasHasImportType, n), (e.moduleReference = n), this.semicolon(), this.finishNode(e, 'TSImportEqualsDeclaration');
          }
          tsIsExternalModuleReference() {
           return this.isContextual(119) && 40 === this.lookaheadCharCode();
          }
          tsParseModuleReference() {
           return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(0);
          }
          tsParseExternalModuleReference() {
           let e = this.startNode();
           return this.expectContextual(119), this.expect(10), this.match(134) || this.unexpected(), (e.expression = super.parseExprAtom()), this.expect(11), (this.sawUnambiguousESM = !0), this.finishNode(e, 'TSExternalModuleReference');
          }
          tsLookAhead(e) {
           let t = this.state.clone(),
            r = e();
           return (this.state = t), r;
          }
          tsTryParseAndCatch(e) {
           let t = this.tryParse((t) => e() || t());
           if (!t.aborted && t.node) return t.error && (this.state = t.failState), t.node;
          }
          tsTryParse(e) {
           let t = this.state.clone(),
            r = e();
           if (void 0 !== r && !1 !== r) return r;
           this.state = t;
          }
          tsTryParseDeclare(e) {
           if (this.isLineTerminator()) return;
           let t,
            r = this.state.type;
           return (
            this.isContextual(100) && ((r = 74), (t = 'let')),
            this.tsInAmbientContext(() => {
             switch (r) {
              case 68:
               return (e.declare = !0), super.parseFunctionStatement(e, !1, !1);
              case 80:
               return (e.declare = !0), this.parseClass(e, !0, !1);
              case 126:
               return this.tsParseEnumDeclaration(e, { declare: !0 });
              case 112:
               return this.tsParseAmbientExternalModuleDeclaration(e);
              case 75:
              case 74:
               return this.match(75) && this.isLookaheadContextual('enum') ? (this.expect(75), this.tsParseEnumDeclaration(e, { const: !0, declare: !0 })) : ((e.declare = !0), this.parseVarStatement(e, t || this.state.value, !0));
              case 129: {
               let t = this.tsParseInterfaceDeclaration(e, { declare: !0 });
               if (t) return t;
              }
              default:
               if (U(r)) return this.tsParseDeclaration(e, this.state.value, !0, null);
             }
            })
           );
          }
          tsTryParseExportDeclaration() {
           return this.tsParseDeclaration(this.startNode(), this.state.value, !0, null);
          }
          tsParseExpressionStatement(e, t, r) {
           switch (t.name) {
            case 'declare': {
             let t = this.tsTryParseDeclare(e);
             return t && (t.declare = !0), t;
            }
            case 'global':
             if (this.match(5)) {
              this.scope.enter(256), this.prodParam.enter(0);
              let r = e;
              return (r.kind = 'global'), (e.global = !0), (r.id = t), (r.body = this.tsParseModuleBlock()), this.scope.exit(), this.prodParam.exit(), this.finishNode(r, 'TSModuleDeclaration');
             }
             break;
            default:
             return this.tsParseDeclaration(e, t.name, !1, r);
           }
          }
          tsParseDeclaration(e, t, r, n) {
           switch (t) {
            case 'abstract':
             if (this.tsCheckLineTerminator(r) && (this.match(80) || U(this.state.type))) return this.tsParseAbstractDeclaration(e, n);
             break;
            case 'module':
             if (this.tsCheckLineTerminator(r)) {
              if (this.match(134)) return this.tsParseAmbientExternalModuleDeclaration(e);
              if (U(this.state.type)) return (e.kind = 'module'), this.tsParseModuleOrNamespaceDeclaration(e);
             }
             break;
            case 'namespace':
             if (this.tsCheckLineTerminator(r) && U(this.state.type)) return (e.kind = 'namespace'), this.tsParseModuleOrNamespaceDeclaration(e);
             break;
            case 'type':
             if (this.tsCheckLineTerminator(r) && U(this.state.type)) return this.tsParseTypeAliasDeclaration(e);
           }
          }
          tsCheckLineTerminator(e) {
           return e ? !this.hasFollowingLineBreak() && (this.next(), !0) : !this.isLineTerminator();
          }
          tsTryParseGenericAsyncArrowFunction(e) {
           if (!this.match(47)) return;
           let t = this.state.maybeInArrowParameters;
           this.state.maybeInArrowParameters = !0;
           let r = this.tsTryParseAndCatch(() => {
            let t = this.startNodeAt(e);
            return (t.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier)), super.parseFunctionParams(t), (t.returnType = this.tsTryParseTypeOrTypePredicateAnnotation()), this.expect(19), t;
           });
           return (this.state.maybeInArrowParameters = t), r ? super.parseArrowExpression(r, null, !0) : void 0;
          }
          tsParseTypeArgumentsInExpression() {
           if (47 === this.reScan_lt()) return this.tsParseTypeArguments();
          }
          tsParseTypeArguments() {
           let e = this.startNode();
           return (e.params = this.tsInType(() => this.tsInTopLevelContext(() => (this.expect(47), this.tsParseDelimitedList('TypeParametersOrArguments', this.tsParseType.bind(this)))))), 0 === e.params.length ? this.raise(xt.EmptyTypeArguments, e) : !this.state.inType && this.curContext() === v.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(e, 'TSTypeParameterInstantiation');
          }
          tsIsDeclarationStart() {
           return (function (e) {
            return e >= 124 && e <= 130;
           })(this.state.type);
          }
          isExportDefaultSpecifier() {
           return !this.tsIsDeclarationStart() && super.isExportDefaultSpecifier();
          }
          parseAssignableListItem(e, t) {
           let r = this.state.startLoc,
            n = {};
           this.tsParseModifiers({ allowedModifiers: ['public', 'private', 'protected', 'override', 'readonly'] }, n);
           let s = n.accessibility,
            i = n.override,
            a = n.readonly;
           !(4 & e) && (s || a || i) && this.raise(xt.UnexpectedParameterModifier, r);
           let o = this.parseMaybeDefault();
           2 & e && this.parseFunctionParamType(o);
           let u = this.parseMaybeDefault(o.loc.start, o);
           if (s || a || i) {
            let e = this.startNodeAt(r);
            return t.length && (e.decorators = t), s && (e.accessibility = s), a && (e.readonly = a), i && (e.override = i), 'Identifier' !== u.type && 'AssignmentPattern' !== u.type && this.raise(xt.UnsupportedParameterPropertyKind, e), (e.parameter = u), this.finishNode(e, 'TSParameterProperty');
           }
           return t.length && (o.decorators = t), u;
          }
          isSimpleParameter(e) {
           return ('TSParameterProperty' === e.type && super.isSimpleParameter(e.parameter)) || super.isSimpleParameter(e);
          }
          tsDisallowOptionalPattern(e) {
           for (let t of e.params) 'Identifier' !== t.type && t.optional && !this.state.isAmbientContext && this.raise(xt.PatternIsOptional, t);
          }
          setArrowFunctionParameters(e, t, r) {
           super.setArrowFunctionParameters(e, t, r), this.tsDisallowOptionalPattern(e);
          }
          parseFunctionBodyAndFinish(e, t, r = !1) {
           this.match(14) && (e.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
           let n = 'FunctionDeclaration' === t ? 'TSDeclareFunction' : 'ClassMethod' === t || 'ClassPrivateMethod' === t ? 'TSDeclareMethod' : void 0;
           return n && !this.match(5) && this.isLineTerminator() ? this.finishNode(e, n) : 'TSDeclareFunction' === n && this.state.isAmbientContext && (this.raise(xt.DeclareFunctionHasImplementation, e), e.declare) ? super.parseFunctionBodyAndFinish(e, n, r) : (this.tsDisallowOptionalPattern(e), super.parseFunctionBodyAndFinish(e, t, r));
          }
          registerFunctionStatementId(e) {
           !e.body && e.id ? this.checkIdentifier(e.id, 1024) : super.registerFunctionStatementId(e);
          }
          tsCheckForInvalidTypeCasts(e) {
           e.forEach((e) => {
            'TSTypeCastExpression' === (null == e ? void 0 : e.type) && this.raise(xt.UnexpectedTypeAnnotation, e.typeAnnotation);
           });
          }
          toReferencedList(e, t) {
           return this.tsCheckForInvalidTypeCasts(e), e;
          }
          parseArrayLike(e, t, r, n) {
           let s = super.parseArrayLike(e, t, r, n);
           return 'ArrayExpression' === s.type && this.tsCheckForInvalidTypeCasts(s.elements), s;
          }
          parseSubscript(e, t, r, n) {
           if (!this.hasPrecedingLineBreak() && this.match(35)) {
            (this.state.canStartJSXElement = !1), this.next();
            let r = this.startNodeAt(t);
            return (r.expression = e), this.finishNode(r, 'TSNonNullExpression');
           }
           let s = !1;
           if (this.match(18) && 60 === this.lookaheadCharCode()) {
            if (r) return (n.stop = !0), e;
            (n.optionalChainMember = s = !0), this.next();
           }
           if (this.match(47) || this.match(51)) {
            let i,
             a = this.tsTryParseAndCatch(() => {
              if (!r && this.atPossibleAsyncArrow(e)) {
               let e = this.tsTryParseGenericAsyncArrowFunction(t);
               if (e) return e;
              }
              let a = this.tsParseTypeArgumentsInExpression();
              if (!a) return;
              if (s && !this.match(10)) return void (i = this.state.curPosition());
              if (G(this.state.type)) {
               let r = super.parseTaggedTemplateExpression(e, t, n);
               return (r.typeParameters = a), r;
              }
              if (!r && this.eat(10)) {
               let r = this.startNodeAt(t);
               return (r.callee = e), (r.arguments = this.parseCallExpressionArguments(11)), this.tsCheckForInvalidTypeCasts(r.arguments), (r.typeParameters = a), n.optionalChainMember && (r.optional = s), this.finishCallExpression(r, n.optionalChainMember);
              }
              let o = this.state.type;
              if (48 === o || 52 === o || (10 !== o && z(o) && !this.hasPrecedingLineBreak())) return;
              let u = this.startNodeAt(t);
              return (u.expression = e), (u.typeParameters = a), this.finishNode(u, 'TSInstantiationExpression');
             });
            if ((i && this.unexpected(i, 10), a)) return 'TSInstantiationExpression' === a.type && (this.match(16) || (this.match(18) && 40 !== this.lookaheadCharCode())) && this.raise(xt.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc), a;
           }
           return super.parseSubscript(e, t, r, n);
          }
          parseNewCallee(e) {
           var t;
           super.parseNewCallee(e);
           let { callee: r } = e;
           'TSInstantiationExpression' === r.type && (null == (t = r.extra) || !t.parenthesized) && ((e.typeParameters = r.typeParameters), (e.callee = r.expression));
          }
          parseExprOp(e, t, r) {
           let n;
           if (K(58) > r && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (n = this.isContextual(120)))) {
            let s = this.startNodeAt(t);
            return (s.expression = e), (s.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (n && this.raise(y.UnexpectedKeyword, this.state.startLoc, { keyword: 'const' }), this.tsParseTypeReference()) : this.tsParseType()))), this.finishNode(s, n ? 'TSSatisfiesExpression' : 'TSAsExpression'), this.reScan_lt_gt(), this.parseExprOp(s, t, r);
           }
           return super.parseExprOp(e, t, r);
          }
          checkReservedWord(e, t, r, n) {
           this.state.isAmbientContext || super.checkReservedWord(e, t, r, n);
          }
          checkImportReflection(e) {
           super.checkImportReflection(e), e.module && 'value' !== e.importKind && this.raise(xt.ImportReflectionHasImportType, e.specifiers[0].loc.start);
          }
          checkDuplicateExports() {}
          isPotentialImportPhase(e) {
           if (super.isPotentialImportPhase(e)) return !0;
           if (this.isContextual(130)) {
            let t = this.lookaheadCharCode();
            return e ? 123 === t || 42 === t : 61 !== t;
           }
           return !e && this.isContextual(87);
          }
          applyImportPhase(e, t, r, n) {
           super.applyImportPhase(e, t, r, n), t ? (e.exportKind = 'type' === r ? 'type' : 'value') : (e.importKind = 'type' === r || 'typeof' === r ? r : 'value');
          }
          parseImport(e) {
           if (this.match(134)) return (e.importKind = 'value'), super.parseImport(e);
           let t;
           if (U(this.state.type) && 61 === this.lookaheadCharCode()) return (e.importKind = 'value'), this.tsParseImportEqualsDeclaration(e);
           if (this.isContextual(130)) {
            let r = this.parseMaybeImportPhase(e, !1);
            if (61 === this.lookaheadCharCode()) return this.tsParseImportEqualsDeclaration(e, r);
            t = super.parseImportSpecifiersAndAfter(e, r);
           } else t = super.parseImport(e);
           return 'type' === t.importKind && t.specifiers.length > 1 && 'ImportDefaultSpecifier' === t.specifiers[0].type && this.raise(xt.TypeImportCannotSpecifyDefaultAndNamed, t), t;
          }
          parseExport(e, t) {
           if (this.match(83)) {
            let t = e;
            this.next();
            let r = null;
            return this.isContextual(130) && this.isPotentialImportPhase(!1) ? (r = this.parseMaybeImportPhase(t, !1)) : (t.importKind = 'value'), this.tsParseImportEqualsDeclaration(t, r, !0);
           }
           if (this.eat(29)) {
            let t = e;
            return (t.expression = super.parseExpression()), this.semicolon(), (this.sawUnambiguousESM = !0), this.finishNode(t, 'TSExportAssignment');
           }
           if (this.eatContextual(93)) {
            let t = e;
            return this.expectContextual(128), (t.id = this.parseIdentifier()), this.semicolon(), this.finishNode(t, 'TSNamespaceExportDeclaration');
           }
           return super.parseExport(e, t);
          }
          isAbstractClass() {
           return this.isContextual(124) && 80 === this.lookahead().type;
          }
          parseExportDefaultExpression() {
           if (this.isAbstractClass()) {
            let e = this.startNode();
            return this.next(), (e.abstract = !0), this.parseClass(e, !0, !0);
           }
           if (this.match(129)) {
            let e = this.tsParseInterfaceDeclaration(this.startNode());
            if (e) return e;
           }
           return super.parseExportDefaultExpression();
          }
          parseVarStatement(e, t, r = !1) {
           let { isAmbientContext: n } = this.state,
            s = super.parseVarStatement(e, t, r || n);
           if (!n) return s;
           for (let { id: i, init: a } of s.declarations) a && ('const' !== t || i.typeAnnotation ? this.raise(xt.InitializerNotAllowedInAmbientContext, a) : Ct(a, this.hasPlugin('estree')) || this.raise(xt.ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference, a));
           return s;
          }
          parseStatementContent(e, t) {
           if (this.match(75) && this.isLookaheadContextual('enum')) {
            let e = this.startNode();
            return this.expect(75), this.tsParseEnumDeclaration(e, { const: !0 });
           }
           if (this.isContextual(126)) return this.tsParseEnumDeclaration(this.startNode());
           if (this.isContextual(129)) {
            let e = this.tsParseInterfaceDeclaration(this.startNode());
            if (e) return e;
           }
           return super.parseStatementContent(e, t);
          }
          parseAccessModifier() {
           return this.tsParseModifier(['public', 'protected', 'private']);
          }
          tsHasSomeModifiers(e, t) {
           return t.some((t) => (bt(t) ? e.accessibility === t : !!e[t]));
          }
          tsIsStartOfStaticBlocks() {
           return this.isContextual(106) && 123 === this.lookaheadCharCode();
          }
          parseClassMember(e, t, r) {
           let n = ['declare', 'private', 'public', 'protected', 'override', 'abstract', 'readonly', 'static'];
           this.tsParseModifiers({ allowedModifiers: n, disallowedModifiers: ['in', 'out'], stopOnStartOfClassStaticBlock: !0, errorTemplate: xt.InvalidModifierOnTypeParameterPositions }, t);
           let s = () => {
            this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(t, n) && this.raise(xt.StaticBlockCannotHaveModifier, this.state.curPosition()), super.parseClassStaticBlock(e, t)) : this.parseClassMemberWithIsStatic(e, t, r, !!t.static);
           };
           t.declare ? this.tsInAmbientContext(s) : s();
          }
          parseClassMemberWithIsStatic(e, t, r, n) {
           let s = this.tsTryParseIndexSignature(t);
           if (s) return e.body.push(s), t.abstract && this.raise(xt.IndexSignatureHasAbstract, t), t.accessibility && this.raise(xt.IndexSignatureHasAccessibility, t, { modifier: t.accessibility }), t.declare && this.raise(xt.IndexSignatureHasDeclare, t), void (t.override && this.raise(xt.IndexSignatureHasOverride, t));
           !this.state.inAbstractClass && t.abstract && this.raise(xt.NonAbstractClassHasAbstractMethod, t), t.override && (r.hadSuperClass || this.raise(xt.OverrideNotInSubClass, t)), super.parseClassMemberWithIsStatic(e, t, r, n);
          }
          parsePostMemberNameModifiers(e) {
           this.eat(17) && (e.optional = !0), e.readonly && this.match(10) && this.raise(xt.ClassMethodHasReadonly, e), e.declare && this.match(10) && this.raise(xt.ClassMethodHasDeclare, e);
          }
          parseExpressionStatement(e, t, r) {
           return ('Identifier' === t.type ? this.tsParseExpressionStatement(e, t, r) : void 0) || super.parseExpressionStatement(e, t, r);
          }
          shouldParseExportDeclaration() {
           return !!this.tsIsDeclarationStart() || super.shouldParseExportDeclaration();
          }
          parseConditional(e, t, r) {
           if (!this.state.maybeInArrowParameters || !this.match(17)) return super.parseConditional(e, t, r);
           let n = this.tryParse(() => super.parseConditional(e, t));
           return n.node ? (n.error && (this.state = n.failState), n.node) : (n.error && super.setOptionalParametersError(r, n.error), e);
          }
          parseParenItem(e, t) {
           let r = super.parseParenItem(e, t);
           if ((this.eat(17) && ((r.optional = !0), this.resetEndLocation(e)), this.match(14))) {
            let r = this.startNodeAt(t);
            return (r.expression = e), (r.typeAnnotation = this.tsParseTypeAnnotation()), this.finishNode(r, 'TSTypeCastExpression');
           }
           return e;
          }
          parseExportDeclaration(e) {
           if (!this.state.isAmbientContext && this.isContextual(125)) return this.tsInAmbientContext(() => this.parseExportDeclaration(e));
           let t = this.state.startLoc,
            r = this.eatContextual(125);
           if (r && (this.isContextual(125) || !this.shouldParseExportDeclaration())) throw this.raise(xt.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
           let n = (U(this.state.type) && this.tsTryParseExportDeclaration()) || super.parseExportDeclaration(e);
           return n ? (('TSInterfaceDeclaration' === n.type || 'TSTypeAliasDeclaration' === n.type || r) && (e.exportKind = 'type'), r && 'TSImportEqualsDeclaration' !== n.type && (this.resetStartLocation(n, t), (n.declare = !0)), n) : null;
          }
          parseClassId(e, t, r, n) {
           if ((!t || r) && this.isContextual(113)) return;
           super.parseClassId(e, t, r, e.declare ? 1024 : 8331);
           let s = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
           s && (e.typeParameters = s);
          }
          parseClassPropertyAnnotation(e) {
           e.optional || (this.eat(35) ? (e.definite = !0) : this.eat(17) && (e.optional = !0));
           let t = this.tsTryParseTypeAnnotation();
           t && (e.typeAnnotation = t);
          }
          parseClassProperty(e) {
           if ((this.parseClassPropertyAnnotation(e), this.state.isAmbientContext && !(e.readonly && !e.typeAnnotation) && this.match(29) && this.raise(xt.DeclareClassFieldHasInitializer, this.state.startLoc), e.abstract && this.match(29))) {
            let { key: t } = e;
            this.raise(xt.AbstractPropertyHasInitializer, this.state.startLoc, { propertyName: 'Identifier' !== t.type || e.computed ? `[${this.input.slice(this.offsetToSourcePos(t.start), this.offsetToSourcePos(t.end))}]` : t.name });
           }
           return super.parseClassProperty(e);
          }
          parseClassPrivateProperty(e) {
           return e.abstract && this.raise(xt.PrivateElementHasAbstract, e), e.accessibility && this.raise(xt.PrivateElementHasAccessibility, e, { modifier: e.accessibility }), this.parseClassPropertyAnnotation(e), super.parseClassPrivateProperty(e);
          }
          parseClassAccessorProperty(e) {
           return this.parseClassPropertyAnnotation(e), e.optional && this.raise(xt.AccessorCannotBeOptional, e), super.parseClassAccessorProperty(e);
          }
          pushClassMethod(e, t, r, n, s, i) {
           let a = this.tsTryParseTypeParameters(this.tsParseConstModifier);
           a && s && this.raise(xt.ConstructorHasTypeParameters, a);
           let { declare: o = !1, kind: u } = t;
           o && ('get' === u || 'set' === u) && this.raise(xt.DeclareAccessor, t, { kind: u }), a && (t.typeParameters = a), super.pushClassMethod(e, t, r, n, s, i);
          }
          pushClassPrivateMethod(e, t, r, n) {
           let s = this.tsTryParseTypeParameters(this.tsParseConstModifier);
           s && (t.typeParameters = s), super.pushClassPrivateMethod(e, t, r, n);
          }
          declareClassPrivateMethodInScope(e, t) {
           'TSDeclareMethod' !== e.type && (('MethodDefinition' === e.type && !hasOwnProperty.call(e.value, 'body')) || super.declareClassPrivateMethodInScope(e, t));
          }
          parseClassSuper(e) {
           super.parseClassSuper(e), e.superClass && (this.match(47) || this.match(51)) && (e.superTypeParameters = this.tsParseTypeArgumentsInExpression()), this.eatContextual(113) && (e.implements = this.tsParseHeritageClause('implements'));
          }
          parseObjPropValue(e, t, r, n, s, i, a) {
           let o = this.tsTryParseTypeParameters(this.tsParseConstModifier);
           return o && (e.typeParameters = o), super.parseObjPropValue(e, t, r, n, s, i, a);
          }
          parseFunctionParams(e, t) {
           let r = this.tsTryParseTypeParameters(this.tsParseConstModifier);
           r && (e.typeParameters = r), super.parseFunctionParams(e, t);
          }
          parseVarId(e, t) {
           super.parseVarId(e, t), 'Identifier' === e.id.type && !this.hasPrecedingLineBreak() && this.eat(35) && (e.definite = !0);
           let r = this.tsTryParseTypeAnnotation();
           r && ((e.id.typeAnnotation = r), this.resetEndLocation(e.id));
          }
          parseAsyncArrowFromCallExpression(e, t) {
           return this.match(14) && (e.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(e, t);
          }
          parseMaybeAssign(e, t) {
           var r, n, s, i, a;
           let o, u, l;
           if (this.hasPlugin('jsx') && (this.match(143) || this.match(47))) {
            if (((o = this.state.clone()), (u = this.tryParse(() => super.parseMaybeAssign(e, t), o)), !u.error)) return u.node;
            let { context: r } = this.state,
             n = r[r.length - 1];
            (n === v.j_oTag || n === v.j_expr) && r.pop();
           }
           if (!((null != (r = u) && r.error) || this.match(47))) return super.parseMaybeAssign(e, t);
           (!o || o === this.state) && (o = this.state.clone());
           let p,
            c = this.tryParse((r) => {
             var n, s;
             p = this.tsParseTypeParameters(this.tsParseConstModifier);
             let i = super.parseMaybeAssign(e, t);
             return ('ArrowFunctionExpression' !== i.type || (null != (n = i.extra) && n.parenthesized)) && r(), 0 !== (null == (s = p) ? void 0 : s.params.length) && this.resetStartLocationFromNode(i, p), (i.typeParameters = p), i;
            }, o);
           if (!c.error && !c.aborted) return p && this.reportReservedArrowTypeParam(p), c.node;
           if (!u && (Dt(!this.hasPlugin('jsx')), (l = this.tryParse(() => super.parseMaybeAssign(e, t), o)), !l.error)) return l.node;
           if (null != (n = u) && n.node) return (this.state = u.failState), u.node;
           if (c.node) return (this.state = c.failState), p && this.reportReservedArrowTypeParam(p), c.node;
           if (null != (s = l) && s.node) return (this.state = l.failState), l.node;
           throw (null == (i = u) ? void 0 : i.error) || c.error || (null == (a = l) ? void 0 : a.error);
          }
          reportReservedArrowTypeParam(e) {
           var t;
           1 === e.params.length && !e.params[0].constraint && (null == (t = e.extra) || !t.trailingComma) && this.getPluginOption('typescript', 'disallowAmbiguousJSXLike') && this.raise(xt.ReservedArrowTypeParam, e);
          }
          parseMaybeUnary(e, t) {
           return !this.hasPlugin('jsx') && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(e, t);
          }
          parseArrow(e) {
           if (this.match(14)) {
            let t = this.tryParse((e) => {
             let t = this.tsParseTypeOrTypePredicateAnnotation(14);
             return (this.canInsertSemicolon() || !this.match(19)) && e(), t;
            });
            if (t.aborted) return;
            t.thrown || (t.error && (this.state = t.failState), (e.returnType = t.node));
           }
           return super.parseArrow(e);
          }
          parseFunctionParamType(e) {
           this.eat(17) && (e.optional = !0);
           let t = this.tsTryParseTypeAnnotation();
           return t && (e.typeAnnotation = t), this.resetEndLocation(e), e;
          }
          isAssignable(e, t) {
           switch (e.type) {
            case 'TSTypeCastExpression':
             return this.isAssignable(e.expression, t);
            case 'TSParameterProperty':
             return !0;
            default:
             return super.isAssignable(e, t);
           }
          }
          toAssignable(e, t = !1) {
           switch (e.type) {
            case 'ParenthesizedExpression':
             this.toAssignableParenthesizedExpression(e, t);
             break;
            case 'TSAsExpression':
            case 'TSSatisfiesExpression':
            case 'TSNonNullExpression':
            case 'TSTypeAssertion':
             t ? this.expressionScope.recordArrowParameterBindingError(xt.UnexpectedTypeCastInParameter, e) : this.raise(xt.UnexpectedTypeCastInParameter, e), this.toAssignable(e.expression, t);
             break;
            case 'AssignmentExpression':
             !t && 'TSTypeCastExpression' === e.left.type && (e.left = this.typeCastToParameter(e.left));
            default:
             super.toAssignable(e, t);
           }
          }
          toAssignableParenthesizedExpression(e, t) {
           switch (e.expression.type) {
            case 'TSAsExpression':
            case 'TSSatisfiesExpression':
            case 'TSNonNullExpression':
            case 'TSTypeAssertion':
            case 'ParenthesizedExpression':
             this.toAssignable(e.expression, t);
             break;
            default:
             super.toAssignable(e, t);
           }
          }
          checkToRestConversion(e, t) {
           switch (e.type) {
            case 'TSAsExpression':
            case 'TSSatisfiesExpression':
            case 'TSTypeAssertion':
            case 'TSNonNullExpression':
             this.checkToRestConversion(e.expression, !1);
             break;
            default:
             super.checkToRestConversion(e, t);
           }
          }
          isValidLVal(e, t, r) {
           switch (e) {
            case 'TSTypeCastExpression':
             return !0;
            case 'TSParameterProperty':
             return 'parameter';
            case 'TSNonNullExpression':
            case 'TSInstantiationExpression':
             return 'expression';
            case 'TSAsExpression':
            case 'TSSatisfiesExpression':
            case 'TSTypeAssertion':
             return (64 !== r || !t) && ['expression', !0];
            default:
             return super.isValidLVal(e, t, r);
           }
          }
          parseBindingAtom() {
           return 78 === this.state.type ? this.parseIdentifier(!0) : super.parseBindingAtom();
          }
          parseMaybeDecoratorArguments(e, t) {
           if (this.match(47) || this.match(51)) {
            let r = this.tsParseTypeArgumentsInExpression();
            if (this.match(10)) {
             let n = super.parseMaybeDecoratorArguments(e, t);
             return (n.typeParameters = r), n;
            }
            this.unexpected(null, 10);
           }
           return super.parseMaybeDecoratorArguments(e, t);
          }
          checkCommaAfterRest(e) {
           return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === e ? (this.next(), !1) : super.checkCommaAfterRest(e);
          }
          isClassMethod() {
           return this.match(47) || super.isClassMethod();
          }
          isClassProperty() {
           return this.match(35) || this.match(14) || super.isClassProperty();
          }
          parseMaybeDefault(e, t) {
           let r = super.parseMaybeDefault(e, t);
           return 'AssignmentPattern' === r.type && r.typeAnnotation && r.right.start < r.typeAnnotation.start && this.raise(xt.TypeAnnotationAfterAssign, r.typeAnnotation), r;
          }
          getTokenFromCode(e) {
           if (this.state.inType) {
            if (62 === e) return void this.finishOp(48, 1);
            if (60 === e) return void this.finishOp(47, 1);
           }
           super.getTokenFromCode(e);
          }
          reScan_lt_gt() {
           let { type: e } = this.state;
           47 === e ? ((this.state.pos -= 1), this.readToken_lt()) : 48 === e && ((this.state.pos -= 1), this.readToken_gt());
          }
          reScan_lt() {
           let { type: e } = this.state;
           return 51 === e ? ((this.state.pos -= 2), this.finishOp(47, 1), 47) : e;
          }
          toAssignableList(e, t, r) {
           for (let n = 0; n < e.length; n++) {
            let t = e[n];
            'TSTypeCastExpression' === (null == t ? void 0 : t.type) && (e[n] = this.typeCastToParameter(t));
           }
           super.toAssignableList(e, t, r);
          }
          typeCastToParameter(e) {
           return (e.expression.typeAnnotation = e.typeAnnotation), this.resetEndLocation(e.expression, e.typeAnnotation.loc.end), e.expression;
          }
          shouldParseArrow(e) {
           return this.match(14) ? e.every((e) => this.isAssignable(e, !0)) : super.shouldParseArrow(e);
          }
          shouldParseAsyncArrow() {
           return this.match(14) || super.shouldParseAsyncArrow();
          }
          canHaveLeadingDecorator() {
           return super.canHaveLeadingDecorator() || this.isAbstractClass();
          }
          jsxParseOpeningElementAfterName(e) {
           if (this.match(47) || this.match(51)) {
            let t = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
            t && (e.typeParameters = t);
           }
           return super.jsxParseOpeningElementAfterName(e);
          }
          getGetterSetterExpectedParamCount(e) {
           let t = super.getGetterSetterExpectedParamCount(e),
            r = this.getObjectOrClassMethodParams(e)[0];
           return r && this.isThisParam(r) ? t + 1 : t;
          }
          parseCatchClauseParam() {
           let e = super.parseCatchClauseParam(),
            t = this.tsTryParseTypeAnnotation();
           return t && ((e.typeAnnotation = t), this.resetEndLocation(e)), e;
          }
          tsInAmbientContext(e) {
           let { isAmbientContext: t, strict: r } = this.state;
           (this.state.isAmbientContext = !0), (this.state.strict = !1);
           try {
            return e();
           } finally {
            (this.state.isAmbientContext = t), (this.state.strict = r);
           }
          }
          parseClass(e, t, r) {
           let n = this.state.inAbstractClass;
           this.state.inAbstractClass = !!e.abstract;
           try {
            return super.parseClass(e, t, r);
           } finally {
            this.state.inAbstractClass = n;
           }
          }
          tsParseAbstractDeclaration(e, t) {
           if (this.match(80)) return (e.abstract = !0), this.maybeTakeDecorators(t, this.parseClass(e, !0, !1));
           if (this.isContextual(129)) {
            if (!this.hasFollowingLineBreak()) return (e.abstract = !0), this.raise(xt.NonClassMethodPropertyHasAbstractModifer, e), this.tsParseInterfaceDeclaration(e);
           } else this.unexpected(null, 80);
          }
          parseMethod(e, t, r, n, s, i, a) {
           let o = super.parseMethod(e, t, r, n, s, i, a);
           if (o.abstract && (this.hasPlugin('estree') ? o.value : o).body) {
            let { key: e } = o;
            this.raise(xt.AbstractMethodHasImplementation, o, { methodName: 'Identifier' !== e.type || o.computed ? `[${this.input.slice(this.offsetToSourcePos(e.start), this.offsetToSourcePos(e.end))}]` : e.name });
           }
           return o;
          }
          tsParseTypeParameterName() {
           return this.parseIdentifier().name;
          }
          shouldParseAsAmbientContext() {
           return !!this.getPluginOption('typescript', 'dts');
          }
          parse() {
           return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.parse();
          }
          getExpression() {
           return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.getExpression();
          }
          parseExportSpecifier(e, t, r, n) {
           return !t && n ? (this.parseTypeOnlyImportExportSpecifier(e, !1, r), this.finishNode(e, 'ExportSpecifier')) : ((e.exportKind = 'value'), super.parseExportSpecifier(e, t, r, n));
          }
          parseImportSpecifier(e, t, r, n, s) {
           return !t && n ? (this.parseTypeOnlyImportExportSpecifier(e, !0, r), this.finishNode(e, 'ImportSpecifier')) : ((e.importKind = 'value'), super.parseImportSpecifier(e, t, r, n, r ? 4098 : 4096));
          }
          parseTypeOnlyImportExportSpecifier(e, t, r) {
           let n,
            s = t ? 'imported' : 'local',
            i = t ? 'local' : 'exported',
            a = e[s],
            o = !1,
            u = !0,
            l = a.loc.start;
           if (this.isContextual(93)) {
            let e = this.parseIdentifier();
            if (this.isContextual(93)) {
             let r = this.parseIdentifier();
             $(this.state.type) ? ((o = !0), (a = e), (n = t ? this.parseIdentifier() : this.parseModuleExportName()), (u = !1)) : ((n = r), (u = !1));
            } else $(this.state.type) ? ((u = !1), (n = t ? this.parseIdentifier() : this.parseModuleExportName())) : ((o = !0), (a = e));
           } else $(this.state.type) && ((o = !0), t ? ((a = this.parseIdentifier(!0)), this.isContextual(93) || this.checkReservedWord(a.name, a.loc.start, !0, !0)) : (a = this.parseModuleExportName()));
           o && r && this.raise(t ? xt.TypeModifierIsUsedInTypeImports : xt.TypeModifierIsUsedInTypeExports, l), (e[s] = a), (e[i] = n), (e[t ? 'importKind' : 'exportKind'] = o ? 'type' : 'value'), u && this.eatContextual(93) && (e[i] = t ? this.parseIdentifier() : this.parseModuleExportName()), e[i] || (e[i] = nt(e[s])), t && this.checkIdentifier(e[i], o ? 4098 : 4096);
          }
         },
        v8intrinsic: (e) =>
         class extends e {
          parseV8Intrinsic() {
           if (this.match(54)) {
            let e = this.state.startLoc,
             t = this.startNode();
            if ((this.next(), U(this.state.type))) {
             let e = this.parseIdentifierName(),
              r = this.createIdentifier(t, e);
             if (((r.type = 'V8IntrinsicIdentifier'), this.match(10))) return r;
            }
            this.unexpected(e);
           }
          }
          parseExprAtom(e) {
           return this.parseV8Intrinsic() || super.parseExprAtom(e);
          }
         },
        placeholders: (e) =>
         class extends e {
          parsePlaceholder(e) {
           if (this.match(133)) {
            let t = this.startNode();
            return this.next(), this.assertNoSpace(), (t.name = super.parseIdentifier(!0)), this.assertNoSpace(), this.expect(133), this.finishPlaceholder(t, e);
           }
          }
          finishPlaceholder(e, t) {
           let r = e;
           return (!r.expectedNode || !r.type) && (r = this.finishNode(r, 'Placeholder')), (r.expectedNode = t), r;
          }
          getTokenFromCode(e) {
           37 === e && 37 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(133, 2) : super.getTokenFromCode(e);
          }
          parseExprAtom(e) {
           return this.parsePlaceholder('Expression') || super.parseExprAtom(e);
          }
          parseIdentifier(e) {
           return this.parsePlaceholder('Identifier') || super.parseIdentifier(e);
          }
          checkReservedWord(e, t, r, n) {
           void 0 !== e && super.checkReservedWord(e, t, r, n);
          }
          parseBindingAtom() {
           return this.parsePlaceholder('Pattern') || super.parseBindingAtom();
          }
          isValidLVal(e, t, r) {
           return 'Placeholder' === e || super.isValidLVal(e, t, r);
          }
          toAssignable(e, t) {
           e && 'Placeholder' === e.type && 'Expression' === e.expectedNode ? (e.expectedNode = 'Pattern') : super.toAssignable(e, t);
          }
          chStartsBindingIdentifier(e, t) {
           return !(!super.chStartsBindingIdentifier(e, t) && 133 !== this.lookahead().type);
          }
          verifyBreakContinue(e, t) {
           (e.label && 'Placeholder' === e.label.type) || super.verifyBreakContinue(e, t);
          }
          parseExpressionStatement(e, t) {
           var r;
           if ('Placeholder' !== t.type || (null != (r = t.extra) && r.parenthesized)) return super.parseExpressionStatement(e, t);
           if (this.match(14)) {
            let r = e;
            return (r.label = this.finishPlaceholder(t, 'Identifier')), this.next(), (r.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration()), this.finishNode(r, 'LabeledStatement');
           }
           this.semicolon();
           let n = e;
           return (n.name = t.name), this.finishPlaceholder(n, 'Statement');
          }
          parseBlock(e, t, r) {
           return this.parsePlaceholder('BlockStatement') || super.parseBlock(e, t, r);
          }
          parseFunctionId(e) {
           return this.parsePlaceholder('Identifier') || super.parseFunctionId(e);
          }
          parseClass(e, t, r) {
           let n = t ? 'ClassDeclaration' : 'ClassExpression';
           this.next();
           let s = this.state.strict,
            i = this.parsePlaceholder('Identifier');
           if (i) {
            if (!(this.match(81) || this.match(133) || this.match(5))) {
             if (r || !t) return (e.id = null), (e.body = this.finishPlaceholder(i, 'ClassBody')), this.finishNode(e, n);
             throw this.raise(wt.ClassNameIsRequired, this.state.startLoc);
            }
            e.id = i;
           } else this.parseClassId(e, t, r);
           return super.parseClassSuper(e), (e.body = this.parsePlaceholder('ClassBody') || super.parseClassBody(!!e.superClass, s)), this.finishNode(e, n);
          }
          parseExport(e, t) {
           let r = this.parsePlaceholder('Identifier');
           if (!r) return super.parseExport(e, t);
           let n = e;
           if (!this.isContextual(98) && !this.match(12)) return (n.specifiers = []), (n.source = null), (n.declaration = this.finishPlaceholder(r, 'Declaration')), this.finishNode(n, 'ExportNamedDeclaration');
           this.expectPlugin('exportDefaultFrom');
           let s = this.startNode();
           return (s.exported = r), (n.specifiers = [this.finishNode(s, 'ExportDefaultSpecifier')]), super.parseExport(n, t);
          }
          isExportDefaultSpecifier() {
           if (this.match(65)) {
            let e = this.nextTokenStart();
            if (this.isUnparsedContextual(e, 'from') && this.input.startsWith(J(133), this.nextTokenStartSince(e + 4))) return !0;
           }
           return super.isExportDefaultSpecifier();
          }
          maybeParseExportDefaultSpecifier(e, t) {
           var r;
           return !(null == (r = e.specifiers) || !r.length) || super.maybeParseExportDefaultSpecifier(e, t);
          }
          checkExport(e) {
           let { specifiers: t } = e;
           null != t && t.length && (e.specifiers = t.filter((e) => 'Placeholder' === e.exported.type)), super.checkExport(e), (e.specifiers = t);
          }
          parseImport(e) {
           let t = this.parsePlaceholder('Identifier');
           if (!t) return super.parseImport(e);
           if (((e.specifiers = []), !this.isContextual(98) && !this.match(12))) return (e.source = this.finishPlaceholder(t, 'StringLiteral')), this.semicolon(), this.finishNode(e, 'ImportDeclaration');
           let r = this.startNodeAtNode(t);
           return (r.local = t), e.specifiers.push(this.finishNode(r, 'ImportDefaultSpecifier')), this.eat(12) && (this.maybeParseStarImportSpecifier(e) || this.parseNamedImportSpecifiers(e)), this.expectContextual(98), (e.source = this.parseImportSource()), this.semicolon(), this.finishNode(e, 'ImportDeclaration');
          }
          parseImportSource() {
           return this.parsePlaceholder('StringLiteral') || super.parseImportSource();
          }
          assertNoSpace() {
           this.state.start > this.offsetToSourcePos(this.state.lastTokEndLoc.index) && this.raise(wt.UnexpectedSpace, this.state.lastTokEndLoc);
          }
         },
       },
       Pt = Object.keys(kt),
       It = class extends gt {
        checkProto(e, t, r, n) {
         if ('SpreadElement' === e.type || this.isObjectMethod(e) || e.computed || e.shorthand) return;
         let s = e.key;
         if ('__proto__' === ('Identifier' === s.type ? s.name : s.value)) {
          if (t) return void this.raise(y.RecordNoProto, s);
          r.used && (n ? null === n.doubleProtoLoc && (n.doubleProtoLoc = s.loc.start) : this.raise(y.DuplicateProto, s)), (r.used = !0);
         }
        }
        shouldExitDescending(e, t) {
         return 'ArrowFunctionExpression' === e.type && this.offsetToSourcePos(e.start) === t;
        }
        getExpression() {
         this.enterInitialScopes(), this.nextToken();
         let e = this.parseExpression();
         return this.match(140) || this.unexpected(), this.finalizeRemainingComments(), (e.comments = this.comments), (e.errors = this.state.errors), 128 & this.optionFlags && (e.tokens = this.tokens), e;
        }
        parseExpression(e, t) {
         return e ? this.disallowInAnd(() => this.parseExpressionBase(t)) : this.allowInAnd(() => this.parseExpressionBase(t));
        }
        parseExpressionBase(e) {
         let t = this.state.startLoc,
          r = this.parseMaybeAssign(e);
         if (this.match(12)) {
          let n = this.startNodeAt(t);
          for (n.expressions = [r]; this.eat(12); ) n.expressions.push(this.parseMaybeAssign(e));
          return this.toReferencedList(n.expressions), this.finishNode(n, 'SequenceExpression');
         }
         return r;
        }
        parseMaybeAssignDisallowIn(e, t) {
         return this.disallowInAnd(() => this.parseMaybeAssign(e, t));
        }
        parseMaybeAssignAllowIn(e, t) {
         return this.allowInAnd(() => this.parseMaybeAssign(e, t));
        }
        setOptionalParametersError(e, t) {
         var r;
         e.optionalParametersLoc = null != (r = null == t ? void 0 : t.loc) ? r : this.state.startLoc;
        }
        parseMaybeAssign(e, t) {
         let r,
          n = this.state.startLoc;
         if (this.isContextual(108) && this.prodParam.hasYield) {
          let e = this.parseYield();
          return t && (e = t.call(this, e, n)), e;
         }
         e ? (r = !1) : ((e = new et()), (r = !0));
         let { type: s } = this.state;
         (10 === s || U(s)) && (this.state.potentialArrowAt = this.state.start);
         let i = this.parseMaybeConditional(e);
         if ((t && (i = t.call(this, i, n)), (a = this.state.type) >= 29 && a <= 33)) {
          let t = this.startNodeAt(n),
           r = this.state.value;
          if (((t.operator = r), this.match(29))) {
           this.toAssignable(i, !0), (t.left = i);
           let r = n.index;
           null != e.doubleProtoLoc && e.doubleProtoLoc.index >= r && (e.doubleProtoLoc = null), null != e.shorthandAssignLoc && e.shorthandAssignLoc.index >= r && (e.shorthandAssignLoc = null), null != e.privateKeyLoc && e.privateKeyLoc.index >= r && (this.checkDestructuringPrivate(e), (e.privateKeyLoc = null));
          } else t.left = i;
          return this.next(), (t.right = this.parseMaybeAssign()), this.checkLVal(i, this.finishNode(t, 'AssignmentExpression')), t;
         }
         var a;
         return r && this.checkExpressionErrors(e, !0), i;
        }
        parseMaybeConditional(e) {
         let t = this.state.startLoc,
          r = this.state.potentialArrowAt,
          n = this.parseExprOps(e);
         return this.shouldExitDescending(n, r) ? n : this.parseConditional(n, t, e);
        }
        parseConditional(e, t, r) {
         if (this.eat(17)) {
          let r = this.startNodeAt(t);
          return (r.test = e), (r.consequent = this.parseMaybeAssignAllowIn()), this.expect(14), (r.alternate = this.parseMaybeAssign()), this.finishNode(r, 'ConditionalExpression');
         }
         return e;
        }
        parseMaybeUnaryOrPrivate(e) {
         return this.match(139) ? this.parsePrivateName() : this.parseMaybeUnary(e);
        }
        parseExprOps(e) {
         let t = this.state.startLoc,
          r = this.state.potentialArrowAt,
          n = this.parseMaybeUnaryOrPrivate(e);
         return this.shouldExitDescending(n, r) ? n : this.parseExprOp(n, t, -1);
        }
        parseExprOp(e, t, r) {
         if (this.isPrivateName(e)) {
          let t = this.getPrivateNameSV(e);
          (r >= K(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(y.PrivateInExpectedIn, e, { identifierName: t }), this.classScope.usePrivateName(t, e.loc.start);
         }
         let n = this.state.type;
         if ((s = n) >= 39 && s <= 59 && (this.prodParam.hasIn || !this.match(58))) {
          let s = K(n);
          if (s > r) {
           if (39 === n) {
            if ((this.expectPlugin('pipelineOperator'), this.state.inFSharpPipelineDirectBody)) return e;
            this.checkPipelineAtInfixOperator(e, t);
           }
           let i = this.startNodeAt(t);
           (i.left = e), (i.operator = this.state.value);
           let a = 41 === n || 42 === n,
            o = 40 === n;
           if ((o && (s = K(42)), this.next(), 39 === n && this.hasPlugin(['pipelineOperator', { proposal: 'minimal' }]) && 96 === this.state.type && this.prodParam.hasAwait)) throw this.raise(y.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
           i.right = this.parseExprOpRightExpr(n, s);
           let u = this.finishNode(i, a || o ? 'LogicalExpression' : 'BinaryExpression'),
            l = this.state.type;
           if ((o && (41 === l || 42 === l)) || (a && 40 === l)) throw this.raise(y.MixingCoalesceWithLogical, this.state.startLoc);
           return this.parseExprOp(u, t, r);
          }
         }
         var s;
         return e;
        }
        parseExprOpRightExpr(e, t) {
         let r = this.state.startLoc;
         if (39 === e) {
          switch (this.getPluginOption('pipelineOperator', 'proposal')) {
           case 'hack':
            return this.withTopicBindingContext(() => this.parseHackPipeBody());
           case 'fsharp':
            return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(t));
          }
          if ('smart' === this.getPluginOption('pipelineOperator', 'proposal'))
           return this.withTopicBindingContext(() => {
            if (this.prodParam.hasYield && this.isContextual(108)) throw this.raise(y.PipeBodyIsTighter, this.state.startLoc);
            return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(e, t), r);
           });
         }
         return this.parseExprOpBaseRightExpr(e, t);
        }
        parseExprOpBaseRightExpr(e, t) {
         let r = this.state.startLoc;
         return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), r, 57 === e ? t - 1 : t);
        }
        parseHackPipeBody() {
         var e;
         let { startLoc: t } = this.state,
          r = this.parseMaybeAssign();
         return p.has(r.type) && !(null != (e = r.extra) && e.parenthesized) && this.raise(y.PipeUnparenthesizedBody, t, { type: r.type }), this.topicReferenceWasUsedInCurrentContext() || this.raise(y.PipeTopicUnused, t), r;
        }
        checkExponentialAfterUnary(e) {
         this.match(57) && this.raise(y.UnexpectedTokenUnaryExponentiation, e.argument);
        }
        parseMaybeUnary(e, t) {
         let r = this.state.startLoc,
          n = this.isContextual(96);
         if (n && this.recordAwaitIfAllowed()) {
          this.next();
          let e = this.parseAwait(r);
          return t || this.checkExponentialAfterUnary(e), e;
         }
         let s = this.match(34),
          i = this.startNode();
         if (((a = this.state.type), M[a])) {
          (i.operator = this.state.value), (i.prefix = !0), this.match(72) && this.expectPlugin('throwExpressions');
          let r = this.match(89);
          if ((this.next(), (i.argument = this.parseMaybeUnary(null, !0)), this.checkExpressionErrors(e, !0), this.state.strict && r)) {
           let e = i.argument;
           'Identifier' === e.type ? this.raise(y.StrictDelete, i) : this.hasPropertyAsPrivateName(e) && this.raise(y.DeletePrivateField, i);
          }
          if (!s) return t || this.checkExponentialAfterUnary(i), this.finishNode(i, 'UnaryExpression');
         }
         var a;
         let o = this.parseUpdate(i, s, e);
         if (n) {
          let { type: e } = this.state;
          if ((this.hasPlugin('v8intrinsic') ? z(e) : z(e) && !this.match(54)) && !this.isAmbiguousAwait()) return this.raiseOverwrite(y.AwaitNotInAsyncContext, r), this.parseAwait(r);
         }
         return o;
        }
        parseUpdate(e, t, r) {
         if (t) {
          let t = e;
          return this.checkLVal(t.argument, this.finishNode(t, 'UpdateExpression')), e;
         }
         let n = this.state.startLoc,
          s = this.parseExprSubscripts(r);
         if (this.checkExpressionErrors(r, !1)) return s;
         for (; 34 === this.state.type && !this.canInsertSemicolon(); ) {
          let e = this.startNodeAt(n);
          (e.operator = this.state.value), (e.prefix = !1), (e.argument = s), this.next(), this.checkLVal(s, (s = this.finishNode(e, 'UpdateExpression')));
         }
         return s;
        }
        parseExprSubscripts(e) {
         let t = this.state.startLoc,
          r = this.state.potentialArrowAt,
          n = this.parseExprAtom(e);
         return this.shouldExitDescending(n, r) ? n : this.parseSubscripts(n, t);
        }
        parseSubscripts(e, t, r) {
         let n = { optionalChainMember: !1, maybeAsyncArrow: this.atPossibleAsyncArrow(e), stop: !1 };
         do {
          (e = this.parseSubscript(e, t, r, n)), (n.maybeAsyncArrow = !1);
         } while (!n.stop);
         return e;
        }
        parseSubscript(e, t, r, n) {
         let { type: s } = this.state;
         if (!r && 15 === s) return this.parseBind(e, t, r, n);
         if (G(s)) return this.parseTaggedTemplateExpression(e, t, n);
         let i = !1;
         if (18 === s) {
          if (r && (this.raise(y.OptionalChainingNoNew, this.state.startLoc), 40 === this.lookaheadCharCode())) return (n.stop = !0), e;
          (n.optionalChainMember = i = !0), this.next();
         }
         if (!r && this.match(10)) return this.parseCoverCallAndAsyncArrowHead(e, t, n, i);
         {
          let r = this.eat(0);
          return r || i || this.eat(16) ? this.parseMember(e, t, n, r, i) : ((n.stop = !0), e);
         }
        }
        parseMember(e, t, r, n, s) {
         let i = this.startNodeAt(t);
         return (i.object = e), (i.computed = n), n ? ((i.property = this.parseExpression()), this.expect(3)) : this.match(139) ? ('Super' === e.type && this.raise(y.SuperPrivateField, t), this.classScope.usePrivateName(this.state.value, this.state.startLoc), (i.property = this.parsePrivateName())) : (i.property = this.parseIdentifier(!0)), r.optionalChainMember ? ((i.optional = s), this.finishNode(i, 'OptionalMemberExpression')) : this.finishNode(i, 'MemberExpression');
        }
        parseBind(e, t, r, n) {
         let s = this.startNodeAt(t);
         return (s.object = e), this.next(), (s.callee = this.parseNoCallExpr()), (n.stop = !0), this.parseSubscripts(this.finishNode(s, 'BindExpression'), t, r);
        }
        parseCoverCallAndAsyncArrowHead(e, t, r, n) {
         let s = this.state.maybeInArrowParameters,
          i = null;
         (this.state.maybeInArrowParameters = !0), this.next();
         let a = this.startNodeAt(t);
         a.callee = e;
         let { maybeAsyncArrow: o, optionalChainMember: u } = r;
         o && (this.expressionScope.enter(new Ke(2)), (i = new et())), u && (a.optional = n), (a.arguments = n ? this.parseCallExpressionArguments(11) : this.parseCallExpressionArguments(11, 'Super' !== e.type, a, i));
         let l = this.finishCallExpression(a, u);
         return o && this.shouldParseAsyncArrow() && !n ? ((r.stop = !0), this.checkDestructuringPrivate(i), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), (l = this.parseAsyncArrowFromCallExpression(this.startNodeAt(t), l))) : (o && (this.checkExpressionErrors(i, !0), this.expressionScope.exit()), this.toReferencedArguments(l)), (this.state.maybeInArrowParameters = s), l;
        }
        toReferencedArguments(e, t) {
         this.toReferencedListDeep(e.arguments, t);
        }
        parseTaggedTemplateExpression(e, t, r) {
         let n = this.startNodeAt(t);
         return (n.tag = e), (n.quasi = this.parseTemplate(!0)), r.optionalChainMember && this.raise(y.OptionalChainingNoTemplate, t), this.finishNode(n, 'TaggedTemplateExpression');
        }
        atPossibleAsyncArrow(e) {
         return 'Identifier' === e.type && 'async' === e.name && this.state.lastTokEndLoc.index === e.end && !this.canInsertSemicolon() && e.end - e.start == 5 && this.offsetToSourcePos(e.start) === this.state.potentialArrowAt;
        }
        finishCallExpression(e, t) {
         if ('Import' === e.callee.type)
          if (0 === e.arguments.length || e.arguments.length > 2) this.raise(y.ImportCallArity, e);
          else for (let r of e.arguments) 'SpreadElement' === r.type && this.raise(y.ImportCallSpreadArgument, r);
         return this.finishNode(e, t ? 'OptionalCallExpression' : 'CallExpression');
        }
        parseCallExpressionArguments(e, t, r, n) {
         let s = [],
          i = !0,
          a = this.state.inFSharpPipelineDirectBody;
         for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(e); ) {
          if (i) i = !1;
          else if ((this.expect(12), this.match(e))) {
           r && this.addTrailingCommaExtraToNode(r), this.next();
           break;
          }
          s.push(this.parseExprListItem(!1, n, t));
         }
         return (this.state.inFSharpPipelineDirectBody = a), s;
        }
        shouldParseAsyncArrow() {
         return this.match(19) && !this.canInsertSemicolon();
        }
        parseAsyncArrowFromCallExpression(e, t) {
         var r;
         return this.resetPreviousNodeTrailingComments(t), this.expect(19), this.parseArrowExpression(e, t.arguments, !0, null == (r = t.extra) ? void 0 : r.trailingCommaLoc), t.innerComments && Ee(e, t.innerComments), t.callee.trailingComments && Ee(e, t.callee.trailingComments), e;
        }
        parseNoCallExpr() {
         let e = this.state.startLoc;
         return this.parseSubscripts(this.parseExprAtom(), e, !0);
        }
        parseExprAtom(e) {
         let t,
          r = null,
          { type: n } = this.state;
         switch (n) {
          case 79:
           return this.parseSuper();
          case 83:
           return (t = this.startNode()), this.next(), this.match(16) ? this.parseImportMetaProperty(t) : this.match(10) ? (256 & this.optionFlags ? this.parseImportCall(t) : this.finishNode(t, 'Import')) : (this.raise(y.UnsupportedImport, this.state.lastTokStartLoc), this.finishNode(t, 'Import'));
          case 78:
           return (t = this.startNode()), this.next(), this.finishNode(t, 'ThisExpression');
          case 90:
           return this.parseDo(this.startNode(), !1);
          case 56:
          case 31:
           return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
          case 135:
           return this.parseNumericLiteral(this.state.value);
          case 136:
           return this.parseBigIntLiteral(this.state.value);
          case 134:
           return this.parseStringLiteral(this.state.value);
          case 84:
           return this.parseNullLiteral();
          case 85:
           return this.parseBooleanLiteral(!0);
          case 86:
           return this.parseBooleanLiteral(!1);
          case 10: {
           let e = this.state.potentialArrowAt === this.state.start;
           return this.parseParenAndDistinguishExpression(e);
          }
          case 2:
          case 1:
           return this.parseArrayLike(2 === this.state.type ? 4 : 3, !1, !0);
          case 0:
           return this.parseArrayLike(3, !0, !1, e);
          case 6:
          case 7:
           return this.parseObjectLike(6 === this.state.type ? 9 : 8, !1, !0);
          case 5:
           return this.parseObjectLike(8, !1, !1, e);
          case 68:
           return this.parseFunctionOrFunctionSent();
          case 26:
           r = this.parseDecorators();
          case 80:
           return this.parseClass(this.maybeTakeDecorators(r, this.startNode()), !1);
          case 77:
           return this.parseNewOrNewTarget();
          case 25:
          case 24:
           return this.parseTemplate(!1);
          case 15: {
           (t = this.startNode()), this.next(), (t.object = null);
           let e = (t.callee = this.parseNoCallExpr());
           if ('MemberExpression' === e.type) return this.finishNode(t, 'BindExpression');
           throw this.raise(y.UnsupportedBind, e);
          }
          case 139:
           return this.raise(y.PrivateInExpectedIn, this.state.startLoc, { identifierName: this.state.value }), this.parsePrivateName();
          case 33:
           return this.parseTopicReferenceThenEqualsSign(54, '%');
          case 32:
           return this.parseTopicReferenceThenEqualsSign(44, '^');
          case 37:
          case 38:
           return this.parseTopicReference('hack');
          case 44:
          case 54:
          case 27: {
           let e = this.getPluginOption('pipelineOperator', 'proposal');
           if (e) return this.parseTopicReference(e);
           this.unexpected();
           break;
          }
          case 47: {
           let e = this.input.codePointAt(this.nextTokenStart());
           se(e) || 62 === e ? this.expectOnePlugin(['jsx', 'flow', 'typescript']) : this.unexpected();
           break;
          }
          default:
           if (137 === n) return this.parseDecimalLiteral(this.state.value);
           if (U(n)) {
            if (this.isContextual(127) && 123 === this.lookaheadInLineCharCode()) return this.parseModuleExpression();
            let e = this.state.potentialArrowAt === this.state.start,
             t = this.state.containsEsc,
             r = this.parseIdentifier();
            if (!t && 'async' === r.name && !this.canInsertSemicolon()) {
             let { type: e } = this.state;
             if (68 === e) return this.resetPreviousNodeTrailingComments(r), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(r));
             if (U(e)) return 61 === this.lookaheadCharCode() ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(r)) : r;
             if (90 === e) return this.resetPreviousNodeTrailingComments(r), this.parseDo(this.startNodeAtNode(r), !0);
            }
            return e && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(r), [r], !1)) : r;
           }
           this.unexpected();
         }
        }
        parseTopicReferenceThenEqualsSign(e, t) {
         let r = this.getPluginOption('pipelineOperator', 'proposal');
         if (r) return (this.state.type = e), (this.state.value = t), this.state.pos--, this.state.end--, (this.state.endLoc = s(this.state.endLoc, -1)), this.parseTopicReference(r);
         this.unexpected();
        }
        parseTopicReference(e) {
         let t = this.startNode(),
          r = this.state.startLoc,
          n = this.state.type;
         return this.next(), this.finishTopicReference(t, r, e, n);
        }
        finishTopicReference(e, t, r, n) {
         if (this.testTopicReferenceConfiguration(r, t, n)) return 'hack' === r ? (this.topicReferenceIsAllowedInCurrentContext() || this.raise(y.PipeTopicUnbound, t), this.registerTopicReference(), this.finishNode(e, 'TopicReference')) : (this.topicReferenceIsAllowedInCurrentContext() || this.raise(y.PrimaryTopicNotAllowed, t), this.registerTopicReference(), this.finishNode(e, 'PipelinePrimaryTopicReference'));
         throw this.raise(y.PipeTopicUnconfiguredToken, t, { token: J(n) });
        }
        testTopicReferenceConfiguration(e, t, r) {
         switch (e) {
          case 'hack':
           return this.hasPlugin(['pipelineOperator', { topicToken: J(r) }]);
          case 'smart':
           return 27 === r;
          default:
           throw this.raise(y.PipeTopicRequiresHackPipes, t);
         }
        }
        parseAsyncArrowUnaryFunction(e) {
         this.prodParam.enter(Qe(!0, this.prodParam.hasYield));
         let t = [this.parseIdentifier()];
         return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(y.LineTerminatorBeforeArrow, this.state.curPosition()), this.expect(19), this.parseArrowExpression(e, t, !0);
        }
        parseDo(e, t) {
         this.expectPlugin('doExpressions'), t && this.expectPlugin('asyncDoExpressions'), (e.async = t), this.next();
         let r = this.state.labels;
         return (this.state.labels = []), t ? (this.prodParam.enter(2), (e.body = this.parseBlock()), this.prodParam.exit()) : (e.body = this.parseBlock()), (this.state.labels = r), this.finishNode(e, 'DoExpression');
        }
        parseSuper() {
         let e = this.startNode();
         return this.next(), !this.match(10) || this.scope.allowDirectSuper || 16 & this.optionFlags ? !this.scope.allowSuper && !(16 & this.optionFlags) && this.raise(y.UnexpectedSuper, e) : this.raise(y.SuperNotAllowed, e), !this.match(10) && !this.match(0) && !this.match(16) && this.raise(y.UnsupportedSuper, e), this.finishNode(e, 'Super');
        }
        parsePrivateName() {
         let e = this.startNode(),
          t = this.startNodeAt(s(this.state.startLoc, 1)),
          r = this.state.value;
         return this.next(), (e.id = this.createIdentifier(t, r)), this.finishNode(e, 'PrivateName');
        }
        parseFunctionOrFunctionSent() {
         let e = this.startNode();
         if ((this.next(), this.prodParam.hasYield && this.match(16))) {
          let t = this.createIdentifier(this.startNodeAtNode(e), 'function');
          return this.next(), this.match(103) ? this.expectPlugin('functionSent') : this.hasPlugin('functionSent') || this.unexpected(), this.parseMetaProperty(e, t, 'sent');
         }
         return this.parseFunction(e);
        }
        parseMetaProperty(e, t, r) {
         e.meta = t;
         let n = this.state.containsEsc;
         return (e.property = this.parseIdentifier(!0)), (e.property.name !== r || n) && this.raise(y.UnsupportedMetaProperty, e.property, { target: t.name, onlyValidPropertyName: r }), this.finishNode(e, 'MetaProperty');
        }
        parseImportMetaProperty(e) {
         let t = this.createIdentifier(this.startNodeAtNode(e), 'import');
         if ((this.next(), this.isContextual(101))) this.inModule || this.raise(y.ImportMetaOutsideModule, t), (this.sawUnambiguousESM = !0);
         else if (this.isContextual(105) || this.isContextual(97)) {
          let t = this.isContextual(105);
          if ((this.expectPlugin(t ? 'sourcePhaseImports' : 'deferredImportEvaluation'), !(256 & this.optionFlags))) throw this.raise(y.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, { phase: this.state.value });
          return this.next(), (e.phase = t ? 'source' : 'defer'), this.parseImportCall(e);
         }
         return this.parseMetaProperty(e, t, 'meta');
        }
        parseLiteralAtNode(e, t, r) {
         return this.addExtra(r, 'rawValue', e), this.addExtra(r, 'raw', this.input.slice(this.offsetToSourcePos(r.start), this.state.end)), (r.value = e), this.next(), this.finishNode(r, t);
        }
        parseLiteral(e, t) {
         let r = this.startNode();
         return this.parseLiteralAtNode(e, t, r);
        }
        parseStringLiteral(e) {
         return this.parseLiteral(e, 'StringLiteral');
        }
        parseNumericLiteral(e) {
         return this.parseLiteral(e, 'NumericLiteral');
        }
        parseBigIntLiteral(e) {
         return this.parseLiteral(e, 'BigIntLiteral');
        }
        parseDecimalLiteral(e) {
         return this.parseLiteral(e, 'DecimalLiteral');
        }
        parseRegExpLiteral(e) {
         let t = this.startNode();
         return this.addExtra(t, 'raw', this.input.slice(this.offsetToSourcePos(t.start), this.state.end)), (t.pattern = e.pattern), (t.flags = e.flags), this.next(), this.finishNode(t, 'RegExpLiteral');
        }
        parseBooleanLiteral(e) {
         let t = this.startNode();
         return (t.value = e), this.next(), this.finishNode(t, 'BooleanLiteral');
        }
        parseNullLiteral() {
         let e = this.startNode();
         return this.next(), this.finishNode(e, 'NullLiteral');
        }
        parseParenAndDistinguishExpression(e) {
         let t,
          r = this.state.startLoc;
         this.next(), this.expressionScope.enter(new Ke(1));
         let n = this.state.maybeInArrowParameters,
          s = this.state.inFSharpPipelineDirectBody;
         (this.state.maybeInArrowParameters = !0), (this.state.inFSharpPipelineDirectBody = !1);
         let i,
          a,
          o = this.state.startLoc,
          u = [],
          l = new et(),
          p = !0;
         for (; !this.match(11); ) {
          if (p) p = !1;
          else if ((this.expect(12, null === l.optionalParametersLoc ? null : l.optionalParametersLoc), this.match(11))) {
           a = this.state.startLoc;
           break;
          }
          if (this.match(21)) {
           let e = this.state.startLoc;
           if (((i = this.state.startLoc), u.push(this.parseParenItem(this.parseRestBinding(), e)), !this.checkCommaAfterRest(41))) break;
          } else u.push(this.parseMaybeAssignAllowIn(l, this.parseParenItem));
         }
         let c = this.state.lastTokEndLoc;
         this.expect(11), (this.state.maybeInArrowParameters = n), (this.state.inFSharpPipelineDirectBody = s);
         let h = this.startNodeAt(r);
         return e && this.shouldParseArrow(u) && (h = this.parseArrow(h)) ? (this.checkDestructuringPrivate(l), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(h, u, !1), h) : (this.expressionScope.exit(), u.length || this.unexpected(this.state.lastTokStartLoc), a && this.unexpected(a), i && this.unexpected(i), this.checkExpressionErrors(l, !0), this.toReferencedListDeep(u, !0), u.length > 1 ? ((t = this.startNodeAt(o)), (t.expressions = u), this.finishNode(t, 'SequenceExpression'), this.resetEndLocation(t, c)) : (t = u[0]), this.wrapParenthesis(r, t));
        }
        wrapParenthesis(e, t) {
         if (!(512 & this.optionFlags)) return this.addExtra(t, 'parenthesized', !0), this.addExtra(t, 'parenStart', e.index), this.takeSurroundingComments(t, e.index, this.state.lastTokEndLoc.index), t;
         let r = this.startNodeAt(e);
         return (r.expression = t), this.finishNode(r, 'ParenthesizedExpression');
        }
        shouldParseArrow(e) {
         return !this.canInsertSemicolon();
        }
        parseArrow(e) {
         if (this.eat(19)) return e;
        }
        parseParenItem(e, t) {
         return e;
        }
        parseNewOrNewTarget() {
         let e = this.startNode();
         if ((this.next(), this.match(16))) {
          let t = this.createIdentifier(this.startNodeAtNode(e), 'new');
          this.next();
          let r = this.parseMetaProperty(e, t, 'target');
          return !this.scope.inNonArrowFunction && !this.scope.inClass && !(4 & this.optionFlags) && this.raise(y.UnexpectedNewTarget, r), r;
         }
         return this.parseNew(e);
        }
        parseNew(e) {
         if ((this.parseNewCallee(e), this.eat(10))) {
          let t = this.parseExprList(11);
          this.toReferencedList(t), (e.arguments = t);
         } else e.arguments = [];
         return this.finishNode(e, 'NewExpression');
        }
        parseNewCallee(e) {
         let t = this.match(83),
          r = this.parseNoCallExpr();
         (e.callee = r), t && ('Import' === r.type || 'ImportExpression' === r.type) && this.raise(y.ImportCallNotNewExpression, r);
        }
        parseTemplateElement(e) {
         let { start: t, startLoc: r, end: n, value: i } = this.state,
          a = t + 1,
          o = this.startNodeAt(s(r, 1));
         null === i && (e || this.raise(y.InvalidEscapeSequenceTemplate, s(this.state.firstInvalidTemplateEscapePos, 1)));
         let u = this.match(24),
          l = u ? -1 : -2,
          p = n + l;
         (o.value = { raw: this.input.slice(a, p).replace(/\r\n?/g, '\n'), cooked: null === i ? null : i.slice(1, l) }), (o.tail = u), this.next();
         let c = this.finishNode(o, 'TemplateElement');
         return this.resetEndLocation(c, s(this.state.lastTokEndLoc, l)), c;
        }
        parseTemplate(e) {
         let t = this.startNode(),
          r = this.parseTemplateElement(e),
          n = [r],
          s = [];
         for (; !r.tail; ) s.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), n.push((r = this.parseTemplateElement(e)));
         return (t.expressions = s), (t.quasis = n), this.finishNode(t, 'TemplateLiteral');
        }
        parseTemplateSubstitution() {
         return this.parseExpression();
        }
        parseObjectLike(e, t, r, n) {
         r && this.expectPlugin('recordAndTuple');
         let s = this.state.inFSharpPipelineDirectBody;
         this.state.inFSharpPipelineDirectBody = !1;
         let i = Object.create(null),
          a = !0,
          o = this.startNode();
         for (o.properties = [], this.next(); !this.match(e); ) {
          if (a) a = !1;
          else if ((this.expect(12), this.match(e))) {
           this.addTrailingCommaExtraToNode(o);
           break;
          }
          let s;
          t ? (s = this.parseBindingProperty()) : ((s = this.parsePropertyDefinition(n)), this.checkProto(s, r, i, n)), r && !this.isObjectProperty(s) && 'SpreadElement' !== s.type && this.raise(y.InvalidRecordProperty, s), s.shorthand && this.addExtra(s, 'shorthand', !0), o.properties.push(s);
         }
         this.next(), (this.state.inFSharpPipelineDirectBody = s);
         let u = 'ObjectExpression';
         return t ? (u = 'ObjectPattern') : r && (u = 'RecordExpression'), this.finishNode(o, u);
        }
        addTrailingCommaExtraToNode(e) {
         this.addExtra(e, 'trailingComma', this.state.lastTokStartLoc.index), this.addExtra(e, 'trailingCommaLoc', this.state.lastTokStartLoc, !1);
        }
        maybeAsyncOrAccessorProp(e) {
         return !e.computed && 'Identifier' === e.key.type && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
        }
        parsePropertyDefinition(e) {
         let t = [];
         if (this.match(26)) for (this.hasPlugin('decorators') && this.raise(y.UnsupportedPropertyDecorator, this.state.startLoc); this.match(26); ) t.push(this.parseDecorator());
         let r,
          n = this.startNode(),
          s = !1,
          i = !1;
         if (this.match(21)) return t.length && this.unexpected(), this.parseSpread();
         t.length && ((n.decorators = t), (t = [])), (n.method = !1), e && (r = this.state.startLoc);
         let a = this.eat(55);
         this.parsePropertyNamePrefixOperator(n);
         let o = this.state.containsEsc;
         if ((this.parsePropertyName(n, e), !a && !o && this.maybeAsyncOrAccessorProp(n))) {
          let { key: e } = n,
           t = e.name;
          'async' === t && !this.hasPrecedingLineBreak() && ((s = !0), this.resetPreviousNodeTrailingComments(e), (a = this.eat(55)), this.parsePropertyName(n)), ('get' === t || 'set' === t) && ((i = !0), this.resetPreviousNodeTrailingComments(e), (n.kind = t), this.match(55) && ((a = !0), this.raise(y.AccessorIsGenerator, this.state.curPosition(), { kind: t }), this.next()), this.parsePropertyName(n));
         }
         return this.parseObjPropValue(n, r, a, s, !1, i, e);
        }
        getGetterSetterExpectedParamCount(e) {
         return 'get' === e.kind ? 0 : 1;
        }
        getObjectOrClassMethodParams(e) {
         return e.params;
        }
        checkGetterSetterParams(e) {
         var t;
         let r = this.getGetterSetterExpectedParamCount(e),
          n = this.getObjectOrClassMethodParams(e);
         n.length !== r && this.raise('get' === e.kind ? y.BadGetterArity : y.BadSetterArity, e), 'set' === e.kind && 'RestElement' === (null == (t = n[n.length - 1]) ? void 0 : t.type) && this.raise(y.BadSetterRestParameter, e);
        }
        parseObjectMethod(e, t, r, n, s) {
         if (s) {
          let r = this.parseMethod(e, t, !1, !1, !1, 'ObjectMethod');
          return this.checkGetterSetterParams(r), r;
         }
         if (r || t || this.match(10)) return n && this.unexpected(), (e.kind = 'method'), (e.method = !0), this.parseMethod(e, t, r, !1, !1, 'ObjectMethod');
        }
        parseObjectProperty(e, t, r, n) {
         if (((e.shorthand = !1), this.eat(14))) return (e.value = r ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(n)), this.finishNode(e, 'ObjectProperty');
         if (!e.computed && 'Identifier' === e.key.type) {
          if ((this.checkReservedWord(e.key.name, e.key.loc.start, !0, !1), r)) e.value = this.parseMaybeDefault(t, nt(e.key));
          else if (this.match(29)) {
           let r = this.state.startLoc;
           null != n ? null === n.shorthandAssignLoc && (n.shorthandAssignLoc = r) : this.raise(y.InvalidCoverInitializedName, r), (e.value = this.parseMaybeDefault(t, nt(e.key)));
          } else e.value = nt(e.key);
          return (e.shorthand = !0), this.finishNode(e, 'ObjectProperty');
         }
        }
        parseObjPropValue(e, t, r, n, s, i, a) {
         let o = this.parseObjectMethod(e, r, n, s, i) || this.parseObjectProperty(e, t, s, a);
         return o || this.unexpected(), o;
        }
        parsePropertyName(e, t) {
         if (this.eat(0)) (e.computed = !0), (e.key = this.parseMaybeAssignAllowIn()), this.expect(3);
         else {
          let r,
           { type: n, value: s } = this.state;
          if ($(n)) r = this.parseIdentifier(!0);
          else
           switch (n) {
            case 135:
             r = this.parseNumericLiteral(s);
             break;
            case 134:
             r = this.parseStringLiteral(s);
             break;
            case 136:
             r = this.parseBigIntLiteral(s);
             break;
            case 139: {
             let e = this.state.startLoc;
             null != t ? null === t.privateKeyLoc && (t.privateKeyLoc = e) : this.raise(y.UnexpectedPrivateField, e), (r = this.parsePrivateName());
             break;
            }
            default:
             if (137 === n) {
              r = this.parseDecimalLiteral(s);
              break;
             }
             this.unexpected();
           }
          (e.key = r), 139 !== n && (e.computed = !1);
         }
        }
        initFunction(e, t) {
         (e.id = null), (e.generator = !1), (e.async = t);
        }
        parseMethod(e, t, r, n, s, i, a = !1) {
         this.initFunction(e, r), (e.generator = t), this.scope.enter(18 | (a ? 64 : 0) | (s ? 32 : 0)), this.prodParam.enter(Qe(r, e.generator)), this.parseFunctionParams(e, n);
         let o = this.parseFunctionBodyAndFinish(e, i, !0);
         return this.prodParam.exit(), this.scope.exit(), o;
        }
        parseArrayLike(e, t, r, n) {
         r && this.expectPlugin('recordAndTuple');
         let s = this.state.inFSharpPipelineDirectBody;
         this.state.inFSharpPipelineDirectBody = !1;
         let i = this.startNode();
         return this.next(), (i.elements = this.parseExprList(e, !r, n, i)), (this.state.inFSharpPipelineDirectBody = s), this.finishNode(i, r ? 'TupleExpression' : 'ArrayExpression');
        }
        parseArrowExpression(e, t, r, n) {
         this.scope.enter(6);
         let s = Qe(r, !1);
         !this.match(5) && this.prodParam.hasIn && (s |= 8), this.prodParam.enter(s), this.initFunction(e, r);
         let i = this.state.maybeInArrowParameters;
         return t && ((this.state.maybeInArrowParameters = !0), this.setArrowFunctionParameters(e, t, n)), (this.state.maybeInArrowParameters = !1), this.parseFunctionBody(e, !0), this.prodParam.exit(), this.scope.exit(), (this.state.maybeInArrowParameters = i), this.finishNode(e, 'ArrowFunctionExpression');
        }
        setArrowFunctionParameters(e, t, r) {
         this.toAssignableList(t, r, !1), (e.params = t);
        }
        parseFunctionBodyAndFinish(e, t, r = !1) {
         return this.parseFunctionBody(e, !1, r), this.finishNode(e, t);
        }
        parseFunctionBody(e, t, r = !1) {
         let n = t && !this.match(5);
         if ((this.expressionScope.enter(Xe()), n)) (e.body = this.parseMaybeAssign()), this.checkParams(e, !1, t, !1);
         else {
          let n = this.state.strict,
           s = this.state.labels;
          (this.state.labels = []),
           this.prodParam.enter(4 | this.prodParam.currentFlags()),
           (e.body = this.parseBlock(!0, !1, (s) => {
            let i = !this.isSimpleParamList(e.params);
            s && i && this.raise(y.IllegalLanguageModeDirective, ('method' !== e.kind && 'constructor' !== e.kind) || !e.key ? e : e.key.loc.end);
            let a = !n && this.state.strict;
            this.checkParams(e, !(this.state.strict || t || r || i), t, a), this.state.strict && e.id && this.checkIdentifier(e.id, 65, a);
           })),
           this.prodParam.exit(),
           (this.state.labels = s);
         }
         this.expressionScope.exit();
        }
        isSimpleParameter(e) {
         return 'Identifier' === e.type;
        }
        isSimpleParamList(e) {
         for (let t = 0, r = e.length; t < r; t++) if (!this.isSimpleParameter(e[t])) return !1;
         return !0;
        }
        checkParams(e, t, r, n = !0) {
         let s = !t && new Set(),
          i = { type: 'FormalParameters' };
         for (let a of e.params) this.checkLVal(a, i, 5, s, n);
        }
        parseExprList(e, t, r, n) {
         let s = [],
          i = !0;
         for (; !this.eat(e); ) {
          if (i) i = !1;
          else if ((this.expect(12), this.match(e))) {
           n && this.addTrailingCommaExtraToNode(n), this.next();
           break;
          }
          s.push(this.parseExprListItem(t, r));
         }
         return s;
        }
        parseExprListItem(e, t, r) {
         let n;
         if (this.match(12)) e || this.raise(y.UnexpectedToken, this.state.curPosition(), { unexpected: ',' }), (n = null);
         else if (this.match(21)) {
          let e = this.state.startLoc;
          n = this.parseParenItem(this.parseSpread(t), e);
         } else if (this.match(17)) {
          this.expectPlugin('partialApplication'), r || this.raise(y.UnexpectedArgumentPlaceholder, this.state.startLoc);
          let e = this.startNode();
          this.next(), (n = this.finishNode(e, 'ArgumentPlaceholder'));
         } else n = this.parseMaybeAssignAllowIn(t, this.parseParenItem);
         return n;
        }
        parseIdentifier(e) {
         let t = this.startNode(),
          r = this.parseIdentifierName(e);
         return this.createIdentifier(t, r);
        }
        createIdentifier(e, t) {
         return (e.name = t), (e.loc.identifierName = t), this.finishNode(e, 'Identifier');
        }
        parseIdentifierName(e) {
         let t,
          { startLoc: r, type: n } = this.state;
         $(n) ? (t = this.state.value) : this.unexpected();
         let s = n <= 92;
         return e ? s && this.replaceToken(132) : this.checkReservedWord(t, r, s, !1), this.next(), t;
        }
        checkReservedWord(e, t, r, n) {
         var s;
         if (!(e.length > 10) && ((s = e), me.has(s)))
          if (
           r &&
           (function (e) {
            return ue.has(e);
           })(e)
          )
           this.raise(y.UnexpectedKeyword, t, { keyword: e });
          else if ((this.state.strict ? (n ? fe : he) : ce)(e, this.inModule)) this.raise(y.UnexpectedReservedWord, t, { reservedWord: e });
          else if ('yield' === e) {
           if (this.prodParam.hasYield) return void this.raise(y.YieldBindingIdentifier, t);
          } else if ('await' === e) {
           if (this.prodParam.hasAwait) return void this.raise(y.AwaitBindingIdentifier, t);
           if (this.scope.inStaticBlock) return void this.raise(y.AwaitBindingIdentifierInStaticBlock, t);
           this.expressionScope.recordAsyncArrowParametersError(t);
          } else if ('arguments' === e && this.scope.inClassAndNotInNonArrowFunction) return void this.raise(y.ArgumentsInClass, t);
        }
        recordAwaitIfAllowed() {
         let e = this.prodParam.hasAwait || (1 & this.optionFlags && !this.scope.inFunction);
         return e && !this.scope.inFunction && (this.state.hasTopLevelAwait = !0), e;
        }
        parseAwait(e) {
         let t = this.startNodeAt(e);
         return this.expressionScope.recordParameterInitializerError(y.AwaitExpressionFormalParameter, t), this.eat(55) && this.raise(y.ObsoleteAwaitStar, t), !this.scope.inFunction && !(1 & this.optionFlags) && (this.isAmbiguousAwait() ? (this.ambiguousScriptDifferentAst = !0) : (this.sawUnambiguousESM = !0)), this.state.soloAwait || (t.argument = this.parseMaybeUnary(null, !0)), this.finishNode(t, 'AwaitExpression');
        }
        isAmbiguousAwait() {
         if (this.hasPrecedingLineBreak()) return !0;
         let { type: e } = this.state;
         return 53 === e || 10 === e || 0 === e || G(e) || (102 === e && !this.state.containsEsc) || 138 === e || 56 === e || (this.hasPlugin('v8intrinsic') && 54 === e);
        }
        parseYield() {
         let e = this.startNode();
         this.expressionScope.recordParameterInitializerError(y.YieldInParameter, e), this.next();
         let t = !1,
          r = null;
         if (!this.hasPrecedingLineBreak())
          switch (((t = this.eat(55)), this.state.type)) {
           case 13:
           case 140:
           case 8:
           case 11:
           case 3:
           case 9:
           case 14:
           case 12:
            if (!t) break;
           default:
            r = this.parseMaybeAssign();
          }
         return (e.delegate = t), (e.argument = r), this.finishNode(e, 'YieldExpression');
        }
        parseImportCall(e) {
         if ((this.next(), (e.source = this.parseMaybeAssignAllowIn()), (e.options = null), this.eat(12) && !this.match(11) && ((e.options = this.parseMaybeAssignAllowIn()), this.eat(12) && !this.match(11)))) {
          do {
           this.parseMaybeAssignAllowIn();
          } while (this.eat(12) && !this.match(11));
          this.raise(y.ImportCallArity, e);
         }
         return this.expect(11), this.finishNode(e, 'ImportExpression');
        }
        checkPipelineAtInfixOperator(e, t) {
         this.hasPlugin(['pipelineOperator', { proposal: 'smart' }]) && 'SequenceExpression' === e.type && this.raise(y.PipelineHeadSequenceExpression, t);
        }
        parseSmartPipelineBodyInStyle(e, t) {
         if (this.isSimpleReference(e)) {
          let r = this.startNodeAt(t);
          return (r.callee = e), this.finishNode(r, 'PipelineBareFunction');
         }
         {
          let r = this.startNodeAt(t);
          return this.checkSmartPipeTopicBodyEarlyErrors(t), (r.expression = e), this.finishNode(r, 'PipelineTopicExpression');
         }
        }
        isSimpleReference(e) {
         switch (e.type) {
          case 'MemberExpression':
           return !e.computed && this.isSimpleReference(e.object);
          case 'Identifier':
           return !0;
          default:
           return !1;
         }
        }
        checkSmartPipeTopicBodyEarlyErrors(e) {
         if (this.match(19)) throw this.raise(y.PipelineBodyNoArrow, this.state.startLoc);
         this.topicReferenceWasUsedInCurrentContext() || this.raise(y.PipelineTopicUnused, e);
        }
        withTopicBindingContext(e) {
         let t = this.state.topicContext;
         this.state.topicContext = { maxNumOfResolvableTopics: 1, maxTopicIndex: null };
         try {
          return e();
         } finally {
          this.state.topicContext = t;
         }
        }
        withSmartMixTopicForbiddingContext(e) {
         if (!this.hasPlugin(['pipelineOperator', { proposal: 'smart' }])) return e();
         {
          let t = this.state.topicContext;
          this.state.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null };
          try {
           return e();
          } finally {
           this.state.topicContext = t;
          }
         }
        }
        withSoloAwaitPermittingContext(e) {
         let t = this.state.soloAwait;
         this.state.soloAwait = !0;
         try {
          return e();
         } finally {
          this.state.soloAwait = t;
         }
        }
        allowInAnd(e) {
         let t = this.prodParam.currentFlags();
         if (8 & ~t) {
          this.prodParam.enter(8 | t);
          try {
           return e();
          } finally {
           this.prodParam.exit();
          }
         }
         return e();
        }
        disallowInAnd(e) {
         let t = this.prodParam.currentFlags();
         if (8 & t) {
          this.prodParam.enter(-9 & t);
          try {
           return e();
          } finally {
           this.prodParam.exit();
          }
         }
         return e();
        }
        registerTopicReference() {
         this.state.topicContext.maxTopicIndex = 0;
        }
        topicReferenceIsAllowedInCurrentContext() {
         return this.state.topicContext.maxNumOfResolvableTopics >= 1;
        }
        topicReferenceWasUsedInCurrentContext() {
         return null != this.state.topicContext.maxTopicIndex && this.state.topicContext.maxTopicIndex >= 0;
        }
        parseFSharpPipelineBody(e) {
         let t = this.state.startLoc;
         this.state.potentialArrowAt = this.state.start;
         let r = this.state.inFSharpPipelineDirectBody;
         this.state.inFSharpPipelineDirectBody = !0;
         let n = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), t, e);
         return (this.state.inFSharpPipelineDirectBody = r), n;
        }
        parseModuleExpression() {
         this.expectPlugin('moduleBlocks');
         let e = this.startNode();
         this.next(), this.match(5) || this.unexpected(null, 5);
         let t = this.startNodeAt(this.state.endLoc);
         this.next();
         let r = this.initializeScopes(!0);
         this.enterInitialScopes();
         try {
          e.body = this.parseProgram(t, 8, 'module');
         } finally {
          r();
         }
         return this.finishNode(e, 'ModuleExpression');
        }
        parsePropertyNamePrefixOperator(e) {}
       },
       Nt = { kind: 1 },
       Bt = { kind: 2 },
       _t = /[\uD800-\uDFFF]/u,
       Lt = /in(?:stanceof)?/y,
       Ot = class extends It {
        parseTopLevel(e, t) {
         return (
          (e.program = this.parseProgram(t)),
          (e.comments = this.comments),
          128 & this.optionFlags &&
           (e.tokens = (function (e, t, r) {
            for (let n = 0; n < e.length; n++) {
             let i = e[n],
              { type: a } = i;
             if ('number' == typeof a) {
              if (139 === a) {
               let { loc: t, start: r, value: a, end: o } = i,
                u = r + 1,
                l = s(t.start, 1);
               e.splice(n, 1, new He({ type: X(27), value: '#', start: r, end: u, startLoc: t.start, endLoc: l }), new He({ type: X(132), value: a, start: u, end: o, startLoc: l, endLoc: t.end })), n++;
               continue;
              }
              if (G(a)) {
               let o,
                u,
                l,
                p,
                c,
                { loc: h, start: d, value: f, end: m } = i,
                y = d + 1,
                g = s(h.start, 1);
               (o = 96 === t.charCodeAt(d - r) ? new He({ type: X(22), value: '`', start: d, end: y, startLoc: h.start, endLoc: g }) : new He({ type: X(8), value: '}', start: d, end: y, startLoc: h.start, endLoc: g })), 24 === a ? ((l = m - 1), (p = s(h.end, -1)), (u = null === f ? null : f.slice(1, -1)), (c = new He({ type: X(22), value: '`', start: l, end: m, startLoc: p, endLoc: h.end }))) : ((l = m - 2), (p = s(h.end, -2)), (u = null === f ? null : f.slice(1, -2)), (c = new He({ type: X(23), value: '${', start: l, end: m, startLoc: p, endLoc: h.end }))), e.splice(n, 1, o, new He({ type: X(20), value: u, start: y, end: l, startLoc: g, endLoc: p }), c), (n += 2);
               continue;
              }
              i.type = X(a);
             }
            }
            return e;
           })(this.tokens, this.input, this.startIndex)),
          this.finishNode(e, 'File')
         );
        }
        parseProgram(e, t = 140, r = this.options.sourceType) {
         if (((e.sourceType = r), (e.interpreter = this.parseInterpreterDirective()), this.parseBlockBody(e, !0, !0, t), this.inModule)) {
          if (!(32 & this.optionFlags) && this.scope.undefinedExports.size > 0) for (let [e, t] of Array.from(this.scope.undefinedExports)) this.raise(y.ModuleExportUndefined, t, { localName: e });
          this.addExtra(e, 'topLevelAwait', this.state.hasTopLevelAwait);
         }
         let n;
         return (n = 140 === t ? this.finishNode(e, 'Program') : this.finishNodeAt(e, 'Program', s(this.state.startLoc, -1))), n;
        }
        stmtToDirective(e) {
         let t = e;
         (t.type = 'Directive'), (t.value = t.expression), delete t.expression;
         let r = t.value,
          n = r.value,
          s = this.input.slice(this.offsetToSourcePos(r.start), this.offsetToSourcePos(r.end)),
          i = (r.value = s.slice(1, -1));
         return this.addExtra(r, 'raw', s), this.addExtra(r, 'rawValue', i), this.addExtra(r, 'expressionValue', n), (r.type = 'DirectiveLiteral'), t;
        }
        parseInterpreterDirective() {
         if (!this.match(28)) return null;
         let e = this.startNode();
         return (e.value = this.state.value), this.next(), this.finishNode(e, 'InterpreterDirective');
        }
        isLet() {
         return !!this.isContextual(100) && this.hasFollowingBindingAtom();
        }
        chStartsBindingIdentifier(e, t) {
         if (se(e)) {
          if (((Lt.lastIndex = t), Lt.test(this.input))) {
           let e = this.codePointAtPos(Lt.lastIndex);
           if (!ie(e) && 92 !== e) return !1;
          }
          return !0;
         }
         return 92 === e;
        }
        chStartsBindingPattern(e) {
         return 91 === e || 123 === e;
        }
        hasFollowingBindingAtom() {
         let e = this.nextTokenStart(),
          t = this.codePointAtPos(e);
         return this.chStartsBindingPattern(t) || this.chStartsBindingIdentifier(t, e);
        }
        hasInLineFollowingBindingIdentifierOrBrace() {
         let e = this.nextTokenInLineStart(),
          t = this.codePointAtPos(e);
         return 123 === t || this.chStartsBindingIdentifier(t, e);
        }
        startsUsingForOf() {
         let { type: e, containsEsc: t } = this.lookahead();
         return !(102 === e && !t) && (U(e) && !this.hasFollowingLineBreak() ? (this.expectPlugin('explicitResourceManagement'), !0) : void 0);
        }
        startsAwaitUsing() {
         let e = this.nextTokenInLineStart();
         if (this.isUnparsedContextual(e, 'using')) {
          e = this.nextTokenInLineStartSince(e + 5);
          let t = this.codePointAtPos(e);
          if (this.chStartsBindingIdentifier(t, e)) return this.expectPlugin('explicitResourceManagement'), !0;
         }
         return !1;
        }
        parseModuleItem() {
         return this.parseStatementLike(15);
        }
        parseStatementListItem() {
         return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
        }
        parseStatementOrSloppyAnnexBFunctionDeclaration(e = !1) {
         let t = 0;
         return this.options.annexB && !this.state.strict && ((t |= 4), e && (t |= 8)), this.parseStatementLike(t);
        }
        parseStatement() {
         return this.parseStatementLike(0);
        }
        parseStatementLike(e) {
         let t = null;
         return this.match(26) && (t = this.parseDecorators(!0)), this.parseStatementContent(e, t);
        }
        parseStatementContent(e, t) {
         let r = this.state.type,
          n = this.startNode(),
          s = !!(2 & e),
          i = !!(4 & e),
          a = 1 & e;
         switch (r) {
          case 60:
           return this.parseBreakContinueStatement(n, !0);
          case 63:
           return this.parseBreakContinueStatement(n, !1);
          case 64:
           return this.parseDebuggerStatement(n);
          case 90:
           return this.parseDoWhileStatement(n);
          case 91:
           return this.parseForStatement(n);
          case 68:
           if (46 === this.lookaheadCharCode()) break;
           return i || this.raise(this.state.strict ? y.StrictFunction : this.options.annexB ? y.SloppyFunctionAnnexB : y.SloppyFunction, this.state.startLoc), this.parseFunctionStatement(n, !1, !s && i);
          case 80:
           return s || this.unexpected(), this.parseClass(this.maybeTakeDecorators(t, n), !0);
          case 69:
           return this.parseIfStatement(n);
          case 70:
           return this.parseReturnStatement(n);
          case 71:
           return this.parseSwitchStatement(n);
          case 72:
           return this.parseThrowStatement(n);
          case 73:
           return this.parseTryStatement(n);
          case 96:
           if (!this.state.containsEsc && this.startsAwaitUsing()) return this.recordAwaitIfAllowed() ? s || this.raise(y.UnexpectedLexicalDeclaration, n) : this.raise(y.AwaitUsingNotInAsyncContext, n), this.next(), this.parseVarStatement(n, 'await using');
           break;
          case 107:
           if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifierOrBrace()) break;
           return this.expectPlugin('explicitResourceManagement'), !this.scope.inModule && this.scope.inTopLevel ? this.raise(y.UnexpectedUsingDeclaration, this.state.startLoc) : s || this.raise(y.UnexpectedLexicalDeclaration, this.state.startLoc), this.parseVarStatement(n, 'using');
          case 100: {
           if (this.state.containsEsc) break;
           let e = this.nextTokenStart(),
            t = this.codePointAtPos(e);
           if (91 !== t && ((!s && this.hasFollowingLineBreak()) || (!this.chStartsBindingIdentifier(t, e) && 123 !== t))) break;
          }
          case 75:
           s || this.raise(y.UnexpectedLexicalDeclaration, this.state.startLoc);
          case 74: {
           let e = this.state.value;
           return this.parseVarStatement(n, e);
          }
          case 92:
           return this.parseWhileStatement(n);
          case 76:
           return this.parseWithStatement(n);
          case 5:
           return this.parseBlock();
          case 13:
           return this.parseEmptyStatement(n);
          case 83: {
           let e = this.lookaheadCharCode();
           if (40 === e || 46 === e) break;
          }
          case 82: {
           let e;
           return !(8 & this.optionFlags) && !a && this.raise(y.UnexpectedImportExport, this.state.startLoc), this.next(), 83 === r ? ((e = this.parseImport(n)), 'ImportDeclaration' === e.type && (!e.importKind || 'value' === e.importKind) && (this.sawUnambiguousESM = !0)) : ((e = this.parseExport(n, t)), (('ExportNamedDeclaration' === e.type && (!e.exportKind || 'value' === e.exportKind)) || ('ExportAllDeclaration' === e.type && (!e.exportKind || 'value' === e.exportKind)) || 'ExportDefaultDeclaration' === e.type) && (this.sawUnambiguousESM = !0)), this.assertModuleNodeAllowed(e), e;
          }
          default:
           if (this.isAsyncFunction()) return s || this.raise(y.AsyncFunctionInSingleStatementContext, this.state.startLoc), this.next(), this.parseFunctionStatement(n, !0, !s && i);
         }
         let o = this.state.value,
          u = this.parseExpression();
         return U(r) && 'Identifier' === u.type && this.eat(14) ? this.parseLabeledStatement(n, o, u, e) : this.parseExpressionStatement(n, u, t);
        }
        assertModuleNodeAllowed(e) {
         !(8 & this.optionFlags) && !this.inModule && this.raise(y.ImportOutsideModule, e);
        }
        decoratorsEnabledBeforeExport() {
         return !!this.hasPlugin('decorators-legacy') || (this.hasPlugin('decorators') && !1 !== this.getPluginOption('decorators', 'decoratorsBeforeExport'));
        }
        maybeTakeDecorators(e, t, r) {
         var n;
         return e && (null != (n = t.decorators) && n.length ? ('boolean' != typeof this.getPluginOption('decorators', 'decoratorsBeforeExport') && this.raise(y.DecoratorsBeforeAfterExport, t.decorators[0]), t.decorators.unshift(...e)) : (t.decorators = e), this.resetStartLocationFromNode(t, e[0]), r && this.resetStartLocationFromNode(r, t)), t;
        }
        canHaveLeadingDecorator() {
         return this.match(80);
        }
        parseDecorators(e) {
         let t = [];
         do {
          t.push(this.parseDecorator());
         } while (this.match(26));
         if (this.match(82)) e || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(y.DecoratorExportClass, this.state.startLoc);
         else if (!this.canHaveLeadingDecorator()) throw this.raise(y.UnexpectedLeadingDecorator, this.state.startLoc);
         return t;
        }
        parseDecorator() {
         this.expectOnePlugin(['decorators', 'decorators-legacy']);
         let e = this.startNode();
         if ((this.next(), this.hasPlugin('decorators'))) {
          let t,
           r = this.state.startLoc;
          if (this.match(10)) {
           let r = this.state.startLoc;
           this.next(), (t = this.parseExpression()), this.expect(11), (t = this.wrapParenthesis(r, t));
           let n = this.state.startLoc;
           (e.expression = this.parseMaybeDecoratorArguments(t, r)), !1 === this.getPluginOption('decorators', 'allowCallParenthesized') && e.expression !== t && this.raise(y.DecoratorArgumentsOutsideParentheses, n);
          } else {
           for (t = this.parseIdentifier(!1); this.eat(16); ) {
            let e = this.startNodeAt(r);
            (e.object = t), this.match(139) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), (e.property = this.parsePrivateName())) : (e.property = this.parseIdentifier(!0)), (e.computed = !1), (t = this.finishNode(e, 'MemberExpression'));
           }
           e.expression = this.parseMaybeDecoratorArguments(t, r);
          }
         } else e.expression = this.parseExprSubscripts();
         return this.finishNode(e, 'Decorator');
        }
        parseMaybeDecoratorArguments(e, t) {
         if (this.eat(10)) {
          let r = this.startNodeAt(t);
          return (r.callee = e), (r.arguments = this.parseCallExpressionArguments(11)), this.toReferencedList(r.arguments), this.finishNode(r, 'CallExpression');
         }
         return e;
        }
        parseBreakContinueStatement(e, t) {
         return this.next(), this.isLineTerminator() ? (e.label = null) : ((e.label = this.parseIdentifier()), this.semicolon()), this.verifyBreakContinue(e, t), this.finishNode(e, t ? 'BreakStatement' : 'ContinueStatement');
        }
        verifyBreakContinue(e, t) {
         let r;
         for (r = 0; r < this.state.labels.length; ++r) {
          let n = this.state.labels[r];
          if ((null == e.label || n.name === e.label.name) && ((null != n.kind && (t || 1 === n.kind)) || (e.label && t))) break;
         }
         if (r === this.state.labels.length) {
          let r = t ? 'BreakStatement' : 'ContinueStatement';
          this.raise(y.IllegalBreakContinue, e, { type: r });
         }
        }
        parseDebuggerStatement(e) {
         return this.next(), this.semicolon(), this.finishNode(e, 'DebuggerStatement');
        }
        parseHeaderExpression() {
         this.expect(10);
         let e = this.parseExpression();
         return this.expect(11), e;
        }
        parseDoWhileStatement(e) {
         return this.next(), this.state.labels.push(Nt), (e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement())), this.state.labels.pop(), this.expect(92), (e.test = this.parseHeaderExpression()), this.eat(13), this.finishNode(e, 'DoWhileStatement');
        }
        parseForStatement(e) {
         this.next(), this.state.labels.push(Nt);
         let t = null;
         if ((this.isContextual(96) && this.recordAwaitIfAllowed() && ((t = this.state.startLoc), this.next()), this.scope.enter(0), this.expect(10), this.match(13))) return null !== t && this.unexpected(t), this.parseFor(e, null);
         let r = this.isContextual(100);
         {
          let n = this.isContextual(96) && this.startsAwaitUsing(),
           s = n || (this.isContextual(107) && this.startsUsingForOf()),
           i = (r && this.hasFollowingBindingAtom()) || s;
          if (this.match(74) || this.match(75) || i) {
           let r,
            i = this.startNode();
           n ? ((r = 'await using'), this.recordAwaitIfAllowed() || this.raise(y.AwaitUsingNotInAsyncContext, this.state.startLoc), this.next()) : (r = this.state.value), this.next(), this.parseVar(i, !0, r);
           let a = this.finishNode(i, 'VariableDeclaration'),
            o = this.match(58);
           return o && s && this.raise(y.ForInUsing, a), (o || this.isContextual(102)) && 1 === a.declarations.length ? this.parseForIn(e, a, t) : (null !== t && this.unexpected(t), this.parseFor(e, a));
          }
         }
         let n = this.isContextual(95),
          s = new et(),
          i = this.parseExpression(!0, s),
          a = this.isContextual(102);
         if ((a && (r && this.raise(y.ForOfLet, i), null === t && n && 'Identifier' === i.type && this.raise(y.ForOfAsync, i)), a || this.match(58))) {
          this.checkDestructuringPrivate(s), this.toAssignable(i, !0);
          let r = a ? 'ForOfStatement' : 'ForInStatement';
          return this.checkLVal(i, { type: r }), this.parseForIn(e, i, t);
         }
         return this.checkExpressionErrors(s, !0), null !== t && this.unexpected(t), this.parseFor(e, i);
        }
        parseFunctionStatement(e, t, r) {
         return this.next(), this.parseFunction(e, 1 | (r ? 2 : 0) | (t ? 8 : 0));
        }
        parseIfStatement(e) {
         return this.next(), (e.test = this.parseHeaderExpression()), (e.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration()), (e.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null), this.finishNode(e, 'IfStatement');
        }
        parseReturnStatement(e) {
         return !this.prodParam.hasReturn && !(2 & this.optionFlags) && this.raise(y.IllegalReturn, this.state.startLoc), this.next(), this.isLineTerminator() ? (e.argument = null) : ((e.argument = this.parseExpression()), this.semicolon()), this.finishNode(e, 'ReturnStatement');
        }
        parseSwitchStatement(e) {
         this.next(), (e.discriminant = this.parseHeaderExpression());
         let t,
          r = (e.cases = []);
         this.expect(5), this.state.labels.push(Bt), this.scope.enter(0);
         for (let n; !this.match(8); )
          if (this.match(61) || this.match(65)) {
           let e = this.match(61);
           t && this.finishNode(t, 'SwitchCase'), r.push((t = this.startNode())), (t.consequent = []), this.next(), e ? (t.test = this.parseExpression()) : (n && this.raise(y.MultipleDefaultsInSwitch, this.state.lastTokStartLoc), (n = !0), (t.test = null)), this.expect(14);
          } else t ? t.consequent.push(this.parseStatementListItem()) : this.unexpected();
         return this.scope.exit(), t && this.finishNode(t, 'SwitchCase'), this.next(), this.state.labels.pop(), this.finishNode(e, 'SwitchStatement');
        }
        parseThrowStatement(e) {
         return this.next(), this.hasPrecedingLineBreak() && this.raise(y.NewlineAfterThrow, this.state.lastTokEndLoc), (e.argument = this.parseExpression()), this.semicolon(), this.finishNode(e, 'ThrowStatement');
        }
        parseCatchClauseParam() {
         let e = this.parseBindingAtom();
         return this.scope.enter(this.options.annexB && 'Identifier' === e.type ? 8 : 0), this.checkLVal(e, { type: 'CatchClause' }, 9), e;
        }
        parseTryStatement(e) {
         if ((this.next(), (e.block = this.parseBlock()), (e.handler = null), this.match(62))) {
          let t = this.startNode();
          this.next(), this.match(10) ? (this.expect(10), (t.param = this.parseCatchClauseParam()), this.expect(11)) : ((t.param = null), this.scope.enter(0)), (t.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(!1, !1))), this.scope.exit(), (e.handler = this.finishNode(t, 'CatchClause'));
         }
         return (e.finalizer = this.eat(67) ? this.parseBlock() : null), !e.handler && !e.finalizer && this.raise(y.NoCatchOrFinally, e), this.finishNode(e, 'TryStatement');
        }
        parseVarStatement(e, t, r = !1) {
         return this.next(), this.parseVar(e, !1, t, r), this.semicolon(), this.finishNode(e, 'VariableDeclaration');
        }
        parseWhileStatement(e) {
         return this.next(), (e.test = this.parseHeaderExpression()), this.state.labels.push(Nt), (e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement())), this.state.labels.pop(), this.finishNode(e, 'WhileStatement');
        }
        parseWithStatement(e) {
         return this.state.strict && this.raise(y.StrictWith, this.state.startLoc), this.next(), (e.object = this.parseHeaderExpression()), (e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement())), this.finishNode(e, 'WithStatement');
        }
        parseEmptyStatement(e) {
         return this.next(), this.finishNode(e, 'EmptyStatement');
        }
        parseLabeledStatement(e, t, r, n) {
         for (let a of this.state.labels) a.name === t && this.raise(y.LabelRedeclaration, r, { labelName: t });
         let s = (i = this.state.type) >= 90 && i <= 92 ? 1 : this.match(71) ? 2 : null;
         var i;
         for (let a = this.state.labels.length - 1; a >= 0; a--) {
          let t = this.state.labels[a];
          if (t.statementStart !== e.start) break;
          (t.statementStart = this.sourceToOffsetPos(this.state.start)), (t.kind = s);
         }
         return this.state.labels.push({ name: t, kind: s, statementStart: this.sourceToOffsetPos(this.state.start) }), (e.body = 8 & n ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(!0) : this.parseStatement()), this.state.labels.pop(), (e.label = r), this.finishNode(e, 'LabeledStatement');
        }
        parseExpressionStatement(e, t, r) {
         return (e.expression = t), this.semicolon(), this.finishNode(e, 'ExpressionStatement');
        }
        parseBlock(e = !1, t = !0, r) {
         let n = this.startNode();
         return e && this.state.strictErrors.clear(), this.expect(5), t && this.scope.enter(0), this.parseBlockBody(n, e, !1, 8, r), t && this.scope.exit(), this.finishNode(n, 'BlockStatement');
        }
        isValidDirective(e) {
         return 'ExpressionStatement' === e.type && 'StringLiteral' === e.expression.type && !e.expression.extra.parenthesized;
        }
        parseBlockBody(e, t, r, n, s) {
         let i = (e.body = []),
          a = (e.directives = []);
         this.parseBlockOrModuleBlockBody(i, t ? a : void 0, r, n, s);
        }
        parseBlockOrModuleBlockBody(e, t, r, n, s) {
         let i = this.state.strict,
          a = !1,
          o = !1;
         for (; !this.match(n); ) {
          let n = r ? this.parseModuleItem() : this.parseStatementListItem();
          if (t && !o) {
           if (this.isValidDirective(n)) {
            let e = this.stmtToDirective(n);
            t.push(e), !a && 'use strict' === e.value.value && ((a = !0), this.setStrict(!0));
            continue;
           }
           (o = !0), this.state.strictErrors.clear();
          }
          e.push(n);
         }
         null == s || s.call(this, a), i || this.setStrict(!1), this.next();
        }
        parseFor(e, t) {
         return (e.init = t), this.semicolon(!1), (e.test = this.match(13) ? null : this.parseExpression()), this.semicolon(!1), (e.update = this.match(11) ? null : this.parseExpression()), this.expect(11), (e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement())), this.scope.exit(), this.state.labels.pop(), this.finishNode(e, 'ForStatement');
        }
        parseForIn(e, t, r) {
         let n = this.match(58);
         return this.next(), n ? null !== r && this.unexpected(r) : (e.await = null !== r), 'VariableDeclaration' === t.type && null != t.declarations[0].init && (!n || !this.options.annexB || this.state.strict || 'var' !== t.kind || 'Identifier' !== t.declarations[0].id.type) && this.raise(y.ForInOfLoopInitializer, t, { type: n ? 'ForInStatement' : 'ForOfStatement' }), 'AssignmentPattern' === t.type && this.raise(y.InvalidLhs, t, { ancestor: { type: 'ForStatement' } }), (e.left = t), (e.right = n ? this.parseExpression() : this.parseMaybeAssignAllowIn()), this.expect(11), (e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement())), this.scope.exit(), this.state.labels.pop(), this.finishNode(e, n ? 'ForInStatement' : 'ForOfStatement');
        }
        parseVar(e, t, r, n = !1) {
         let s = (e.declarations = []);
         for (e.kind = r; ; ) {
          let e = this.startNode();
          if ((this.parseVarId(e, r), (e.init = this.eat(29) ? (t ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn()) : null), null === e.init && !n && ('Identifier' === e.id.type || (t && (this.match(58) || this.isContextual(102))) ? ('const' === r || 'using' === r || 'await using' === r) && !(this.match(58) || this.isContextual(102)) && this.raise(y.DeclarationMissingInitializer, this.state.lastTokEndLoc, { kind: r }) : this.raise(y.DeclarationMissingInitializer, this.state.lastTokEndLoc, { kind: 'destructuring' })), s.push(this.finishNode(e, 'VariableDeclarator')), !this.eat(12))) break;
         }
         return e;
        }
        parseVarId(e, t) {
         let r = this.parseBindingAtom();
         ('using' === t || 'await using' === t) && ('ArrayPattern' === r.type || 'ObjectPattern' === r.type) && this.raise(y.UsingDeclarationHasBindingPattern, r.loc.start), this.checkLVal(r, { type: 'VariableDeclarator' }, 'var' === t ? 5 : 8201), (e.id = r);
        }
        parseAsyncFunctionExpression(e) {
         return this.parseFunction(e, 8);
        }
        parseFunction(e, t = 0) {
         let r = 2 & t,
          n = !!(1 & t),
          s = n && !(4 & t),
          i = !!(8 & t);
         this.initFunction(e, i), this.match(55) && (r && this.raise(y.GeneratorInSingleStatementContext, this.state.startLoc), this.next(), (e.generator = !0)), n && (e.id = this.parseFunctionId(s));
         let a = this.state.maybeInArrowParameters;
         return (
          (this.state.maybeInArrowParameters = !1),
          this.scope.enter(2),
          this.prodParam.enter(Qe(i, e.generator)),
          n || (e.id = this.parseFunctionId()),
          this.parseFunctionParams(e, !1),
          this.withSmartMixTopicForbiddingContext(() => {
           this.parseFunctionBodyAndFinish(e, n ? 'FunctionDeclaration' : 'FunctionExpression');
          }),
          this.prodParam.exit(),
          this.scope.exit(),
          n && !r && this.registerFunctionStatementId(e),
          (this.state.maybeInArrowParameters = a),
          e
         );
        }
        parseFunctionId(e) {
         return e || U(this.state.type) ? this.parseIdentifier() : null;
        }
        parseFunctionParams(e, t) {
         this.expect(10), this.expressionScope.enter(new Je(3)), (e.params = this.parseBindingList(11, 41, 2 | (t ? 4 : 0))), this.expressionScope.exit();
        }
        registerFunctionStatementId(e) {
         e.id && this.scope.declareName(e.id.name, !this.options.annexB || this.state.strict || e.generator || e.async ? (this.scope.treatFunctionsAsVar ? 5 : 8201) : 17, e.id.loc.start);
        }
        parseClass(e, t, r) {
         this.next();
         let n = this.state.strict;
         return (this.state.strict = !0), this.parseClassId(e, t, r), this.parseClassSuper(e), (e.body = this.parseClassBody(!!e.superClass, n)), this.finishNode(e, t ? 'ClassDeclaration' : 'ClassExpression');
        }
        isClassProperty() {
         return this.match(29) || this.match(13) || this.match(8);
        }
        isClassMethod() {
         return this.match(10);
        }
        nameIsConstructor(e) {
         return ('Identifier' === e.type && 'constructor' === e.name) || ('StringLiteral' === e.type && 'constructor' === e.value);
        }
        isNonstaticConstructor(e) {
         return !e.computed && !e.static && this.nameIsConstructor(e.key);
        }
        parseClassBody(e, t) {
         this.classScope.enter();
         let r = { hadConstructor: !1, hadSuperClass: e },
          n = [],
          s = this.startNode();
         if (
          ((s.body = []),
          this.expect(5),
          this.withSmartMixTopicForbiddingContext(() => {
           for (; !this.match(8); ) {
            if (this.eat(13)) {
             if (n.length > 0) throw this.raise(y.DecoratorSemicolon, this.state.lastTokEndLoc);
             continue;
            }
            if (this.match(26)) {
             n.push(this.parseDecorator());
             continue;
            }
            let e = this.startNode();
            n.length && ((e.decorators = n), this.resetStartLocationFromNode(e, n[0]), (n = [])), this.parseClassMember(s, e, r), 'constructor' === e.kind && e.decorators && e.decorators.length > 0 && this.raise(y.DecoratorConstructor, e);
           }
          }),
          (this.state.strict = t),
          this.next(),
          n.length)
         )
          throw this.raise(y.TrailingDecorator, this.state.startLoc);
         return this.classScope.exit(), this.finishNode(s, 'ClassBody');
        }
        parseClassMemberFromModifier(e, t) {
         let r = this.parseIdentifier(!0);
         if (this.isClassMethod()) {
          let n = t;
          return (n.kind = 'method'), (n.computed = !1), (n.key = r), (n.static = !1), this.pushClassMethod(e, n, !1, !1, !1, !1), !0;
         }
         if (this.isClassProperty()) {
          let n = t;
          return (n.computed = !1), (n.key = r), (n.static = !1), e.body.push(this.parseClassProperty(n)), !0;
         }
         return this.resetPreviousNodeTrailingComments(r), !1;
        }
        parseClassMember(e, t, r) {
         let n = this.isContextual(106);
         if (n) {
          if (this.parseClassMemberFromModifier(e, t)) return;
          if (this.eat(5)) return void this.parseClassStaticBlock(e, t);
         }
         this.parseClassMemberWithIsStatic(e, t, r, n);
        }
        parseClassMemberWithIsStatic(e, t, r, n) {
         let s = t,
          i = t,
          a = t,
          o = t,
          u = t,
          l = s,
          p = s;
         if (((t.static = n), this.parsePropertyNamePrefixOperator(t), this.eat(55))) {
          l.kind = 'method';
          let t = this.match(139);
          return this.parseClassElementName(l), t ? void this.pushClassPrivateMethod(e, i, !0, !1) : (this.isNonstaticConstructor(s) && this.raise(y.ConstructorIsGenerator, s.key), void this.pushClassMethod(e, s, !0, !1, !1, !1));
         }
         let c = !this.state.containsEsc && U(this.state.type),
          h = this.parseClassElementName(t),
          d = c ? h.name : null,
          f = this.isPrivateName(h),
          m = this.state.startLoc;
         if ((this.parsePostMemberNameModifiers(p), this.isClassMethod())) {
          if (((l.kind = 'method'), f)) return void this.pushClassPrivateMethod(e, i, !1, !1);
          let n = this.isNonstaticConstructor(s),
           a = !1;
          n && ((s.kind = 'constructor'), r.hadConstructor && !this.hasPlugin('typescript') && this.raise(y.DuplicateConstructor, h), n && this.hasPlugin('typescript') && t.override && this.raise(y.OverrideOnConstructor, h), (r.hadConstructor = !0), (a = r.hadSuperClass)), this.pushClassMethod(e, s, !1, !1, n, a);
         } else if (this.isClassProperty()) f ? this.pushClassPrivateProperty(e, o) : this.pushClassProperty(e, a);
         else if ('async' !== d || this.isLineTerminator())
          if (('get' !== d && 'set' !== d) || (this.match(55) && this.isLineTerminator()))
           if ('accessor' !== d || this.isLineTerminator()) this.isLineTerminator() ? (f ? this.pushClassPrivateProperty(e, o) : this.pushClassProperty(e, a)) : this.unexpected();
           else {
            this.expectPlugin('decoratorAutoAccessors'), this.resetPreviousNodeTrailingComments(h);
            let t = this.match(139);
            this.parseClassElementName(a), this.pushClassAccessorProperty(e, u, t);
           }
          else {
           this.resetPreviousNodeTrailingComments(h), (l.kind = d);
           let t = this.match(139);
           this.parseClassElementName(s), t ? this.pushClassPrivateMethod(e, i, !1, !1) : (this.isNonstaticConstructor(s) && this.raise(y.ConstructorIsAccessor, s.key), this.pushClassMethod(e, s, !1, !1, !1, !1)), this.checkGetterSetterParams(s);
          }
         else {
          this.resetPreviousNodeTrailingComments(h);
          let t = this.eat(55);
          p.optional && this.unexpected(m), (l.kind = 'method');
          let r = this.match(139);
          this.parseClassElementName(l), this.parsePostMemberNameModifiers(p), r ? this.pushClassPrivateMethod(e, i, t, !0) : (this.isNonstaticConstructor(s) && this.raise(y.ConstructorIsAsync, s.key), this.pushClassMethod(e, s, t, !0, !1, !1));
         }
        }
        parseClassElementName(e) {
         let { type: t, value: r } = this.state;
         if (((132 === t || 134 === t) && e.static && 'prototype' === r && this.raise(y.StaticPrototype, this.state.startLoc), 139 === t)) {
          'constructor' === r && this.raise(y.ConstructorClassPrivateField, this.state.startLoc);
          let t = this.parsePrivateName();
          return (e.key = t), t;
         }
         return this.parsePropertyName(e), e.key;
        }
        parseClassStaticBlock(e, t) {
         var r;
         this.scope.enter(208);
         let n = this.state.labels;
         (this.state.labels = []), this.prodParam.enter(0);
         let s = (t.body = []);
         this.parseBlockOrModuleBlockBody(s, void 0, !1, 8), this.prodParam.exit(), this.scope.exit(), (this.state.labels = n), e.body.push(this.finishNode(t, 'StaticBlock')), null != (r = t.decorators) && r.length && this.raise(y.DecoratorStaticBlock, t);
        }
        pushClassProperty(e, t) {
         !t.computed && this.nameIsConstructor(t.key) && this.raise(y.ConstructorClassField, t.key), e.body.push(this.parseClassProperty(t));
        }
        pushClassPrivateProperty(e, t) {
         let r = this.parseClassPrivateProperty(t);
         e.body.push(r), this.classScope.declarePrivateName(this.getPrivateNameSV(r.key), 0, r.key.loc.start);
        }
        pushClassAccessorProperty(e, t, r) {
         !r && !t.computed && this.nameIsConstructor(t.key) && this.raise(y.ConstructorClassField, t.key);
         let n = this.parseClassAccessorProperty(t);
         e.body.push(n), r && this.classScope.declarePrivateName(this.getPrivateNameSV(n.key), 0, n.key.loc.start);
        }
        pushClassMethod(e, t, r, n, s, i) {
         e.body.push(this.parseMethod(t, r, n, s, i, 'ClassMethod', !0));
        }
        pushClassPrivateMethod(e, t, r, n) {
         let s = this.parseMethod(t, r, n, !1, !1, 'ClassPrivateMethod', !0);
         e.body.push(s);
         let i = 'get' === s.kind ? (s.static ? 6 : 2) : 'set' === s.kind ? (s.static ? 5 : 1) : 0;
         this.declareClassPrivateMethodInScope(s, i);
        }
        declareClassPrivateMethodInScope(e, t) {
         this.classScope.declarePrivateName(this.getPrivateNameSV(e.key), t, e.key.loc.start);
        }
        parsePostMemberNameModifiers(e) {}
        parseClassPrivateProperty(e) {
         return this.parseInitializer(e), this.semicolon(), this.finishNode(e, 'ClassPrivateProperty');
        }
        parseClassProperty(e) {
         return this.parseInitializer(e), this.semicolon(), this.finishNode(e, 'ClassProperty');
        }
        parseClassAccessorProperty(e) {
         return this.parseInitializer(e), this.semicolon(), this.finishNode(e, 'ClassAccessorProperty');
        }
        parseInitializer(e) {
         this.scope.enter(80), this.expressionScope.enter(Xe()), this.prodParam.enter(0), (e.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null), this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
        }
        parseClassId(e, t, r, n = 8331) {
         if (U(this.state.type)) (e.id = this.parseIdentifier()), t && this.declareNameFromIdentifier(e.id, n);
         else {
          if (!r && t) throw this.raise(y.MissingClassName, this.state.startLoc);
          e.id = null;
         }
        }
        parseClassSuper(e) {
         e.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
        }
        parseExport(e, t) {
         let r = this.parseMaybeImportPhase(e, !0),
          n = this.maybeParseExportDefaultSpecifier(e, r),
          s = !n || this.eat(12),
          i = s && this.eatExportStar(e),
          a = i && this.maybeParseExportNamespaceSpecifier(e),
          o = s && (!a || this.eat(12)),
          u = n || i;
         if (i && !a) {
          if ((n && this.unexpected(), t)) throw this.raise(y.UnsupportedDecoratorExport, e);
          return this.parseExportFrom(e, !0), this.finishNode(e, 'ExportAllDeclaration');
         }
         let l,
          p = this.maybeParseExportNamedSpecifiers(e);
         if ((n && s && !i && !p && this.unexpected(null, 5), a && o && this.unexpected(null, 98), u || p)) {
          if (((l = !1), t)) throw this.raise(y.UnsupportedDecoratorExport, e);
          this.parseExportFrom(e, u);
         } else l = this.maybeParseExportDeclaration(e);
         if (u || p || l) {
          var c;
          let r = e;
          if ((this.checkExport(r, !0, !1, !!r.source), 'ClassDeclaration' === (null == (c = r.declaration) ? void 0 : c.type))) this.maybeTakeDecorators(t, r.declaration, r);
          else if (t) throw this.raise(y.UnsupportedDecoratorExport, e);
          return this.finishNode(r, 'ExportNamedDeclaration');
         }
         if (this.eat(65)) {
          let r = e,
           n = this.parseExportDefaultExpression();
          if (((r.declaration = n), 'ClassDeclaration' === n.type)) this.maybeTakeDecorators(t, n, r);
          else if (t) throw this.raise(y.UnsupportedDecoratorExport, e);
          return this.checkExport(r, !0, !0), this.finishNode(r, 'ExportDefaultDeclaration');
         }
         this.unexpected(null, 5);
        }
        eatExportStar(e) {
         return this.eat(55);
        }
        maybeParseExportDefaultSpecifier(e, t) {
         if (t || this.isExportDefaultSpecifier()) {
          this.expectPlugin('exportDefaultFrom', null == t ? void 0 : t.loc.start);
          let r = t || this.parseIdentifier(!0),
           n = this.startNodeAtNode(r);
          return (n.exported = r), (e.specifiers = [this.finishNode(n, 'ExportDefaultSpecifier')]), !0;
         }
         return !1;
        }
        maybeParseExportNamespaceSpecifier(e) {
         if (this.isContextual(93)) {
          var t;
          null != (t = e).specifiers || (t.specifiers = []);
          let r = this.startNodeAt(this.state.lastTokStartLoc);
          return this.next(), (r.exported = this.parseModuleExportName()), e.specifiers.push(this.finishNode(r, 'ExportNamespaceSpecifier')), !0;
         }
         return !1;
        }
        maybeParseExportNamedSpecifiers(e) {
         if (this.match(5)) {
          let t = e;
          t.specifiers || (t.specifiers = []);
          let r = 'type' === t.exportKind;
          return t.specifiers.push(...this.parseExportSpecifiers(r)), (t.source = null), (t.declaration = null), this.hasPlugin('importAssertions') && (t.assertions = []), !0;
         }
         return !1;
        }
        maybeParseExportDeclaration(e) {
         return !!this.shouldParseExportDeclaration() && ((e.specifiers = []), (e.source = null), this.hasPlugin('importAssertions') && (e.assertions = []), (e.declaration = this.parseExportDeclaration(e)), !0);
        }
        isAsyncFunction() {
         if (!this.isContextual(95)) return !1;
         let e = this.nextTokenInLineStart();
         return this.isUnparsedContextual(e, 'function');
        }
        parseExportDefaultExpression() {
         let e = this.startNode();
         if (this.match(68)) return this.next(), this.parseFunction(e, 5);
         if (this.isAsyncFunction()) return this.next(), this.next(), this.parseFunction(e, 13);
         if (this.match(80)) return this.parseClass(e, !0, !0);
         if (this.match(26)) return this.hasPlugin('decorators') && !0 === this.getPluginOption('decorators', 'decoratorsBeforeExport') && this.raise(y.DecoratorBeforeExport, this.state.startLoc), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(!1), this.startNode()), !0, !0);
         if (this.match(75) || this.match(74) || this.isLet()) throw this.raise(y.UnsupportedDefaultExport, this.state.startLoc);
         let t = this.parseMaybeAssignAllowIn();
         return this.semicolon(), t;
        }
        parseExportDeclaration(e) {
         return this.match(80) ? this.parseClass(this.startNode(), !0, !1) : this.parseStatementListItem();
        }
        isExportDefaultSpecifier() {
         let { type: e } = this.state;
         if (U(e)) {
          if ((95 === e && !this.state.containsEsc) || 100 === e) return !1;
          if ((130 === e || 129 === e) && !this.state.containsEsc) {
           let { type: e } = this.lookahead();
           if ((U(e) && 98 !== e) || 5 === e) return this.expectOnePlugin(['flow', 'typescript']), !1;
          }
         } else if (!this.match(65)) return !1;
         let t = this.nextTokenStart(),
          r = this.isUnparsedContextual(t, 'from');
         if (44 === this.input.charCodeAt(t) || (U(this.state.type) && r)) return !0;
         if (this.match(65) && r) {
          let e = this.input.charCodeAt(this.nextTokenStartSince(t + 4));
          return 34 === e || 39 === e;
         }
         return !1;
        }
        parseExportFrom(e, t) {
         this.eatContextual(98) ? ((e.source = this.parseImportSource()), this.checkExport(e), this.maybeParseImportAttributes(e), this.checkJSONModuleImport(e)) : t && this.unexpected(), this.semicolon();
        }
        shouldParseExportDeclaration() {
         let { type: e } = this.state;
         return 26 === e && (this.expectOnePlugin(['decorators', 'decorators-legacy']), this.hasPlugin('decorators')) ? (!0 === this.getPluginOption('decorators', 'decoratorsBeforeExport') && this.raise(y.DecoratorBeforeExport, this.state.startLoc), !0) : this.isContextual(107) || (this.isContextual(96) && this.startsAwaitUsing()) ? (this.raise(y.UsingDeclarationExport, this.state.startLoc), !0) : 74 === e || 75 === e || 68 === e || 80 === e || this.isLet() || this.isAsyncFunction();
        }
        checkExport(e, t, r, n) {
         var s;
         if (t)
          if (r) {
           if ((this.checkDuplicateExports(e, 'default'), this.hasPlugin('exportDefaultFrom'))) {
            var i;
            let t = e.declaration;
            'Identifier' === t.type && 'from' === t.name && t.end - t.start == 4 && (null == (i = t.extra) || !i.parenthesized) && this.raise(y.ExportDefaultFromAsIdentifier, t);
           }
          } else if (null != (s = e.specifiers) && s.length)
           for (let a of e.specifiers) {
            let { exported: e } = a,
             t = 'Identifier' === e.type ? e.name : e.value;
            if ((this.checkDuplicateExports(a, t), !n && a.local)) {
             let { local: e } = a;
             'Identifier' !== e.type ? this.raise(y.ExportBindingIsString, a, { localName: e.value, exportName: t }) : (this.checkReservedWord(e.name, e.loc.start, !0, !1), this.scope.checkLocalExport(e));
            }
           }
          else if (e.declaration) {
           let t = e.declaration;
           if ('FunctionDeclaration' === t.type || 'ClassDeclaration' === t.type) {
            let { id: r } = t;
            if (!r) throw new Error('Assertion failure');
            this.checkDuplicateExports(e, r.name);
           } else if ('VariableDeclaration' === t.type) for (let e of t.declarations) this.checkDeclaration(e.id);
          }
        }
        checkDeclaration(e) {
         if ('Identifier' === e.type) this.checkDuplicateExports(e, e.name);
         else if ('ObjectPattern' === e.type) for (let t of e.properties) this.checkDeclaration(t);
         else if ('ArrayPattern' === e.type) for (let t of e.elements) t && this.checkDeclaration(t);
         else 'ObjectProperty' === e.type ? this.checkDeclaration(e.value) : 'RestElement' === e.type ? this.checkDeclaration(e.argument) : 'AssignmentPattern' === e.type && this.checkDeclaration(e.left);
        }
        checkDuplicateExports(e, t) {
         this.exportedIdentifiers.has(t) && ('default' === t ? this.raise(y.DuplicateDefaultExport, e) : this.raise(y.DuplicateExport, e, { exportName: t })), this.exportedIdentifiers.add(t);
        }
        parseExportSpecifiers(e) {
         let t = [],
          r = !0;
         for (this.expect(5); !this.eat(8); ) {
          if (r) r = !1;
          else if ((this.expect(12), this.eat(8))) break;
          let n = this.isContextual(130),
           s = this.match(134),
           i = this.startNode();
          (i.local = this.parseModuleExportName()), t.push(this.parseExportSpecifier(i, s, e, n));
         }
         return t;
        }
        parseExportSpecifier(e, t, r, n) {
         return this.eatContextual(93) ? (e.exported = this.parseModuleExportName()) : t ? (e.exported = st(e.local)) : e.exported || (e.exported = nt(e.local)), this.finishNode(e, 'ExportSpecifier');
        }
        parseModuleExportName() {
         if (this.match(134)) {
          let e = this.parseStringLiteral(this.state.value),
           t = _t.exec(e.value);
          return t && this.raise(y.ModuleExportNameHasLoneSurrogate, e, { surrogateCharCode: t[0].charCodeAt(0) }), e;
         }
         return this.parseIdentifier(!0);
        }
        isJSONModuleImport(e) {
         return null != e.assertions && e.assertions.some(({ key: e, value: t }) => 'json' === t.value && ('Identifier' === e.type ? 'type' === e.name : 'type' === e.value));
        }
        checkImportReflection(e) {
         let { specifiers: t } = e,
          r = 1 === t.length ? t[0].type : null;
         if ('source' === e.phase) 'ImportDefaultSpecifier' !== r && this.raise(y.SourcePhaseImportRequiresDefault, t[0].loc.start);
         else if ('defer' === e.phase) 'ImportNamespaceSpecifier' !== r && this.raise(y.DeferImportRequiresNamespace, t[0].loc.start);
         else if (e.module) {
          var n;
          'ImportDefaultSpecifier' !== r && this.raise(y.ImportReflectionNotBinding, t[0].loc.start), (null == (n = e.assertions) ? void 0 : n.length) > 0 && this.raise(y.ImportReflectionHasAssertion, t[0].loc.start);
         }
        }
        checkJSONModuleImport(e) {
         if (this.isJSONModuleImport(e) && 'ExportAllDeclaration' !== e.type) {
          let { specifiers: t } = e;
          if (null != t) {
           let e = t.find((e) => {
            let t;
            if (('ExportSpecifier' === e.type ? (t = e.local) : 'ImportSpecifier' === e.type && (t = e.imported), void 0 !== t)) return 'Identifier' === t.type ? 'default' !== t.name : 'default' !== t.value;
           });
           void 0 !== e && this.raise(y.ImportJSONBindingNotDefault, e.loc.start);
          }
         }
        }
        isPotentialImportPhase(e) {
         return !e && (this.isContextual(105) || this.isContextual(97) || this.isContextual(127));
        }
        applyImportPhase(e, t, r, n) {
         t || ('module' === r ? (this.expectPlugin('importReflection', n), (e.module = !0)) : this.hasPlugin('importReflection') && (e.module = !1), 'source' === r ? (this.expectPlugin('sourcePhaseImports', n), (e.phase = 'source')) : 'defer' === r ? (this.expectPlugin('deferredImportEvaluation', n), (e.phase = 'defer')) : this.hasPlugin('sourcePhaseImports') && (e.phase = null));
        }
        parseMaybeImportPhase(e, t) {
         if (!this.isPotentialImportPhase(t)) return this.applyImportPhase(e, t, null), null;
         let r = this.parseIdentifier(!0),
          { type: n } = this.state;
         return ($(n) ? 98 !== n || 102 === this.lookaheadCharCode() : 12 !== n) ? (this.resetPreviousIdentifierLeadingComments(r), this.applyImportPhase(e, t, r.name, r.loc.start), null) : (this.applyImportPhase(e, t, null), r);
        }
        isPrecedingIdImportPhase(e) {
         let { type: t } = this.state;
         return U(t) ? 98 !== t || 102 === this.lookaheadCharCode() : 12 !== t;
        }
        parseImport(e) {
         return this.match(134) ? this.parseImportSourceAndAttributes(e) : this.parseImportSpecifiersAndAfter(e, this.parseMaybeImportPhase(e, !1));
        }
        parseImportSpecifiersAndAfter(e, t) {
         e.specifiers = [];
         let r = !this.maybeParseDefaultImportSpecifier(e, t) || this.eat(12),
          n = r && this.maybeParseStarImportSpecifier(e);
         return r && !n && this.parseNamedImportSpecifiers(e), this.expectContextual(98), this.parseImportSourceAndAttributes(e);
        }
        parseImportSourceAndAttributes(e) {
         return null != e.specifiers || (e.specifiers = []), (e.source = this.parseImportSource()), this.maybeParseImportAttributes(e), this.checkImportReflection(e), this.checkJSONModuleImport(e), this.semicolon(), this.finishNode(e, 'ImportDeclaration');
        }
        parseImportSource() {
         return this.match(134) || this.unexpected(), this.parseExprAtom();
        }
        parseImportSpecifierLocal(e, t, r) {
         (t.local = this.parseIdentifier()), e.specifiers.push(this.finishImportSpecifier(t, r));
        }
        finishImportSpecifier(e, t, r = 8201) {
         return this.checkLVal(e.local, { type: t }, r), this.finishNode(e, t);
        }
        parseImportAttributes() {
         this.expect(5);
         let e = [],
          t = new Set();
         do {
          if (this.match(8)) break;
          let r = this.startNode(),
           n = this.state.value;
          if ((t.has(n) && this.raise(y.ModuleAttributesWithDuplicateKeys, this.state.startLoc, { key: n }), t.add(n), this.match(134) ? (r.key = this.parseStringLiteral(n)) : (r.key = this.parseIdentifier(!0)), this.expect(14), !this.match(134))) throw this.raise(y.ModuleAttributeInvalidValue, this.state.startLoc);
          (r.value = this.parseStringLiteral(this.state.value)), e.push(this.finishNode(r, 'ImportAttribute'));
         } while (this.eat(12));
         return this.expect(8), e;
        }
        parseModuleAttributes() {
         let e = [],
          t = new Set();
         do {
          let r = this.startNode();
          if (((r.key = this.parseIdentifier(!0)), 'type' !== r.key.name && this.raise(y.ModuleAttributeDifferentFromType, r.key), t.has(r.key.name) && this.raise(y.ModuleAttributesWithDuplicateKeys, r.key, { key: r.key.name }), t.add(r.key.name), this.expect(14), !this.match(134))) throw this.raise(y.ModuleAttributeInvalidValue, this.state.startLoc);
          (r.value = this.parseStringLiteral(this.state.value)), e.push(this.finishNode(r, 'ImportAttribute'));
         } while (this.eat(12));
         return e;
        }
        maybeParseImportAttributes(e) {
         let t;
         var r = !1;
         if (this.match(76)) {
          if (this.hasPrecedingLineBreak() && 40 === this.lookaheadCharCode()) return;
          this.next(), (t = this.hasPlugin('moduleAttributes') ? this.parseModuleAttributes() : this.parseImportAttributes()), (r = !0);
         } else this.isContextual(94) && !this.hasPrecedingLineBreak() ? (!this.hasPlugin('deprecatedImportAssert') && !this.hasPlugin('importAssertions') && this.raise(y.ImportAttributesUseAssert, this.state.startLoc), this.hasPlugin('importAssertions') || this.addExtra(e, 'deprecatedAssertSyntax', !0), this.next(), (t = this.parseImportAttributes())) : (t = []);
         !r && this.hasPlugin('importAssertions') ? (e.assertions = t) : (e.attributes = t);
        }
        maybeParseDefaultImportSpecifier(e, t) {
         if (t) {
          let r = this.startNodeAtNode(t);
          return (r.local = t), e.specifiers.push(this.finishImportSpecifier(r, 'ImportDefaultSpecifier')), !0;
         }
         return !!$(this.state.type) && (this.parseImportSpecifierLocal(e, this.startNode(), 'ImportDefaultSpecifier'), !0);
        }
        maybeParseStarImportSpecifier(e) {
         if (this.match(55)) {
          let t = this.startNode();
          return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(e, t, 'ImportNamespaceSpecifier'), !0;
         }
         return !1;
        }
        parseNamedImportSpecifiers(e) {
         let t = !0;
         for (this.expect(5); !this.eat(8); ) {
          if (t) t = !1;
          else {
           if (this.eat(14)) throw this.raise(y.DestructureNamedImport, this.state.startLoc);
           if ((this.expect(12), this.eat(8))) break;
          }
          let r = this.startNode(),
           n = this.match(134),
           s = this.isContextual(130);
          r.imported = this.parseModuleExportName();
          let i = this.parseImportSpecifier(r, n, 'type' === e.importKind || 'typeof' === e.importKind, s, void 0);
          e.specifiers.push(i);
         }
        }
        parseImportSpecifier(e, t, r, n, s) {
         if (this.eatContextual(93)) e.local = this.parseIdentifier();
         else {
          let { imported: r } = e;
          if (t) throw this.raise(y.ImportBindingIsString, e, { importName: r.value });
          this.checkReservedWord(r.name, e.loc.start, !0, !0), e.local || (e.local = nt(r));
         }
         return this.finishImportSpecifier(e, 'ImportSpecifier', s);
        }
        isThisParam(e) {
         return 'Identifier' === e.type && 'this' === e.name;
        }
       },
       Mt = class extends Ot {
        constructor(e, t, r) {
         (e = (function (e) {
          let t = { sourceType: 'script', sourceFilename: void 0, startIndex: 0, startColumn: 0, startLine: 1, allowAwaitOutsideFunction: !1, allowReturnOutsideFunction: !1, allowNewTargetOutsideFunction: !1, allowImportExportEverywhere: !1, allowSuperOutsideMethod: !1, allowUndeclaredExports: !1, plugins: [], strictMode: null, ranges: !1, tokens: !1, createImportExpressions: !1, createParenthesizedExpressions: !1, errorRecovery: !1, attachComment: !0, annexB: !0 };
          if (null == e) return t;
          if (null != e.annexB && !1 !== e.annexB) throw new Error('The `annexB` option can only be set to `false`.');
          for (let r of Object.keys(t)) null != e[r] && (t[r] = e[r]);
          if (1 === t.startLine) null == e.startIndex && t.startColumn > 0 ? (t.startIndex = t.startColumn) : null == e.startColumn && t.startIndex > 0 && (t.startColumn = t.startIndex);
          else if ((null == e.startColumn || null == e.startIndex) && null != e.startIndex) throw new Error('With a `startLine > 1` you must also specify `startIndex` and `startColumn`.');
          return t;
         })(e)),
          super(e, t),
          (this.options = e),
          this.initializeScopes(),
          (this.plugins = r),
          (this.filename = e.sourceFilename),
          (this.startIndex = e.startIndex);
         let n = 0;
         e.allowAwaitOutsideFunction && (n |= 1), e.allowReturnOutsideFunction && (n |= 2), e.allowImportExportEverywhere && (n |= 8), e.allowSuperOutsideMethod && (n |= 16), e.allowUndeclaredExports && (n |= 32), e.allowNewTargetOutsideFunction && (n |= 4), e.ranges && (n |= 64), e.tokens && (n |= 128), e.createImportExpressions && (n |= 256), e.createParenthesizedExpressions && (n |= 512), e.errorRecovery && (n |= 1024), e.attachComment && (n |= 2048), e.annexB && (n |= 4096), (this.optionFlags = n);
        }
        getScopeHandler() {
         return ge;
        }
        parse() {
         this.enterInitialScopes();
         let e = this.startNode(),
          t = this.startNode();
         return this.nextToken(), (e.errors = null), this.parseTopLevel(e, t), (e.errors = this.state.errors), (e.comments.length = this.state.commentsLen), e;
        }
       },
       jt = (function (e) {
        let t = {};
        for (let r of Object.keys(e)) t[r] = X(e[r]);
        return t;
       })(q);
      function Rt(e, t) {
       let r = Mt,
        n = new Map();
       if (null != e && e.plugins) {
        for (let t of e.plugins) {
         let e, r;
         'string' == typeof t ? (e = t) : ([e, r] = t), n.has(e) || n.set(e, r || {});
        }
        (function (e) {
         if (e.has('decorators')) {
          if (e.has('decorators-legacy')) throw new Error('Cannot use the decorators and decorators-legacy plugin together');
          let t = e.get('decorators').decoratorsBeforeExport;
          if (null != t && 'boolean' != typeof t) throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
          let r = e.get('decorators').allowCallParenthesized;
          if (null != r && 'boolean' != typeof r) throw new Error("'allowCallParenthesized' must be a boolean.");
         }
         if (e.has('flow') && e.has('typescript')) throw new Error('Cannot combine flow and typescript plugins.');
         if (e.has('placeholders') && e.has('v8intrinsic')) throw new Error('Cannot combine placeholders and v8intrinsic plugins.');
         if (e.has('pipelineOperator')) {
          var t;
          let r = e.get('pipelineOperator').proposal;
          if (!At.includes(r)) {
           let e = At.map((e) => `"${e}"`).join(', ');
           throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${e}.`);
          }
          let n = 'hash' === (null == (t = e.get('recordAndTuple')) ? void 0 : t.syntaxType);
          if ('hack' === r) {
           if (e.has('placeholders')) throw new Error('Cannot combine placeholders plugin and Hack-style pipes.');
           if (e.has('v8intrinsic')) throw new Error('Cannot combine v8intrinsic plugin and Hack-style pipes.');
           let t = e.get('pipelineOperator').topicToken;
           if (!Ft.includes(t)) {
            let e = Ft.map((e) => `"${e}"`).join(', ');
            throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${e}.`);
           }
           if ('#' === t && n) throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "hack", topicToken: "#" }]\` and \`${JSON.stringify(['recordAndTuple', e.get('recordAndTuple')])}\`.`);
          } else if ('smart' === r && n) throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "smart" }]\` and \`${JSON.stringify(['recordAndTuple', e.get('recordAndTuple')])}\`.`);
         }
         if (e.has('moduleAttributes')) {
          if (e.has('deprecatedImportAssert') || e.has('importAssertions')) throw new Error('Cannot combine importAssertions, deprecatedImportAssert and moduleAttributes plugins.');
          if ('may-2020' !== e.get('moduleAttributes').version) throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
         }
         if (e.has('importAssertions') && e.has('deprecatedImportAssert')) throw new Error('Cannot combine importAssertions and deprecatedImportAssert plugins.');
         if ((!e.has('deprecatedImportAssert') && e.has('importAttributes') && e.get('importAttributes').deprecatedAssertSyntax && e.set('deprecatedImportAssert', {}), e.has('recordAndTuple'))) {
          let t = e.get('recordAndTuple').syntaxType;
          if (null != t) {
           let e = ['hash', 'bar'];
           if (!e.includes(t)) throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + e.map((e) => `'${e}'`).join(', '));
          }
         }
         if (e.has('asyncDoExpressions') && !e.has('doExpressions')) {
          let e = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
          throw ((e.missingPlugins = 'doExpressions'), e);
         }
         if (e.has('optionalChainingAssign') && '2023-07' !== e.get('optionalChainingAssign').version) throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'.");
        })(n),
         (r = (function (e) {
          let t = [];
          for (let s of Pt) e.has(s) && t.push(s);
          let r = t.join('|'),
           n = qt.get(r);
          if (!n) {
           n = Mt;
           for (let e of t) n = kt[e](n);
           qt.set(r, n);
          }
          return n;
         })(n));
       }
       return new r(e, t, n);
      }
      var qt = new Map();
      (e.parse = function (e, t) {
       var r;
       if ('unambiguous' !== (null == (r = t) ? void 0 : r.sourceType)) return Rt(t, e).parse();
       t = Object.assign({}, t);
       try {
        t.sourceType = 'module';
        let r = Rt(t, e),
         n = r.parse();
        if (r.sawUnambiguousESM) return n;
        if (r.ambiguousScriptDifferentAst)
         try {
          return (t.sourceType = 'script'), Rt(t, e).parse();
         } catch {}
        else n.program.sourceType = 'script';
        return n;
       } catch (n) {
        try {
         return (t.sourceType = 'script'), Rt(t, e).parse();
        } catch {}
        throw n;
       }
      }),
       (e.parseExpression = function (e, t) {
        let r = Rt(t, e);
        return r.options.strictMode && (r.state.strict = !0), r.getExpression();
       }),
       (e.tokTypes = jt);
     }),
     () => (s || n((s = { exports: {} }).exports, s), s.exports)),
    d = {};
   ((e, t) => {
    for (var r in t) a(e, r, { get: t[r], enumerable: !0 });
   })(d, { parsers: () => Ce });
   var f = c(h(), 1);
   function m(e) {
    return (t, r, n) => {
     let s = !(null == n || !n.backwards);
     if (!1 === r) return !1;
     let { length: i } = t,
      a = r;
     for (; a >= 0 && a < i; ) {
      let r = t.charAt(a);
      if (e instanceof RegExp) {
       if (!e.test(r)) return a;
      } else if (!e.includes(r)) return a;
      s ? a-- : a++;
     }
     return (-1 === a || a === i) && a;
    };
   }
   m(/\s/u);
   var y = m(' \t'),
    g = (m(',; \t'), m(/[^\n\r]/u));
   var D = function (e, t) {
    if (!1 === t) return !1;
    if ('/' === e.charAt(t) && '*' === e.charAt(t + 1)) for (let r = t + 2; r < e.length; ++r) if ('*' === e.charAt(r) && '/' === e.charAt(r + 1)) return r + 2;
    return t;
   };
   var x = function (e, t, r) {
    let n = !(null == r || !r.backwards);
    if (!1 === t) return !1;
    let s = e.charAt(t);
    if (n) {
     if ('\r' === e.charAt(t - 1) && '\n' === s) return t - 2;
     if ('\n' === s || '\r' === s || '\u2028' === s || '\u2029' === s) return t - 1;
    } else {
     if ('\r' === s && '\n' === e.charAt(t + 1)) return t + 2;
     if ('\n' === s || '\r' === s || '\u2028' === s || '\u2029' === s) return t + 1;
    }
    return t;
   };
   var b = function (e, t) {
    return !1 !== t && ('/' === e.charAt(t) && '/' === e.charAt(t + 1) ? g(e, t) : t);
   };
   var v = function (e, t) {
    let r = null,
     n = t;
    for (; n !== r; ) (r = n), (n = y(e, n)), (n = D(e, n)), (n = b(e, n)), (n = x(e, n));
    return n;
   };
   var E = function (e) {
    let t = [];
    for (let n of e)
     try {
      return n();
     } catch (r) {
      t.push(r);
     }
    throw Object.assign(new Error('All combinations failed'), { errors: t });
   };
   var C = function (e) {
     if (!e.startsWith('#!')) return '';
     let t = e.indexOf('\n');
     return -1 === t ? e : e.slice(0, t);
    },
    T = (e, t, r) => {
     if (!e || null != t) return Array.isArray(t) || 'string' == typeof t ? t[r < 0 ? t.length + r : r] : t.at(r);
    };
   var S = function (e) {
    return Array.isArray(e) && e.length > 0;
   };
   function w(e) {
    var t, r, n;
    let s = (null == (t = e.range) ? void 0 : t[0]) ?? e.start,
     i = null == (n = (null == (r = e.declaration) ? void 0 : r.decorators) ?? e.decorators) ? void 0 : n[0];
    return i ? Math.min(w(i), s) : s;
   }
   function A(e) {
    var t;
    return (null == (t = e.range) ? void 0 : t[1]) ?? e.end;
   }
   var F = function (e) {
     let t = new Set(e);
     return (e) => t.has(null == e ? void 0 : e.type);
    },
    k = F(['Block', 'CommentBlock', 'MultiLine']);
   var P = function (e) {
    let t = `*${e.value}*`.split('\n');
    return t.length > 1 && t.every((e) => '*' === e.trimStart()[0]);
   };
   var I = function (e) {
     return k(e) && '*' === e.value[0] && /@(?:type|satisfies)\b/u.test(e.value);
    },
    N = null;
   function B(e) {
    if (null !== N && (N.property, 1)) {
     let e = N;
     return (N = B.prototype = null), e;
    }
    return (N = B.prototype = e ?? Object.create(null)), new B();
   }
   for (let Se = 0; Se <= 10; Se++) B();
   var _ = function (e, t = 'type') {
     return (
      (function (e) {
       B(e);
      })(e),
      function (r) {
       let n = r[t],
        s = e[n];
       if (!Array.isArray(s)) throw Object.assign(new Error(`Missing visitor keys for '${n}'.`), { node: r });
       return s;
      }
     );
    },
    L = _({ ArrayExpression: ['elements'], AssignmentExpression: ['left', 'right'], BinaryExpression: ['left', 'right'], InterpreterDirective: [], Directive: ['value'], DirectiveLiteral: [], BlockStatement: ['directives', 'body'], BreakStatement: ['label'], CallExpression: ['callee', 'arguments', 'typeParameters', 'typeArguments'], CatchClause: ['param', 'body'], ConditionalExpression: ['test', 'consequent', 'alternate'], ContinueStatement: ['label'], DebuggerStatement: [], DoWhileStatement: ['body', 'test'], EmptyStatement: [], ExpressionStatement: ['expression'], File: ['program'], ForInStatement: ['left', 'right', 'body'], ForStatement: ['init', 'test', 'update', 'body'], FunctionDeclaration: ['id', 'typeParameters', 'params', 'predicate', 'returnType', 'body'], FunctionExpression: ['id', 'typeParameters', 'params', 'returnType', 'body'], Identifier: ['typeAnnotation', 'decorators'], IfStatement: ['test', 'consequent', 'alternate'], LabeledStatement: ['label', 'body'], StringLiteral: [], NumericLiteral: [], NullLiteral: [], BooleanLiteral: [], RegExpLiteral: [], LogicalExpression: ['left', 'right'], MemberExpression: ['object', 'property'], NewExpression: ['callee', 'arguments', 'typeParameters', 'typeArguments'], Program: ['directives', 'body'], ObjectExpression: ['properties'], ObjectMethod: ['decorators', 'key', 'typeParameters', 'params', 'returnType', 'body'], ObjectProperty: ['key', 'value', 'decorators'], RestElement: ['argument', 'typeAnnotation', 'decorators'], ReturnStatement: ['argument'], SequenceExpression: ['expressions'], ParenthesizedExpression: ['expression'], SwitchCase: ['test', 'consequent'], SwitchStatement: ['discriminant', 'cases'], ThisExpression: [], ThrowStatement: ['argument'], TryStatement: ['block', 'handler', 'finalizer'], UnaryExpression: ['argument'], UpdateExpression: ['argument'], VariableDeclaration: ['declarations'], VariableDeclarator: ['id', 'init'], WhileStatement: ['test', 'body'], WithStatement: ['object', 'body'], AssignmentPattern: ['left', 'right', 'decorators', 'typeAnnotation'], ArrayPattern: ['elements', 'typeAnnotation', 'decorators'], ArrowFunctionExpression: ['typeParameters', 'params', 'predicate', 'returnType', 'body'], ClassBody: ['body'], ClassExpression: ['decorators', 'id', 'typeParameters', 'superClass', 'superTypeParameters', 'mixins', 'implements', 'body', 'superTypeArguments'], ClassDeclaration: ['decorators', 'id', 'typeParameters', 'superClass', 'superTypeParameters', 'mixins', 'implements', 'body', 'superTypeArguments'], ExportAllDeclaration: ['source', 'attributes', 'exported'], ExportDefaultDeclaration: ['declaration'], ExportNamedDeclaration: ['declaration', 'specifiers', 'source', 'attributes'], ExportSpecifier: ['local', 'exported'], ForOfStatement: ['left', 'right', 'body'], ImportDeclaration: ['specifiers', 'source', 'attributes'], ImportDefaultSpecifier: ['local'], ImportNamespaceSpecifier: ['local'], ImportSpecifier: ['imported', 'local'], ImportExpression: ['source', 'options'], MetaProperty: ['meta', 'property'], ClassMethod: ['decorators', 'key', 'typeParameters', 'params', 'returnType', 'body'], ObjectPattern: ['properties', 'typeAnnotation', 'decorators'], SpreadElement: ['argument'], Super: [], TaggedTemplateExpression: ['tag', 'typeParameters', 'quasi', 'typeArguments'], TemplateElement: [], TemplateLiteral: ['quasis', 'expressions'], YieldExpression: ['argument'], AwaitExpression: ['argument'], BigIntLiteral: [], ExportNamespaceSpecifier: ['exported'], OptionalMemberExpression: ['object', 'property'], OptionalCallExpression: ['callee', 'arguments', 'typeParameters', 'typeArguments'], ClassProperty: ['decorators', 'variance', 'key', 'typeAnnotation', 'value'], ClassAccessorProperty: ['decorators', 'key', 'typeAnnotation', 'value'], ClassPrivateProperty: ['decorators', 'variance', 'key', 'typeAnnotation', 'value'], ClassPrivateMethod: ['decorators', 'key', 'typeParameters', 'params', 'returnType', 'body'], PrivateName: ['id'], StaticBlock: ['body'], AnyTypeAnnotation: [], ArrayTypeAnnotation: ['elementType'], BooleanTypeAnnotation: [], BooleanLiteralTypeAnnotation: [], NullLiteralTypeAnnotation: [], ClassImplements: ['id', 'typeParameters'], DeclareClass: ['id', 'typeParameters', 'extends', 'mixins', 'implements', 'body'], DeclareFunction: ['id', 'predicate'], DeclareInterface: ['id', 'typeParameters', 'extends', 'body'], DeclareModule: ['id', 'body'], DeclareModuleExports: ['typeAnnotation'], DeclareTypeAlias: ['id', 'typeParameters', 'right'], DeclareOpaqueType: ['id', 'typeParameters', 'supertype'], DeclareVariable: ['id'], DeclareExportDeclaration: ['declaration', 'specifiers', 'source', 'attributes'], DeclareExportAllDeclaration: ['source', 'attributes'], DeclaredPredicate: ['value'], ExistsTypeAnnotation: [], FunctionTypeAnnotation: ['typeParameters', 'this', 'params', 'rest', 'returnType'], FunctionTypeParam: ['name', 'typeAnnotation'], GenericTypeAnnotation: ['id', 'typeParameters'], InferredPredicate: [], InterfaceExtends: ['id', 'typeParameters'], InterfaceDeclaration: ['id', 'typeParameters', 'extends', 'body'], InterfaceTypeAnnotation: ['extends', 'body'], IntersectionTypeAnnotation: ['types'], MixedTypeAnnotation: [], EmptyTypeAnnotation: [], NullableTypeAnnotation: ['typeAnnotation'], NumberLiteralTypeAnnotation: [], NumberTypeAnnotation: [], ObjectTypeAnnotation: ['properties', 'indexers', 'callProperties', 'internalSlots'], ObjectTypeInternalSlot: ['id', 'value'], ObjectTypeCallProperty: ['value'], ObjectTypeIndexer: ['variance', 'id', 'key', 'value'], ObjectTypeProperty: ['key', 'value', 'variance'], ObjectTypeSpreadProperty: ['argument'], OpaqueType: ['id', 'typeParameters', 'supertype', 'impltype'], QualifiedTypeIdentifier: ['qualification', 'id'], StringLiteralTypeAnnotation: [], StringTypeAnnotation: [], SymbolTypeAnnotation: [], ThisTypeAnnotation: [], TupleTypeAnnotation: ['types', 'elementTypes'], TypeofTypeAnnotation: ['argument', 'typeArguments'], TypeAlias: ['id', 'typeParameters', 'right'], TypeAnnotation: ['typeAnnotation'], TypeCastExpression: ['expression', 'typeAnnotation'], TypeParameter: ['bound', 'default', 'variance'], TypeParameterDeclaration: ['params'], TypeParameterInstantiation: ['params'], UnionTypeAnnotation: ['types'], Variance: [], VoidTypeAnnotation: [], EnumDeclaration: ['id', 'body'], EnumBooleanBody: ['members'], EnumNumberBody: ['members'], EnumStringBody: ['members'], EnumSymbolBody: ['members'], EnumBooleanMember: ['id', 'init'], EnumNumberMember: ['id', 'init'], EnumStringMember: ['id', 'init'], EnumDefaultedMember: ['id'], IndexedAccessType: ['objectType', 'indexType'], OptionalIndexedAccessType: ['objectType', 'indexType'], JSXAttribute: ['name', 'value'], JSXClosingElement: ['name'], JSXElement: ['openingElement', 'children', 'closingElement'], JSXEmptyExpression: [], JSXExpressionContainer: ['expression'], JSXSpreadChild: ['expression'], JSXIdentifier: [], JSXMemberExpression: ['object', 'property'], JSXNamespacedName: ['namespace', 'name'], JSXOpeningElement: ['name', 'typeParameters', 'typeArguments', 'attributes'], JSXSpreadAttribute: ['argument'], JSXText: [], JSXFragment: ['openingFragment', 'children', 'closingFragment'], JSXOpeningFragment: [], JSXClosingFragment: [], Noop: [], Placeholder: [], V8IntrinsicIdentifier: [], ArgumentPlaceholder: [], BindExpression: ['object', 'callee'], ImportAttribute: ['key', 'value'], Decorator: ['expression'], DoExpression: ['body'], ExportDefaultSpecifier: ['exported'], RecordExpression: ['properties'], TupleExpression: ['elements'], ModuleExpression: ['body'], TopicReference: [], PipelineTopicExpression: ['expression'], PipelineBareFunction: ['callee'], PipelinePrimaryTopicReference: [], TSParameterProperty: ['parameter', 'decorators'], TSDeclareFunction: ['id', 'typeParameters', 'params', 'returnType', 'body'], TSDeclareMethod: ['decorators', 'key', 'typeParameters', 'params', 'returnType'], TSQualifiedName: ['left', 'right'], TSCallSignatureDeclaration: ['typeParameters', 'parameters', 'typeAnnotation', 'params', 'returnType'], TSConstructSignatureDeclaration: ['typeParameters', 'parameters', 'typeAnnotation', 'params', 'returnType'], TSPropertySignature: ['key', 'typeAnnotation'], TSMethodSignature: ['key', 'typeParameters', 'parameters', 'typeAnnotation', 'params', 'returnType'], TSIndexSignature: ['parameters', 'typeAnnotation'], TSAnyKeyword: [], TSBooleanKeyword: [], TSBigIntKeyword: [], TSIntrinsicKeyword: [], TSNeverKeyword: [], TSNullKeyword: [], TSNumberKeyword: [], TSObjectKeyword: [], TSStringKeyword: [], TSSymbolKeyword: [], TSUndefinedKeyword: [], TSUnknownKeyword: [], TSVoidKeyword: [], TSThisType: [], TSFunctionType: ['typeParameters', 'parameters', 'typeAnnotation', 'params', 'returnType'], TSConstructorType: ['typeParameters', 'parameters', 'typeAnnotation', 'params', 'returnType'], TSTypeReference: ['typeName', 'typeParameters', 'typeArguments'], TSTypePredicate: ['parameterName', 'typeAnnotation'], TSTypeQuery: ['exprName', 'typeParameters', 'typeArguments'], TSTypeLiteral: ['members'], TSArrayType: ['elementType'], TSTupleType: ['elementTypes'], TSOptionalType: ['typeAnnotation'], TSRestType: ['typeAnnotation'], TSNamedTupleMember: ['label', 'elementType'], TSUnionType: ['types'], TSIntersectionType: ['types'], TSConditionalType: ['checkType', 'extendsType', 'trueType', 'falseType'], TSInferType: ['typeParameter'], TSParenthesizedType: ['typeAnnotation'], TSTypeOperator: ['typeAnnotation'], TSIndexedAccessType: ['objectType', 'indexType'], TSMappedType: ['typeParameter', 'nameType', 'typeAnnotation'], TSTemplateLiteralType: ['quasis', 'types'], TSLiteralType: ['literal'], TSExpressionWithTypeArguments: ['expression', 'typeParameters'], TSInterfaceDeclaration: ['id', 'typeParameters', 'extends', 'body'], TSInterfaceBody: ['body'], TSTypeAliasDeclaration: ['id', 'typeParameters', 'typeAnnotation'], TSInstantiationExpression: ['expression', 'typeParameters', 'typeArguments'], TSAsExpression: ['expression', 'typeAnnotation'], TSSatisfiesExpression: ['expression', 'typeAnnotation'], TSTypeAssertion: ['typeAnnotation', 'expression'], TSEnumBody: ['members'], TSEnumDeclaration: ['id', 'members'], TSEnumMember: ['id', 'initializer'], TSModuleDeclaration: ['id', 'body'], TSModuleBlock: ['body'], TSImportType: ['argument', 'options', 'qualifier', 'typeParameters', 'typeArguments'], TSImportEqualsDeclaration: ['id', 'moduleReference'], TSExternalModuleReference: ['expression'], TSNonNullExpression: ['expression'], TSExportAssignment: ['expression'], TSNamespaceExportDeclaration: ['id'], TSTypeAnnotation: ['typeAnnotation'], TSTypeParameterInstantiation: ['params'], TSTypeParameterDeclaration: ['params'], TSTypeParameter: ['constraint', 'default', 'name'], ChainExpression: ['expression'], ExperimentalRestProperty: ['argument'], ExperimentalSpreadProperty: ['argument'], Literal: [], MethodDefinition: ['decorators', 'key', 'value'], PrivateIdentifier: [], Property: ['key', 'value'], PropertyDefinition: ['decorators', 'key', 'typeAnnotation', 'value', 'variance'], AccessorProperty: ['decorators', 'key', 'typeAnnotation', 'value'], TSAbstractAccessorProperty: ['decorators', 'key', 'typeAnnotation'], TSAbstractKeyword: [], TSAbstractMethodDefinition: ['key', 'value'], TSAbstractPropertyDefinition: ['decorators', 'key', 'typeAnnotation'], TSAsyncKeyword: [], TSClassImplements: ['expression', 'typeArguments', 'typeParameters'], TSDeclareKeyword: [], TSEmptyBodyFunctionExpression: ['id', 'typeParameters', 'params', 'returnType'], TSExportKeyword: [], TSInterfaceHeritage: ['expression', 'typeArguments', 'typeParameters'], TSPrivateKeyword: [], TSProtectedKeyword: [], TSPublicKeyword: [], TSReadonlyKeyword: [], TSStaticKeyword: [], AsConstExpression: ['expression'], AsExpression: ['expression', 'typeAnnotation'], BigIntLiteralTypeAnnotation: [], BigIntTypeAnnotation: [], ComponentDeclaration: ['id', 'params', 'body', 'typeParameters', 'rendersType'], ComponentParameter: ['name', 'local'], ComponentTypeAnnotation: ['params', 'rest', 'typeParameters', 'rendersType'], ComponentTypeParameter: ['name', 'typeAnnotation'], ConditionalTypeAnnotation: ['checkType', 'extendsType', 'trueType', 'falseType'], DeclareComponent: ['id', 'params', 'rest', 'typeParameters', 'rendersType'], DeclareEnum: ['id', 'body'], DeclareHook: ['id'], DeclareNamespace: ['id', 'body'], EnumBigIntBody: ['members'], EnumBigIntMember: ['id', 'init'], HookDeclaration: ['id', 'params', 'body', 'typeParameters', 'returnType'], HookTypeAnnotation: ['params', 'returnType', 'rest', 'typeParameters'], InferTypeAnnotation: ['typeParameter'], KeyofTypeAnnotation: ['argument'], ObjectTypeMappedTypeProperty: ['keyTparam', 'propType', 'sourceType', 'variance'], QualifiedTypeofIdentifier: ['qualification', 'id'], TupleTypeLabeledElement: ['label', 'elementType', 'variance'], TupleTypeSpreadElement: ['label', 'typeAnnotation'], TypeOperator: ['typeAnnotation'], TypePredicate: ['parameterName', 'typeAnnotation', 'asserts'], NGRoot: ['node'], NGPipeExpression: ['left', 'right', 'arguments'], NGChainedExpression: ['expressions'], NGEmptyExpression: [], NGMicrosyntax: ['body'], NGMicrosyntaxKey: [], NGMicrosyntaxExpression: ['expression', 'alias'], NGMicrosyntaxKeyedExpression: ['key', 'expression'], NGMicrosyntaxLet: ['key', 'value'], NGMicrosyntaxAs: ['key', 'alias'], JsExpressionRoot: ['node'], JsonRoot: ['node'], TSJSDocAllType: [], TSJSDocUnknownType: [], TSJSDocNullableType: ['typeAnnotation'], TSJSDocNonNullableType: ['typeAnnotation'], NeverTypeAnnotation: [], UndefinedTypeAnnotation: [], UnknownTypeAnnotation: [], SatisfiesExpression: ['expression', 'typeAnnotation'] });
   var O = function e(t, r) {
    if (null === t || 'object' != typeof t) return t;
    if (Array.isArray(t)) {
     for (let n = 0; n < t.length; n++) t[n] = e(t[n], r);
     return t;
    }
    let n = L(t);
    for (let s = 0; s < n.length; s++) t[n[s]] = e(t[n[s]], r);
    return r(t) || t;
   };
   function M(e) {
    return 'LogicalExpression' === e.type && 'LogicalExpression' === e.right.type && e.operator === e.right.operator;
   }
   function j(e) {
    return M(e) ? j({ type: 'LogicalExpression', operator: e.operator, left: j({ type: 'LogicalExpression', operator: e.operator, left: e.left, right: e.right.left, range: [w(e.left), A(e.right.left)] }), right: e.right.right, range: [w(e), A(e)] }) : e;
   }
   var R = function (e, t) {
    let { parser: r, text: n } = t;
    if ('File' === e.type && e.program.interpreter) {
     let {
      program: { interpreter: t },
      comments: r,
     } = e;
     delete e.program.interpreter, r.unshift(t);
    }
    if ('babel' === r) {
     let t = new Set();
     (e = O(e, (e) => {
      var r;
      null != (r = e.leadingComments) && r.some(I) && t.add(w(e));
     })),
      (e = O(e, (e) => {
       if ('ParenthesizedExpression' === e.type) {
        let { expression: r } = e;
        if ('TypeCastExpression' === r.type) return (r.range = [...e.range]), r;
        let n = w(e);
        if (!t.has(n)) return (r.extra = { ...r.extra, parenthesized: !0 }), r;
       }
      }));
    }
    if (
     ((e = O(e, (t) => {
      switch (t.type) {
       case 'LogicalExpression':
        if (M(t)) return j(t);
        break;
       case 'VariableDeclaration': {
        let e = T(!1, t.declarations, -1);
        null != e && e.init && ';' !== n[A(e)] && (t.range = [w(t), A(e)]);
        break;
       }
       case 'TSParenthesizedType':
        return t.typeAnnotation;
       case 'TSTypeParameter':
        if ('string' == typeof t.name) {
         let e = w(t);
         t.name = { type: 'Identifier', name: t.name, range: [e, e + t.name.length] };
        }
        break;
       case 'TopicReference':
        e.extra = { ...e.extra, __isUsingHackPipeline: !0 };
        break;
       case 'TSUnionType':
       case 'TSIntersectionType':
        if (1 === t.types.length) return t.types[0];
      }
     })),
     S(e.comments))
    ) {
     let t = T(!1, e.comments, -1);
     for (let r = e.comments.length - 2; r >= 0; r--) {
      let n = e.comments[r];
      A(n) === w(t) && k(n) && k(t) && P(n) && P(t) && (e.comments.splice(r + 1, 1), (n.value += '*//*' + t.value), (n.range = [w(n), A(t)])), (t = n);
     }
    }
    return 'Program' === e.type && (e.range = [0, n.length]), e;
   };
   var q = function (e, t) {
    let r = new SyntaxError(e + ' (' + t.loc.start.line + ':' + t.loc.start.column + ')');
    return Object.assign(r, t);
   };
   var U = function (e) {
     let {
       message: t,
       loc: { line: r, column: n },
       reasonCode: s,
      } = e,
      i = e;
     ('MissingPlugin' === s || 'MissingOneOfPlugins' === s) && ((t = 'Unexpected token.'), (i = void 0));
     let a = ` (${r}:${n})`;
     return t.endsWith(a) && (t = t.slice(0, -a.length)), q(t, { loc: { start: { line: r, column: n + 1 } }, cause: i });
    },
    $ = (e, t, r, n) => {
     if (!e || null != t) return t.replaceAll ? t.replaceAll(r, n) : r.global ? t.replace(r, n) : t.split(r).join(n);
    },
    H = /\*\/$/,
    z = /^\/\*\*?/,
    V = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/,
    W = /(^|\s+)\/\/([^\n\r]*)/g,
    J = /^(\r?\n)+/,
    K = /(?:^|\r?\n) *(@[^\n\r]*?) *\r?\n *(?![^\n\r@]*\/\/[^]*)([^\s@][^\n\r@]+?) *\r?\n/g,
    G = /(?:^|\r?\n) *@(\S+) *([^\n\r]*)/g,
    X = /(\r?\n|^) *\* ?/g,
    Y = [];
   function Q(e) {
    let t = C(e);
    t && (e = e.slice(t.length + 1));
    let r = (function (e) {
      let t = e.match(V);
      return t ? t[0].trimStart() : '';
     })(e),
     { pragmas: n, comments: s } = (function (e) {
      e = $(!1, e.replace(z, '').replace(H, ''), X, '$1');
      let t = '';
      for (; t !== e; ) (t = e), (e = $(!1, e, K, '\n$1 $2\n'));
      e = e.replace(J, '').trimEnd();
      let r,
       n = Object.create(null),
       s = $(!1, e, G, '').replace(J, '').trimEnd();
      for (; (r = G.exec(e)); ) {
       let e = $(!1, r[2], W, '');
       if ('string' == typeof n[r[1]] || Array.isArray(n[r[1]])) {
        let t = n[r[1]];
        n[r[1]] = [...Y, ...(Array.isArray(t) ? t : [t]), e];
       } else n[r[1]] = e;
      }
      return { comments: s, pragmas: n };
     })(r);
    return { shebang: t, text: e, pragmas: n, comments: s };
   }
   function Z(e) {
    let { pragmas: t } = Q(e);
    return Object.prototype.hasOwnProperty.call(t, 'prettier') || Object.prototype.hasOwnProperty.call(t, 'format');
   }
   var ee = function (e) {
    return (e = 'function' == typeof e ? { parse: e } : e), { astFormat: 'estree', hasPragma: Z, locStart: w, locEnd: A, ...e };
   };
   var te = function (e) {
    let { filepath: t } = e;
    if (t) {
     if (((t = t.toLowerCase()), t.endsWith('.cjs') || t.endsWith('.cts'))) return 'script';
     if (t.endsWith('.mjs') || t.endsWith('.mts')) return 'module';
    }
   };
   var re = function (e, t) {
     let { type: r = 'JsExpressionRoot', rootMarker: n, text: s } = t,
      { tokens: i, comments: a } = e;
     return delete e.tokens, delete e.comments, { tokens: i, comments: a, type: r, node: e, range: [0, s.length], rootMarker: n };
    },
    ne = (e) =>
     ee(
      (function ({ isExpression: e = !1, optionsCombinations: t }) {
       return (r, n = {}) => {
        if (
         ('babel' === n.parser || '__babel_estree' === n.parser) &&
         (function (e, t) {
          var r;
          if (null != (r = t.filepath) && r.endsWith('.js.flow')) return !0;
          let n = C(e);
          n && (e = e.slice(n.length));
          let s = v(e, 0);
          return !1 !== s && (e = e.slice(0, s)), ue.test(e);
         })(r, n)
        )
         return (n.parser = 'babel-flow'), me.parse(r, n);
        let s = t;
        'script' === (n.__babelSourceType ?? te(n)) && (s = s.map((e) => ({ ...e, sourceType: 'script' })));
        let i = /%[A-Z]/u.test(r);
        r.includes('|>') ? (s = (i ? [...ae, ie] : ae).flatMap((e) => s.map((t) => oe([e], t)))) : i && (s = s.map((e) => oe([ie], e)));
        let a,
         o = e ? f.parseExpression : f.parse;
        try {
         a = E(
          s.map(
           (e) => () =>
            (function (e, t, r) {
             let n = e(t, r),
              s = n.errors.find((e) => !le.has(e.reasonCode));
             if (s) throw s;
             return n;
            })(o, r, e),
          ),
         );
        } catch ({ errors: [u] }) {
         throw U(u);
        }
        return e && (a = re(a, { text: r, rootMarker: n.rootMarker })), R(a, { parser: 'babel', text: r });
       };
      })(e),
     ),
    se = { sourceType: 'module', allowImportExportEverywhere: !0, allowReturnOutsideFunction: !0, allowNewTargetOutsideFunction: !0, allowSuperOutsideMethod: !0, allowUndeclaredExports: !0, errorRecovery: !0, createParenthesizedExpressions: !0, createImportExpressions: !0, plugins: ['doExpressions', 'exportDefaultFrom', 'functionBind', 'functionSent', 'throwExpressions', 'partialApplication', 'decorators', 'moduleBlocks', 'asyncDoExpressions', 'destructuringPrivate', 'decoratorAutoAccessors', 'explicitResourceManagement', 'sourcePhaseImports', 'deferredImportEvaluation', ['optionalChainingAssign', { version: '2023-07' }], 'recordAndTuple'], tokens: !0, ranges: !0 },
    ie = 'v8intrinsic',
    ae = [
     ['pipelineOperator', { proposal: 'hack', topicToken: '%' }],
     ['pipelineOperator', { proposal: 'fsharp' }],
    ],
    oe = (e, t = se) => ({ ...t, plugins: [...t.plugins, ...e] }),
    ue = /@(?:no)?flow\b/u;
   var le = new Set(['StrictNumericEscape', 'StrictWith', 'StrictOctalLiteral', 'StrictDelete', 'StrictEvalArguments', 'StrictEvalArgumentsBinding', 'StrictFunction', 'ForInOfLoopInitializer', 'EmptyTypeArguments', 'EmptyTypeParameters', 'ConstructorHasTypeParameters', 'UnsupportedParameterPropertyKind', 'DecoratorExportClass', 'ParamDupe', 'InvalidDecimal', 'RestTrailingComma', 'UnsupportedParameterDecorator', 'UnterminatedJsxContent', 'UnexpectedReservedWord', 'ModuleAttributesWithDuplicateKeys', 'LineTerminatorBeforeArrow', 'InvalidEscapeSequenceTemplate', 'NonAbstractClassHasAbstractMethod', 'OptionalTypeBeforeRequired', 'PatternIsOptional', 'OptionalBindingPattern', 'DeclareClassFieldHasInitializer', 'TypeImportCannotSpecifyDefaultAndNamed', 'ConstructorClassField', 'VarRedeclaration', 'InvalidPrivateFieldResolution', 'DuplicateExport', 'ImportAttributesUseAssert']),
    pe = [oe(['jsx'])],
    ce = ne({ optionsCombinations: pe }),
    he = ne({ optionsCombinations: [oe(['jsx', 'typescript']), oe(['typescript'])] }),
    de = ne({ isExpression: !0, optionsCombinations: [oe(['jsx'])] }),
    fe = ne({ isExpression: !0, optionsCombinations: [oe(['typescript'])] }),
    me = ne({ optionsCombinations: [oe(['jsx', ['flow', { all: !0 }], 'flowComments'])] }),
    ye = ne({ optionsCombinations: pe.map((e) => oe(['estree'], e)) }),
    ge = { babel: ce, 'babel-flow': me, 'babel-ts': he, __js_expression: de, __ts_expression: fe, __vue_expression: de, __vue_ts_expression: fe, __vue_event_binding: ce, __vue_ts_event_binding: he, __babel_estree: ye },
    De = c(h(), 1);
   function xe(e = {}) {
    let { allowComments: t = !0 } = e;
    return function (e) {
     let r;
     try {
      r = (0, De.parseExpression)(e, { tokens: !0, ranges: !0, attachComment: !1 });
     } catch (n) {
      throw U(n);
     }
     if (!t && S(r.comments)) throw be(r.comments[0], 'Comment');
     return ve(r), re(r, { type: 'JsonRoot', text: e });
    };
   }
   function be(e, t) {
    let [r, n] = [e.loc.start, e.loc.end].map(({ line: e, column: t }) => ({ line: e, column: t + 1 }));
    return q(`${t} is not allowed in JSON.`, { loc: { start: r, end: n } });
   }
   function ve(e) {
    switch (e.type) {
     case 'ArrayExpression':
      for (let t of e.elements) null !== t && ve(t);
      return;
     case 'ObjectExpression':
      for (let t of e.properties) ve(t);
      return;
     case 'ObjectProperty':
      if (e.computed) throw be(e.key, 'Computed key');
      if (e.shorthand) throw be(e.key, 'Shorthand property');
      return 'Identifier' !== e.key.type && ve(e.key), void ve(e.value);
     case 'UnaryExpression': {
      let { operator: t, argument: r } = e;
      if ('+' !== t && '-' !== t) throw be(e, `Operator '${e.operator}'`);
      if ('NumericLiteral' === r.type || ('Identifier' === r.type && ('Infinity' === r.name || 'NaN' === r.name))) return;
      throw be(r, `Operator '${t}' before '${r.type}'`);
     }
     case 'Identifier':
      if ('Infinity' !== e.name && 'NaN' !== e.name && 'undefined' !== e.name) throw be(e, `Identifier '${e.name}'`);
      return;
     case 'TemplateLiteral':
      if (S(e.expressions)) throw be(e.expressions[0], "'TemplateLiteral' with expression");
      for (let t of e.quasis) ve(t);
      return;
     case 'NullLiteral':
     case 'BooleanLiteral':
     case 'NumericLiteral':
     case 'StringLiteral':
     case 'TemplateElement':
      return;
     default:
      throw be(e, `'${e.type}'`);
    }
   }
   var Ee = xe(),
    Ce = { ...ge, ...{ json: ee({ parse: Ee, hasPragma: () => !0 }), json5: ee(Ee), jsonc: ee(Ee), 'json-stringify': ee({ parse: xe({ allowComments: !1 }), astFormat: 'estree-json' }) } },
    Te = d;
  },
  93872: (e, t, r) => {
   r.d(t, { ZP: () => Uo });
   var n = Object.defineProperty,
    s = (e) => {
     throw TypeError(e);
    },
    i = (e, t) => {
     for (var r in t) n(e, r, { get: t[r], enumerable: !0 });
    },
    a = (e, t, r) => t.has(e) || s('Cannot ' + r),
    o = (e, t, r) => (a(e, t, 'read from private field'), r ? r.call(e) : t.get(e)),
    u = {};
   i(u, { languages: () => qo, options: () => jo, printers: () => Ro });
   var l = {};
   i(l, { canAttachComment: () => gn, embed: () => es, experimentalFeatures: () => ko, getCommentChildNodes: () => Dn, getVisitorKeys: () => U, handleComments: () => gr, insertPragma: () => ds, isBlockComment: () => H, isGap: () => bn, massageAstNode: () => ct, print: () => Fo, printComment: () => yr, willPrintOwnComments: () => xn });
   var p = (e, t, r, n) => {
     if (!e || null != t) return t.replaceAll ? t.replaceAll(r, n) : r.global ? t.replace(r, n) : t.split(r).join(n);
    },
    c = (e, t, r) => {
     if (!e || null != t) return Array.isArray(t) || 'string' == typeof t ? t[r < 0 ? t.length + r : r] : t.at(r);
    };
   var h = function (e) {
    return null !== e && 'object' == typeof e;
   };
   function* d(e, t) {
    let { getVisitorKeys: r, filter: n = () => !0 } = t,
     s = (e) => h(e) && n(e);
    for (let i of r(e)) {
     let t = e[i];
     if (Array.isArray(t)) for (let e of t) s(e) && (yield e);
     else s(t) && (yield t);
    }
   }
   function f(e, { getVisitorKeys: t, predicate: r }) {
    for (let n of (function* (e, t) {
     let r = [e];
     for (let n = 0; n < r.length; n++) {
      let e = r[n];
      for (let n of d(e, t)) yield n, r.push(n);
     }
    })(e, { getVisitorKeys: t }))
     if (r(n)) return !0;
    return !1;
   }
   var m = (e) =>
     !(
      (function (e) {
       return 12288 === e || (e >= 65281 && e <= 65376) || (e >= 65504 && e <= 65510);
      })(e) ||
      (function (e) {
       return (e >= 4352 && e <= 4447) || 8986 === e || 8987 === e || 9001 === e || 9002 === e || (e >= 9193 && e <= 9196) || 9200 === e || 9203 === e || 9725 === e || 9726 === e || 9748 === e || 9749 === e || (e >= 9776 && e <= 9783) || (e >= 9800 && e <= 9811) || 9855 === e || (e >= 9866 && e <= 9871) || 9875 === e || 9889 === e || 9898 === e || 9899 === e || 9917 === e || 9918 === e || 9924 === e || 9925 === e || 9934 === e || 9940 === e || 9962 === e || 9970 === e || 9971 === e || 9973 === e || 9978 === e || 9981 === e || 9989 === e || 9994 === e || 9995 === e || 10024 === e || 10060 === e || 10062 === e || (e >= 10067 && e <= 10069) || 10071 === e || (e >= 10133 && e <= 10135) || 10160 === e || 10175 === e || 11035 === e || 11036 === e || 11088 === e || 11093 === e || (e >= 11904 && e <= 11929) || (e >= 11931 && e <= 12019) || (e >= 12032 && e <= 12245) || (e >= 12272 && e <= 12287) || (e >= 12289 && e <= 12350) || (e >= 12353 && e <= 12438) || (e >= 12441 && e <= 12543) || (e >= 12549 && e <= 12591) || (e >= 12593 && e <= 12686) || (e >= 12688 && e <= 12773) || (e >= 12783 && e <= 12830) || (e >= 12832 && e <= 12871) || (e >= 12880 && e <= 42124) || (e >= 42128 && e <= 42182) || (e >= 43360 && e <= 43388) || (e >= 44032 && e <= 55203) || (e >= 63744 && e <= 64255) || (e >= 65040 && e <= 65049) || (e >= 65072 && e <= 65106) || (e >= 65108 && e <= 65126) || (e >= 65128 && e <= 65131) || (e >= 94176 && e <= 94180) || 94192 === e || 94193 === e || (e >= 94208 && e <= 100343) || (e >= 100352 && e <= 101589) || (e >= 101631 && e <= 101640) || (e >= 110576 && e <= 110579) || (e >= 110581 && e <= 110587) || 110589 === e || 110590 === e || (e >= 110592 && e <= 110882) || 110898 === e || (e >= 110928 && e <= 110930) || 110933 === e || (e >= 110948 && e <= 110951) || (e >= 110960 && e <= 111355) || (e >= 119552 && e <= 119638) || (e >= 119648 && e <= 119670) || 126980 === e || 127183 === e || 127374 === e || (e >= 127377 && e <= 127386) || (e >= 127488 && e <= 127490) || (e >= 127504 && e <= 127547) || (e >= 127552 && e <= 127560) || 127568 === e || 127569 === e || (e >= 127584 && e <= 127589) || (e >= 127744 && e <= 127776) || (e >= 127789 && e <= 127797) || (e >= 127799 && e <= 127868) || (e >= 127870 && e <= 127891) || (e >= 127904 && e <= 127946) || (e >= 127951 && e <= 127955) || (e >= 127968 && e <= 127984) || 127988 === e || (e >= 127992 && e <= 128062) || 128064 === e || (e >= 128066 && e <= 128252) || (e >= 128255 && e <= 128317) || (e >= 128331 && e <= 128334) || (e >= 128336 && e <= 128359) || 128378 === e || 128405 === e || 128406 === e || 128420 === e || (e >= 128507 && e <= 128591) || (e >= 128640 && e <= 128709) || 128716 === e || (e >= 128720 && e <= 128722) || (e >= 128725 && e <= 128727) || (e >= 128732 && e <= 128735) || 128747 === e || 128748 === e || (e >= 128756 && e <= 128764) || (e >= 128992 && e <= 129003) || 129008 === e || (e >= 129292 && e <= 129338) || (e >= 129340 && e <= 129349) || (e >= 129351 && e <= 129535) || (e >= 129648 && e <= 129660) || (e >= 129664 && e <= 129673) || (e >= 129679 && e <= 129734) || (e >= 129742 && e <= 129756) || (e >= 129759 && e <= 129769) || (e >= 129776 && e <= 129784) || (e >= 131072 && e <= 196605) || (e >= 196608 && e <= 262141);
      })(e)
     ),
    y = /[^\x20-\x7F]/u;
   var g = function (e) {
    if (!e) return 0;
    if (!y.test(e)) return e.length;
    e = e.replace(/[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE89\uDE8F-\uDEC2\uDEC6\uDECE-\uDEDC\uDEDF-\uDEE9]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g, '  ');
    let t = 0;
    for (let r of e) {
     let e = r.codePointAt(0);
     e <= 31 || (e >= 127 && e <= 159) || (e >= 768 && e <= 879) || (t += m(e) ? 1 : 2);
    }
    return t;
   };
   function D(e) {
    return (t, r, n) => {
     let s = !(null == n || !n.backwards);
     if (!1 === r) return !1;
     let { length: i } = t,
      a = r;
     for (; a >= 0 && a < i; ) {
      let r = t.charAt(a);
      if (e instanceof RegExp) {
       if (!e.test(r)) return a;
      } else if (!e.includes(r)) return a;
      s ? a-- : a++;
     }
     return (-1 === a || a === i) && a;
    };
   }
   D(/\s/u);
   var x = D(' \t'),
    b = D(',; \t'),
    v = D(/[^\n\r]/u);
   var E = function (e, t, r) {
    let n = !(null == r || !r.backwards);
    if (!1 === t) return !1;
    let s = e.charAt(t);
    if (n) {
     if ('\r' === e.charAt(t - 1) && '\n' === s) return t - 2;
     if ('\n' === s || '\r' === s || '\u2028' === s || '\u2029' === s) return t - 1;
    } else {
     if ('\r' === s && '\n' === e.charAt(t + 1)) return t + 2;
     if ('\n' === s || '\r' === s || '\u2028' === s || '\u2029' === s) return t + 1;
    }
    return t;
   };
   var C = function (e, t, r = {}) {
    let n = x(e, r.backwards ? t - 1 : t, r);
    return n !== E(e, n, r);
   };
   var T = function (e, t) {
    if (!1 === t) return !1;
    if ('/' === e.charAt(t) && '*' === e.charAt(t + 1)) for (let r = t + 2; r < e.length; ++r) if ('*' === e.charAt(r) && '/' === e.charAt(r + 1)) return r + 2;
    return t;
   };
   var S = function (e, t) {
    return !1 !== t && ('/' === e.charAt(t) && '/' === e.charAt(t + 1) ? v(e, t) : t);
   };
   var w = function (e, t) {
    let r = null,
     n = t;
    for (; n !== r; ) (r = n), (n = b(e, n)), (n = T(e, n)), (n = x(e, n));
    return (n = S(e, n)), (n = E(e, n)), !1 !== n && C(e, n);
   };
   var A = function (e) {
     return Array.isArray(e) && e.length > 0;
    },
    F = new Proxy(() => {}, { get: () => F }),
    k = F,
    P = "'";
   var I = function (e, t) {
    let r = !0 === t || t === P ? P : '"',
     n = r === P ? '"' : P,
     s = 0,
     i = 0;
    for (let a of e) a === r ? s++ : a === n && i++;
    return s > i ? n : r;
   };
   var N = function (e, t, r) {
    let n = '"' === t ? "'" : '"',
     s = p(!1, e, /\\(.)|(["'])/gsu, (e, s, i) => (s === n ? s : i === t ? '\\' + i : i || (r && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/u.test(s) ? s : '\\' + s)));
    return t + s + t;
   };
   var B = function (e, t) {
    k(/^(?<quote>["']).*\k<quote>$/su.test(e));
    let r = e.slice(1, -1),
     n = 'json' === t.parser || 'jsonc' === t.parser || ('json5' === t.parser && 'preserve' === t.quoteProps && !t.singleQuote) ? '"' : t.__isInHtmlAttribute ? "'" : I(r, t.singleQuote);
    return e.charAt(0) === n ? e : N(r, n, !1);
   };
   function _(e) {
    var t, r, n;
    let s = (null == (t = e.range) ? void 0 : t[0]) ?? e.start,
     i = null == (n = (null == (r = e.declaration) ? void 0 : r.decorators) ?? e.decorators) ? void 0 : n[0];
    return i ? Math.min(_(i), s) : s;
   }
   function L(e) {
    var t;
    return (null == (t = e.range) ? void 0 : t[1]) ?? e.end;
   }
   function O(e, t) {
    let r = _(e);
    return Number.isInteger(r) && r === _(t);
   }
   function M(e, t) {
    return (
     O(e, t) &&
     (function (e, t) {
      let r = L(e);
      return Number.isInteger(r) && r === L(t);
     })(e, t)
    );
   }
   var j = null;
   function R(e) {
    if (null !== j && (j.property, 1)) {
     let e = j;
     return (j = R.prototype = null), e;
    }
    return (j = R.prototype = e ?? Object.create(null)), new R();
   }
   for (let $o = 0; $o <= 10; $o++) R();
   var q = function (e, t = 'type') {
     return (
      (function (e) {
       R(e);
      })(e),
      function (r) {
       let n = r[t],
        s = e[n];
       if (!Array.isArray(s)) throw Object.assign(new Error(`Missing visitor keys for '${n}'.`), { node: r });
       return s;
      }
     );
    },
    U = q({ ArrayExpression: ['elements'], AssignmentExpression: ['left', 'right'], BinaryExpression: ['left', 'right'], InterpreterDirective: [], Directive: ['value'], DirectiveLiteral: [], BlockStatement: ['directives', 'body'], BreakStatement: ['label'], CallExpression: ['callee', 'arguments', 'typeParameters', 'typeArguments'], CatchClause: ['param', 'body'], ConditionalExpression: ['test', 'consequent', 'alternate'], ContinueStatement: ['label'], DebuggerStatement: [], DoWhileStatement: ['body', 'test'], EmptyStatement: [], ExpressionStatement: ['expression'], File: ['program'], ForInStatement: ['left', 'right', 'body'], ForStatement: ['init', 'test', 'update', 'body'], FunctionDeclaration: ['id', 'typeParameters', 'params', 'predicate', 'returnType', 'body'], FunctionExpression: ['id', 'typeParameters', 'params', 'returnType', 'body'], Identifier: ['typeAnnotation', 'decorators'], IfStatement: ['test', 'consequent', 'alternate'], LabeledStatement: ['label', 'body'], StringLiteral: [], NumericLiteral: [], NullLiteral: [], BooleanLiteral: [], RegExpLiteral: [], LogicalExpression: ['left', 'right'], MemberExpression: ['object', 'property'], NewExpression: ['callee', 'arguments', 'typeParameters', 'typeArguments'], Program: ['directives', 'body'], ObjectExpression: ['properties'], ObjectMethod: ['decorators', 'key', 'typeParameters', 'params', 'returnType', 'body'], ObjectProperty: ['key', 'value', 'decorators'], RestElement: ['argument', 'typeAnnotation', 'decorators'], ReturnStatement: ['argument'], SequenceExpression: ['expressions'], ParenthesizedExpression: ['expression'], SwitchCase: ['test', 'consequent'], SwitchStatement: ['discriminant', 'cases'], ThisExpression: [], ThrowStatement: ['argument'], TryStatement: ['block', 'handler', 'finalizer'], UnaryExpression: ['argument'], UpdateExpression: ['argument'], VariableDeclaration: ['declarations'], VariableDeclarator: ['id', 'init'], WhileStatement: ['test', 'body'], WithStatement: ['object', 'body'], AssignmentPattern: ['left', 'right', 'decorators', 'typeAnnotation'], ArrayPattern: ['elements', 'typeAnnotation', 'decorators'], ArrowFunctionExpression: ['typeParameters', 'params', 'predicate', 'returnType', 'body'], ClassBody: ['body'], ClassExpression: ['decorators', 'id', 'typeParameters', 'superClass', 'superTypeParameters', 'mixins', 'implements', 'body', 'superTypeArguments'], ClassDeclaration: ['decorators', 'id', 'typeParameters', 'superClass', 'superTypeParameters', 'mixins', 'implements', 'body', 'superTypeArguments'], ExportAllDeclaration: ['source', 'attributes', 'exported'], ExportDefaultDeclaration: ['declaration'], ExportNamedDeclaration: ['declaration', 'specifiers', 'source', 'attributes'], ExportSpecifier: ['local', 'exported'], ForOfStatement: ['left', 'right', 'body'], ImportDeclaration: ['specifiers', 'source', 'attributes'], ImportDefaultSpecifier: ['local'], ImportNamespaceSpecifier: ['local'], ImportSpecifier: ['imported', 'local'], ImportExpression: ['source', 'options'], MetaProperty: ['meta', 'property'], ClassMethod: ['decorators', 'key', 'typeParameters', 'params', 'returnType', 'body'], ObjectPattern: ['properties', 'typeAnnotation', 'decorators'], SpreadElement: ['argument'], Super: [], TaggedTemplateExpression: ['tag', 'typeParameters', 'quasi', 'typeArguments'], TemplateElement: [], TemplateLiteral: ['quasis', 'expressions'], YieldExpression: ['argument'], AwaitExpression: ['argument'], BigIntLiteral: [], ExportNamespaceSpecifier: ['exported'], OptionalMemberExpression: ['object', 'property'], OptionalCallExpression: ['callee', 'arguments', 'typeParameters', 'typeArguments'], ClassProperty: ['decorators', 'variance', 'key', 'typeAnnotation', 'value'], ClassAccessorProperty: ['decorators', 'key', 'typeAnnotation', 'value'], ClassPrivateProperty: ['decorators', 'variance', 'key', 'typeAnnotation', 'value'], ClassPrivateMethod: ['decorators', 'key', 'typeParameters', 'params', 'returnType', 'body'], PrivateName: ['id'], StaticBlock: ['body'], AnyTypeAnnotation: [], ArrayTypeAnnotation: ['elementType'], BooleanTypeAnnotation: [], BooleanLiteralTypeAnnotation: [], NullLiteralTypeAnnotation: [], ClassImplements: ['id', 'typeParameters'], DeclareClass: ['id', 'typeParameters', 'extends', 'mixins', 'implements', 'body'], DeclareFunction: ['id', 'predicate'], DeclareInterface: ['id', 'typeParameters', 'extends', 'body'], DeclareModule: ['id', 'body'], DeclareModuleExports: ['typeAnnotation'], DeclareTypeAlias: ['id', 'typeParameters', 'right'], DeclareOpaqueType: ['id', 'typeParameters', 'supertype'], DeclareVariable: ['id'], DeclareExportDeclaration: ['declaration', 'specifiers', 'source', 'attributes'], DeclareExportAllDeclaration: ['source', 'attributes'], DeclaredPredicate: ['value'], ExistsTypeAnnotation: [], FunctionTypeAnnotation: ['typeParameters', 'this', 'params', 'rest', 'returnType'], FunctionTypeParam: ['name', 'typeAnnotation'], GenericTypeAnnotation: ['id', 'typeParameters'], InferredPredicate: [], InterfaceExtends: ['id', 'typeParameters'], InterfaceDeclaration: ['id', 'typeParameters', 'extends', 'body'], InterfaceTypeAnnotation: ['extends', 'body'], IntersectionTypeAnnotation: ['types'], MixedTypeAnnotation: [], EmptyTypeAnnotation: [], NullableTypeAnnotation: ['typeAnnotation'], NumberLiteralTypeAnnotation: [], NumberTypeAnnotation: [], ObjectTypeAnnotation: ['properties', 'indexers', 'callProperties', 'internalSlots'], ObjectTypeInternalSlot: ['id', 'value'], ObjectTypeCallProperty: ['value'], ObjectTypeIndexer: ['variance', 'id', 'key', 'value'], ObjectTypeProperty: ['key', 'value', 'variance'], ObjectTypeSpreadProperty: ['argument'], OpaqueType: ['id', 'typeParameters', 'supertype', 'impltype'], QualifiedTypeIdentifier: ['qualification', 'id'], StringLiteralTypeAnnotation: [], StringTypeAnnotation: [], SymbolTypeAnnotation: [], ThisTypeAnnotation: [], TupleTypeAnnotation: ['types', 'elementTypes'], TypeofTypeAnnotation: ['argument', 'typeArguments'], TypeAlias: ['id', 'typeParameters', 'right'], TypeAnnotation: ['typeAnnotation'], TypeCastExpression: ['expression', 'typeAnnotation'], TypeParameter: ['bound', 'default', 'variance'], TypeParameterDeclaration: ['params'], TypeParameterInstantiation: ['params'], UnionTypeAnnotation: ['types'], Variance: [], VoidTypeAnnotation: [], EnumDeclaration: ['id', 'body'], EnumBooleanBody: ['members'], EnumNumberBody: ['members'], EnumStringBody: ['members'], EnumSymbolBody: ['members'], EnumBooleanMember: ['id', 'init'], EnumNumberMember: ['id', 'init'], EnumStringMember: ['id', 'init'], EnumDefaultedMember: ['id'], IndexedAccessType: ['objectType', 'indexType'], OptionalIndexedAccessType: ['objectType', 'indexType'], JSXAttribute: ['name', 'value'], JSXClosingElement: ['name'], JSXElement: ['openingElement', 'children', 'closingElement'], JSXEmptyExpression: [], JSXExpressionContainer: ['expression'], JSXSpreadChild: ['expression'], JSXIdentifier: [], JSXMemberExpression: ['object', 'property'], JSXNamespacedName: ['namespace', 'name'], JSXOpeningElement: ['name', 'typeParameters', 'typeArguments', 'attributes'], JSXSpreadAttribute: ['argument'], JSXText: [], JSXFragment: ['openingFragment', 'children', 'closingFragment'], JSXOpeningFragment: [], JSXClosingFragment: [], Noop: [], Placeholder: [], V8IntrinsicIdentifier: [], ArgumentPlaceholder: [], BindExpression: ['object', 'callee'], ImportAttribute: ['key', 'value'], Decorator: ['expression'], DoExpression: ['body'], ExportDefaultSpecifier: ['exported'], RecordExpression: ['properties'], TupleExpression: ['elements'], ModuleExpression: ['body'], TopicReference: [], PipelineTopicExpression: ['expression'], PipelineBareFunction: ['callee'], PipelinePrimaryTopicReference: [], TSParameterProperty: ['parameter', 'decorators'], TSDeclareFunction: ['id', 'typeParameters', 'params', 'returnType', 'body'], TSDeclareMethod: ['decorators', 'key', 'typeParameters', 'params', 'returnType'], TSQualifiedName: ['left', 'right'], TSCallSignatureDeclaration: ['typeParameters', 'parameters', 'typeAnnotation', 'params', 'returnType'], TSConstructSignatureDeclaration: ['typeParameters', 'parameters', 'typeAnnotation', 'params', 'returnType'], TSPropertySignature: ['key', 'typeAnnotation'], TSMethodSignature: ['key', 'typeParameters', 'parameters', 'typeAnnotation', 'params', 'returnType'], TSIndexSignature: ['parameters', 'typeAnnotation'], TSAnyKeyword: [], TSBooleanKeyword: [], TSBigIntKeyword: [], TSIntrinsicKeyword: [], TSNeverKeyword: [], TSNullKeyword: [], TSNumberKeyword: [], TSObjectKeyword: [], TSStringKeyword: [], TSSymbolKeyword: [], TSUndefinedKeyword: [], TSUnknownKeyword: [], TSVoidKeyword: [], TSThisType: [], TSFunctionType: ['typeParameters', 'parameters', 'typeAnnotation', 'params', 'returnType'], TSConstructorType: ['typeParameters', 'parameters', 'typeAnnotation', 'params', 'returnType'], TSTypeReference: ['typeName', 'typeParameters', 'typeArguments'], TSTypePredicate: ['parameterName', 'typeAnnotation'], TSTypeQuery: ['exprName', 'typeParameters', 'typeArguments'], TSTypeLiteral: ['members'], TSArrayType: ['elementType'], TSTupleType: ['elementTypes'], TSOptionalType: ['typeAnnotation'], TSRestType: ['typeAnnotation'], TSNamedTupleMember: ['label', 'elementType'], TSUnionType: ['types'], TSIntersectionType: ['types'], TSConditionalType: ['checkType', 'extendsType', 'trueType', 'falseType'], TSInferType: ['typeParameter'], TSParenthesizedType: ['typeAnnotation'], TSTypeOperator: ['typeAnnotation'], TSIndexedAccessType: ['objectType', 'indexType'], TSMappedType: ['typeParameter', 'nameType', 'typeAnnotation'], TSTemplateLiteralType: ['quasis', 'types'], TSLiteralType: ['literal'], TSExpressionWithTypeArguments: ['expression', 'typeParameters'], TSInterfaceDeclaration: ['id', 'typeParameters', 'extends', 'body'], TSInterfaceBody: ['body'], TSTypeAliasDeclaration: ['id', 'typeParameters', 'typeAnnotation'], TSInstantiationExpression: ['expression', 'typeParameters', 'typeArguments'], TSAsExpression: ['expression', 'typeAnnotation'], TSSatisfiesExpression: ['expression', 'typeAnnotation'], TSTypeAssertion: ['typeAnnotation', 'expression'], TSEnumBody: ['members'], TSEnumDeclaration: ['id', 'members'], TSEnumMember: ['id', 'initializer'], TSModuleDeclaration: ['id', 'body'], TSModuleBlock: ['body'], TSImportType: ['argument', 'options', 'qualifier', 'typeParameters', 'typeArguments'], TSImportEqualsDeclaration: ['id', 'moduleReference'], TSExternalModuleReference: ['expression'], TSNonNullExpression: ['expression'], TSExportAssignment: ['expression'], TSNamespaceExportDeclaration: ['id'], TSTypeAnnotation: ['typeAnnotation'], TSTypeParameterInstantiation: ['params'], TSTypeParameterDeclaration: ['params'], TSTypeParameter: ['constraint', 'default', 'name'], ChainExpression: ['expression'], ExperimentalRestProperty: ['argument'], ExperimentalSpreadProperty: ['argument'], Literal: [], MethodDefinition: ['decorators', 'key', 'value'], PrivateIdentifier: [], Property: ['key', 'value'], PropertyDefinition: ['decorators', 'key', 'typeAnnotation', 'value', 'variance'], AccessorProperty: ['decorators', 'key', 'typeAnnotation', 'value'], TSAbstractAccessorProperty: ['decorators', 'key', 'typeAnnotation'], TSAbstractKeyword: [], TSAbstractMethodDefinition: ['key', 'value'], TSAbstractPropertyDefinition: ['decorators', 'key', 'typeAnnotation'], TSAsyncKeyword: [], TSClassImplements: ['expression', 'typeArguments', 'typeParameters'], TSDeclareKeyword: [], TSEmptyBodyFunctionExpression: ['id', 'typeParameters', 'params', 'returnType'], TSExportKeyword: [], TSInterfaceHeritage: ['expression', 'typeArguments', 'typeParameters'], TSPrivateKeyword: [], TSProtectedKeyword: [], TSPublicKeyword: [], TSReadonlyKeyword: [], TSStaticKeyword: [], AsConstExpression: ['expression'], AsExpression: ['expression', 'typeAnnotation'], BigIntLiteralTypeAnnotation: [], BigIntTypeAnnotation: [], ComponentDeclaration: ['id', 'params', 'body', 'typeParameters', 'rendersType'], ComponentParameter: ['name', 'local'], ComponentTypeAnnotation: ['params', 'rest', 'typeParameters', 'rendersType'], ComponentTypeParameter: ['name', 'typeAnnotation'], ConditionalTypeAnnotation: ['checkType', 'extendsType', 'trueType', 'falseType'], DeclareComponent: ['id', 'params', 'rest', 'typeParameters', 'rendersType'], DeclareEnum: ['id', 'body'], DeclareHook: ['id'], DeclareNamespace: ['id', 'body'], EnumBigIntBody: ['members'], EnumBigIntMember: ['id', 'init'], HookDeclaration: ['id', 'params', 'body', 'typeParameters', 'returnType'], HookTypeAnnotation: ['params', 'returnType', 'rest', 'typeParameters'], InferTypeAnnotation: ['typeParameter'], KeyofTypeAnnotation: ['argument'], ObjectTypeMappedTypeProperty: ['keyTparam', 'propType', 'sourceType', 'variance'], QualifiedTypeofIdentifier: ['qualification', 'id'], TupleTypeLabeledElement: ['label', 'elementType', 'variance'], TupleTypeSpreadElement: ['label', 'typeAnnotation'], TypeOperator: ['typeAnnotation'], TypePredicate: ['parameterName', 'typeAnnotation', 'asserts'], NGRoot: ['node'], NGPipeExpression: ['left', 'right', 'arguments'], NGChainedExpression: ['expressions'], NGEmptyExpression: [], NGMicrosyntax: ['body'], NGMicrosyntaxKey: [], NGMicrosyntaxExpression: ['expression', 'alias'], NGMicrosyntaxKeyedExpression: ['key', 'expression'], NGMicrosyntaxLet: ['key', 'value'], NGMicrosyntaxAs: ['key', 'alias'], JsExpressionRoot: ['node'], JsonRoot: ['node'], TSJSDocAllType: [], TSJSDocUnknownType: [], TSJSDocNullableType: ['typeAnnotation'], TSJSDocNonNullableType: ['typeAnnotation'], NeverTypeAnnotation: [], UndefinedTypeAnnotation: [], UnknownTypeAnnotation: [], SatisfiesExpression: ['expression', 'typeAnnotation'] });
   var $ = function (e) {
     let t = new Set(e);
     return (e) => t.has(null == e ? void 0 : e.type);
    },
    H = $(['Block', 'CommentBlock', 'MultiLine']),
    z = $(['AnyTypeAnnotation', 'ThisTypeAnnotation', 'NumberTypeAnnotation', 'VoidTypeAnnotation', 'BooleanTypeAnnotation', 'BigIntTypeAnnotation', 'SymbolTypeAnnotation', 'StringTypeAnnotation', 'NeverTypeAnnotation', 'UndefinedTypeAnnotation', 'UnknownTypeAnnotation', 'EmptyTypeAnnotation', 'MixedTypeAnnotation']);
   var V = function (e, t) {
    return t.some((t) =>
     (function (e, t) {
      let r = t.split('.');
      for (let n = r.length - 1; n >= 0; n--) {
       let t = r[n];
       if (0 === n) return 'Identifier' === e.type && e.name === t;
       if ('MemberExpression' !== e.type || e.optional || e.computed || 'Identifier' !== e.property.type || e.property.name !== t) return !1;
       e = e.object;
      }
     })(e, t),
    );
   };
   var W = function ({ type: e }) {
    return e.startsWith('TS') && e.endsWith('Keyword');
   };
   function J(e, t) {
    return t(e) || f(e, { getVisitorKeys: U, predicate: t });
   }
   function K(e) {
    return 'AssignmentExpression' === e.type || 'BinaryExpression' === e.type || 'LogicalExpression' === e.type || 'NGPipeExpression' === e.type || 'ConditionalExpression' === e.type || be(e) || ve(e) || 'SequenceExpression' === e.type || 'TaggedTemplateExpression' === e.type || 'BindExpression' === e.type || ('UpdateExpression' === e.type && !e.prefix) || it(e) || 'TSNonNullExpression' === e.type || 'ChainExpression' === e.type;
   }
   function G(e) {
    return e.expressions ? e.expressions[0] : (e.left ?? e.test ?? e.callee ?? e.object ?? e.tag ?? e.argument ?? e.expression);
   }
   function X(e) {
    if (e.expressions) return ['expressions', 0];
    if (e.left) return ['left'];
    if (e.test) return ['test'];
    if (e.object) return ['object'];
    if (e.callee) return ['callee'];
    if (e.tag) return ['tag'];
    if (e.argument) return ['argument'];
    if (e.expression) return ['expression'];
    throw new Error('Unexpected node has no left side.');
   }
   var Y = $(['Line', 'CommentLine', 'SingleLine', 'HashbangComment', 'HTMLOpen', 'HTMLClose', 'Hashbang', 'InterpreterDirective']),
    Q = $(['ExportDefaultDeclaration', 'DeclareExportDeclaration', 'ExportNamedDeclaration', 'ExportAllDeclaration', 'DeclareExportAllDeclaration']),
    Z = $(['ArrayExpression', 'TupleExpression']),
    ee = $(['ObjectExpression', 'RecordExpression']);
   function te(e) {
    return 'NumericLiteral' === e.type || ('Literal' === e.type && 'number' == typeof e.value);
   }
   function re(e) {
    return 'UnaryExpression' === e.type && ('+' === e.operator || '-' === e.operator) && te(e.argument);
   }
   function ne(e) {
    return !(!e || ('StringLiteral' !== e.type && ('Literal' !== e.type || 'string' != typeof e.value)));
   }
   function se(e) {
    return 'RegExpLiteral' === e.type || ('Literal' === e.type && !!e.regex);
   }
   var ie = $(['Literal', 'BooleanLiteral', 'BigIntLiteral', 'DirectiveLiteral', 'NullLiteral', 'NumericLiteral', 'RegExpLiteral', 'StringLiteral']),
    ae = $(['Identifier', 'ThisExpression', 'Super', 'PrivateName', 'PrivateIdentifier']),
    oe = $(['ObjectTypeAnnotation', 'TSTypeLiteral', 'TSMappedType']),
    ue = $(['FunctionExpression', 'ArrowFunctionExpression']);
   function le(e) {
    return be(e) && 'Identifier' === e.callee.type && ['async', 'inject', 'fakeAsync', 'waitForAsync'].includes(e.callee.name);
   }
   var pe = $(['JSXElement', 'JSXFragment']);
   function ce(e) {
    return (e.method && 'init' === e.kind) || 'get' === e.kind || 'set' === e.kind;
   }
   function he(e) {
    return !(('ObjectTypeProperty' !== e.type && 'ObjectTypeInternalSlot' !== e.type) || e.static || e.method || 'get' === e.kind || 'set' === e.kind || 'FunctionTypeAnnotation' !== e.value.type);
   }
   var de = $(['BinaryExpression', 'LogicalExpression', 'NGPipeExpression']);
   function fe(e) {
    return ve(e) || ('BindExpression' === e.type && !!e.object);
   }
   var me = $(['TSThisType', 'NullLiteralTypeAnnotation', 'BooleanLiteralTypeAnnotation', 'StringLiteralTypeAnnotation', 'BigIntLiteralTypeAnnotation', 'NumberLiteralTypeAnnotation', 'TSLiteralType', 'TSTemplateLiteralType']);
   function ye(e) {
    return W(e) || z(e) || me(e) || (('GenericTypeAnnotation' === e.type || 'TSTypeReference' === e.type) && !e.typeParameters && !e.typeArguments);
   }
   var ge = ['it', 'it.only', 'it.skip', 'describe', 'describe.only', 'describe.skip', 'test', 'test.only', 'test.skip', 'test.step', 'test.describe', 'test.describe.only', 'test.describe.parallel', 'test.describe.parallel.only', 'test.describe.serial', 'test.describe.serial.only', 'skip', 'xit', 'xdescribe', 'xtest', 'fit', 'fdescribe', 'ftest'];
   function De(e, t) {
    if ('CallExpression' !== (null == e ? void 0 : e.type) || e.optional) return !1;
    let r = Je(e);
    if (1 === r.length) {
     if (le(e) && De(t)) return ue(r[0]);
     if (
      (function (e) {
       return 'Identifier' === e.type && ('beforeEach' === e.name || 'beforeAll' === e.name || 'afterEach' === e.name || 'afterAll' === e.name);
      })(e.callee)
     )
      return le(r[0]);
    } else if (
     (2 === r.length || 3 === r.length) &&
     ('TemplateLiteral' === r[0].type || ne(r[0])) &&
     (function (e) {
      return V(e, ge);
     })(e.callee)
    )
     return (
      !(r[2] && !te(r[2])) &&
      ((2 === r.length
       ? ue(r[1])
       : (function (e) {
          return 'FunctionExpression' === e.type || ('ArrowFunctionExpression' === e.type && 'BlockStatement' === e.body.type);
         })(r[1]) && Ve(r[1]).length <= 1) ||
       le(r[1]))
     );
    return !1;
   }
   var xe = (e) => (t) => ('ChainExpression' === (null == t ? void 0 : t.type) && (t = t.expression), e(t)),
    be = xe($(['CallExpression', 'OptionalCallExpression'])),
    ve = xe($(['MemberExpression', 'OptionalMemberExpression']));
   function Ee(e, t = 5) {
    return Ce(e, t) <= t;
   }
   function Ce(e, t) {
    let r = 0;
    for (let n in e) {
     let s = e[n];
     if ((s && 'object' == typeof s && 'string' == typeof s.type && (r++, (r += Ce(s, t - r))), r > t)) return r;
    }
    return r;
   }
   var Te = 0.25;
   function Se(e, t) {
    let { printWidth: r } = t;
    if (et(e)) return !1;
    let n = r * Te;
    if ('ThisExpression' === e.type || ('Identifier' === e.type && e.name.length <= n) || (re(e) && !et(e.argument))) return !0;
    let s = ('Literal' === e.type && 'regex' in e && e.regex.pattern) || ('RegExpLiteral' === e.type && e.pattern);
    return s ? s.length <= n : ne(e) ? B(Be(e), t).length <= n : 'TemplateLiteral' === e.type ? 0 === e.expressions.length && e.quasis[0].value.raw.length <= n && !e.quasis[0].value.raw.includes('\n') : 'UnaryExpression' === e.type ? Se(e.argument, { printWidth: r }) : 'CallExpression' === e.type && 0 === e.arguments.length && 'Identifier' === e.callee.type ? e.callee.name.length <= n - 2 : ie(e);
   }
   function we(e, t) {
    return pe(t) ? Ye(t) : et(t, Qe.Leading, (t) => C(e, L(t)));
   }
   function Ae(e) {
    return e.quasis.some((e) => e.value.raw.includes('\n'));
   }
   function Fe(e, t) {
    return (('TemplateLiteral' === e.type && Ae(e)) || ('TaggedTemplateExpression' === e.type && Ae(e.quasi))) && !C(t, _(e), { backwards: !0 });
   }
   function ke(e) {
    if (!et(e)) return !1;
    let t = c(!1, tt(e, Qe.Dangling), -1);
    return t && !H(t);
   }
   function Pe(e) {
    let { node: t, parent: r, key: n } = e;
    return 'callee' === n && be(t) && be(r) && r.arguments.length > 0 && t.arguments.length > r.arguments.length;
   }
   var Ie = new Set(['!', '-', '+', '~']);
   function Ne(e, t = 2) {
    if (t <= 0) return !1;
    if ('ChainExpression' === e.type || 'TSNonNullExpression' === e.type) return Ne(e.expression, t);
    let r = (e) => Ne(e, t - 1);
    if (se(e)) return g(e.pattern ?? e.regex.pattern) <= 5;
    if (ie(e) || ae(e) || 'ArgumentPlaceholder' === e.type) return !0;
    if ('TemplateLiteral' === e.type) return e.quasis.every((e) => !e.value.raw.includes('\n')) && e.expressions.every(r);
    if (ee(e)) return e.properties.every((e) => !e.computed && (e.shorthand || (e.value && r(e.value))));
    if (Z(e)) return e.elements.every((e) => null === e || r(e));
    if (nt(e)) {
     if ('ImportExpression' === e.type || Ne(e.callee, t)) {
      let n = Je(e);
      return n.length <= t && n.every(r);
     }
     return !1;
    }
    return ve(e) ? Ne(e.object, t) && Ne(e.property, t) : !!(('UnaryExpression' === e.type && Ie.has(e.operator)) || 'UpdateExpression' === e.type) && Ne(e.argument, t);
   }
   function Be(e) {
    var t;
    return (null == (t = e.extra) ? void 0 : t.raw) ?? e.raw;
   }
   function _e(e) {
    return e;
   }
   function Le(e, t = 'es5') {
    return ('es5' === e.trailingComma && 'es5' === t) || ('all' === e.trailingComma && ('all' === t || 'es5' === t));
   }
   function Oe(e, t) {
    switch (e.type) {
     case 'BinaryExpression':
     case 'LogicalExpression':
     case 'AssignmentExpression':
     case 'NGPipeExpression':
      return Oe(e.left, t);
     case 'MemberExpression':
     case 'OptionalMemberExpression':
      return Oe(e.object, t);
     case 'TaggedTemplateExpression':
      return 'FunctionExpression' !== e.tag.type && Oe(e.tag, t);
     case 'CallExpression':
     case 'OptionalCallExpression':
      return 'FunctionExpression' !== e.callee.type && Oe(e.callee, t);
     case 'ConditionalExpression':
      return Oe(e.test, t);
     case 'UpdateExpression':
      return !e.prefix && Oe(e.argument, t);
     case 'BindExpression':
      return e.object && Oe(e.object, t);
     case 'SequenceExpression':
      return Oe(e.expressions[0], t);
     case 'ChainExpression':
     case 'TSSatisfiesExpression':
     case 'TSAsExpression':
     case 'TSNonNullExpression':
     case 'AsExpression':
     case 'AsConstExpression':
     case 'SatisfiesExpression':
      return Oe(e.expression, t);
     default:
      return t(e);
    }
   }
   var Me = { '==': !0, '!=': !0, '===': !0, '!==': !0 },
    je = { '*': !0, '/': !0, '%': !0 },
    Re = { '>>': !0, '>>>': !0, '<<': !0 };
   function qe(e, t) {
    return !($e(t) !== $e(e) || '**' === e || (Me[e] && Me[t]) || ('%' === t && je[e]) || ('%' === e && je[t]) || (t !== e && je[t] && je[e]) || (Re[e] && Re[t]));
   }
   var Ue = new Map([['|>'], ['??'], ['||'], ['&&'], ['|'], ['^'], ['&'], ['==', '===', '!=', '!=='], ['<', '>', '<=', '>=', 'in', 'instanceof'], ['>>', '<<', '>>>'], ['+', '-'], ['*', '/', '%'], ['**']].flatMap((e, t) => e.map((e) => [e, t])));
   function $e(e) {
    return Ue.get(e);
   }
   function He(e) {
    var t;
    if (e.rest) return !0;
    let r = Ve(e);
    return 'RestElement' === (null == (t = c(!1, r, -1)) ? void 0 : t.type);
   }
   var ze = new WeakMap();
   function Ve(e) {
    if (ze.has(e)) return ze.get(e);
    let t = [];
    return e.this && t.push(e.this), Array.isArray(e.parameters) ? t.push(...e.parameters) : Array.isArray(e.params) && t.push(...e.params), e.rest && t.push(e.rest), ze.set(e, t), t;
   }
   var We = new WeakMap();
   function Je(e) {
    if (We.has(e)) return We.get(e);
    if ('ChainExpression' === e.type) return Je(e.expression);
    let t = e.arguments;
    return 'ImportExpression' === e.type && ((t = [e.source]), e.options && t.push(e.options)), We.set(e, t), t;
   }
   function Ke(e, t) {
    let { node: r } = e;
    if ('ChainExpression' === r.type) return e.call(() => Ke(e, t), 'expression');
    'ImportExpression' === r.type ? (e.call((e) => t(e, 0), 'source'), r.options && e.call((e) => t(e, 1), 'options')) : e.each(t, 'arguments');
   }
   function Ge(e, t) {
    let r = [];
    if (('ChainExpression' === e.type && ((e = e.expression), r.push('expression')), 'ImportExpression' === e.type)) {
     if (0 === t || t === (e.options ? -2 : -1)) return [...r, 'source'];
     if (e.options && (1 === t || -1 === t)) return [...r, 'options'];
     throw new RangeError('Invalid argument index');
    }
    if ((t < 0 && (t = e.arguments.length + t), t < 0 || t >= e.arguments.length)) throw new RangeError('Invalid argument index');
    return [...r, 'arguments', t];
   }
   function Xe(e) {
    return 'prettier-ignore' === e.value.trim() && !e.unignore;
   }
   function Ye(e) {
    return (null == e ? void 0 : e.prettierIgnore) || et(e, Qe.PrettierIgnore);
   }
   var Qe = { Leading: 2, Trailing: 4, Dangling: 8, Block: 16, Line: 32, PrettierIgnore: 64, First: 128, Last: 256 },
    Ze = (e, t) => {
     if (('function' == typeof e && ((t = e), (e = 0)), e || t)) return (r, n, s) => !((e & Qe.Leading && !r.leading) || (e & Qe.Trailing && !r.trailing) || (e & Qe.Dangling && (r.leading || r.trailing)) || (e & Qe.Block && !H(r)) || (e & Qe.Line && !Y(r)) || (e & Qe.First && 0 !== n) || (e & Qe.Last && n !== s.length - 1) || (e & Qe.PrettierIgnore && !Xe(r)) || (t && !t(r)));
    };
   function et(e, t, r) {
    if (!A(null == e ? void 0 : e.comments)) return !1;
    let n = Ze(t, r);
    return !n || e.comments.some(n);
   }
   function tt(e, t, r) {
    if (!Array.isArray(null == e ? void 0 : e.comments)) return [];
    let n = Ze(t, r);
    return n ? e.comments.filter(n) : e.comments;
   }
   var rt = (e, { originalText: t }) => w(t, L(e));
   function nt(e) {
    return be(e) || 'NewExpression' === e.type || 'ImportExpression' === e.type;
   }
   function st(e) {
    return e && ('ObjectProperty' === e.type || ('Property' === e.type && !ce(e)));
   }
   var it = $(['TSAsExpression', 'TSSatisfiesExpression', 'AsExpression', 'AsConstExpression', 'SatisfiesExpression']),
    at = $(['UnionTypeAnnotation', 'TSUnionType']),
    ot = $(['IntersectionTypeAnnotation', 'TSIntersectionType']),
    ut = new Set(['range', 'raw', 'comments', 'leadingComments', 'trailingComments', 'innerComments', 'extra', 'start', 'end', 'loc', 'flags', 'errors', 'tokens']),
    lt = (e) => {
     for (let t of e.quasis) delete t.value;
    };
   function pt(e, t, r) {
    var n, s;
    if (('Program' === e.type && delete t.sourceType, ('BigIntLiteral' === e.type || 'BigIntLiteralTypeAnnotation' === e.type) && e.value && (t.value = e.value.toLowerCase()), ('BigIntLiteral' === e.type || 'Literal' === e.type) && e.bigint && (t.bigint = e.bigint.toLowerCase()), 'EmptyStatement' === e.type || 'JSXText' === e.type || ('JSXExpressionContainer' === e.type && ('Literal' === e.expression.type || 'StringLiteral' === e.expression.type) && ' ' === e.expression.value))) return null;
    if (('Property' === e.type || 'ObjectProperty' === e.type || 'MethodDefinition' === e.type || 'ClassProperty' === e.type || 'ClassMethod' === e.type || 'PropertyDefinition' === e.type || 'TSDeclareMethod' === e.type || 'TSPropertySignature' === e.type || 'ObjectTypeProperty' === e.type || 'ImportAttribute' === e.type) && e.key && !e.computed) {
     let { key: r } = e;
     ne(r) || te(r) ? (t.key = String(r.value)) : 'Identifier' === r.type && (t.key = r.name);
    }
    if ('JSXElement' === e.type && 'style' === e.openingElement.name.name && e.openingElement.attributes.some((e) => 'JSXAttribute' === e.type && 'jsx' === e.name.name)) for (let { type: a, expression: o } of t.children) 'JSXExpressionContainer' === a && 'TemplateLiteral' === o.type && lt(o);
    'JSXAttribute' === e.type && 'css' === e.name.name && 'JSXExpressionContainer' === e.value.type && 'TemplateLiteral' === e.value.expression.type && lt(t.value.expression), 'JSXAttribute' === e.type && 'Literal' === (null == (n = e.value) ? void 0 : n.type) && /["']|&quot;|&apos;/u.test(e.value.value) && (t.value.value = p(!1, e.value.value, /["']|&quot;|&apos;/gu, '"'));
    let i = e.expression || e.callee;
    if ('Decorator' === e.type && 'CallExpression' === i.type && 'Component' === i.callee.name && 1 === i.arguments.length) {
     let r = e.expression.arguments[0].properties;
     for (let [e, n] of t.expression.arguments[0].properties.entries())
      switch (r[e].key.name) {
       case 'styles':
        Z(n.value) && lt(n.value.elements[0]);
        break;
       case 'template':
        'TemplateLiteral' === n.value.type && lt(n.value);
      }
    }
    'TaggedTemplateExpression' === e.type && ('MemberExpression' === e.tag.type || ('Identifier' === e.tag.type && ('gql' === e.tag.name || 'graphql' === e.tag.name || 'css' === e.tag.name || 'md' === e.tag.name || 'markdown' === e.tag.name || 'html' === e.tag.name)) || 'CallExpression' === e.tag.type) && lt(t.quasi), 'TemplateLiteral' === e.type && ((null != (s = e.leadingComments) && s.some((e) => H(e) && ['GraphQL', 'HTML'].some((t) => e.value === ` ${t} `))) || ('CallExpression' === r.type && 'graphql' === r.callee.name) || !e.leadingComments) && lt(t), 'ChainExpression' === e.type && 'TSNonNullExpression' === e.expression.type && ((t.type = 'TSNonNullExpression'), (t.expression.type = 'ChainExpression')), 'TSMappedType' === e.type && (delete t.key, delete t.constraint), 'TSEnumDeclaration' === e.type && delete t.body;
   }
   pt.ignoredProperties = ut;
   var ct = pt,
    ht = 'string',
    dt = 'array',
    ft = 'cursor',
    mt = 'indent',
    yt = 'align',
    gt = 'trim',
    Dt = 'group',
    xt = 'fill',
    bt = 'if-break',
    vt = 'indent-if-break',
    Et = 'line-suffix',
    Ct = 'line-suffix-boundary',
    Tt = 'line',
    St = 'label',
    wt = 'break-parent',
    At = new Set([ft, mt, yt, gt, Dt, xt, bt, vt, Et, Ct, Tt, St, wt]);
   var Ft = function (e) {
    if ('string' == typeof e) return ht;
    if (Array.isArray(e)) return dt;
    if (!e) return;
    let { type: t } = e;
    return At.has(t) ? t : void 0;
   };
   function kt(e) {
    let t = null === e ? 'null' : typeof e;
    if ('string' !== t && 'object' !== t) return `Unexpected doc '${t}', \nExpected it to be 'string' or 'object'.`;
    if (Ft(e)) throw new Error('doc is valid.');
    let r = Object.prototype.toString.call(e);
    if ('[object Object]' !== r) return `Unexpected doc '${r}'.`;
    let n = ((e) => new Intl.ListFormat('en-US', { type: 'disjunction' }).format(e))([...At].map((e) => `'${e}'`));
    return `Unexpected doc.type '${e.type}'.\nExpected it to be ${n}.`;
   }
   var Pt = class extends Error {
     name = 'InvalidDocError';
     constructor(e) {
      super(kt(e)), (this.doc = e);
     }
    },
    It = {};
   var Nt = function (e, t, r, n) {
    let s = [e];
    for (; s.length > 0; ) {
     let e = s.pop();
     if (e === It) {
      r(s.pop());
      continue;
     }
     r && s.push(e, It);
     let i = Ft(e);
     if (!i) throw new Pt(e);
     if (!1 !== (null == t ? void 0 : t(e)))
      switch (i) {
       case dt:
       case xt: {
        let t = i === dt ? e : e.parts;
        for (let e = t.length - 1; e >= 0; --e) s.push(t[e]);
        break;
       }
       case bt:
        s.push(e.flatContents, e.breakContents);
        break;
       case Dt:
        if (n && e.expandedStates) for (let t = e.expandedStates.length - 1; t >= 0; --t) s.push(e.expandedStates[t]);
        else s.push(e.contents);
        break;
       case yt:
       case mt:
       case vt:
       case St:
       case Et:
        s.push(e.contents);
        break;
       case ht:
       case ft:
       case gt:
       case Ct:
       case Tt:
       case wt:
        break;
       default:
        throw new Pt(e);
      }
    }
   };
   function Bt(e, t) {
    if ('string' == typeof e) return t(e);
    let r = new Map();
    return n(e);
    function n(e) {
     if (r.has(e)) return r.get(e);
     let s = (function (e) {
      switch (Ft(e)) {
       case dt:
        return t(e.map(n));
       case xt:
        return t({ ...e, parts: e.parts.map(n) });
       case bt:
        return t({ ...e, breakContents: n(e.breakContents), flatContents: n(e.flatContents) });
       case Dt: {
        let { expandedStates: r, contents: s } = e;
        return r ? ((r = r.map(n)), (s = r[0])) : (s = n(s)), t({ ...e, contents: s, expandedStates: r });
       }
       case yt:
       case mt:
       case vt:
       case St:
       case Et:
        return t({ ...e, contents: n(e.contents) });
       case ht:
       case ft:
       case gt:
       case Ct:
       case Tt:
       case wt:
        return t(e);
       default:
        throw new Pt(e);
      }
     })(e);
     return r.set(e, s), s;
    }
   }
   function _t(e, t, r) {
    let n = r,
     s = !1;
    return (
     Nt(e, function (e) {
      if (s) return !1;
      let r = t(e);
      void 0 !== r && ((s = !0), (n = r));
     }),
     n
    );
   }
   function Lt(e) {
    if ((e.type === Dt && e.break) || (e.type === Tt && e.hard) || e.type === wt) return !0;
   }
   function Ot(e) {
    return _t(e, Lt, !1);
   }
   function Mt(e) {
    if (e.length > 0) {
     let t = c(!1, e, -1);
     !t.expandedStates && !t.break && (t.break = 'propagated');
    }
    return null;
   }
   function jt(e) {
    return e.type !== Tt || e.hard ? (e.type === bt ? e.flatContents : e) : e.soft ? '' : ' ';
   }
   function Rt(e) {
    return Bt(e, jt);
   }
   function qt(e) {
    return Bt(e, (e) =>
     (function (e) {
      switch (Ft(e)) {
       case xt:
        if (e.parts.every((e) => '' === e)) return '';
        break;
       case Dt:
        if (!(e.contents || e.id || e.break || e.expandedStates)) return '';
        if (e.contents.type === Dt && e.contents.id === e.id && e.contents.break === e.break && e.contents.expandedStates === e.expandedStates) return e.contents;
        break;
       case yt:
       case mt:
       case vt:
       case Et:
        if (!e.contents) return '';
        break;
       case bt:
        if (!e.flatContents && !e.breakContents) return '';
        break;
       case dt: {
        let t = [];
        for (let r of e) {
         if (!r) continue;
         let [e, ...n] = Array.isArray(r) ? r : [r];
         'string' == typeof e && 'string' == typeof c(!1, t, -1) ? (t[t.length - 1] += e) : t.push(e), t.push(...n);
        }
        return 0 === t.length ? '' : 1 === t.length ? t[0] : t;
       }
       case ht:
       case ft:
       case gt:
       case Ct:
       case Tt:
       case St:
       case wt:
        break;
       default:
        throw new Pt(e);
      }
      return e;
     })(e),
    );
   }
   function Ut(e, t = cr) {
    return Bt(e, (e) => ('string' == typeof e ? dr(t, e.split('\n')) : e));
   }
   function $t(e) {
    if (e.type === Tt) return !0;
   }
   function Ht(e, t) {
    return e.type === St ? { ...e, contents: t(e.contents) } : t(e);
   }
   function zt(e) {
    let t = !0;
    return (
     Nt(e, (e) => {
      switch (Ft(e)) {
       case ht:
        if ('' === e) break;
       case gt:
       case Ct:
       case Tt:
       case wt:
        return (t = !1), !1;
      }
     }),
     t
    );
   }
   var Vt = () => {},
    Wt = Vt,
    Jt = Vt,
    Kt = Vt;
   function Gt(e) {
    return Wt(e), { type: mt, contents: e };
   }
   function Xt(e, t) {
    return Wt(t), { type: yt, contents: t, n: e };
   }
   function Yt(e, t = {}) {
    return Wt(e), Jt(t.expandedStates, !0), { type: Dt, id: t.id, contents: e, break: !!t.shouldBreak, expandedStates: t.expandedStates };
   }
   function Qt(e) {
    return Xt(Number.NEGATIVE_INFINITY, e);
   }
   function Zt(e) {
    return Xt(-1, e);
   }
   function er(e, t) {
    return Yt(e[0], { ...t, expandedStates: e });
   }
   function tr(e) {
    return Kt(e), { type: xt, parts: e };
   }
   function rr(e, t = '', r = {}) {
    return Wt(e), '' !== t && Wt(t), { type: bt, breakContents: e, flatContents: t, groupId: r.groupId };
   }
   function nr(e, t) {
    return Wt(e), { type: vt, contents: e, groupId: t.groupId, negate: t.negate };
   }
   function sr(e) {
    return Wt(e), { type: Et, contents: e };
   }
   var ir = { type: Ct },
    ar = { type: wt },
    or = { type: Tt, hard: !0 },
    ur = { type: Tt },
    lr = { type: Tt, soft: !0 },
    pr = [or, ar],
    cr = [{ type: Tt, hard: !0, literal: !0 }, ar],
    hr = { type: ft };
   function dr(e, t) {
    Wt(e), Jt(t);
    let r = [];
    for (let n = 0; n < t.length; n++) 0 !== n && r.push(e), r.push(t[n]);
    return r;
   }
   function fr(e, t) {
    return Wt(t), e ? { type: St, label: e, contents: t } : t;
   }
   var mr = function (e) {
    let t = `*${e.value}*`.split('\n');
    return t.length > 1 && t.every((e) => '*' === e.trimStart()[0]);
   };
   function yr(e, t) {
    let r = e.node;
    if (Y(r)) return t.originalText.slice(_(r), L(r)).trimEnd();
    if (H(r))
     return mr(r)
      ? (function (e) {
         let t = e.value.split('\n');
         return [
          '/*',
          dr(
           pr,
           t.map((e, r) => (0 === r ? e.trimEnd() : ' ' + (r < t.length - 1 ? e.trim() : e.trimStart()))),
          ),
          '*/',
         ];
        })(r)
      : ['/*', Ut(r.value), '*/'];
    throw new Error('Not a comment: ' + JSON.stringify(r));
   }
   var gr = {};
   function Dr(e, t) {
    (e.comments ?? (e.comments = [])).push(t),
     (t.printed = !1),
     (t.nodeDescription = (function (e) {
      let t = e.type || e.kind || '(unknown type)',
       r = String(e.name || (e.id && ('object' == typeof e.id ? e.id.name : e.id)) || (e.key && ('object' == typeof e.key ? e.key.name : e.key)) || (e.value && ('object' == typeof e.value ? '' : String(e.value))) || e.operator || '');
      return r.length > 20 && (r = r.slice(0, 19) + '\u2026'), t + (r ? ' ' + r : '');
     })(e));
   }
   function xr(e, t) {
    (t.leading = !0), (t.trailing = !1), Dr(e, t);
   }
   function br(e, t, r) {
    (t.leading = !1), (t.trailing = !1), r && (t.marker = r), Dr(e, t);
   }
   function vr(e, t) {
    (t.leading = !1), (t.trailing = !0), Dr(e, t);
   }
   i(gr, { endOfLine: () => Ar, ownLine: () => wr, remaining: () => Fr });
   var Er = function (e, t) {
    let r = null,
     n = t;
    for (; n !== r; ) (r = n), (n = x(e, n)), (n = T(e, n)), (n = S(e, n)), (n = E(e, n));
    return n;
   };
   var Cr = function (e, t) {
    let r = Er(e, t);
    return !1 === r ? '' : e.charAt(r);
   };
   var Tr = function (e, t, r) {
    for (let n = t; n < r; ++n) if ('\n' === e.charAt(n)) return !0;
    return !1;
   };
   var Sr = function (e) {
    return H(e) && '*' === e.value[0] && /@(?:type|satisfies)\b/u.test(e.value);
   };
   function wr(e) {
    return [ln, Mr, Kr, Jr, Lr, Nr, Br, _r, qr, tn, Qr, en, rn, nn, $r, Gr, Xr, Or, dn].some((t) => t(e));
   }
   function Ar(e) {
    return [Ir, Kr, Mr, rn, Nr, Br, _r, qr, Gr, Yr, Zr, en, on, Xr, cn, hn, fn].some((t) => t(e));
   }
   function Fr(e) {
    return [ln, Nr, Br, jr, Wr, $r, en, Vr, zr, pn, Xr, un].some((t) => t(e));
   }
   function kr(e, t) {
    let r = (e.body || e.properties).find(({ type: e }) => 'EmptyStatement' !== e);
    r ? xr(r, t) : br(e, t);
   }
   function Pr(e, t) {
    'BlockStatement' === e.type ? kr(e, t) : xr(e, t);
   }
   function Ir({ comment: e, followingNode: t }) {
    return !(!t || !Sr(e)) && (xr(t, e), !0);
   }
   function Nr({ comment: e, precedingNode: t, enclosingNode: r, followingNode: n, text: s }) {
    if ('IfStatement' !== (null == r ? void 0 : r.type) || !n) return !1;
    if (')' === Cr(s, L(e))) return vr(t, e), !0;
    if (t === r.consequent && n === r.alternate) {
     let n = Er(s, L(r.consequent));
     if (_(e) < n || 'BlockStatement' === r.alternate.type) {
      if ('BlockStatement' === t.type) vr(t, e);
      else {
       let n = Y(e) || e.loc.start.line === e.loc.end.line,
        s = e.loc.start.line === t.loc.start.line;
       n && s ? vr(t, e) : br(r, e);
      }
      return !0;
     }
    }
    return 'BlockStatement' === n.type ? (kr(n, e), !0) : 'IfStatement' === n.type ? (Pr(n.consequent, e), !0) : r.consequent === n && (xr(n, e), !0);
   }
   function Br({ comment: e, precedingNode: t, enclosingNode: r, followingNode: n, text: s }) {
    return !('WhileStatement' !== (null == r ? void 0 : r.type) || !n) && (')' === Cr(s, L(e)) ? (vr(t, e), !0) : 'BlockStatement' === n.type ? (kr(n, e), !0) : r.body === n && (xr(n, e), !0));
   }
   function _r({ comment: e, precedingNode: t, enclosingNode: r, followingNode: n }) {
    return !(('TryStatement' !== (null == r ? void 0 : r.type) && 'CatchClause' !== (null == r ? void 0 : r.type)) || !n) && ('CatchClause' === r.type && t ? (vr(t, e), !0) : 'BlockStatement' === n.type ? (kr(n, e), !0) : 'TryStatement' === n.type ? (Pr(n.finalizer, e), !0) : 'CatchClause' === n.type && (Pr(n.body, e), !0));
   }
   function Lr({ comment: e, enclosingNode: t, followingNode: r }) {
    return !(!ve(t) || 'Identifier' !== (null == r ? void 0 : r.type)) && (xr(t, e), !0);
   }
   function Or({ comment: e, enclosingNode: t, followingNode: r, options: n }) {
    return !(!n.experimentalTernaries || ('ConditionalExpression' !== (null == t ? void 0 : t.type) && 'ConditionalTypeAnnotation' !== (null == t ? void 0 : t.type) && 'TSConditionalType' !== (null == t ? void 0 : t.type))) && ('ConditionalExpression' === (null == r ? void 0 : r.type) || 'ConditionalTypeAnnotation' === (null == r ? void 0 : r.type) || 'TSConditionalType' === (null == r ? void 0 : r.type)) && (br(t, e), !0);
   }
   function Mr({ comment: e, precedingNode: t, enclosingNode: r, followingNode: n, text: s, options: i }) {
    let a = t && !Tr(s, L(t), _(e));
    return !((t && a) || ('ConditionalExpression' !== (null == r ? void 0 : r.type) && 'ConditionalTypeAnnotation' !== (null == r ? void 0 : r.type) && 'TSConditionalType' !== (null == r ? void 0 : r.type)) || !n) && (!i.experimentalTernaries || r.alternate !== n || (H(e) && !Tr(i.originalText, _(e), L(e))) ? (xr(n, e), !0) : (br(r, e), !0));
   }
   function jr({ comment: e, precedingNode: t, enclosingNode: r }) {
    return !(!st(r) || !r.shorthand || r.key !== t || 'AssignmentPattern' !== r.value.type) && (vr(r.value.left, e), !0);
   }
   var Rr = new Set(['ClassDeclaration', 'ClassExpression', 'DeclareClass', 'DeclareInterface', 'InterfaceDeclaration', 'TSInterfaceDeclaration']);
   function qr({ comment: e, precedingNode: t, enclosingNode: r, followingNode: n }) {
    if (Rr.has(null == r ? void 0 : r.type)) {
     if (A(r.decorators) && 'Decorator' !== (null == n ? void 0 : n.type)) return vr(c(!1, r.decorators, -1), e), !0;
     if (r.body && n === r.body) return kr(r.body, e), !0;
     if (n) {
      if (r.superClass && n === r.superClass && t && (t === r.id || t === r.typeParameters)) return vr(t, e), !0;
      for (let s of ['implements', 'extends', 'mixins']) if (r[s] && n === r[s][0]) return !t || (t !== r.id && t !== r.typeParameters && t !== r.superClass) ? br(r, e, s) : vr(t, e), !0;
     }
    }
    return !1;
   }
   var Ur = new Set(['ClassMethod', 'ClassProperty', 'PropertyDefinition', 'TSAbstractPropertyDefinition', 'TSAbstractMethodDefinition', 'TSDeclareMethod', 'MethodDefinition', 'ClassAccessorProperty', 'AccessorProperty', 'TSAbstractAccessorProperty', 'TSParameterProperty']);
   function $r({ comment: e, precedingNode: t, enclosingNode: r, text: n }) {
    return ((r && t && '(' === Cr(n, L(e)) && ('Property' === r.type || 'TSDeclareMethod' === r.type || 'TSAbstractMethodDefinition' === r.type) && 'Identifier' === t.type && r.key === t && ':' !== Cr(n, L(t))) || !('Decorator' !== (null == t ? void 0 : t.type) || !Ur.has(null == r ? void 0 : r.type) || (!Y(e) && 'ownLine' !== e.placement))) && (vr(t, e), !0);
   }
   var Hr = new Set(['FunctionDeclaration', 'FunctionExpression', 'ClassMethod', 'MethodDefinition', 'ObjectMethod']);
   function zr({ comment: e, precedingNode: t, enclosingNode: r, text: n }) {
    return '(' === Cr(n, L(e)) && !(!t || !Hr.has(null == r ? void 0 : r.type)) && (vr(t, e), !0);
   }
   function Vr({ comment: e, enclosingNode: t, text: r }) {
    if ('ArrowFunctionExpression' !== (null == t ? void 0 : t.type)) return !1;
    let n = Er(r, L(e));
    return !1 !== n && '=>' === r.slice(n, n + 2) && (br(t, e), !0);
   }
   function Wr({ comment: e, enclosingNode: t, text: r }) {
    return ')' === Cr(r, L(e)) && (t && ((mn(t) && 0 === Ve(t).length) || (nt(t) && 0 === Je(t).length)) ? (br(t, e), !0) : ('MethodDefinition' === (null == t ? void 0 : t.type) || 'TSAbstractMethodDefinition' === (null == t ? void 0 : t.type)) && 0 === Ve(t.value).length && (br(t.value, e), !0));
   }
   function Jr({ comment: e, precedingNode: t, enclosingNode: r, followingNode: n, text: s }) {
    return 'ComponentTypeParameter' !== (null == t ? void 0 : t.type) || ('DeclareComponent' !== (null == r ? void 0 : r.type) && 'ComponentTypeAnnotation' !== (null == r ? void 0 : r.type)) || 'ComponentTypeParameter' === (null == n ? void 0 : n.type) ? ('ComponentParameter' === (null == t ? void 0 : t.type) || 'RestElement' === (null == t ? void 0 : t.type)) && 'ComponentDeclaration' === (null == r ? void 0 : r.type) && ')' === Cr(s, L(e)) && (vr(t, e), !0) : (vr(t, e), !0);
   }
   function Kr({ comment: e, precedingNode: t, enclosingNode: r, followingNode: n, text: s }) {
    return 'FunctionTypeParam' === (null == t ? void 0 : t.type) && 'FunctionTypeAnnotation' === (null == r ? void 0 : r.type) && 'FunctionTypeParam' !== (null == n ? void 0 : n.type) ? (vr(t, e), !0) : ('Identifier' !== (null == t ? void 0 : t.type) && 'AssignmentPattern' !== (null == t ? void 0 : t.type) && 'ObjectPattern' !== (null == t ? void 0 : t.type) && 'ArrayPattern' !== (null == t ? void 0 : t.type) && 'RestElement' !== (null == t ? void 0 : t.type) && 'TSParameterProperty' !== (null == t ? void 0 : t.type)) || !mn(r) || ')' !== Cr(s, L(e)) ? !(H(e) || ('FunctionDeclaration' !== (null == r ? void 0 : r.type) && 'FunctionExpression' !== (null == r ? void 0 : r.type) && 'ObjectMethod' !== (null == r ? void 0 : r.type)) || 'BlockStatement' !== (null == n ? void 0 : n.type) || r.body !== n || Er(s, L(e)) !== _(n)) && (kr(n, e), !0) : (vr(t, e), !0);
   }
   function Gr({ comment: e, enclosingNode: t }) {
    return 'LabeledStatement' === (null == t ? void 0 : t.type) && (xr(t, e), !0);
   }
   function Xr({ comment: e, enclosingNode: t }) {
    return !(('ContinueStatement' !== (null == t ? void 0 : t.type) && 'BreakStatement' !== (null == t ? void 0 : t.type)) || t.label) && (vr(t, e), !0);
   }
   function Yr({ comment: e, precedingNode: t, enclosingNode: r }) {
    return !!(be(r) && t && r.callee === t && r.arguments.length > 0) && (xr(r.arguments[0], e), !0);
   }
   function Qr({ comment: e, precedingNode: t, enclosingNode: r, followingNode: n }) {
    return at(r) ? (Xe(e) && ((n.prettierIgnore = !0), (e.unignore = !0)), !!t && (vr(t, e), !0)) : (at(n) && Xe(e) && ((n.types[0].prettierIgnore = !0), (e.unignore = !0)), !1);
   }
   function Zr({ comment: e, enclosingNode: t }) {
    return !!st(t) && (xr(t, e), !0);
   }
   function en({ comment: e, enclosingNode: t, ast: r, isLastComment: n }) {
    var s;
    return 0 === (null == (s = null == r ? void 0 : r.body) ? void 0 : s.length) ? (n ? br(r, e) : xr(r, e), !0) : 'Program' === (null == t ? void 0 : t.type) && 0 === t.body.length && !A(t.directives) && (n ? br(t, e) : xr(t, e), !0);
   }
   function tn({ comment: e, enclosingNode: t }) {
    return ('ForInStatement' === (null == t ? void 0 : t.type) || 'ForOfStatement' === (null == t ? void 0 : t.type)) && (xr(t, e), !0);
   }
   function rn({ comment: e, precedingNode: t, enclosingNode: r, text: n }) {
    if ('ImportSpecifier' === (null == r ? void 0 : r.type) || 'ExportSpecifier' === (null == r ? void 0 : r.type)) return xr(r, e), !0;
    let s = 'ImportSpecifier' === (null == t ? void 0 : t.type) && 'ImportDeclaration' === (null == r ? void 0 : r.type),
     i = 'ExportSpecifier' === (null == t ? void 0 : t.type) && 'ExportNamedDeclaration' === (null == r ? void 0 : r.type);
    return !((!s && !i) || !C(n, L(e))) && (vr(t, e), !0);
   }
   function nn({ comment: e, enclosingNode: t }) {
    return 'AssignmentPattern' === (null == t ? void 0 : t.type) && (xr(t, e), !0);
   }
   var sn = new Set(['VariableDeclarator', 'AssignmentExpression', 'TypeAlias', 'TSTypeAliasDeclaration']),
    an = new Set(['ObjectExpression', 'RecordExpression', 'ArrayExpression', 'TupleExpression', 'TemplateLiteral', 'TaggedTemplateExpression', 'ObjectTypeAnnotation', 'TSTypeLiteral']);
   function on({ comment: e, enclosingNode: t, followingNode: r }) {
    return !(!sn.has(null == t ? void 0 : t.type) || !r || (!an.has(r.type) && !H(e))) && (xr(r, e), !0);
   }
   function un({ comment: e, enclosingNode: t, followingNode: r, text: n }) {
    return !(r || ('TSMethodSignature' !== (null == t ? void 0 : t.type) && 'TSDeclareFunction' !== (null == t ? void 0 : t.type) && 'TSAbstractMethodDefinition' !== (null == t ? void 0 : t.type)) || ';' !== Cr(n, L(e))) && (vr(t, e), !0);
   }
   function ln({ comment: e, enclosingNode: t, followingNode: r }) {
    if (Xe(e) && 'TSMappedType' === (null == t ? void 0 : t.type) && 'TSTypeParameter' === (null == r ? void 0 : r.type) && r.constraint) return (t.prettierIgnore = !0), (e.unignore = !0), !0;
   }
   function pn({ comment: e, precedingNode: t, enclosingNode: r, followingNode: n }) {
    return 'TSMappedType' === (null == r ? void 0 : r.type) && ('TSTypeParameter' === (null == n ? void 0 : n.type) && n.name ? (xr(n.name, e), !0) : !('TSTypeParameter' !== (null == t ? void 0 : t.type) || !t.constraint) && (vr(t.constraint, e), !0));
   }
   function cn({ comment: e, enclosingNode: t, followingNode: r }) {
    return !(!t || 'SwitchCase' !== t.type || t.test || !r || r !== t.consequent[0]) && ('BlockStatement' === r.type && Y(e) ? kr(r, e) : br(t, e), !0);
   }
   function hn({ comment: e, precedingNode: t, enclosingNode: r, followingNode: n }) {
    return !(!at(t) || ((('TSArrayType' !== r.type && 'ArrayTypeAnnotation' !== r.type) || n) && !ot(r))) && (vr(c(!1, t.types, -1), e), !0);
   }
   function dn({ comment: e, enclosingNode: t, precedingNode: r, followingNode: n }) {
    if (('ObjectPattern' === (null == t ? void 0 : t.type) || 'ArrayPattern' === (null == t ? void 0 : t.type)) && 'TSTypeAnnotation' === (null == n ? void 0 : n.type)) return r ? vr(r, e) : br(t, e), !0;
   }
   function fn({ comment: e, precedingNode: t, enclosingNode: r, followingNode: n }) {
    var s;
    if (!n && 'UnaryExpression' === (null == r ? void 0 : r.type) && ('LogicalExpression' === (null == t ? void 0 : t.type) || 'BinaryExpression' === (null == t ? void 0 : t.type))) {
     let n = (null == (s = r.argument.loc) ? void 0 : s.start.line) !== t.right.loc.start.line,
      i = Y(e) || e.loc.start.line === e.loc.end.line,
      a = e.loc.start.line === t.right.loc.start.line;
     if (n && i && a) return vr(t.right, e), !0;
    }
    return !1;
   }
   var mn = $(['ArrowFunctionExpression', 'FunctionExpression', 'FunctionDeclaration', 'ObjectMethod', 'ClassMethod', 'TSDeclareFunction', 'TSCallSignatureDeclaration', 'TSConstructSignatureDeclaration', 'TSMethodSignature', 'TSConstructorType', 'TSFunctionType', 'TSDeclareMethod']),
    yn = new Set(['EmptyStatement', 'TemplateElement', 'TSEmptyBodyFunctionExpression', 'ChainExpression']);
   function gn(e) {
    return !yn.has(e.type);
   }
   function Dn(e, t) {
    var r;
    if (('typescript' === t.parser || 'flow' === t.parser || 'acorn' === t.parser || 'espree' === t.parser || 'meriyah' === t.parser || '__babel_estree' === t.parser) && 'MethodDefinition' === e.type && 'FunctionExpression' === (null == (r = e.value) ? void 0 : r.type) && 0 === Ve(e.value).length && !e.value.returnType && !A(e.value.typeParameters) && e.value.body) return [...(e.decorators || []), e.key, e.value.body];
   }
   function xn(e) {
    let { node: t, parent: r } = e;
    return (pe(t) || (r && ('JSXSpreadAttribute' === r.type || 'JSXSpreadChild' === r.type || at(r) || (('ClassDeclaration' === r.type || 'ClassExpression' === r.type) && r.superClass === t)))) && (!Ye(t) || at(r));
   }
   function bn(e, { parser: t }) {
    if ('flow' === t || 'babel-flow' === t) return '' === (e = p(!1, e, /[\s(]/gu, '')) || '/*' === e || '/*::' === e;
   }
   var vn = Symbol('MODE_BREAK'),
    En = Symbol('MODE_FLAT'),
    Cn = Symbol('cursor'),
    Tn = Symbol('DOC_FILL_PRINTED_LENGTH');
   function Sn(e, t) {
    return An(e, { type: 'indent' }, t);
   }
   function wn(e, t, r) {
    return t === Number.NEGATIVE_INFINITY ? e.root || { value: '', length: 0, queue: [] } : t < 0 ? An(e, { type: 'dedent' }, r) : t ? ('root' === t.type ? { ...e, root: e } : An(e, { type: 'string' == typeof t ? 'stringAlign' : 'numberAlign', n: t }, r)) : e;
   }
   function An(e, t, r) {
    let n = 'dedent' === t.type ? e.queue.slice(0, -1) : [...e.queue, t],
     s = '',
     i = 0,
     a = 0,
     o = 0;
    for (let d of n)
     switch (d.type) {
      case 'indent':
       p(), r.useTabs ? u(1) : l(r.tabWidth);
       break;
      case 'stringAlign':
       p(), (s += d.n), (i += d.n.length);
       break;
      case 'numberAlign':
       (a += 1), (o += d.n);
       break;
      default:
       throw new Error(`Unexpected type '${d.type}'`);
     }
    return c(), { ...e, value: s, length: i, queue: n };
    function u(e) {
     (s += '\t'.repeat(e)), (i += r.tabWidth * e);
    }
    function l(e) {
     (s += ' '.repeat(e)), (i += e);
    }
    function p() {
     r.useTabs ? (a > 0 && u(a), h()) : c();
    }
    function c() {
     o > 0 && l(o), h();
    }
    function h() {
     (a = 0), (o = 0);
    }
   }
   function Fn(e) {
    let t = 0,
     r = 0,
     n = e.length;
    e: for (; n--; ) {
     let s = e[n];
     if (s !== Cn)
      for (let r = s.length - 1; r >= 0; r--) {
       let i = s[r];
       if (' ' !== i && '\t' !== i) {
        e[n] = s.slice(0, r + 1);
        break e;
       }
       t++;
      }
     else r++;
    }
    if (t > 0 || r > 0) for (e.length = n + 1; r-- > 0; ) e.push(Cn);
    return t;
   }
   function kn(e, t, r, n, s, i) {
    if (r === Number.POSITIVE_INFINITY) return !0;
    let a = t.length,
     o = [e],
     u = [];
    for (; r >= 0; ) {
     if (0 === o.length) {
      if (0 === a) return !0;
      o.push(t[--a]);
      continue;
     }
     let { mode: e, doc: l } = o.pop(),
      p = Ft(l);
     switch (p) {
      case ht:
       u.push(l), (r -= g(l));
       break;
      case dt:
      case xt: {
       let t = p === dt ? l : l.parts,
        r = l[Tn] ?? 0;
       for (let n = t.length - 1; n >= r; n--) o.push({ mode: e, doc: t[n] });
       break;
      }
      case mt:
      case yt:
      case vt:
      case St:
       o.push({ mode: e, doc: l.contents });
       break;
      case gt:
       r += Fn(u);
       break;
      case Dt: {
       if (i && l.break) return !1;
       let t = l.break ? vn : e,
        r = l.expandedStates && t === vn ? c(!1, l.expandedStates, -1) : l.contents;
       o.push({ mode: t, doc: r });
       break;
      }
      case bt: {
       let t = (l.groupId ? s[l.groupId] || En : e) === vn ? l.breakContents : l.flatContents;
       t && o.push({ mode: e, doc: t });
       break;
      }
      case Tt:
       if (e === vn || l.hard) return !0;
       l.soft || (u.push(' '), r--);
       break;
      case Et:
       n = !0;
       break;
      case Ct:
       if (n) return !1;
     }
    }
    return !1;
   }
   function Pn(e, t) {
    let r = {},
     n = t.printWidth,
     s = (function (e) {
      switch (e) {
       case 'cr':
        return '\r';
       case 'crlf':
        return '\r\n';
       default:
        return '\n';
      }
     })(t.endOfLine),
     i = 0,
     a = [{ ind: { value: '', length: 0, queue: [] }, mode: vn, doc: e }],
     o = [],
     u = !1,
     l = [],
     h = 0;
    for (
     (function (e) {
      let t = new Set(),
       r = [];
      Nt(
       e,
       function (e) {
        if ((e.type === wt && Mt(r), e.type === Dt)) {
         if ((r.push(e), t.has(e))) return !1;
         t.add(e);
        }
       },
       function (e) {
        e.type === Dt && r.pop().break && Mt(r);
       },
       !0,
      );
     })(e);
     a.length > 0;

    ) {
     let { ind: e, mode: d, doc: f } = a.pop();
     switch (Ft(f)) {
      case ht: {
       let e = '\n' !== s ? p(!1, f, '\n', s) : f;
       o.push(e), a.length > 0 && (i += g(e));
       break;
      }
      case dt:
       for (let t = f.length - 1; t >= 0; t--) a.push({ ind: e, mode: d, doc: f[t] });
       break;
      case ft:
       if (h >= 2) throw new Error("There are too many 'cursor' in doc.");
       o.push(Cn), h++;
       break;
      case mt:
       a.push({ ind: Sn(e, t), mode: d, doc: f.contents });
       break;
      case yt:
       a.push({ ind: wn(e, f.n, t), mode: d, doc: f.contents });
       break;
      case gt:
       i -= Fn(o);
       break;
      case Dt:
       switch (d) {
        case En:
         if (!u) {
          a.push({ ind: e, mode: f.break ? vn : En, doc: f.contents });
          break;
         }
        case vn: {
         u = !1;
         let t = { ind: e, mode: En, doc: f.contents },
          s = n - i,
          o = l.length > 0;
         if (!f.break && kn(t, a, s, o, r)) a.push(t);
         else if (f.expandedStates) {
          let t = c(!1, f.expandedStates, -1);
          if (f.break) {
           a.push({ ind: e, mode: vn, doc: t });
           break;
          }
          for (let n = 1; n < f.expandedStates.length + 1; n++) {
           if (n >= f.expandedStates.length) {
            a.push({ ind: e, mode: vn, doc: t });
            break;
           }
           {
            let t = f.expandedStates[n],
             i = { ind: e, mode: En, doc: t };
            if (kn(i, a, s, o, r)) {
             a.push(i);
             break;
            }
           }
          }
         } else a.push({ ind: e, mode: vn, doc: f.contents });
         break;
        }
       }
       f.id && (r[f.id] = c(!1, a, -1).mode);
       break;
      case xt: {
       let t = n - i,
        s = f[Tn] ?? 0,
        { parts: o } = f,
        u = o.length - s;
       if (0 === u) break;
       let p = o[s + 0],
        c = o[s + 1],
        h = { ind: e, mode: En, doc: p },
        m = { ind: e, mode: vn, doc: p },
        y = kn(h, [], t, l.length > 0, r, !0);
       if (1 === u) {
        y ? a.push(h) : a.push(m);
        break;
       }
       let g = { ind: e, mode: En, doc: c },
        D = { ind: e, mode: vn, doc: c };
       if (2 === u) {
        y ? a.push(g, h) : a.push(D, m);
        break;
       }
       let x = o[s + 2],
        b = { ind: e, mode: d, doc: { ...f, [Tn]: s + 2 } };
       kn({ ind: e, mode: En, doc: [p, c, x] }, [], t, l.length > 0, r, !0) ? a.push(b, g, h) : y ? a.push(b, D, h) : a.push(b, D, m);
       break;
      }
      case bt:
      case vt: {
       let t = f.groupId ? r[f.groupId] : d;
       if (t === vn) {
        let t = f.type === bt ? f.breakContents : f.negate ? f.contents : Gt(f.contents);
        t && a.push({ ind: e, mode: d, doc: t });
       }
       if (t === En) {
        let t = f.type === bt ? f.flatContents : f.negate ? Gt(f.contents) : f.contents;
        t && a.push({ ind: e, mode: d, doc: t });
       }
       break;
      }
      case Et:
       l.push({ ind: e, mode: d, doc: f.contents });
       break;
      case Ct:
       l.length > 0 && a.push({ ind: e, mode: d, doc: or });
       break;
      case Tt:
       switch (d) {
        case En:
         if (!f.hard) {
          f.soft || (o.push(' '), (i += 1));
          break;
         }
         u = !0;
        case vn:
         if (l.length > 0) {
          a.push({ ind: e, mode: d, doc: f }, ...l.reverse()), (l.length = 0);
          break;
         }
         f.literal ? (e.root ? (o.push(s, e.root.value), (i = e.root.length)) : (o.push(s), (i = 0))) : ((i -= Fn(o)), o.push(s + e.value), (i = e.length));
       }
       break;
      case St:
       a.push({ ind: e, mode: d, doc: f.contents });
       break;
      case wt:
       break;
      default:
       throw new Pt(f);
     }
     0 === a.length && l.length > 0 && (a.push(...l.reverse()), (l.length = 0));
    }
    let d = o.indexOf(Cn);
    if (-1 !== d) {
     let e = o.indexOf(Cn, d + 1);
     if (-1 === e) return { formatted: o.filter((e) => e !== Cn).join('') };
     let t = o.slice(0, d).join(''),
      r = o.slice(d + 1, e).join('');
     return { formatted: t + r + o.slice(e + 1).join(''), cursorNodeStart: t.length, cursorNodeText: r };
    }
    return { formatted: o.join('') };
   }
   var In = function (e, t, r = 0) {
    let n = 0;
    for (let s = r; s < e.length; ++s) '\t' === e[s] ? (n = n + t - (n % t)) : n++;
    return n;
   };
   var Nn = function (e, t) {
    let r = e.lastIndexOf('\n');
    return -1 === r ? 0 : In(e.slice(r + 1).match(/^[\t ]*/u)[0], t);
   };
   function Bn(e, t, r) {
    let { node: n } = e;
    if (
     'TemplateLiteral' === n.type &&
     (function ({ node: e, parent: t }) {
      let r = /^[fx]?(?:describe|it|test)$/u;
      return 'TaggedTemplateExpression' === t.type && t.quasi === e && 'MemberExpression' === t.tag.type && 'Identifier' === t.tag.property.type && 'each' === t.tag.property.name && (('Identifier' === t.tag.object.type && r.test(t.tag.object.name)) || ('MemberExpression' === t.tag.object.type && 'Identifier' === t.tag.object.property.type && ('only' === t.tag.object.property.name || 'skip' === t.tag.object.property.name) && 'Identifier' === t.tag.object.object.type && r.test(t.tag.object.object.name)));
     })(e)
    ) {
     let n = (function (e, t, r) {
      let { node: n } = e,
       s = n.quasis[0].value.raw.trim().split(/\s*\|\s*/u);
      if (s.length > 1 || s.some((e) => e.length > 0)) {
       t.__inJestEach = !0;
       let i = e.map(r, 'expressions');
       t.__inJestEach = !1;
       let a = [],
        o = i.map((e) => '${' + Pn(e, { ...t, printWidth: Number.POSITIVE_INFINITY, endOfLine: 'lf' }).formatted + '}'),
        u = [{ hasLineBreak: !1, cells: [] }];
       for (let e = 1; e < n.quasis.length; e++) {
        let t = c(!1, u, -1),
         r = o[e - 1];
        t.cells.push(r), r.includes('\n') && (t.hasLineBreak = !0), n.quasis[e].value.raw.includes('\n') && u.push({ hasLineBreak: !1, cells: [] });
       }
       let l = Math.max(s.length, ...u.map((e) => e.cells.length)),
        p = Array.from({ length: l }).fill(0),
        h = [{ cells: s }, ...u.filter((e) => e.cells.length > 0)];
       for (let { cells: e } of h.filter((e) => !e.hasLineBreak)) for (let [t, r] of e.entries()) p[t] = Math.max(p[t], g(r));
       return (
        a.push(
         ir,
         '`',
         Gt([
          pr,
          dr(
           pr,
           h.map((e) =>
            dr(
             ' | ',
             e.cells.map((t, r) => (e.hasLineBreak ? t : t + ' '.repeat(p[r] - g(t)))),
            ),
           ),
          ),
         ]),
         pr,
         '`',
        ),
        a
       );
      }
     })(e, r, t);
     if (n) return n;
    }
    let s = 'expressions';
    'TSTemplateLiteralType' === n.type && (s = 'types');
    let i = [],
     a = e.map(t, s);
    i.push(ir, '`');
    let o = 0;
    return (
     e.each(({ index: e, node: u }) => {
      if ((i.push(t()), u.tail)) return;
      let { tabWidth: l } = r,
       p = u.value.raw,
       c = p.includes('\n') ? Nn(p, l) : o;
      o = c;
      let h = a[e],
       d = n[s][e],
       f = Tr(r.originalText, L(u), _(n.quasis[e + 1]));
      if (!f) {
       let e = Pn(h, { ...r, printWidth: Number.POSITIVE_INFINITY }).formatted;
       e.includes('\n') ? (f = !0) : (h = e);
      }
      f && (et(d) || 'Identifier' === d.type || ve(d) || 'ConditionalExpression' === d.type || 'SequenceExpression' === d.type || it(d) || de(d)) && (h = [Gt([lr, h]), lr]);
      let m =
       0 === c && p.endsWith('\n')
        ? Xt(Number.NEGATIVE_INFINITY, h)
        : (function (e, t, r) {
           Wt(e);
           let n = e;
           if (t > 0) {
            for (let e = 0; e < Math.floor(t / r); ++e) n = Gt(n);
            (n = Xt(t % r, n)), (n = Xt(Number.NEGATIVE_INFINITY, n));
           }
           return n;
          })(h, c, l);
      i.push(Yt(['${', m, ir, '}']));
     }, 'quasis'),
     i.push('`'),
     i
    );
   }
   function _n(e, t) {
    return e.map(
     (e) =>
      (function (e, t) {
       let { node: r } = e,
        n = t();
       return et(r) && (n = Yt([Gt([lr, n]), lr])), ['${', n, ir, '}'];
      })(e, t),
     'expressions',
    );
   }
   function Ln(e, t) {
    return Bt(e, (e) => ('string' == typeof e ? (t ? p(!1, e, /(\\*)`/gu, '$1$1\\`') : On(e)) : e));
   }
   function On(e) {
    return p(!1, e, /([\\`]|\$\{)/gu, String.raw`\$1`);
   }
   var Mn = [(e, t) => 'ObjectExpression' === e.type && 'properties' === t, (e, t) => 'CallExpression' === e.type && 'Identifier' === e.callee.type && 'Component' === e.callee.name && 'arguments' === t, (e, t) => 'Decorator' === e.type && 'expression' === t];
   function jn(e, t) {
    return et(e, Qe.Block | Qe.Leading, ({ value: e }) => e === ` ${t} `);
   }
   function Rn({ node: e, parent: t }, r) {
    return (
     jn(e, r) ||
     ((function (e) {
      return 'AsConstExpression' === e.type || ('TSAsExpression' === e.type && 'TSTypeReference' === e.typeAnnotation.type && 'Identifier' === e.typeAnnotation.typeName.type && 'const' === e.typeAnnotation.typeName.name);
     })(t) &&
      jn(t, r)) ||
     ('ExpressionStatement' === t.type && jn(t, r))
    );
   }
   async function qn(e, t, r) {
    let { node: n } = r,
     s = n.quasis.map((e) => e.value.raw),
     i = 0,
     a = s.reduce((e, t, r) => (0 === r ? t : e + '@prettier-placeholder-' + i++ + '-id' + t), ''),
     o = (function (e, t) {
      if (!A(t)) return e;
      let r = 0,
       n = Bt(qt(e), (e) => ('string' == typeof e && e.includes('@prettier-placeholder') ? e.split(/@prettier-placeholder-(\d+)-id/u).map((e, n) => (n % 2 == 0 ? Ut(e) : (r++, t[e]))) : e));
      return t.length === r ? n : null;
     })(await e(a, { parser: 'scss' }), _n(r, t));
    if (!o) throw new Error("Couldn't insert all the expressions");
    return ['`', Gt([pr, o]), lr, '`'];
   }
   function Un(e) {
    return 'Identifier' === e.type && 'styled' === e.name;
   }
   function $n(e) {
    return /^[A-Z]/u.test(e.object.name) && 'extend' === e.property.name;
   }
   var Hn = function (e) {
    if (
     (function ({ node: e, parent: t, grandparent: r }) {
      return (r && e.quasis && 'JSXExpressionContainer' === t.type && 'JSXElement' === r.type && 'style' === r.openingElement.name.name && r.openingElement.attributes.some((e) => 'JSXAttribute' === e.type && 'jsx' === e.name.name)) || ('TaggedTemplateExpression' === (null == t ? void 0 : t.type) && 'Identifier' === t.tag.type && 'css' === t.tag.name) || ('TaggedTemplateExpression' === (null == t ? void 0 : t.type) && 'MemberExpression' === t.tag.type && 'css' === t.tag.object.name && ('global' === t.tag.property.name || 'resolve' === t.tag.property.name));
     })(e) ||
     (function ({ parent: e }) {
      if (!e || 'TaggedTemplateExpression' !== e.type) return !1;
      let t = 'ParenthesizedExpression' === e.tag.type ? e.tag.expression : e.tag;
      switch (t.type) {
       case 'MemberExpression':
        return Un(t.object) || $n(t);
       case 'CallExpression':
        return Un(t.callee) || ('MemberExpression' === t.callee.type && (('MemberExpression' === t.callee.object.type && (Un(t.callee.object.object) || $n(t.callee.object))) || ('CallExpression' === t.callee.object.type && Un(t.callee.object.callee))));
       case 'Identifier':
        return 'css' === t.name;
       default:
        return !1;
      }
     })(e) ||
     (function ({ parent: e, grandparent: t }) {
      return 'JSXAttribute' === (null == t ? void 0 : t.type) && 'JSXExpressionContainer' === e.type && 'JSXIdentifier' === t.name.type && 'css' === t.name.name;
     })(e) ||
     (function (e) {
      let t = (e) => 'TemplateLiteral' === e.type,
       r = (e, t) => st(e) && !e.computed && 'Identifier' === e.key.type && 'styles' === e.key.name && 'value' === t;
      return e.match(t, (e, t) => Z(e) && 'elements' === t, r, ...Mn) || e.match(t, r, ...Mn);
     })(e)
    )
     return qn;
   };
   async function zn(e, t, r) {
    let { node: n } = r,
     s = n.quasis.length,
     i = _n(r, t),
     a = [];
    for (let o = 0; o < s; o++) {
     let t = 0 === o,
      r = o === s - 1,
      u = n.quasis[o].value.cooked,
      l = u.split('\n'),
      p = l.length,
      c = i[o],
      h = p > 2 && '' === l[0].trim() && '' === l[1].trim(),
      d = p > 2 && '' === l[p - 1].trim() && '' === l[p - 2].trim(),
      f = l.every((e) => /^\s*(?:#[^\n\r]*)?$/u.test(e));
     if (!r && /#[^\n\r]*$/u.test(l[p - 1])) return null;
     let m = null;
     (m = f ? Vn(l) : await e(u, { parser: 'graphql' })), m ? ((m = Ln(m, !1)), !t && h && a.push(''), a.push(m), !r && d && a.push('')) : !t && !r && h && a.push(''), c && a.push(c);
    }
    return ['`', Gt([pr, dr(pr, a)]), pr, '`'];
   }
   function Vn(e) {
    let t = [],
     r = !1,
     n = e.map((e) => e.trim());
    for (let [s, i] of n.entries()) '' !== i && ('' === n[s - 1] && r ? t.push([pr, i]) : t.push(i), (r = !0));
    return 0 === t.length ? null : dr(pr, t);
   }
   var Wn = function (e) {
     if (
      (function ({ node: e, parent: t }) {
       return Rn({ node: e, parent: t }, 'GraphQL') || (t && (('TaggedTemplateExpression' === t.type && (('MemberExpression' === t.tag.type && 'graphql' === t.tag.object.name && 'experimental' === t.tag.property.name) || ('Identifier' === t.tag.type && ('gql' === t.tag.name || 'graphql' === t.tag.name)))) || ('CallExpression' === t.type && 'Identifier' === t.callee.type && 'graphql' === t.callee.name)));
      })(e)
     )
      return zn;
    },
    Jn = 0;
   async function Kn(e, t, r, n, s) {
    let { node: i } = n,
     a = Jn;
    Jn = (Jn + 1) >>> 0;
    let o = (e) => `PRETTIER_HTML_PLACEHOLDER_${e}_${a}_IN_JS`,
     u = i.quasis.map((e, t, r) => (t === r.length - 1 ? e.value.cooked : e.value.cooked + o(t))).join(''),
     l = _n(n, r),
     c = new RegExp(o(String.raw`(\d+)`), 'gu'),
     h = 0,
     d = Bt(
      await t(u, {
       parser: e,
       __onHtmlRoot(e) {
        h = e.children.length;
       },
      }),
      (e) => {
       if ('string' != typeof e) return e;
       let t = [],
        r = e.split(c);
       for (let n = 0; n < r.length; n++) {
        let e = r[n];
        if (n % 2 == 0) {
         e && ((e = On(e)), s.__embeddedInHtml && (e = p(!1, e, /<\/(?=script\b)/giu, String.raw`<\/`)), t.push(e));
         continue;
        }
        let i = Number(e);
        t.push(l[i]);
       }
       return t;
      },
     ),
     f = /^\s/u.test(u) ? ' ' : '',
     m = /\s$/u.test(u) ? ' ' : '',
     y = 'ignore' === s.htmlWhitespaceSensitivity ? pr : f && m ? ur : null;
    return y ? Yt(['`', Gt([y, Yt(d)]), y, '`']) : fr({ hug: !1 }, Yt(['`', f, h > 1 ? Gt(Yt(d)) : Yt(d), m, '`']));
   }
   var Gn = Kn.bind(void 0, 'html'),
    Xn = Kn.bind(void 0, 'angular');
   var Yn = function (e) {
    return (function (e) {
     return (
      Rn(e, 'HTML') ||
      e.match(
       (e) => 'TemplateLiteral' === e.type,
       (e, t) => 'TaggedTemplateExpression' === e.type && 'Identifier' === e.tag.type && 'html' === e.tag.name && 'quasi' === t,
      )
     );
    })(e)
     ? Gn
     : (function (e) {
          return e.match(
           (e) => 'TemplateLiteral' === e.type,
           (e, t) => st(e) && !e.computed && 'Identifier' === e.key.type && 'template' === e.key.name && 'value' === t,
           ...Mn,
          );
         })(e)
       ? Xn
       : void 0;
   };
   async function Qn(e, t, r) {
    let { node: n } = r,
     s = p(!1, n.quasis[0].value.raw, /((?:\\\\)*)\\`/gu, (e, t) => '\\'.repeat(t.length / 2) + '`'),
     i = (function (e) {
      let t = e.match(/^([^\S\n]*)\S/mu);
      return null === t ? '' : t[1];
     })(s),
     a = '' !== i;
    a && (s = p(!1, s, new RegExp(`^${i}`, 'gmu'), ''));
    let o = Ln(await e(s, { parser: 'markdown', __inJsTemplate: !0 }), !0);
    return ['`', a ? Gt([lr, o]) : [cr, Qt(o)], lr, '`'];
   }
   var Zn = function (e) {
    if (
     (function ({ node: e, parent: t }) {
      return 'TaggedTemplateExpression' === (null == t ? void 0 : t.type) && 1 === e.quasis.length && 'Identifier' === t.tag.type && ('md' === t.tag.name || 'markdown' === t.tag.name);
     })(e)
    )
     return Qn;
   };
   var es = function (e) {
     let t,
      { node: r } = e;
     if (
      'TemplateLiteral' === r.type &&
      !(function ({ quasis: e }) {
       return e.some(({ value: { cooked: e } }) => null === e);
      })(r)
     )
      for (let n of [Hn, Wn, Yn, Zn])
       if (((t = n(e)), t))
        return 1 === r.quasis.length && '' === r.quasis[0].value.raw.trim()
         ? '``'
         : async (...e) => {
            let r = await t(...e);
            return r && fr({ embed: !0, ...r.label }, r);
           };
    },
    ts = /\*\/$/,
    rs = /^\/\*\*?/,
    ns = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/,
    ss = /(^|\s+)\/\/([^\n\r]*)/g,
    is = /^(\r?\n)+/,
    as = /(?:^|\r?\n) *(@[^\n\r]*?) *\r?\n *(?![^\n\r@]*\/\/[^]*)([^\s@][^\n\r@]+?) *\r?\n/g,
    os = /(?:^|\r?\n) *@(\S+) *([^\n\r]*)/g,
    us = /(\r?\n|^) *\* ?/g,
    ls = [];
   function ps(e, t) {
    return [...ls, ...(Array.isArray(t) ? t : [t])].map((t) => `@${e} ${t}`.trim());
   }
   var cs = function (e) {
    if (!e.startsWith('#!')) return '';
    let t = e.indexOf('\n');
    return -1 === t ? e : e.slice(0, t);
   };
   function hs(e) {
    let t = cs(e);
    t && (e = e.slice(t.length + 1));
    let r = (function (e) {
      let t = e.match(ns);
      return t ? t[0].trimStart() : '';
     })(e),
     { pragmas: n, comments: s } = (function (e) {
      e = p(!1, e.replace(rs, '').replace(ts, ''), us, '$1');
      let t = '';
      for (; t !== e; ) (t = e), (e = p(!1, e, as, '\n$1 $2\n'));
      e = e.replace(is, '').trimEnd();
      let r,
       n = Object.create(null),
       s = p(!1, e, os, '').replace(is, '').trimEnd();
      for (; (r = os.exec(e)); ) {
       let e = p(!1, r[2], ss, '');
       if ('string' == typeof n[r[1]] || Array.isArray(n[r[1]])) {
        let t = n[r[1]];
        n[r[1]] = [...ls, ...(Array.isArray(t) ? t : [t]), e];
       } else n[r[1]] = e;
      }
      return { comments: s, pragmas: n };
     })(r);
    return { shebang: t, text: e, pragmas: n, comments: s };
   }
   function ds(e) {
    let { shebang: t, text: r, pragmas: n, comments: s } = hs(e),
     i = (function (e) {
      let t = e.match(ns),
       r = null == t ? void 0 : t[0];
      return null == r ? e : e.slice(r.length);
     })(r),
     a = (function ({ comments: e = '', pragmas: t = {} }) {
      let r = '\n',
       n = ' *',
       s = Object.keys(t),
       i = s
        .flatMap((e) => ps(e, t[e]))
        .map((e) => `${n} ${e}${r}`)
        .join('');
      if (!e) {
       if (0 === s.length) return '';
       if (1 === s.length && !Array.isArray(t[s[0]])) {
        let e = t[s[0]];
        return `/** ${ps(s[0], e)[0]} */`;
       }
      }
      let a =
       e
        .split(r)
        .map((e) => `${n} ${e}`)
        .join(r) + r;
      return '/**\n' + (e ? a : '') + (e && s.length > 0 ? n + r : '') + i + ' */';
     })({ pragmas: { format: '', ...n }, comments: s.trimStart() });
    return (t ? `${t}\n` : '') + a + (i.startsWith('\n') ? '\n' : '\n\n') + i;
   }
   var fs = function (e, t) {
    let { originalText: r, [Symbol.for('comments')]: n, locStart: s, locEnd: i, [Symbol.for('printedComments')]: a } = t,
     { node: o } = e,
     u = s(o),
     l = i(o);
    for (let p of n) s(p) >= u && i(p) <= l && a.add(p);
    return r.slice(u, l);
   };
   function ms(e, t) {
    var r, n, s, i, a, o, u, l, p;
    if (e.isRoot) return !1;
    let { node: c, key: h, parent: d } = e;
    if (
     t.__isInHtmlInterpolation &&
     !t.bracketSpacing &&
     (function (e) {
      return ee(e);
     })(c) &&
     gs(e)
    )
     return !0;
    if (ys(c)) return !1;
    if ('Identifier' === c.type) {
     if ((null != (r = c.extra) && r.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/u.test(c.name)) || ('left' === h && (('async' === c.name && !d.await) || 'let' === c.name) && 'ForOfStatement' === d.type)) return !0;
     if ('let' === c.name) {
      let t = null == (n = e.findAncestor((e) => 'ForOfStatement' === e.type)) ? void 0 : n.left;
      if (t && Oe(t, (e) => e === c)) return !0;
     }
     if ('object' === h && 'let' === c.name && 'MemberExpression' === d.type && d.computed && !d.optional) {
      let t = e.findAncestor((e) => 'ExpressionStatement' === e.type || 'ForStatement' === e.type || 'ForInStatement' === e.type),
       r = t ? ('ExpressionStatement' === t.type ? t.expression : 'ForStatement' === t.type ? t.init : t.left) : void 0;
      if (r && Oe(r, (e) => e === c)) return !0;
     }
     if ('expression' === h)
      switch (c.name) {
       case 'await':
       case 'interface':
       case 'module':
       case 'using':
       case 'yield':
       case 'let':
       case 'component':
       case 'hook':
       case 'type': {
        let t = e.findAncestor((e) => !it(e));
        if (t !== d && 'ExpressionStatement' === t.type) return !0;
       }
      }
     return !1;
    }
    if ('ObjectExpression' === c.type || 'FunctionExpression' === c.type || 'ClassExpression' === c.type || 'DoExpression' === c.type) {
     let t = null == (s = e.findAncestor((e) => 'ExpressionStatement' === e.type)) ? void 0 : s.expression;
     if (t && Oe(t, (e) => e === c)) return !0;
    }
    if ('ObjectExpression' === c.type) {
     let t = null == (i = e.findAncestor((e) => 'ArrowFunctionExpression' === e.type)) ? void 0 : i.body;
     if (t && 'SequenceExpression' !== t.type && 'AssignmentExpression' !== t.type && Oe(t, (e) => e === c)) return !0;
    }
    switch (d.type) {
     case 'ParenthesizedExpression':
      return !1;
     case 'ClassDeclaration':
     case 'ClassExpression':
      if ('superClass' === h && ('ArrowFunctionExpression' === c.type || 'AssignmentExpression' === c.type || 'AwaitExpression' === c.type || 'BinaryExpression' === c.type || 'ConditionalExpression' === c.type || 'LogicalExpression' === c.type || 'NewExpression' === c.type || 'ObjectExpression' === c.type || 'SequenceExpression' === c.type || 'TaggedTemplateExpression' === c.type || 'UnaryExpression' === c.type || 'UpdateExpression' === c.type || 'YieldExpression' === c.type || 'TSNonNullExpression' === c.type || ('ClassExpression' === c.type && A(c.decorators)))) return !0;
      break;
     case 'ExportDefaultDeclaration':
      return Ds(e, t) || 'SequenceExpression' === c.type;
     case 'Decorator':
      if (
       'expression' === h &&
       !(function (e) {
        return 'ChainExpression' === e.type && (e = e.expression), xs(e) || (be(e) && !e.optional && xs(e.callee));
       })(c)
      )
       return !0;
      break;
     case 'TypeAnnotation':
      if (
       e.match(void 0, void 0, (e, t) => 'returnType' === t && 'ArrowFunctionExpression' === e.type) &&
       (function (e) {
        return J(e, (e) => 'ObjectTypeAnnotation' === e.type && J(e, (e) => 'FunctionTypeAnnotation' === e.type));
       })(c)
      )
       return !0;
      break;
     case 'BinaryExpression':
      if ('left' === h && ('in' === d.operator || 'instanceof' === d.operator) && 'UnaryExpression' === c.type) return !0;
      break;
     case 'VariableDeclarator':
      if (
       'init' === h &&
       e.match(
        void 0,
        void 0,
        (e, t) => 'declarations' === t && 'VariableDeclaration' === e.type,
        (e, t) => 'left' === t && 'ForInStatement' === e.type,
       )
      )
       return !0;
    }
    switch (c.type) {
     case 'UpdateExpression':
      if ('UnaryExpression' === d.type) return c.prefix && (('++' === c.operator && '+' === d.operator) || ('--' === c.operator && '-' === d.operator));
     case 'UnaryExpression':
      switch (d.type) {
       case 'UnaryExpression':
        return c.operator === d.operator && ('+' === c.operator || '-' === c.operator);
       case 'BindExpression':
       case 'TaggedTemplateExpression':
       case 'TSNonNullExpression':
        return !0;
       case 'MemberExpression':
       case 'OptionalMemberExpression':
        return 'object' === h;
       case 'NewExpression':
       case 'CallExpression':
       case 'OptionalCallExpression':
        return 'callee' === h;
       case 'BinaryExpression':
        return 'left' === h && '**' === d.operator;
       default:
        return !1;
      }
     case 'BinaryExpression':
      if (
       'UpdateExpression' === d.type ||
       ('in' === c.operator &&
        (function (e) {
         let t = 0,
          { node: r } = e;
         for (; r; ) {
          let n = e.getParentNode(t++);
          if ('ForStatement' === (null == n ? void 0 : n.type) && n.init === r) return !0;
          r = n;
         }
         return !1;
        })(e))
      )
       return !0;
      if ('|>' === c.operator && null != (a = c.extra) && a.parenthesized) {
       let t = e.grandparent;
       if ('BinaryExpression' === t.type && '|>' === t.operator) return !0;
      }
     case 'TSTypeAssertion':
     case 'TSAsExpression':
     case 'TSSatisfiesExpression':
     case 'AsExpression':
     case 'AsConstExpression':
     case 'SatisfiesExpression':
     case 'LogicalExpression':
      switch (d.type) {
       case 'TSAsExpression':
       case 'TSSatisfiesExpression':
       case 'AsExpression':
       case 'AsConstExpression':
       case 'SatisfiesExpression':
        return !it(c);
       case 'ConditionalExpression':
        return (
         it(c) ||
         (function (e) {
          return 'LogicalExpression' === e.type && '??' === e.operator;
         })(c)
        );
       case 'CallExpression':
       case 'NewExpression':
       case 'OptionalCallExpression':
        return 'callee' === h;
       case 'ClassExpression':
       case 'ClassDeclaration':
        return 'superClass' === h;
       case 'TSTypeAssertion':
       case 'TaggedTemplateExpression':
       case 'UnaryExpression':
       case 'JSXSpreadAttribute':
       case 'SpreadElement':
       case 'BindExpression':
       case 'AwaitExpression':
       case 'TSNonNullExpression':
       case 'UpdateExpression':
        return !0;
       case 'MemberExpression':
       case 'OptionalMemberExpression':
        return 'object' === h;
       case 'AssignmentExpression':
       case 'AssignmentPattern':
        return 'left' === h && ('TSTypeAssertion' === c.type || it(c));
       case 'LogicalExpression':
        if ('LogicalExpression' === c.type) return d.operator !== c.operator;
       case 'BinaryExpression': {
        let { operator: e, type: t } = c;
        if (!e && 'TSTypeAssertion' !== t) return !0;
        let r = $e(e),
         n = d.operator,
         s = $e(n);
        return (
         s > r ||
         ('right' === h && s === r) ||
         (s === r && !qe(n, e)) ||
         (s < r && '%' === e
          ? '+' === n || '-' === n
          : !!(function (e) {
             return !!Re[e] || '|' === e || '^' === e || '&' === e;
            })(n))
        );
       }
       default:
        return !1;
      }
     case 'SequenceExpression':
      switch (d.type) {
       case 'ReturnStatement':
       case 'ForStatement':
        return !1;
       case 'ExpressionStatement':
        return 'expression' !== h;
       case 'ArrowFunctionExpression':
        return 'body' !== h;
       default:
        return !0;
      }
     case 'YieldExpression':
      if ('AwaitExpression' === d.type || 'TSTypeAssertion' === d.type) return !0;
     case 'AwaitExpression':
      switch (d.type) {
       case 'TaggedTemplateExpression':
       case 'UnaryExpression':
       case 'LogicalExpression':
       case 'SpreadElement':
       case 'TSAsExpression':
       case 'TSSatisfiesExpression':
       case 'TSNonNullExpression':
       case 'AsExpression':
       case 'AsConstExpression':
       case 'SatisfiesExpression':
       case 'BindExpression':
        return !0;
       case 'MemberExpression':
       case 'OptionalMemberExpression':
        return 'object' === h;
       case 'NewExpression':
       case 'CallExpression':
       case 'OptionalCallExpression':
        return 'callee' === h;
       case 'ConditionalExpression':
        return 'test' === h;
       case 'BinaryExpression':
        return !(!c.argument && '|>' === d.operator);
       default:
        return !1;
      }
     case 'TSFunctionType':
      if (
       e.match(
        (e) => 'TSFunctionType' === e.type,
        (e, t) => 'typeAnnotation' === t && 'TSTypeAnnotation' === e.type,
        (e, t) => 'returnType' === t && 'ArrowFunctionExpression' === e.type,
       )
      )
       return !0;
     case 'TSConditionalType':
     case 'TSConstructorType':
      if ('extendsType' === h && 'TSConditionalType' === d.type) {
       if ('TSConditionalType' === c.type) return !0;
       let { typeAnnotation: e } = c.returnType || c.typeAnnotation;
       if (('TSTypePredicate' === e.type && e.typeAnnotation && (e = e.typeAnnotation.typeAnnotation), 'TSInferType' === e.type && e.typeParameter.constraint)) return !0;
      }
      if ('checkType' === h && 'TSConditionalType' === d.type) return !0;
     case 'TSUnionType':
     case 'TSIntersectionType':
      if (('TSUnionType' === d.type || 'TSIntersectionType' === d.type) && d.types.length > 1 && (!c.types || c.types.length > 1)) return !0;
     case 'TSInferType':
      if ('TSInferType' === c.type) {
       if ('TSRestType' === d.type) return !1;
       if ('types' === h && ('TSUnionType' === d.type || 'TSIntersectionType' === d.type) && 'TSTypeParameter' === c.typeParameter.type && c.typeParameter.constraint) return !0;
      }
     case 'TSTypeOperator':
      return 'TSArrayType' === d.type || 'TSOptionalType' === d.type || 'TSRestType' === d.type || ('objectType' === h && 'TSIndexedAccessType' === d.type) || 'TSTypeOperator' === d.type || ('TSTypeAnnotation' === d.type && e.grandparent.type.startsWith('TSJSDoc'));
     case 'TSTypeQuery':
      return ('objectType' === h && 'TSIndexedAccessType' === d.type) || ('elementType' === h && 'TSArrayType' === d.type);
     case 'TypeOperator':
      return 'ArrayTypeAnnotation' === d.type || 'NullableTypeAnnotation' === d.type || ('objectType' === h && ('IndexedAccessType' === d.type || 'OptionalIndexedAccessType' === d.type)) || 'TypeOperator' === d.type;
     case 'TypeofTypeAnnotation':
      return ('objectType' === h && ('IndexedAccessType' === d.type || 'OptionalIndexedAccessType' === d.type)) || ('elementType' === h && 'ArrayTypeAnnotation' === d.type);
     case 'ArrayTypeAnnotation':
      return 'NullableTypeAnnotation' === d.type;
     case 'IntersectionTypeAnnotation':
     case 'UnionTypeAnnotation':
      return 'TypeOperator' === d.type || 'ArrayTypeAnnotation' === d.type || 'NullableTypeAnnotation' === d.type || 'IntersectionTypeAnnotation' === d.type || 'UnionTypeAnnotation' === d.type || ('objectType' === h && ('IndexedAccessType' === d.type || 'OptionalIndexedAccessType' === d.type));
     case 'InferTypeAnnotation':
     case 'NullableTypeAnnotation':
      return 'ArrayTypeAnnotation' === d.type || ('objectType' === h && ('IndexedAccessType' === d.type || 'OptionalIndexedAccessType' === d.type));
     case 'ComponentTypeAnnotation':
     case 'FunctionTypeAnnotation': {
      if ('ComponentTypeAnnotation' === c.type && (null === c.rendersType || void 0 === c.rendersType)) return !1;
      if (
       e.match(
        void 0,
        (e, t) => 'typeAnnotation' === t && 'TypeAnnotation' === e.type,
        (e, t) => 'returnType' === t && 'ArrowFunctionExpression' === e.type,
       ) ||
       e.match(
        void 0,
        (e, t) => 'typeAnnotation' === t && 'TypePredicate' === e.type,
        (e, t) => 'typeAnnotation' === t && 'TypeAnnotation' === e.type,
        (e, t) => 'returnType' === t && 'ArrowFunctionExpression' === e.type,
       )
      )
       return !0;
      let t = 'NullableTypeAnnotation' === d.type ? e.grandparent : d;
      return (
       'UnionTypeAnnotation' === t.type ||
       'IntersectionTypeAnnotation' === t.type ||
       'ArrayTypeAnnotation' === t.type ||
       ('objectType' === h && ('IndexedAccessType' === t.type || 'OptionalIndexedAccessType' === t.type)) ||
       ('checkType' === h && 'ConditionalTypeAnnotation' === d.type) ||
       ('extendsType' === h && 'ConditionalTypeAnnotation' === d.type && 'InferTypeAnnotation' === (null == (o = c.returnType) ? void 0 : o.type) && (null == (u = c.returnType) ? void 0 : u.typeParameter.bound)) ||
       'NullableTypeAnnotation' === t.type ||
       ('FunctionTypeParam' === d.type &&
        null === d.name &&
        Ve(c).some((e) => {
         var t;
         return 'NullableTypeAnnotation' === (null == (t = e.typeAnnotation) ? void 0 : t.type);
        }))
      );
     }
     case 'ConditionalTypeAnnotation':
      if (('extendsType' === h && 'ConditionalTypeAnnotation' === d.type && 'ConditionalTypeAnnotation' === c.type) || ('checkType' === h && 'ConditionalTypeAnnotation' === d.type)) return !0;
     case 'OptionalIndexedAccessType':
      return 'objectType' === h && 'IndexedAccessType' === d.type;
     case 'StringLiteral':
     case 'NumericLiteral':
     case 'Literal':
      if ('string' == typeof c.value && 'ExpressionStatement' === d.type && !d.directive) {
       let t = e.grandparent;
       return 'Program' === t.type || 'BlockStatement' === t.type;
      }
      return 'object' === h && 'MemberExpression' === d.type && 'number' == typeof c.value;
     case 'AssignmentExpression': {
      let t = e.grandparent;
      return ('body' === h && 'ArrowFunctionExpression' === d.type) || (('key' !== h || ('ClassProperty' !== d.type && 'PropertyDefinition' !== d.type) || !d.computed) && (('init' !== h && 'update' !== h) || 'ForStatement' !== d.type) && ('ExpressionStatement' === d.type ? 'ObjectPattern' === c.left.type : !(('key' === h && 'TSPropertySignature' === d.type) || 'AssignmentExpression' === d.type || ('SequenceExpression' === d.type && 'ForStatement' === t.type && (t.init === d || t.update === d)) || ('value' === h && 'Property' === d.type && 'ObjectPattern' === t.type && t.properties.includes(d)) || 'NGChainedExpression' === d.type || ('node' === h && 'JsExpressionRoot' === d.type))));
     }
     case 'ConditionalExpression':
      switch (d.type) {
       case 'TaggedTemplateExpression':
       case 'UnaryExpression':
       case 'SpreadElement':
       case 'BinaryExpression':
       case 'LogicalExpression':
       case 'NGPipeExpression':
       case 'ExportDefaultDeclaration':
       case 'AwaitExpression':
       case 'JSXSpreadAttribute':
       case 'TSTypeAssertion':
       case 'TypeCastExpression':
       case 'TSAsExpression':
       case 'TSSatisfiesExpression':
       case 'AsExpression':
       case 'AsConstExpression':
       case 'SatisfiesExpression':
       case 'TSNonNullExpression':
        return !0;
       case 'NewExpression':
       case 'CallExpression':
       case 'OptionalCallExpression':
        return 'callee' === h;
       case 'ConditionalExpression':
        return !t.experimentalTernaries && 'test' === h;
       case 'MemberExpression':
       case 'OptionalMemberExpression':
        return 'object' === h;
       default:
        return !1;
      }
     case 'FunctionExpression':
      switch (d.type) {
       case 'NewExpression':
       case 'CallExpression':
       case 'OptionalCallExpression':
        return 'callee' === h;
       case 'TaggedTemplateExpression':
        return !0;
       default:
        return !1;
      }
     case 'ArrowFunctionExpression':
      switch (d.type) {
       case 'BinaryExpression':
        return '|>' !== d.operator || (null == (l = c.extra) ? void 0 : l.parenthesized);
       case 'NewExpression':
       case 'CallExpression':
       case 'OptionalCallExpression':
        return 'callee' === h;
       case 'MemberExpression':
       case 'OptionalMemberExpression':
        return 'object' === h;
       case 'TSAsExpression':
       case 'TSSatisfiesExpression':
       case 'AsExpression':
       case 'AsConstExpression':
       case 'SatisfiesExpression':
       case 'TSNonNullExpression':
       case 'BindExpression':
       case 'TaggedTemplateExpression':
       case 'UnaryExpression':
       case 'LogicalExpression':
       case 'AwaitExpression':
       case 'TSTypeAssertion':
        return !0;
       case 'ConditionalExpression':
        return 'test' === h;
       default:
        return !1;
      }
     case 'ClassExpression':
      return 'NewExpression' === d.type && 'callee' === h;
     case 'OptionalMemberExpression':
     case 'OptionalCallExpression':
     case 'CallExpression':
     case 'MemberExpression':
      if (
       (function (e) {
        return !!(
         e.match(
          void 0,
          (e, t) => 'expression' === t && 'ChainExpression' === e.type,
          (e, t) => 'tag' === t && 'TaggedTemplateExpression' === e.type,
         ) ||
         e.match(
          (e) => 'OptionalCallExpression' === e.type || 'OptionalMemberExpression' === e.type,
          (e, t) => 'tag' === t && 'TaggedTemplateExpression' === e.type,
         ) ||
         e.match(
          (e) => 'OptionalCallExpression' === e.type || 'OptionalMemberExpression' === e.type,
          (e, t) => 'expression' === t && 'TSNonNullExpression' === e.type,
          (e, t) => 'tag' === t && 'TaggedTemplateExpression' === e.type,
         ) ||
         e.match(
          void 0,
          (e, t) => 'expression' === t && 'ChainExpression' === e.type,
          (e, t) => 'expression' === t && 'TSNonNullExpression' === e.type,
          (e, t) => 'tag' === t && 'TaggedTemplateExpression' === e.type,
         ) ||
         e.match(
          void 0,
          (e, t) => 'expression' === t && 'TSNonNullExpression' === e.type,
          (e, t) => 'expression' === t && 'ChainExpression' === e.type,
          (e, t) => 'tag' === t && 'TaggedTemplateExpression' === e.type,
         ) ||
         e.match(
          (e) => 'OptionalMemberExpression' === e.type || 'OptionalCallExpression' === e.type,
          (e, t) => ('object' === t && 'MemberExpression' === e.type) || ('callee' === t && ('CallExpression' === e.type || 'NewExpression' === e.type)),
         ) ||
         e.match(
          (e) => 'OptionalMemberExpression' === e.type || 'OptionalCallExpression' === e.type,
          (e, t) => 'expression' === t && 'TSNonNullExpression' === e.type,
          (e, t) => ('object' === t && 'MemberExpression' === e.type) || ('callee' === t && 'CallExpression' === e.type),
         ) ||
         (e.match(
          (e) => 'CallExpression' === e.type || 'MemberExpression' === e.type,
          (e, t) => 'expression' === t && 'ChainExpression' === e.type,
         ) &&
          (e.match(void 0, void 0, (e, t) => ('callee' === t && (('CallExpression' === e.type && !e.optional) || 'NewExpression' === e.type)) || ('object' === t && 'MemberExpression' === e.type && !e.optional)) ||
           e.match(
            void 0,
            void 0,
            (e, t) => 'expression' === t && 'TSNonNullExpression' === e.type,
            (e, t) => ('object' === t && 'MemberExpression' === e.type) || ('callee' === t && 'CallExpression' === e.type),
           ))) ||
         e.match(
          (e) => 'CallExpression' === e.type || 'MemberExpression' === e.type,
          (e, t) => 'expression' === t && 'TSNonNullExpression' === e.type,
          (e, t) => 'expression' === t && 'ChainExpression' === e.type,
          (e, t) => ('object' === t && 'MemberExpression' === e.type) || ('callee' === t && 'CallExpression' === e.type),
         )
        );
       })(e)
      )
       return !0;
     case 'TaggedTemplateExpression':
     case 'TSNonNullExpression':
      if ('callee' === h && ('BindExpression' === d.type || 'NewExpression' === d.type)) {
       let e = c;
       for (; e; )
        switch (e.type) {
         case 'CallExpression':
         case 'OptionalCallExpression':
          return !0;
         case 'MemberExpression':
         case 'OptionalMemberExpression':
         case 'BindExpression':
          e = e.object;
          break;
         case 'TaggedTemplateExpression':
          e = e.tag;
          break;
         case 'TSNonNullExpression':
          e = e.expression;
          break;
         default:
          return !1;
        }
      }
      return !1;
     case 'BindExpression':
      return ('callee' === h && ('BindExpression' === d.type || 'NewExpression' === d.type)) || ('object' === h && ve(d));
     case 'NGPipeExpression':
      return !('NGRoot' === d.type || 'NGMicrosyntaxExpression' === d.type || ('ObjectProperty' === d.type && (null == (p = c.extra) || !p.parenthesized)) || Z(d) || ('arguments' === h && be(d)) || ('right' === h && 'NGPipeExpression' === d.type) || ('property' === h && 'MemberExpression' === d.type) || 'AssignmentExpression' === d.type);
     case 'JSXFragment':
     case 'JSXElement':
      return 'callee' === h || ('left' === h && 'BinaryExpression' === d.type && '<' === d.operator) || (!Z(d) && 'ArrowFunctionExpression' !== d.type && 'AssignmentExpression' !== d.type && 'AssignmentPattern' !== d.type && 'BinaryExpression' !== d.type && 'NewExpression' !== d.type && 'ConditionalExpression' !== d.type && 'ExpressionStatement' !== d.type && 'JsExpressionRoot' !== d.type && 'JSXAttribute' !== d.type && 'JSXElement' !== d.type && 'JSXExpressionContainer' !== d.type && 'JSXFragment' !== d.type && 'LogicalExpression' !== d.type && !be(d) && !st(d) && 'ReturnStatement' !== d.type && 'ThrowStatement' !== d.type && 'TypeCastExpression' !== d.type && 'VariableDeclarator' !== d.type && 'YieldExpression' !== d.type);
     case 'TSInstantiationExpression':
      return 'object' === h && ve(d);
    }
    return !1;
   }
   var ys = $(['BlockStatement', 'BreakStatement', 'ComponentDeclaration', 'ClassBody', 'ClassDeclaration', 'ClassMethod', 'ClassProperty', 'PropertyDefinition', 'ClassPrivateProperty', 'ContinueStatement', 'DebuggerStatement', 'DeclareComponent', 'DeclareClass', 'DeclareExportAllDeclaration', 'DeclareExportDeclaration', 'DeclareFunction', 'DeclareHook', 'DeclareInterface', 'DeclareModule', 'DeclareModuleExports', 'DeclareNamespace', 'DeclareVariable', 'DeclareEnum', 'DoWhileStatement', 'EnumDeclaration', 'ExportAllDeclaration', 'ExportDefaultDeclaration', 'ExportNamedDeclaration', 'ExpressionStatement', 'ForInStatement', 'ForOfStatement', 'ForStatement', 'FunctionDeclaration', 'HookDeclaration', 'IfStatement', 'ImportDeclaration', 'InterfaceDeclaration', 'LabeledStatement', 'MethodDefinition', 'ReturnStatement', 'SwitchStatement', 'ThrowStatement', 'TryStatement', 'TSDeclareFunction', 'TSEnumDeclaration', 'TSImportEqualsDeclaration', 'TSInterfaceDeclaration', 'TSModuleDeclaration', 'TSNamespaceExportDeclaration', 'TypeAlias', 'VariableDeclaration', 'WhileStatement', 'WithStatement']);
   function gs(e) {
    let { parent: t, key: r } = e;
    switch (t.type) {
     case 'NGPipeExpression':
      if ('arguments' === r && e.isLast) return e.callParent(gs);
      break;
     case 'ObjectProperty':
      if ('value' === r) return e.callParent(() => 'properties' === e.key && e.isLast);
      break;
     case 'BinaryExpression':
     case 'LogicalExpression':
      if ('right' === r) return e.callParent(gs);
      break;
     case 'ConditionalExpression':
      if ('alternate' === r) return e.callParent(gs);
      break;
     case 'UnaryExpression':
      if (t.prefix) return e.callParent(gs);
    }
    return !1;
   }
   function Ds(e, t) {
    let { node: r, parent: n } = e;
    return 'FunctionExpression' === r.type || 'ClassExpression' === r.type ? 'ExportDefaultDeclaration' === n.type || !ms(e, t) : !(!K(r) || ('ExportDefaultDeclaration' !== n.type && ms(e, t))) && e.call(() => Ds(e, t), ...X(r));
   }
   function xs(e) {
    return 'Identifier' === e.type || (!!ve(e) && !e.computed && !e.optional && 'Identifier' === e.property.type && xs(e.object));
   }
   var bs = ms;
   var vs = function (e, t) {
     let r = t - 1;
     return (r = x(e, r, { backwards: !0 })), (r = E(e, r, { backwards: !0 })), (r = x(e, r, { backwards: !0 })), r !== E(e, r, { backwards: !0 });
    },
    Es = () => !0;
   function Cs(e, t) {
    return (e.node.printed = !0), t.printer.printComment(e, t);
   }
   function Ts(e, t, r = {}) {
    let { node: n } = e;
    if (!A(null == n ? void 0 : n.comments)) return '';
    let { indent: s = !1, marker: i, filter: a = Es } = r,
     o = [];
    if (
     (e.each(({ node: r }) => {
      r.leading || r.trailing || r.marker !== i || !a(r) || o.push(Cs(e, t));
     }, 'comments'),
     0 === o.length)
    )
     return '';
    let u = dr(pr, o);
    return s ? Gt([pr, u]) : u;
   }
   function Ss(e, t) {
    let r = e.node;
    if (!r) return {};
    let n = t[Symbol.for('printedComments')];
    if (0 === (r.comments || []).filter((e) => !n.has(e)).length) return { leading: '', trailing: '' };
    let s,
     i = [],
     a = [];
    return (
     e.each(() => {
      let r = e.node;
      if (null != n && n.has(r)) return;
      let { leading: o, trailing: u } = r;
      o
       ? i.push(
          (function (e, t) {
           var r;
           let n = e.node,
            s = [Cs(e, t)],
            { printer: i, originalText: a, locStart: o, locEnd: u } = t;
           if (null == (r = i.isBlockComment) ? void 0 : r.call(i, n)) {
            let e = C(a, u(n)) ? (C(a, o(n), { backwards: !0 }) ? pr : ur) : ' ';
            s.push(e);
           } else s.push(pr);
           let l = E(a, x(a, u(n)));
           return !1 !== l && C(a, l) && s.push(pr), s;
          })(e, t),
         )
       : u &&
         ((s = (function (e, t, r) {
          var n;
          let s = e.node,
           i = Cs(e, t),
           { printer: a, originalText: o, locStart: u } = t,
           l = null == (n = a.isBlockComment) ? void 0 : n.call(a, s);
          if ((null != r && r.hasLineSuffix && (null == r || !r.isBlock)) || C(o, u(s), { backwards: !0 })) {
           let e = vs(o, u(s));
           return { doc: sr([pr, e ? pr : '', i]), isBlock: l, hasLineSuffix: !0 };
          }
          return !l || (null != r && r.hasLineSuffix) ? { doc: [sr([' ', i]), ar], isBlock: l, hasLineSuffix: !0 } : { doc: [' ', i], isBlock: l, hasLineSuffix: !1 };
         })(e, t, s)),
         a.push(s.doc));
     }, 'comments'),
     { leading: i, trailing: a }
    );
   }
   function ws(e, t, r) {
    let { leading: n, trailing: s } = Ss(e, r);
    return n || s ? Ht(t, (e) => [n, e, s]) : t;
   }
   var As = class extends Error {
    name = 'UnexpectedNodeError';
    constructor(e, t, r = 'type') {
     super(`Unexpected ${t} node ${r}: ${JSON.stringify(e[r])}.`), (this.node = e);
    }
   };
   var Fs;
   Fs = new WeakMap();
   var ks = new (class {
     constructor(e) {
      ((e, t, r) => {
       t.has(e) ? s('Cannot add the same private member more than once') : t instanceof WeakSet ? t.add(e) : t.set(e, r);
      })(this, Fs),
       ((e, t, r, n) => {
        a(e, t, 'write to private field'), n ? n.call(e, r) : t.set(e, r);
       })(this, Fs, new Set(e));
     }
     getLeadingWhitespaceCount(e) {
      let t = o(this, Fs),
       r = 0;
      for (let n = 0; n < e.length && t.has(e.charAt(n)); n++) r++;
      return r;
     }
     getTrailingWhitespaceCount(e) {
      let t = o(this, Fs),
       r = 0;
      for (let n = e.length - 1; n >= 0 && t.has(e.charAt(n)); n--) r++;
      return r;
     }
     getLeadingWhitespace(e) {
      let t = this.getLeadingWhitespaceCount(e);
      return e.slice(0, t);
     }
     getTrailingWhitespace(e) {
      let t = this.getTrailingWhitespaceCount(e);
      return e.slice(e.length - t);
     }
     hasLeadingWhitespace(e) {
      return o(this, Fs).has(e.charAt(0));
     }
     hasTrailingWhitespace(e) {
      return o(this, Fs).has(c(!1, e, -1));
     }
     trimStart(e) {
      let t = this.getLeadingWhitespaceCount(e);
      return e.slice(t);
     }
     trimEnd(e) {
      let t = this.getTrailingWhitespaceCount(e);
      return e.slice(0, e.length - t);
     }
     trim(e) {
      return this.trimEnd(this.trimStart(e));
     }
     split(e, t = !1) {
      let r = `[${(function (e) {
        if ('string' != typeof e) throw new TypeError('Expected a string');
        return e.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&').replace(/-/g, '\\x2d');
       })([...o(this, Fs)].join(''))}]+`,
       n = new RegExp(t ? `(${r})` : r, 'u');
      return e.split(n);
     }
     hasWhitespaceCharacter(e) {
      let t = o(this, Fs);
      return Array.prototype.some.call(e, (e) => t.has(e));
     }
     hasNonWhitespaceCharacter(e) {
      let t = o(this, Fs);
      return Array.prototype.some.call(e, (e) => !t.has(e));
     }
     isWhitespaceOnly(e) {
      let t = o(this, Fs);
      return Array.prototype.every.call(e, (e) => t.has(e));
     }
    })(' \n\r\t'),
    Ps = (e) => '' === e || e === ur || e === pr || e === lr;
   function Is(e, t, r) {
    var n, s, i, a, o;
    let { node: u } = e;
    if (
     'JSXElement' === u.type &&
     (function (e) {
      if (0 === e.children.length) return !0;
      if (e.children.length > 1) return !1;
      let t = e.children[0];
      return 'JSXText' === t.type && !js(t);
     })(u)
    )
     return [r('openingElement'), r('closingElement')];
    let l = 'JSXElement' === u.type ? r('openingElement') : r('openingFragment'),
     p = 'JSXElement' === u.type ? r('closingElement') : r('closingFragment');
    if (1 === u.children.length && 'JSXExpressionContainer' === u.children[0].type && ('TemplateLiteral' === u.children[0].expression.type || 'TaggedTemplateExpression' === u.children[0].expression.type)) return [l, ...e.map(r, 'children'), p];
    u.children = u.children.map((e) =>
     (function (e) {
      return 'JSXExpressionContainer' === e.type && ne(e.expression) && ' ' === e.expression.value && !et(e.expression);
     })(e)
      ? { type: 'JSXText', value: ' ', raw: ' ' }
      : e,
    );
    let h = u.children.some(pe),
     d = u.children.filter((e) => 'JSXExpressionContainer' === e.type).length > 1,
     f = 'JSXElement' === u.type && u.openingElement.attributes.length > 1,
     m = Ot(l) || h || f || d,
     y = 'mdx' === e.parent.rootMarker,
     g = t.singleQuote ? "{' '}" : '{" "}',
     D = y ? ur : rr([g, lr], ' '),
     x = (function (e, t, r, n, s) {
      let i = '',
       a = [i];
      function o(e) {
       (i = e), a.push([a.pop(), e]);
      }
      function u(e) {
       '' !== e && ((i = e), a.push(e, ''));
      }
      return (
       e.each(({ node: e, next: t }) => {
        if ('JSXText' === e.type) {
         let r = Be(e);
         if (js(e)) {
          let a,
           l = ks.split(r, !0);
          if (('' === l[0] && (l.shift(), /\n/u.test(l[0]) ? u(Bs(s, l[1], e, t)) : u(n), l.shift()), '' === c(!1, l, -1) && (l.pop(), (a = l.pop())), 0 === l.length)) return;
          for (let [e, t] of l.entries()) e % 2 == 1 ? u(ur) : o(t);
          void 0 !== a ? (/\n/u.test(a) ? u(Bs(s, i, e, t)) : u(n)) : u(Ns(s, i, e, t));
         } else /\n/u.test(r) ? r.match(/\n/gu).length > 1 && u(pr) : u(n);
        } else {
         if ((o(r()), t && js(t))) {
          let r = ks.trim(Be(t)),
           [n] = ks.split(r);
          u(Ns(s, n, e, t));
         } else u(pr);
        }
       }, 'children'),
       a
      );
     })(e, 0, r, D, 'fbt' === (null == (s = null == (n = u.openingElement) ? void 0 : n.name) ? void 0 : s.name)),
     b = u.children.some((e) => js(e));
    for (let c = x.length - 2; c >= 0; c--) {
     let e = '' === x[c] && '' === x[c + 1],
      t = x[c] === pr && '' === x[c + 1] && x[c + 2] === pr,
      r = (x[c] === lr || x[c] === pr) && '' === x[c + 1] && x[c + 2] === D,
      n = x[c] === D && '' === x[c + 1] && (x[c + 2] === lr || x[c + 2] === pr),
      s = x[c] === D && '' === x[c + 1] && x[c + 2] === D,
      i = (x[c] === lr && '' === x[c + 1] && x[c + 2] === pr) || (x[c] === pr && '' === x[c + 1] && x[c + 2] === lr);
     (t && b) || e || r || s || i ? x.splice(c, 2) : n && x.splice(c + 1, 2);
    }
    for (; x.length > 0 && Ps(c(!1, x, -1)); ) x.pop();
    for (; x.length > 1 && Ps(x[0]) && Ps(x[1]); ) x.shift(), x.shift();
    let v = [''];
    for (let [c, T] of x.entries()) {
     if (T === D) {
      if (1 === c && zt(x[c - 1])) {
       if (2 === x.length) {
        v.push([v.pop(), g]);
        continue;
       }
       v.push([g, pr], '');
       continue;
      }
      if (c === x.length - 1) {
       v.push([v.pop(), g]);
       continue;
      }
      if ('' === x[c - 1] && x[c - 2] === pr) {
       v.push([v.pop(), g]);
       continue;
      }
     }
     c % 2 == 0 ? v.push([v.pop(), T]) : v.push(T, ''), Ot(T) && (m = !0);
    }
    let E = b ? tr(v) : Yt(v, { shouldBreak: !0 });
    if (('JSXText' === (null == (i = t.cursorNode) ? void 0 : i.type) && u.children.includes(t.cursorNode) ? (E = [hr, E, hr]) : 'JSXText' === (null == (a = t.nodeBeforeCursor) ? void 0 : a.type) && u.children.includes(t.nodeBeforeCursor) ? (E = [hr, E]) : 'JSXText' === (null == (o = t.nodeAfterCursor) ? void 0 : o.type) && u.children.includes(t.nodeAfterCursor) && (E = [E, hr]), y)) return E;
    let C = Yt([l, Gt([pr, E]), pr, p]);
    return m ? C : er([Yt([l, ...x, p]), C]);
   }
   function Ns(e, t, r, n) {
    return e ? '' : ('JSXElement' === r.type && !r.closingElement) || ('JSXElement' === (null == n ? void 0 : n.type) && !n.closingElement) ? (1 === t.length ? lr : pr) : lr;
   }
   function Bs(e, t, r, n) {
    return e ? pr : 1 === t.length ? (('JSXElement' === r.type && !r.closingElement) || ('JSXElement' === (null == n ? void 0 : n.type) && !n.closingElement) ? pr : lr) : pr;
   }
   var _s = new Set(['ArrayExpression', 'TupleExpression', 'JSXAttribute', 'JSXElement', 'JSXExpressionContainer', 'JSXFragment', 'ExpressionStatement', 'CallExpression', 'OptionalCallExpression', 'ConditionalExpression', 'JsExpressionRoot']);
   function Ls(e, t, r) {
    return e.selfClosing
     ? [ur, '/>']
     : (function (e, t, r) {
          let n = e.attributes.length > 0 && et(c(!1, e.attributes, -1), Qe.Trailing);
          return (0 === e.attributes.length && !r) || ((t.bracketSameLine || t.jsxBracketSameLine) && (!r || e.attributes.length > 0) && !n);
         })(e, t, r)
       ? ['>']
       : [lr, '>'];
   }
   function Os(e, t, r) {
    return (function (e, t, r) {
     let { parent: n } = e;
     if (_s.has(n.type)) return t;
     let s = e.match(
       void 0,
       (e) => 'ArrowFunctionExpression' === e.type,
       be,
       (e) => 'JSXExpressionContainer' === e.type,
      ),
      i = bs(e, r);
     return Yt([i ? '' : rr('('), Gt([lr, t]), lr, i ? '' : rr(')')], { shouldBreak: s });
    })(e, ws(e, Is(e, t, r), t), t);
   }
   function Ms(e, t, r) {
    let { node: n } = e;
    if (n.type.startsWith('JSX'))
     switch (n.type) {
      case 'JSXAttribute':
       return (function (e, t, r) {
        let { node: n } = e,
         s = [];
        if ((s.push(r('name')), n.value)) {
         let i;
         if (ne(n.value)) {
          let r = Be(n.value),
           s = p(!1, p(!1, r.slice(1, -1), '&apos;', "'"), '&quot;', '"'),
           a = I(s, t.jsxSingleQuote);
          (s = '"' === a ? p(!1, s, '"', '&quot;') : p(!1, s, "'", '&apos;')), (i = e.call(() => ws(e, Ut(a + s + a), t), 'value'));
         } else i = r('value');
         s.push('=', i);
        }
        return s;
       })(e, t, r);
      case 'JSXIdentifier':
       return n.name;
      case 'JSXNamespacedName':
       return dr(':', [r('namespace'), r('name')]);
      case 'JSXMemberExpression':
       return dr('.', [r('object'), r('property')]);
      case 'JSXSpreadAttribute':
      case 'JSXSpreadChild':
       return (function (e, t, r) {
        let { node: n } = e;
        return [
         '{',
         e.call(
          ({ node: n }) => {
           let s = ['...', r()];
           return et(n) && xn(e) ? [Gt([lr, ws(e, s, t)]), lr] : s;
          },
          'JSXSpreadAttribute' === n.type ? 'argument' : 'expression',
         ),
         '}',
        ];
       })(e, t, r);
      case 'JSXExpressionContainer':
       return (function (e, t, r) {
        let { node: n } = e,
         s = (e, t) => 'JSXEmptyExpression' === e.type || (!et(e) && (Z(e) || ee(e) || 'ArrowFunctionExpression' === e.type || ('AwaitExpression' === e.type && (s(e.argument, e) || 'JSXElement' === e.argument.type)) || be(e) || ('ChainExpression' === e.type && be(e.expression)) || 'FunctionExpression' === e.type || 'TemplateLiteral' === e.type || 'TaggedTemplateExpression' === e.type || 'DoExpression' === e.type || (pe(t) && ('ConditionalExpression' === e.type || de(e)))));
        return s(n.expression, e.parent) ? Yt(['{', r('expression'), ir, '}']) : Yt(['{', Gt([lr, r('expression')]), lr, ir, '}']);
       })(e, 0, r);
      case 'JSXFragment':
      case 'JSXElement':
       return Os(e, t, r);
      case 'JSXOpeningElement':
       return (function (e, t, r) {
        var n, s;
        let { node: i } = e,
         a = et(i.name) || et(i.typeParameters) || et(i.typeArguments);
        if (i.selfClosing && 0 === i.attributes.length && !a) return ['<', r('name'), i.typeArguments ? r('typeArguments') : r('typeParameters'), ' />'];
        if (1 === (null == (n = i.attributes) ? void 0 : n.length) && ne(i.attributes[0].value) && !i.attributes[0].value.value.includes('\n') && !a && !et(i.attributes[0])) return Yt(['<', r('name'), i.typeArguments ? r('typeArguments') : r('typeParameters'), ' ', ...e.map(r, 'attributes'), i.selfClosing ? ' />' : '>']);
        let o = null == (s = i.attributes) ? void 0 : s.some((e) => ne(e.value) && e.value.value.includes('\n')),
         u = t.singleAttributePerLine && i.attributes.length > 1 ? pr : ur;
        return Yt(['<', r('name'), i.typeArguments ? r('typeArguments') : r('typeParameters'), Gt(e.map(() => [u, r()], 'attributes')), ...Ls(i, t, a)], { shouldBreak: o });
       })(e, t, r);
      case 'JSXClosingElement':
       return (function (e, t, r) {
        let { node: n } = e,
         s = [];
        s.push('</');
        let i = r('name');
        return et(n.name, Qe.Leading | Qe.Line) ? s.push(Gt([pr, i]), pr) : et(n.name, Qe.Leading | Qe.Block) ? s.push(' ', i) : s.push(i), s.push('>'), s;
       })(e, 0, r);
      case 'JSXOpeningFragment':
      case 'JSXClosingFragment':
       return (function (e, t) {
        let { node: r } = e,
         n = et(r),
         s = et(r, Qe.Line),
         i = 'JSXOpeningFragment' === r.type;
        return [i ? '<' : '</', Gt([s ? pr : n && !i ? ' ' : '', Ts(e, t)]), s ? pr : '', '>'];
       })(e, t);
      case 'JSXEmptyExpression':
       return (function (e, t) {
        let { node: r } = e,
         n = et(r, Qe.Line);
        return [Ts(e, t, { indent: n }), n ? pr : ''];
       })(e, t);
      case 'JSXText':
       throw new Error('JSXText should be handled by JSXElement');
      default:
       throw new As(n, 'JSX');
     }
   }
   function js(e) {
    return 'JSXText' === e.type && (ks.hasNonWhitespaceCharacter(Be(e)) || !/\n/u.test(Be(e)));
   }
   var Rs = function (e) {
     return (
      Ye(e.node) ||
      (function (e) {
       let { node: t, parent: r } = e;
       if (!pe(t) || !pe(r)) return !1;
       let n,
        { index: s, siblings: i } = e;
       for (let a = s; a > 0; a--) {
        let e = i[a - 1];
        if ('JSXText' !== e.type || js(e)) {
         n = e;
         break;
        }
       }
       return 'JSXExpressionContainer' === (null == n ? void 0 : n.type) && 'JSXEmptyExpression' === n.expression.type && Ye(n.expression);
      })(e)
     );
    },
    qs = 0;
   function Us(e, t, r) {
    var n;
    let { node: s, parent: i, grandparent: a, key: o } = e,
     u = 'body' !== o && ('IfStatement' === i.type || 'WhileStatement' === i.type || 'SwitchStatement' === i.type || 'DoWhileStatement' === i.type),
     l = '|>' === s.operator && (null == (n = e.root.extra) ? void 0 : n.__isUsingHackPipeline),
     p = $s(e, r, t, !1, u);
    if (u) return p;
    if (l) return Yt(p);
    if ((be(i) && i.callee === s) || 'UnaryExpression' === i.type || (ve(i) && !i.computed)) return Yt([Gt([lr, ...p]), lr]);
    let h = 'ReturnStatement' === i.type || 'ThrowStatement' === i.type || ('JSXExpressionContainer' === i.type && 'JSXAttribute' === a.type) || ('|' !== s.operator && 'JsExpressionRoot' === i.type) || ('NGPipeExpression' !== s.type && (('NGRoot' === i.type && '__ng_binding' === t.parser) || ('NGMicrosyntaxExpression' === i.type && 'NGMicrosyntax' === a.type && 1 === a.body.length))) || (s === i.body && 'ArrowFunctionExpression' === i.type) || (s !== i.body && 'ForStatement' === i.type) || ('ConditionalExpression' === i.type && 'ReturnStatement' !== a.type && 'ThrowStatement' !== a.type && !be(a)) || 'TemplateLiteral' === i.type,
     d = 'AssignmentExpression' === i.type || 'VariableDeclarator' === i.type || 'ClassProperty' === i.type || 'PropertyDefinition' === i.type || 'TSAbstractPropertyDefinition' === i.type || 'ClassPrivateProperty' === i.type || st(i),
     f = de(s.left) && qe(s.operator, s.left.operator);
    if (h || (Hs(s) && !f) || (!Hs(s) && d)) return Yt(p);
    if (0 === p.length) return '';
    let m = pe(s.right),
     y = p.findIndex((e) => 'string' != typeof e && !Array.isArray(e) && e.type === Dt),
     g = p.slice(0, -1 === y ? 1 : y + 1),
     D = p.slice(g.length, m ? -1 : void 0),
     x = Symbol('logicalChain-' + ++qs),
     b = Yt([...g, Gt(D)], { id: x });
    return m ? Yt([b, nr(c(!1, p, -1), { groupId: x })]) : b;
   }
   function $s(e, t, r, n, s) {
    var i;
    let { node: a } = e;
    if (!de(a)) return [Yt(t())];
    let o = [];
    qe(a.operator, a.left.operator) ? (o = e.call((e) => $s(e, t, r, !0, s), 'left')) : o.push(Yt(t('left')));
    let u,
     l = Hs(a),
     p =
      ('|>' === a.operator ||
       'NGPipeExpression' === a.type ||
       (function (e, t) {
        return ('__vue_expression' === t.parser || '__vue_ts_expression' === t.parser) && zs(e.node) && !e.hasAncestor((e) => !zs(e) && 'JsExpressionRoot' !== e.type);
       })(e, r)) &&
      !we(r.originalText, a.right),
     c = !et(a.right, Qe.Leading, Sr) && we(r.originalText, a.right),
     h = 'NGPipeExpression' === a.type ? '|' : a.operator,
     d =
      'NGPipeExpression' === a.type && a.arguments.length > 0
       ? Yt(
          Gt([
           lr,
           ': ',
           dr(
            [ur, ': '],
            e.map(() => Xt(2, Yt(t())), 'arguments'),
           ),
          ]),
         )
       : '';
    if (l) u = [h, ' ', t('right'), d];
    else {
     let n = '|>' === h && (null == (i = e.root.extra) ? void 0 : i.__isUsingHackPipeline) ? e.call((e) => $s(e, t, r, !0, s), 'right') : t('right');
     if ('start' === r.experimentalOperatorPosition) {
      let e = '';
      if (c)
       switch (Ft(n)) {
        case dt:
         e = n.splice(0, 1)[0];
         break;
        case St:
         e = n.contents.splice(0, 1)[0];
       }
      u = [ur, e, h, ' ', n, d];
     } else u = [p ? ur : '', h, p ? ' ' : ur, n, d];
    }
    let { parent: f } = e,
     m = et(a.left, Qe.Trailing | Qe.Line);
    if (((m || (!(s && 'LogicalExpression' === a.type) && f.type !== a.type && a.left.type !== a.type && a.right.type !== a.type)) && (u = Yt(u, { shouldBreak: m })), 'start' === r.experimentalOperatorPosition ? o.push(l || c ? ' ' : '', u) : o.push(p ? '' : ' ', u), n && et(a))) {
     let t = qt(ws(e, o, r));
     return t.type === xt ? t.parts : Array.isArray(t) ? t : [t];
    }
    return o;
   }
   function Hs(e) {
    return 'LogicalExpression' === e.type && !!((ee(e.right) && e.right.properties.length > 0) || (Z(e.right) && e.right.elements.length > 0) || pe(e.right));
   }
   var zs = (e) => 'BinaryExpression' === e.type && '|' === e.operator;
   function Vs(e, t, r) {
    let { node: n } = e;
    if (n.type.startsWith('NG'))
     switch (n.type) {
      case 'NGRoot':
       return [r('node'), et(n.node) ? ' //' + tt(n.node)[0].value.trimEnd() : ''];
      case 'NGPipeExpression':
       return Us(e, t, r);
      case 'NGChainedExpression':
       return Yt(
        dr(
         [';', ur],
         e.map(
          () =>
           (function ({ node: e }) {
            return J(e, Js);
           })(e)
            ? r()
            : ['(', r(), ')'],
          'expressions',
         ),
        ),
       );
      case 'NGEmptyExpression':
       return '';
      case 'NGMicrosyntax':
       return e.map(() => [e.isFirst ? '' : Ws(e) ? ' ' : [';', ur], r()], 'body');
      case 'NGMicrosyntaxKey':
       return /^[$_a-z][\w$]*(?:-[$_a-z][\w$])*$/iu.test(n.name) ? n.name : JSON.stringify(n.name);
      case 'NGMicrosyntaxExpression':
       return [r('expression'), null === n.alias ? '' : [' as ', r('alias')]];
      case 'NGMicrosyntaxKeyedExpression': {
       let { index: t, parent: s } = e,
        i = Ws(e) || (((1 === t && ('then' === n.key.name || 'else' === n.key.name || 'as' === n.key.name)) || ((2 === t || 3 === t) && (('else' === n.key.name && 'NGMicrosyntaxKeyedExpression' === s.body[t - 1].type && 'then' === s.body[t - 1].key.name) || 'track' === n.key.name))) && 'NGMicrosyntaxExpression' === s.body[0].type);
       return [r('key'), i ? ' ' : ': ', r('expression')];
      }
      case 'NGMicrosyntaxLet':
       return ['let ', r('key'), null === n.value ? '' : [' = ', r('value')]];
      case 'NGMicrosyntaxAs':
       return [r('key'), ' as ', r('alias')];
      default:
       throw new As(n, 'Angular');
     }
   }
   function Ws({ node: e, index: t }) {
    return 'NGMicrosyntaxKeyedExpression' === e.type && 'of' === e.key.name && 1 === t;
   }
   var Js = $(['CallExpression', 'OptionalCallExpression', 'AssignmentExpression']);
   function Ks(e, t, r) {
    let { node: n } = e;
    return Yt([dr(ur, e.map(r, 'decorators')), Xs(n, t) ? pr : ur]);
   }
   function Gs(e, t, r) {
    return Ys(e.node) ? [dr(pr, e.map(r, 'declaration', 'decorators')), pr] : '';
   }
   function Xs(e, t) {
    return e.decorators.some((e) => C(t.originalText, L(e)));
   }
   function Ys(e) {
    var t;
    if ('ExportDefaultDeclaration' !== e.type && 'ExportNamedDeclaration' !== e.type && 'DeclareExportDeclaration' !== e.type) return !1;
    let r = null == (t = e.declaration) ? void 0 : t.decorators;
    return A(r) && O(e, r[0]);
   }
   var Qs = class extends Error {
    name = 'ArgExpansionBailout';
   };
   function Zs(e, t = !1) {
    return (
     (ee(e) && (e.properties.length > 0 || et(e))) ||
     (Z(e) && (e.elements.length > 0 || et(e))) ||
     ('TSTypeAssertion' === e.type && Zs(e.expression)) ||
     (it(e) && Zs(e.expression)) ||
     'FunctionExpression' === e.type ||
     ('ArrowFunctionExpression' === e.type &&
      (!e.returnType ||
       !e.returnType.typeAnnotation ||
       'TSTypeReference' !== e.returnType.typeAnnotation.type ||
       (function (e) {
        return 'BlockStatement' === e.type && (e.body.some((e) => 'EmptyStatement' !== e.type) || et(e, Qe.Dangling));
       })(e.body)) &&
      ('BlockStatement' === e.body.type || ('ArrowFunctionExpression' === e.body.type && Zs(e.body, !0)) || ee(e.body) || Z(e.body) || (!t && (be(e.body) || 'ConditionalExpression' === e.body.type)) || pe(e.body))) ||
     'DoExpression' === e.type ||
     'ModuleExpression' === e.type
    );
   }
   function ei(e) {
    if ('ParenthesizedExpression' === e.type) return ei(e.expression);
    if (it(e) || 'TypeCastExpression' === e.type) {
     let { typeAnnotation: t } = e;
     if (('TypeAnnotation' === t.type && (t = t.typeAnnotation), 'TSArrayType' === t.type && ((t = t.elementType), 'TSArrayType' === t.type && (t = t.elementType)), 'GenericTypeAnnotation' === t.type || 'TSTypeReference' === t.type)) {
      let e = t.typeArguments ?? t.typeParameters;
      1 === (null == e ? void 0 : e.params.length) && (t = e.params[0]);
     }
     return ye(t) && Ne(e.expression, 1);
    }
    return !(nt(e) && Je(e).length > 1) && (de(e) ? Ne(e.left, 1) && Ne(e.right, 1) : se(e) || Ne(e));
   }
   function ti(e, t) {
    let r = e[t],
     n = e[t + 1];
    return 'ArrowFunctionExpression' === r.type && 0 === Ve(r).length && 'BlockStatement' === r.body.type && 'ArrayExpression' === n.type && !e.some((e) => et(e));
   }
   var ri = function (e, t, r) {
     let { node: n } = e,
      s = Je(n);
     if (0 === s.length) return ['(', Ts(e, t), ')'];
     let i = s.length - 1;
     if (
      (function (e) {
       return 2 === e.length ? ti(e, 0) : 3 === e.length && 'Identifier' === e[0].type && ti(e, 1);
      })(s)
     ) {
      let t = ['('];
      return (
       Ke(e, (e, n) => {
        t.push(r()), n !== i && t.push(', ');
       }),
       t.push(')'),
       t
      );
     }
     let a = !1,
      o = [];
     Ke(e, ({ node: e }, n) => {
      let s = r();
      n === i || (rt(e, t) ? ((a = !0), (s = [s, ',', pr, pr])) : (s = [s, ',', ur])), o.push(s);
     });
     let u = !t.parser.startsWith('__ng_') && 'ImportExpression' !== n.type && Le(t, 'all') ? ',' : '';
     function l() {
      return Yt(['(', Gt([ur, ...o]), u, ur, ')'], { shouldBreak: !0 });
     }
     if (
      a ||
      ('Decorator' !== e.parent.type &&
       (function (e) {
        if (e.length <= 1) return !1;
        let t = 0;
        for (let r of e)
         if (ue(r)) {
          if (((t += 1), t > 1)) return !0;
         } else if (be(r)) for (let e of Je(r)) if (ue(e)) return !0;
        return !1;
       })(s))
     )
      return l();
     if (
      (function (e) {
       if (2 !== e.length) return !1;
       let [t, r] = e;
       return (
        !(
         'ModuleExpression' !== t.type ||
         !(function (e) {
          return 'ObjectExpression' === e.type && 1 === e.properties.length && st(e.properties[0]) && 'Identifier' === e.properties[0].key.type && 'type' === e.properties[0].key.name && ne(e.properties[0].value) && 'module' === e.properties[0].value.value;
         })(r)
        ) ||
        (!et(t) && ('FunctionExpression' === t.type || ('ArrowFunctionExpression' === t.type && 'BlockStatement' === t.body.type)) && 'FunctionExpression' !== r.type && 'ArrowFunctionExpression' !== r.type && 'ConditionalExpression' !== r.type && ei(r) && !Zs(r))
       );
      })(s)
     ) {
      let e,
       t = o.slice(1);
      if (t.some(Ot)) return l();
      try {
       e = r(Ge(n, 0), { expandFirstArg: !0 });
      } catch (h) {
       if (h instanceof Qs) return l();
       throw h;
      }
      return Ot(e) ? [ar, er([['(', Yt(e, { shouldBreak: !0 }), ', ', ...t, ')'], l()])] : er([['(', e, ', ', ...t, ')'], ['(', Yt(e, { shouldBreak: !0 }), ', ', ...t, ')'], l()]);
     }
     if (
      (function (e, t, r) {
       var n, s;
       let i = c(!1, e, -1);
       if (1 === e.length) {
        let e = c(!1, t, -1);
        if (null != (n = e.label) && n.embed && !1 !== (null == (s = e.label) ? void 0 : s.hug)) return !0;
       }
       let a = c(!1, e, -2);
       return !et(i, Qe.Leading) && !et(i, Qe.Trailing) && Zs(i) && (!a || a.type !== i.type) && (2 !== e.length || 'ArrowFunctionExpression' !== a.type || !Z(i)) && !(e.length > 1 && Xi(i, r));
      })(s, o, t)
     ) {
      let e,
       t = o.slice(0, -1);
      if (t.some(Ot)) return l();
      try {
       e = r(Ge(n, -1), { expandLastArg: !0 });
      } catch (h) {
       if (h instanceof Qs) return l();
       throw h;
      }
      return Ot(e) ? [ar, er([['(', ...t, Yt(e, { shouldBreak: !0 }), ')'], l()])] : er([['(', ...t, e, ')'], ['(', ...t, Yt(e, { shouldBreak: !0 }), ')'], l()]);
     }
     let p = ['(', Gt([lr, ...o]), rr(u), lr, ')'];
     return Pe(e) ? p : Yt(p, { shouldBreak: o.some(Ot) || a });
    },
    ni = (e) => (('ChainExpression' === e.type || 'TSNonNullExpression' === e.type) && (e = e.expression), be(e) && Je(e).length > 0);
   function si(e, t, r) {
    let n = r('property'),
     { node: s } = e,
     i = ji(e);
    return s.computed ? (!s.property || te(s.property) ? [i, '[', n, ']'] : Yt([i, '[', Gt([lr, n]), lr, ']'])) : [i, '.', n];
   }
   var ii = function e(t, r, n) {
    if ('ChainExpression' === t.node.type) return t.call(() => e(t, r, n), 'expression');
    let { parent: s } = t,
     i = !s || 'ExpressionStatement' === s.type,
     a = [];
    function o(e) {
     let { originalText: t } = r,
      n = Er(t, L(e));
     return ')' === t.charAt(n) ? !1 !== n && w(t, n + 1) : rt(e, r);
    }
    let { node: u } = t;
    a.unshift({ node: u, printed: [ji(t), zi(t, r, n), ri(t, r, n)] }),
     u.callee &&
      t.call(function e() {
       let { node: s } = t;
       if ('ChainExpression' === s.type) return t.call(e, 'expression');
       if (be(s) && (fe(s.callee) || be(s.callee))) {
        let i = o(s);
        a.unshift({ node: s, hasTrailingEmptyLine: i, printed: [ws(t, [ji(t), zi(t, r, n), ri(t, r, n)], r), i ? pr : ''] }), t.call(e, 'callee');
       } else fe(s) ? (a.unshift({ node: s, needsParens: bs(t, r), printed: ws(t, ve(s) ? si(t, 0, n) : Vi(t, r, n), r) }), t.call(e, 'object')) : 'TSNonNullExpression' === s.type ? (a.unshift({ node: s, printed: ws(t, '!', r) }), t.call(e, 'expression')) : a.unshift({ node: s, printed: n() });
      }, 'callee');
    let l = [],
     p = [a[0]],
     h = 1;
    for (; h < a.length && ('TSNonNullExpression' === a[h].node.type || be(a[h].node) || (ve(a[h].node) && a[h].node.computed && te(a[h].node.property))); ++h) p.push(a[h]);
    if (!be(a[0].node)) for (; h + 1 < a.length && fe(a[h].node) && fe(a[h + 1].node); ++h) p.push(a[h]);
    l.push(p), (p = []);
    let d = !1;
    for (; h < a.length; ++h) {
     if (d && fe(a[h].node)) {
      if (a[h].node.computed && te(a[h].node.property)) {
       p.push(a[h]);
       continue;
      }
      l.push(p), (p = []), (d = !1);
     }
     (be(a[h].node) || 'ImportExpression' === a[h].node.type) && (d = !0), p.push(a[h]), et(a[h].node, Qe.Trailing) && (l.push(p), (p = []), (d = !1));
    }
    function f(e) {
     return /^[A-Z]|^[$_]+$/u.test(e);
    }
    p.length > 0 && l.push(p);
    let m =
     l.length >= 2 &&
     !et(l[1][0].node) &&
     (function (e) {
      var t;
      let n = null == (t = e[1][0]) ? void 0 : t.node.computed;
      if (1 === e[0].length) {
       let t = e[0][0].node;
       return (
        'ThisExpression' === t.type ||
        ('Identifier' === t.type &&
         (f(t.name) ||
          (i &&
           (function (e) {
            return e.length <= r.tabWidth;
           })(t.name)) ||
          n))
       );
      }
      let s = c(!1, e[0], -1).node;
      return ve(s) && 'Identifier' === s.property.type && (f(s.property.name) || n);
     })(l);
    function y(e) {
     let t = e.map((e) => e.printed);
     return e.length > 0 && c(!1, e, -1).needsParens ? ['(', ...t, ')'] : t;
    }
    let g = l.map(y),
     D = g,
     x = m ? 3 : 2,
     b = l.flat(),
     v = b.slice(1, -1).some((e) => et(e.node, Qe.Leading)) || b.slice(0, -1).some((e) => et(e.node, Qe.Trailing)) || (l[x] && et(l[x][0].node, Qe.Leading));
    if (l.length <= x && !v && !l.some((e) => c(!1, e, -1).hasTrailingEmptyLine)) return Pe(t) ? D : Yt(D);
    let E = c(!1, l[m ? 1 : 0], -1).node,
     C = !be(E) && o(E),
     T = [y(l[0]), m ? l.slice(1, 2).map(y) : '', C ? pr : '', ((A = l.slice(m ? 2 : 1)), 0 === A.length ? '' : Gt([pr, dr(pr, A.map(y))]))],
     S = a.map(({ node: e }) => e).filter(be);
    var A;
    let F;
    return (
     (F =
      v ||
      (S.length > 2 && S.some((e) => !e.arguments.every((e) => Ne(e)))) ||
      g.slice(0, -1).some(Ot) ||
      (function () {
       let e = c(!1, c(!1, l, -1), -1).node,
        t = c(!1, g, -1);
       return be(e) && Ot(t) && S.slice(0, -1).some((e) => e.arguments.some(ue));
      })()
       ? Yt(T)
       : [Ot(D) || C ? ar : '', er([D, T])]),
     fr({ memberChain: !0 }, F)
    );
   };
   function ai(e, t, r) {
    var n;
    let { node: s } = e,
     i = 'NewExpression' === s.type,
     a = 'ImportExpression' === s.type,
     o = ji(e),
     u = Je(s),
     l = 1 === u.length && Fe(u[0], t.originalText);
    if (
     l ||
     (function (e) {
      let { node: t } = e;
      if ('CallExpression' !== t.type || t.optional || 'Identifier' !== t.callee.type) return !1;
      let r = Je(t);
      return 'require' === t.callee.name ? (1 === r.length && ne(r[0])) || r.length > 1 : 'define' === t.callee.name && 'ExpressionStatement' === e.parent.type && (1 === r.length || (2 === r.length && 'ArrayExpression' === r[0].type) || (3 === r.length && ne(r[0]) && 'ArrayExpression' === r[1].type));
     })(e) ||
     De(s, e.parent)
    ) {
     let s = [];
     if (
      (Ke(e, () => {
       s.push(r());
      }),
      !l || null == (n = s[0].label) || !n.embed)
     )
      return [i ? 'new ' : '', oi(e, r), o, zi(e, t, r), '(', dr(', ', s), ')'];
    }
    if (!a && !i && fe(s.callee) && !e.call((e) => bs(e, t), 'callee', ...('ChainExpression' === s.callee.type ? ['expression'] : []))) return ii(e, t, r);
    let p = [i ? 'new ' : '', oi(e, r), o, zi(e, t, r), ri(e, t, r)];
    return a || be(s.callee) ? Yt(p) : p;
   }
   function oi(e, t) {
    let { node: r } = e;
    return 'ImportExpression' === r.type ? 'import' + (r.phase ? `.${r.phase}` : '') : t('callee');
   }
   function ui(e, t, r, n, s, i) {
    let a = (function (e, t, r, n, s) {
      let { node: i } = e,
       a = i[s];
      if (!a) return 'only-left';
      let o = !li(a);
      if (e.match(li, pi, (e) => !o || ('ExpressionStatement' !== e.type && 'VariableDeclaration' !== e.type))) return o ? ('ArrowFunctionExpression' === a.type && 'ArrowFunctionExpression' === a.body.type ? 'chain-tail-arrow-chain' : 'chain-tail') : 'chain';
      if ((!o && li(a.right)) || we(t.originalText, a)) return 'break-after-operator';
      if ('ImportAttribute' === i.type || ('CallExpression' === a.type && 'require' === a.callee.name) || 'json5' === t.parser || 'jsonc' === t.parser || 'json' === t.parser) return 'never-break-after-operator';
      let u = (function (e) {
       return _t(e, $t, !1);
      })(n);
      if (
       (function (e) {
        if (pi(e)) {
         let t = e.left || e.id;
         return (
          'ObjectPattern' === t.type &&
          t.properties.length > 2 &&
          t.properties.some((e) => {
           var t;
           return st(e) && (!e.shorthand || 'AssignmentPattern' === (null == (t = e.value) ? void 0 : t.type));
          })
         );
        }
        return !1;
       })(i) ||
       (function (e) {
        if ('VariableDeclarator' !== e.type) return !1;
        let { typeAnnotation: t } = e.id;
        if (!t || !t.typeAnnotation) return !1;
        let r = fi(t.typeAnnotation);
        return A(r) && r.length > 1 && r.some((e) => A(fi(e)) || 'TSConditionalType' === e.type);
       })(i) ||
       (hi(i) && u)
      )
       return 'break-lhs';
      let l = (function (e, t, r) {
       return !!st(e) && ((t = qt(t)), 'string' == typeof t && g(t) < r.tabWidth + 3);
      })(i, n, t);
      return e.call(
       () =>
        (function (e, t, r, n) {
         let s = e.node;
         if (de(s) && !Hs(s)) return !0;
         switch (s.type) {
          case 'StringLiteralTypeAnnotation':
          case 'SequenceExpression':
           return !0;
          case 'TSConditionalType':
          case 'ConditionalTypeAnnotation':
           if (
            !t.experimentalTernaries &&
            !(function (e) {
             function t(e) {
              switch (e.type) {
               case 'FunctionTypeAnnotation':
               case 'GenericTypeAnnotation':
               case 'TSFunctionType':
                return !!e.typeParameters;
               case 'TSTypeReference':
                return !!(e.typeArguments ?? e.typeParameters);
               default:
                return !1;
              }
             }
             return t(e.checkType) || t(e.extendsType);
            })(s)
           )
            break;
           return !0;
          case 'ConditionalExpression': {
           if (!t.experimentalTernaries) {
            let { test: e } = s;
            return de(e) && !Hs(e);
           }
           let { consequent: e, alternate: r } = s;
           return 'ConditionalExpression' === e.type || 'ConditionalExpression' === r.type;
          }
          case 'ClassExpression':
           return A(s.decorators);
         }
         if (n) return !1;
         let i = s,
          a = [];
         for (;;)
          if ('UnaryExpression' === i.type || 'AwaitExpression' === i.type || ('YieldExpression' === i.type && null !== i.argument)) (i = i.argument), a.push('argument');
          else {
           if ('TSNonNullExpression' !== i.type) break;
           (i = i.expression), a.push('expression');
          }
         return !(!ne(i) && !e.call(() => mi(e, t, r), ...a));
        })(e, t, r, l),
       s,
      )
       ? 'break-after-operator'
       : (function (e) {
            let t = (function (e) {
             var t;
             if (ci(e)) return null == (t = e.typeParameters) ? void 0 : t.params;
            })(e);
            if (A(t)) {
             let r = 'TSTypeAliasDeclaration' === e.type ? 'constraint' : 'bound';
             if (t.length > 1 && t.some((e) => e[r] || e.default)) return !0;
            }
            return !1;
           })(i)
         ? 'break-lhs'
         : u || (!l && 'TemplateLiteral' !== a.type && 'TaggedTemplateExpression' !== a.type && 'BooleanLiteral' !== a.type && !te(a) && 'ClassExpression' !== a.type)
           ? 'fluid'
           : 'never-break-after-operator';
     })(e, t, r, n, i),
     o = i ? r(i, { assignmentLayout: a }) : '';
    switch (a) {
     case 'break-after-operator':
      return Yt([Yt(n), s, Yt(Gt([ur, o]))]);
     case 'never-break-after-operator':
      return Yt([Yt(n), s, ' ', o]);
     case 'fluid': {
      let e = Symbol('assignment');
      return Yt([Yt(n), s, Yt(Gt(ur), { id: e }), ir, nr(o, { groupId: e })]);
     }
     case 'break-lhs':
      return Yt([n, s, ' ', Yt(o)]);
     case 'chain':
      return [Yt(n), s, ur, o];
     case 'chain-tail':
      return [Yt(n), s, Gt([ur, o])];
     case 'chain-tail-arrow-chain':
      return [Yt(n), s, o];
     case 'only-left':
      return n;
    }
   }
   function li(e) {
    return 'AssignmentExpression' === e.type;
   }
   function pi(e) {
    return li(e) || 'VariableDeclarator' === e.type;
   }
   var ci = $(['TSTypeAliasDeclaration', 'TypeAlias']);
   function hi(e) {
    var t;
    return 'VariableDeclarator' === e.type && 'ArrowFunctionExpression' === (null == (t = e.init) ? void 0 : t.type);
   }
   var di = $(['TSTypeReference', 'GenericTypeAnnotation']);
   function fi(e) {
    var t;
    if (di(e)) return null == (t = e.typeArguments ?? e.typeParameters) ? void 0 : t.params;
   }
   function mi(e, t, r, n = !1) {
    var s;
    let { node: i } = e,
     a = () => mi(e, t, r, !0);
    if ('ChainExpression' === i.type || 'TSNonNullExpression' === i.type) return e.call(a, 'expression');
    if (be(i)) {
     if (null != (s = ai(e, t, r).label) && s.memberChain) return !1;
     let n = Je(i);
     return (
      !(
       !(0 === n.length || (1 === n.length && Se(n[0], t))) ||
       (function (e, t) {
        let r = (function (e) {
         var t;
         return null == (t = e.typeParameters ?? e.typeArguments) ? void 0 : t.params;
        })(e);
        if (A(r)) {
         if (r.length > 1) return !0;
         if (1 === r.length) {
          let e = r[0];
          if (at(e) || ot(e) || 'TSTypeLiteral' === e.type || 'ObjectTypeAnnotation' === e.type) return !0;
         }
         if (Ot(t(e.typeParameters ? 'typeParameters' : 'typeArguments'))) return !0;
        }
        return !1;
       })(i, r)
      ) && e.call(a, 'callee')
     );
    }
    return ve(i) ? e.call(a, 'object') : n && ('Identifier' === i.type || 'ThisExpression' === i.type);
   }
   function yi(e, t, r, n, s) {
    let i = e.node,
     a = Ve(i),
     o = s ? zi(e, r, t) : '';
    if (0 === a.length) return [o, '(', Ts(e, r, { filter: (e) => ')' === Cr(r.originalText, L(e)) }), ')'];
    let { parent: u } = e,
     l = De(u),
     p = gi(i),
     c = [];
    if (
     ((function (e, t) {
      let { node: r } = e,
       n = 0,
       s = (e) => t(e, n++);
      r.this && e.call(s, 'this'), Array.isArray(r.parameters) ? e.each(s, 'parameters') : Array.isArray(r.params) && e.each(s, 'params'), r.rest && e.call(s, 'rest');
     })(e, (e, n) => {
      let s = n === a.length - 1;
      s && i.rest && c.push('...'), c.push(t()), !s && (c.push(','), l || p ? c.push(' ') : rt(a[n], r) ? c.push(pr, pr) : c.push(ur));
     }),
     n &&
      !(function (e) {
       return e.match(
        (e) => 'ArrowFunctionExpression' === e.type && 'BlockStatement' === e.body.type,
        (e, t) => {
         if ('CallExpression' === e.type && 'arguments' === t && 1 === e.arguments.length && 'CallExpression' === e.callee.type) {
          let t = e.callee.callee;
          return 'Identifier' === t.type || ('MemberExpression' === t.type && !t.computed && 'Identifier' === t.object.type && 'Identifier' === t.property.type);
         }
         return !1;
        },
        (e, t) => ('VariableDeclarator' === e.type && 'init' === t) || ('ExportDefaultDeclaration' === e.type && 'declaration' === t) || ('TSExportAssignment' === e.type && 'expression' === t) || ('AssignmentExpression' === e.type && 'right' === t && 'MemberExpression' === e.left.type && 'Identifier' === e.left.object.type && 'module' === e.left.object.name && 'Identifier' === e.left.property.type && 'exports' === e.left.property.name),
        (e) => 'VariableDeclaration' !== e.type || ('const' === e.kind && 1 === e.declarations.length),
       );
      })(e))
    ) {
     if (Ot(o) || Ot(c)) throw new Qs();
     return Yt([Rt(o), '(', Rt(c), ')']);
    }
    let h = a.every((e) => !A(e.decorators));
    return (p && h) || l
     ? [o, '(', ...c, ')']
     : (he(u) ||
          (function (e) {
           return !(('TypeAnnotation' !== e.type && 'TSTypeAnnotation' !== e.type) || 'FunctionTypeAnnotation' !== e.typeAnnotation.type || e.static || O(e, e.typeAnnotation));
          })(u) ||
          'TypeAlias' === u.type ||
          'UnionTypeAnnotation' === u.type ||
          'IntersectionTypeAnnotation' === u.type ||
          ('FunctionTypeAnnotation' === u.type && u.returnType === i)) &&
         1 === a.length &&
         null === a[0].name &&
         i.this !== a[0] &&
         a[0].typeAnnotation &&
         null === i.typeParameters &&
         ye(a[0].typeAnnotation) &&
         !i.rest
       ? 'always' === r.arrowParens || 'HookTypeAnnotation' === i.type
         ? ['(', ...c, ')']
         : c
       : [o, '(', Gt([lr, ...c]), rr(!He(i) && Le(r, 'all') ? ',' : ''), lr, ')'];
   }
   function gi(e) {
    if (!e) return !1;
    let t = Ve(e);
    if (1 !== t.length) return !1;
    let [r] = t;
    return !et(r) && ('ObjectPattern' === r.type || 'ArrayPattern' === r.type || ('Identifier' === r.type && r.typeAnnotation && ('TypeAnnotation' === r.typeAnnotation.type || 'TSTypeAnnotation' === r.typeAnnotation.type) && oe(r.typeAnnotation.typeAnnotation)) || ('FunctionTypeParam' === r.type && oe(r.typeAnnotation) && r !== e.rest) || ('AssignmentPattern' === r.type && ('ObjectPattern' === r.left.type || 'ArrayPattern' === r.left.type) && ('Identifier' === r.right.type || (ee(r.right) && 0 === r.right.properties.length) || (Z(r.right) && 0 === r.right.elements.length))));
   }
   function Di(e, t) {
    var r;
    let n = (function (e) {
     let t;
     return e.returnType ? ((t = e.returnType), t.typeAnnotation && (t = t.typeAnnotation)) : e.typeAnnotation && (t = e.typeAnnotation), t;
    })(e);
    if (!n) return !1;
    let s = null == (r = e.typeParameters) ? void 0 : r.params;
    if (s) {
     if (s.length > 1) return !1;
     if (1 === s.length) {
      let e = s[0];
      if (e.constraint || e.default) return !1;
     }
    }
    return 1 === Ve(e).length && (oe(n) || Ot(t));
   }
   var xi = $(['VoidTypeAnnotation', 'TSVoidKeyword', 'NullLiteralTypeAnnotation', 'TSNullKeyword']),
    bi = $(['ObjectTypeAnnotation', 'TSTypeLiteral', 'GenericTypeAnnotation', 'TSTypeReference']);
   function vi(e) {
    return (
     !(!ye(e) && !oe(e)) ||
     (!!at(e) &&
      (function (e) {
       let { types: t } = e;
       if (t.some((e) => et(e))) return !1;
       let r = t.find((e) => bi(e));
       return !!r && t.every((e) => e === r || xi(e));
      })(e))
    );
   }
   function Ei(e, t, r) {
    let n = t.semi ? ';' : '',
     { node: s } = e,
     i = [Ui(e)];
    return i.push('type ', r('id'), r('typeParameters')), [ui(e, t, r, i, ' =', 'TSTypeAliasDeclaration' === s.type ? 'typeAnnotation' : 'right'), n];
   }
   function Ci(e, t, r) {
    let n = !1;
    return Yt(
     e.map(({ isFirst: e, previous: s, node: i, index: a }) => {
      let o = r();
      if (e) return o;
      let u = oe(i),
       l = oe(s);
      return l && u ? [' & ', n ? Gt(o) : o] : l || u ? (a > 1 && (n = !0), [' & ', a > 1 ? Gt(o) : o]) : 'start' === t.experimentalOperatorPosition ? Gt([ur, '& ', o]) : Gt([' &', ur, o]);
     }, 'types'),
    );
   }
   function Ti(e, t, r) {
    let { node: n } = e,
     { parent: s } = e,
     i = !('TypeParameterInstantiation' === s.type || ('TSConditionalType' === s.type && t.experimentalTernaries) || ('ConditionalTypeAnnotation' === s.type && t.experimentalTernaries) || 'TSTypeParameterInstantiation' === s.type || 'GenericTypeAnnotation' === s.type || 'TSTypeReference' === s.type || 'TSTypeAssertion' === s.type || 'TupleTypeAnnotation' === s.type || 'TSTupleType' === s.type || ('FunctionTypeParam' === s.type && !s.name && e.grandparent.this !== s) || (('TypeAlias' === s.type || 'VariableDeclarator' === s.type || 'TSTypeAliasDeclaration' === s.type) && we(t.originalText, n))),
     a = vi(n),
     o = e.map((e) => {
      let n = r();
      return a || (n = Xt(2, n)), ws(e, n, t);
     }, 'types');
    if (a) return dr(' | ', o);
    let u = [rr([i && !we(t.originalText, n) ? ur : '', '| ']), dr([ur, '| '], o)];
    return bs(e, t) ? Yt([Gt(u), lr]) : ('TupleTypeAnnotation' === s.type || 'TSTupleType' === s.type) && s['TupleTypeAnnotation' === s.type && s.types ? 'types' : 'elementTypes'].length > 1 ? Yt([Gt([rr(['(', lr]), u]), lr, rr(')')]) : Yt(i ? Gt(u) : u);
   }
   function Si(e, t, r) {
    let { node: n } = e,
     s = [Hi(e)];
    ('TSConstructorType' === n.type || 'TSConstructSignatureDeclaration' === n.type) && s.push('new ');
    let i = yi(e, r, t, !1, !0),
     a = [];
    return (
     'FunctionTypeAnnotation' === n.type
      ? a.push(
         (function (e) {
          var t;
          let { node: r, parent: n } = e;
          return 'FunctionTypeAnnotation' === r.type && (he(n) || !((('ObjectTypeProperty' === n.type || 'ObjectTypeInternalSlot' === n.type) && !n.variance && !n.optional && O(n, r)) || 'ObjectTypeCallProperty' === n.type || 'DeclareFunction' === (null == (t = e.getParentNode(2)) ? void 0 : t.type)));
         })(e)
          ? ' => '
          : ': ',
         r('returnType'),
        )
      : a.push(Ni(e, r, n.returnType ? 'returnType' : 'typeAnnotation')),
     Di(n, a) && (i = Yt(i)),
     s.push(i, a),
     Yt(s)
    );
   }
   function wi(e, t, r) {
    return [r('objectType'), ji(e), '[', r('indexType'), ']'];
   }
   function Ai(e, t, r) {
    return ['infer ', r('typeParameter')];
   }
   function Fi(e, t, r) {
    let { node: n } = e;
    return [n.postfix ? '' : r, Ni(e, t), n.postfix ? r : ''];
   }
   function ki(e, t, r) {
    let { node: n } = e;
    return ['...', ...('TupleTypeSpreadElement' === n.type && n.label ? [r('label'), ': '] : []), r('typeAnnotation')];
   }
   function Pi(e, t, r) {
    let { node: n } = e;
    return [n.variance ? r('variance') : '', r('label'), n.optional ? '?' : '', ': ', r('elementType')];
   }
   var Ii = new WeakSet();
   function Ni(e, t, r = 'typeAnnotation') {
    let {
     node: { [r]: n },
    } = e;
    if (!n) return '';
    let s = !1;
    if ('TSTypeAnnotation' === n.type || 'TypeAnnotation' === n.type) {
     let t = e.call(Bi, r);
     ('=>' === t || (':' === t && et(n, Qe.Leading))) && (s = !0), Ii.add(n);
    }
    return s ? [' ', t(r)] : t(r);
   }
   var Bi = (e) =>
    e.match(
     (e) => 'TSTypeAnnotation' === e.type,
     (e, t) => !(('returnType' !== t && 'typeAnnotation' !== t) || ('TSFunctionType' !== e.type && 'TSConstructorType' !== e.type)),
    )
     ? '=>'
     : e.match(
          (e) => 'TSTypeAnnotation' === e.type,
          (e, t) => 'typeAnnotation' === t && ('TSJSDocNullableType' === e.type || 'TSJSDocNonNullableType' === e.type || 'TSTypePredicate' === e.type),
         ) ||
         e.match(
          (e) => 'TypeAnnotation' === e.type,
          (e, t) => 'typeAnnotation' === t && 'Identifier' === e.type,
          (e, t) => 'id' === t && 'DeclareFunction' === e.type,
         ) ||
         e.match(
          (e) => 'TypeAnnotation' === e.type,
          (e, t) => 'typeAnnotation' === t && 'Identifier' === e.type,
          (e, t) => 'id' === t && 'DeclareHook' === e.type,
         ) ||
         e.match(
          (e) => 'TypeAnnotation' === e.type,
          (e, t) => 'bound' === t && 'TypeParameter' === e.type && e.usesExtendsBound,
         )
       ? ''
       : ':';
   function _i(e, t, r) {
    let n = Bi(e);
    return n ? [n, ' ', r('typeAnnotation')] : r('typeAnnotation');
   }
   function Li(e) {
    return [e('elementType'), '[]'];
   }
   function Oi({ node: e }, t) {
    let r = 'TSTypeQuery' === e.type ? 'exprName' : 'argument',
     n = 'TypeofTypeAnnotation' === e.type || e.typeArguments ? 'typeArguments' : 'typeParameters';
    return ['typeof ', t(r), t(n)];
   }
   function Mi(e, t) {
    let { node: r } = e;
    return ['TSTypePredicate' === r.type && r.asserts ? 'asserts ' : 'TypePredicate' === r.type && r.kind ? `${r.kind} ` : '', t('parameterName'), r.typeAnnotation ? [' is ', Ni(e, t)] : ''];
   }
   function ji(e) {
    let { node: t } = e;
    return !t.optional || ('Identifier' === t.type && t === e.parent.key) ? '' : be(t) || (ve(t) && t.computed) || 'OptionalIndexedAccessType' === t.type ? '?.' : '?';
   }
   function Ri(e) {
    return e.node.definite || e.match(void 0, (e, t) => 'id' === t && 'VariableDeclarator' === e.type && e.definite) ? '!' : '';
   }
   var qi = new Set(['DeclareClass', 'DeclareComponent', 'DeclareFunction', 'DeclareHook', 'DeclareVariable', 'DeclareExportDeclaration', 'DeclareExportAllDeclaration', 'DeclareOpaqueType', 'DeclareTypeAlias', 'DeclareEnum', 'DeclareInterface']);
   function Ui(e) {
    let { node: t } = e;
    return t.declare || (qi.has(t.type) && 'DeclareExportDeclaration' !== e.parent.type) ? 'declare ' : '';
   }
   var $i = new Set(['TSAbstractMethodDefinition', 'TSAbstractPropertyDefinition', 'TSAbstractAccessorProperty']);
   function Hi({ node: e }) {
    return e.abstract || $i.has(e.type) ? 'abstract ' : '';
   }
   function zi(e, t, r) {
    let n = e.node;
    return n.typeArguments ? r('typeArguments') : n.typeParameters ? r('typeParameters') : '';
   }
   function Vi(e, t, r) {
    return ['::', r('callee')];
   }
   function Wi(e, t, r) {
    return 'EmptyStatement' === e.type ? ';' : 'BlockStatement' === e.type || r ? [' ', t] : Gt([ur, t]);
   }
   function Ji(e, t) {
    return ['...', t('argument'), Ni(e, t)];
   }
   function Ki(e) {
    return e.accessibility ? e.accessibility + ' ' : '';
   }
   function Gi(e, t, r) {
    let { node: n } = e,
     s = [],
     i = 'TupleExpression' === n.type ? '#[' : '[',
     a = 'TupleTypeAnnotation' === n.type && n.types ? 'types' : 'TSTupleType' === n.type || 'TupleTypeAnnotation' === n.type ? 'elementTypes' : 'elements',
     o = n[a];
    if (0 === o.length)
     s.push(
      (function (e, t, r, n) {
       let { node: s } = e,
        i = s.inexact ? '...' : '';
       return et(s, Qe.Dangling) ? Yt([r, i, Ts(e, t, { indent: !0 }), lr, n]) : [r, i, n];
      })(e, t, i, ']'),
     );
    else {
     let u = c(!1, o, -1),
      l = 'RestElement' !== (null == u ? void 0 : u.type) && !n.inexact,
      p = null === u,
      h = Symbol('array'),
      d =
       !t.__inJestEach &&
       o.length > 1 &&
       o.every((e, t, r) => {
        let n = null == e ? void 0 : e.type;
        if (!Z(e) && !ee(e)) return !1;
        let s = r[t + 1];
        if (s && n !== s.type) return !1;
        let i = Z(e) ? 'elements' : 'properties';
        return e[i] && e[i].length > 1;
       }),
      f = Xi(n, t),
      m = l ? (p ? ',' : Le(t) ? (f ? rr(',', '', { groupId: h }) : rr(',')) : '') : '';
     s.push(Yt([i, Gt([lr, f ? Zi(e, t, r, m) : [Qi(e, t, a, n.inexact, r), m], Ts(e, t)]), lr, ']'], { shouldBreak: d, id: h }));
    }
    return s.push(ji(e), Ni(e, r)), s;
   }
   function Xi(e, t) {
    return Z(e) && e.elements.length > 1 && e.elements.every((e) => e && (te(e) || (re(e) && !et(e.argument))) && !et(e, Qe.Trailing | Qe.Line, (e) => !C(t.originalText, _(e), { backwards: !0 })));
   }
   function Yi({ node: e }, { originalText: t }) {
    let r = (e) => (',' === t[e] ? e : r(((e) => T(t, S(t, e)))(e + 1)));
    return w(t, r(L(e)));
   }
   function Qi(e, t, r, n, s) {
    let i = [];
    return (
     e.each(({ node: r, isLast: a }) => {
      i.push(r ? Yt(s()) : ''), (!a || n) && i.push([',', ur, r && Yi(e, t) ? lr : '']);
     }, r),
     n && i.push('...'),
     i
    );
   }
   function Zi(e, t, r, n) {
    let s = [];
    return (
     e.each(({ isLast: i, next: a }) => {
      s.push([r(), i ? n : ',']), i || s.push(Yi(e, t) ? [pr, pr] : et(a, Qe.Leading | Qe.Line) ? pr : ur);
     }, 'elements'),
     tr(s)
    );
   }
   var ea = /^[\$A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC][\$0-9A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]*$/,
    ta = (e) => ea.test(e);
   var ra = function (e) {
     return 1 === e.length
      ? e
      : e
         .toLowerCase()
         .replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(?=\d)/u, '$1$2')
         .replace(/^([+-]?[\d.]+)e[+-]?0+$/u, '$1')
         .replace(/^([+-])?\./u, '$10.')
         .replace(/(\.\d+?)0+(?=e|$)/u, '$1')
         .replace(/\.(?=e|$)/u, '');
    },
    na = new WeakMap();
   function sa(e) {
    return /^(?:\d+|\d+\.\d+)$/u.test(e);
   }
   function ia(e, t) {
    return !('json' === t.parser || 'jsonc' === t.parser || !ne(e.key) || B(Be(e.key), t).slice(1, -1) !== e.key.value) && !!((ta(e.key.value) && !(('babel-ts' === t.parser && 'ClassProperty' === e.type) || ('typescript' === t.parser && 'PropertyDefinition' === e.type))) || (sa(e.key.value) && String(Number(e.key.value)) === e.key.value && 'ImportAttribute' !== e.type && ('babel' === t.parser || 'acorn' === t.parser || 'espree' === t.parser || 'meriyah' === t.parser || '__babel_estree' === t.parser)));
   }
   function aa(e, t, r) {
    let { node: n } = e;
    if (n.computed) return ['[', r('key'), ']'];
    let { parent: s } = e,
     { key: i } = n;
    if ('consistent' === t.quoteProps && !na.has(s)) {
     let r = e.siblings.some((e) => !e.computed && ne(e.key) && !ia(e, t));
     na.set(s, r);
    }
    if (
     (function (e, t) {
      let { key: r } = e.node;
      return ('Identifier' === r.type || (te(r) && sa(ra(Be(r))) && String(r.value) === ra(Be(r)) && !('typescript' === t.parser || 'babel-ts' === t.parser))) && ('json' === t.parser || 'jsonc' === t.parser || ('consistent' === t.quoteProps && na.get(e.parent)));
     })(e, t)
    ) {
     let r = B(JSON.stringify('Identifier' === i.type ? i.name : i.value.toString()), t);
     return e.call((e) => ws(e, r, t), 'key');
    }
    return ia(n, t) && ('as-needed' === t.quoteProps || ('consistent' === t.quoteProps && !na.get(s))) ? e.call((e) => ws(e, /^\d/u.test(i.value) ? ra(i.value) : i.value, t), 'key') : r('key');
   }
   function oa(e, t, r) {
    let { node: n } = e;
    return n.shorthand ? r('value') : ui(e, t, r, aa(e, t, r), ':', 'value');
   }
   var ua = ({ node: e, key: t, parent: r }) => 'value' === t && 'FunctionExpression' === e.type && ('ObjectMethod' === r.type || 'ClassMethod' === r.type || 'ClassPrivateMethod' === r.type || 'MethodDefinition' === r.type || 'TSAbstractMethodDefinition' === r.type || 'TSDeclareMethod' === r.type || ('Property' === r.type && ce(r)));
   function la(e, t, r, n) {
    if (ua(e)) return ca(e, r, t);
    let { node: s } = e,
     i = !1;
    if (('FunctionDeclaration' === s.type || 'FunctionExpression' === s.type) && null != n && n.expandLastArg) {
     let { parent: t } = e;
     be(t) && (Je(t).length > 1 || Ve(s).every((e) => 'Identifier' === e.type && !e.typeAnnotation)) && (i = !0);
    }
    let a = [Ui(e), s.async ? 'async ' : '', `function${s.generator ? '*' : ''} `, s.id ? t('id') : ''],
     o = yi(e, t, r, i),
     u = da(e, t),
     l = Di(s, u);
    return a.push(zi(e, 0, t), Yt([l ? Yt(o) : o, u]), s.body ? ' ' : '', t('body')), r.semi && (s.declare || !s.body) && a.push(';'), a;
   }
   function pa(e, t, r) {
    let { node: n } = e,
     { kind: s } = n,
     i = n.value || n,
     a = [];
    return s && 'init' !== s && 'method' !== s && 'constructor' !== s ? (k.ok('get' === s || 'set' === s), a.push(s, ' ')) : i.async && a.push('async '), i.generator && a.push('*'), a.push(aa(e, t, r), n.optional || n.key.optional ? '?' : '', n === i ? ca(e, t, r) : r('value')), a;
   }
   function ca(e, t, r) {
    let { node: n } = e,
     s = yi(e, r, t),
     i = da(e, r),
     a = (function (e) {
      let t = Ve(e);
      return t.length > 1 && t.some((e) => 'TSParameterProperty' === e.type);
     })(n),
     o = Di(n, i),
     u = [zi(e, 0, r), Yt([a ? Yt(s, { shouldBreak: !0 }) : o ? Yt(s) : s, i])];
    return n.body ? u.push(' ', r('body')) : u.push(t.semi ? ';' : ''), u;
   }
   function ha(e, t) {
    if ('always' === t.arrowParens) return !1;
    if ('avoid' === t.arrowParens) {
     let { node: t } = e;
     return (function (e) {
      let t = Ve(e);
      return !(1 !== t.length || e.typeParameters || et(e, Qe.Dangling) || 'Identifier' !== t[0].type || t[0].typeAnnotation || et(t[0]) || t[0].optional || e.predicate || e.returnType);
     })(t);
    }
    return !1;
   }
   function da(e, t) {
    let { node: r } = e,
     n = [Ni(e, t, 'returnType')];
    return r.predicate && n.push(t('predicate')), n;
   }
   function fa(e, t, r) {
    let { node: n } = e,
     s = t.semi ? ';' : '',
     i = [];
    if (n.argument) {
     let e = r('argument');
     !(function (e, t) {
      if (we(e.originalText, t) || (et(t, Qe.Leading, (t) => Tr(e.originalText, _(t), L(t))) && !pe(t))) return !0;
      if (K(t)) {
       let r,
        n = t;
       for (; (r = G(n)); ) if (((n = r), we(e.originalText, n))) return !0;
      }
      return !1;
     })(t, n.argument)
      ? (de(n.argument) || 'SequenceExpression' === n.argument.type || (t.experimentalTernaries && 'ConditionalExpression' === n.argument.type && ('ConditionalExpression' === n.argument.consequent.type || 'ConditionalExpression' === n.argument.alternate.type))) && (e = Yt([rr('('), Gt([lr, e]), lr, rr(')')]))
      : (e = ['(', Gt([pr, e]), pr, ')']),
      i.push(' ', e);
    }
    let a = et(n, Qe.Dangling),
     o = s && a && et(n, Qe.Last | Qe.Line);
    return o && i.push(s), a && i.push(' ', Ts(e, t)), o || i.push(s), i;
   }
   var ma = new WeakMap();
   function ya(e) {
    return ma.has(e) || ma.set(e, 'ConditionalExpression' === e.type && !Oe(e, (e) => 'ObjectExpression' === e.type)), ma.get(e);
   }
   var ga = (e) => 'SequenceExpression' === e.type;
   function Da(e, t, r, n = {}) {
    let s,
     i,
     a = [],
     o = [],
     u = !1,
     l = !n.expandLastArg && 'ArrowFunctionExpression' === e.node.body.type;
    !(function p() {
     let { node: c } = e,
      h = (function (e, t, r, n) {
       let { node: s } = e,
        i = [];
       if ((s.async && i.push('async '), ha(e, t))) i.push(r(['params', 0]));
       else {
        let s = n.expandLastArg || n.expandFirstArg,
         a = da(e, r);
        if (s) {
         if (Ot(a)) throw new Qs();
         a = Yt(Rt(a));
        }
        i.push(Yt([yi(e, r, t, s, !0), a]));
       }
       let a = Ts(e, t, {
        filter(e) {
         let r = Er(t.originalText, L(e));
         return !1 !== r && '=>' === t.originalText.slice(r, r + 2);
        },
       });
       return a && i.push(' ', a), i;
      })(e, t, r, n);
     if (0 === a.length) a.push(h);
     else {
      let { leading: r, trailing: n } = Ss(e, t);
      a.push([r, h]), o.unshift(n);
     }
     l && (u || (u = (c.returnType && Ve(c).length > 0) || c.typeParameters || Ve(c).some((e) => 'Identifier' !== e.type))), l && 'ArrowFunctionExpression' === c.body.type ? e.call(p, 'body') : ((s = r('body', n)), (i = c.body));
    })();
    let p =
      !we(t.originalText, i) &&
      (ga(i) ||
       (function (e, t, r) {
        var n, s;
        return Z(e) || ee(e) || 'ArrowFunctionExpression' === e.type || 'DoExpression' === e.type || 'BlockStatement' === e.type || pe(e) || (!1 !== (null == (n = t.label) ? void 0 : n.hug) && ((null == (s = t.label) ? void 0 : s.embed) || Fe(e, r.originalText)));
       })(i, s, t) ||
       (!u && ya(i))),
     c = 'callee' === e.key && nt(e.parent),
     h = Symbol('arrow-chain'),
     d = (function (e, t, { signatureDocs: r, shouldBreak: n }) {
      if (1 === r.length) return r[0];
      let { parent: s, key: i } = e;
      return ('callee' !== i && nt(s)) || de(s) ? Yt([r[0], ' =>', Gt([ur, dr([' =>', ur], r.slice(1))])], { shouldBreak: n }) : ('callee' === i && nt(s)) || t.assignmentLayout ? Yt(dr([' =>', ur], r), { shouldBreak: n }) : Yt(Gt(dr([' =>', ur], r)), { shouldBreak: n });
     })(e, n, { signatureDocs: a, shouldBreak: u }),
     f = !1,
     m = !1,
     y = !1;
    return (
     l && (c || n.assignmentLayout) && ((m = !0), (y = !et(e.node, Qe.Leading & Qe.Line)), (f = 'chain-tail-arrow-chain' === n.assignmentLayout || (c && !p))),
     (s = (function (e, t, r, { bodyDoc: n, bodyComments: s, functionBody: i, shouldPutBodyOnSameLine: a }) {
      let { node: o, parent: u } = e,
       l = r.expandLastArg && Le(t, 'all') ? rr(',') : '',
       p = (!r.expandLastArg && 'JSXExpressionContainer' !== u.type) || et(o) ? '' : lr;
      return a && ya(i) ? [' ', Yt([rr('', '('), Gt([lr, n]), rr('', ')'), l, p]), s] : (ga(i) && (n = Yt(['(', Gt([lr, n]), lr, ')'])), a ? [' ', n, s] : [Gt([ur, n, s]), l, p]);
     })(e, t, n, { bodyDoc: s, bodyComments: o, functionBody: i, shouldPutBodyOnSameLine: p })),
     Yt([Yt(m ? Gt([y ? lr : '', d]) : d, { shouldBreak: f, id: h }), ' =>', l ? nr(s, { groupId: h }) : Yt(s), l && c ? rr(lr, '', { groupId: h }) : ''])
    );
   }
   var xa = (e, t, r) => {
    if (!e || null != t) {
     if (t.findLast) return t.findLast(r);
     for (let e = t.length - 1; e >= 0; e--) {
      let n = t[e];
      if (r(n, e, t)) return n;
     }
    }
   };
   function ba(e, t, r, n) {
    let { node: s } = e,
     i = [],
     a = xa(!1, s[n], (e) => 'EmptyStatement' !== e.type);
    return (
     e.each(({ node: e }) => {
      'EmptyStatement' !== e.type && (i.push(r()), e !== a && (i.push(pr), rt(e, t) && i.push(pr)));
     }, n),
     i
    );
   }
   function va(e, t, r) {
    let n = (function (e, t, r) {
      let { node: n } = e,
       s = A(n.directives),
       i = n.body.some((e) => 'EmptyStatement' !== e.type),
       a = et(n, Qe.Dangling);
      if (!s && !i && !a) return '';
      let o = [];
      return s && (o.push(ba(e, t, r, 'directives')), (i || a) && (o.push(pr), rt(c(!1, n.directives, -1), t) && o.push(pr))), i && o.push(ba(e, t, r, 'body')), a && o.push(Ts(e, t)), o;
     })(e, t, r),
     { node: s, parent: i } = e;
    if ('Program' === s.type && 'ModuleExpression' !== (null == i ? void 0 : i.type)) return n ? [n, pr] : '';
    let a = [];
    if (('StaticBlock' === s.type && a.push('static '), a.push('{'), n)) a.push(Gt([pr, n]), pr);
    else {
     let t = e.grandparent;
     'ArrowFunctionExpression' === i.type || 'FunctionExpression' === i.type || 'FunctionDeclaration' === i.type || 'ComponentDeclaration' === i.type || 'HookDeclaration' === i.type || 'ObjectMethod' === i.type || 'ClassMethod' === i.type || 'ClassPrivateMethod' === i.type || 'ForStatement' === i.type || 'WhileStatement' === i.type || 'DoWhileStatement' === i.type || 'DoExpression' === i.type || 'ModuleExpression' === i.type || ('CatchClause' === i.type && !t.finalizer) || 'TSModuleDeclaration' === i.type || 'StaticBlock' === s.type || a.push(pr);
    }
    return a.push('}'), a;
   }
   var Ea = function (e) {
    let t = new WeakMap();
    return function (r) {
     return t.has(r) || t.set(r, Symbol(e)), t.get(r);
    };
   };
   function Ca(e) {
    switch (e) {
     case null:
      return '';
     case 'PlusOptional':
      return '+?';
     case 'MinusOptional':
      return '-?';
     case 'Optional':
      return '?';
    }
   }
   function Ta(e, t) {
    return '+' === e || '-' === e ? e + t : t;
   }
   var Sa = Ea('typeParameters');
   function wa(e, t, r, n) {
    let { node: s } = e;
    if (!s[n]) return '';
    if (!Array.isArray(s[n])) return r(n);
    let i = De(e.grandparent),
     a = e.match(
      (e) => !(1 === e[n].length && oe(e[n][0])),
      void 0,
      (e, t) => 'typeAnnotation' === t,
      (e) => 'Identifier' === e.type,
      hi,
     );
    if (0 === s[n].length || (!a && (i || (1 === s[n].length && ('NullableTypeAnnotation' === s[n][0].type || vi(s[n][0])))))) return ['<', dr(', ', e.map(r, n)), Aa(e, t), '>'];
    let o =
     'TSTypeParameterInstantiation' === s.type
      ? ''
      : (function (e, t, r) {
           let { node: n } = e;
           return 1 === Ve(n).length && n.type.startsWith('TS') && !n[r][0].constraint && 'ArrowFunctionExpression' === e.parent.type && !(t.filepath && /\.ts$/u.test(t.filepath));
          })(e, t, n)
        ? ','
        : Le(t)
          ? rr(',')
          : '';
    return Yt(['<', Gt([lr, dr([',', ur], e.map(r, n))]), o, lr, '>'], { id: Sa(s) });
   }
   function Aa(e, t) {
    let { node: r } = e;
    if (!et(r, Qe.Dangling)) return '';
    let n = !et(r, Qe.Line),
     s = Ts(e, t, { indent: !n });
    return n ? s : [s, pr];
   }
   function Fa(e, t, r) {
    let { node: n, parent: s } = e,
     i = [n.const ? 'const ' : ''],
     a = 'TSTypeParameter' === n.type ? r('name') : n.name;
    if ('TSMappedType' === s.type)
     return (
      s.readonly && i.push(Ta(s.readonly, 'readonly'), ' '),
      i.push('[', a),
      n.constraint && i.push(' in ', r('constraint')),
      s.nameType &&
       i.push(
        ' as ',
        e.callParent(() => r('nameType')),
       ),
      i.push(']'),
      i
     );
    if ((n.variance && i.push(r('variance')), n.in && i.push('in '), n.out && i.push('out '), i.push(a), n.bound && (n.usesExtendsBound && i.push(' extends '), i.push(Ni(e, r, 'bound'))), n.constraint)) {
     let e = Symbol('constraint');
     i.push(' extends', Yt(Gt(ur), { id: e }), ir, nr(r('constraint'), { groupId: e }));
    }
    return n.default && i.push(' = ', r('default')), Yt(i);
   }
   var ka = $(['ClassProperty', 'PropertyDefinition', 'ClassPrivateProperty', 'ClassAccessorProperty', 'AccessorProperty', 'TSAbstractPropertyDefinition', 'TSAbstractAccessorProperty']);
   function Pa(e, t, r) {
    let n,
     { node: s } = e,
     i = [Ui(e), Hi(e), 'class'],
     a = et(s.id, Qe.Trailing) || et(s.typeParameters, Qe.Trailing) || et(s.superClass) || A(s.extends) || A(s.mixins) || A(s.implements),
     o = [],
     u = [];
    if ((s.id && o.push(' ', r('id')), o.push(r('typeParameters')), s.superClass)) {
     let n = [La(e, t, r), r(s.superTypeArguments ? 'superTypeArguments' : 'superTypeParameters')],
      i = e.call((e) => ['extends ', ws(e, n, t)], 'superClass');
     a ? u.push(ur, Yt(i)) : u.push(' ', i);
    } else u.push(_a(e, t, r, 'extends'));
    if ((u.push(_a(e, t, r, 'mixins'), _a(e, t, r, 'implements')), a)) {
     let e;
     (e = Ba(s) ? [...o, Gt(u)] : Gt([...o, u])), (n = Ia(s)), i.push(Yt(e, { id: n }));
    } else i.push(...o, ...u);
    let l = s.body;
    return a && A(l.body) ? i.push(rr(pr, ' ', { groupId: n })) : i.push(' '), i.push(r('body')), i;
   }
   var Ia = Ea('heritageGroup');
   function Na(e) {
    return rr(pr, '', { groupId: Ia(e) });
   }
   function Ba(e) {
    return (
     e.typeParameters &&
     !et(e.typeParameters, Qe.Trailing | Qe.Line) &&
     !(function (e) {
      return ['extends', 'mixins', 'implements'].reduce((t, r) => t + (Array.isArray(e[r]) ? e[r].length : 0), e.superClass ? 1 : 0) > 1;
     })(e)
    );
   }
   function _a(e, t, r, n) {
    let { node: s } = e;
    if (!A(s[n])) return '';
    let i = Ts(e, t, { marker: n });
    return [Ba(s) ? rr(' ', ur, { groupId: Sa(s.typeParameters) }) : ur, i, i && pr, n, Yt(Gt([ur, dr([',', ur], e.map(r, n))]))];
   }
   function La(e, t, r) {
    let n = r('superClass'),
     { parent: s } = e;
    return 'AssignmentExpression' === s.type ? Yt(rr(['(', Gt([lr, n]), lr, ')'], n)) : n;
   }
   function Oa(e, t, r) {
    let { node: n } = e,
     s = [];
    return A(n.decorators) && s.push(Ks(e, t, r)), s.push(Ki(n)), n.static && s.push('static '), s.push(Hi(e)), n.override && s.push('override '), s.push(pa(e, t, r)), s;
   }
   function Ma(e, t, r) {
    let { node: n } = e,
     s = [],
     i = t.semi ? ';' : '';
    return A(n.decorators) && s.push(Ks(e, t, r)), s.push(Ui(e), Ki(n)), n.static && s.push('static '), s.push(Hi(e)), n.override && s.push('override '), n.readonly && s.push('readonly '), n.variance && s.push(r('variance')), ('ClassAccessorProperty' === n.type || 'AccessorProperty' === n.type || 'TSAbstractAccessorProperty' === n.type) && s.push('accessor '), s.push(aa(e, t, r), ji(e), Ri(e), Ni(e, r)), [ui(e, t, r, s, ' =', 'TSAbstractPropertyDefinition' === n.type || 'TSAbstractAccessorProperty' === n.type ? void 0 : 'value'), i];
   }
   function ja(e, t, r) {
    let { node: n } = e,
     s = [];
    return (
     e.each(({ node: e, next: n, isLast: i }) => {
      s.push(r()),
       !t.semi &&
        ka(e) &&
        (function (e, t) {
         var r;
         let { type: n, name: s } = e.key;
         if (!(e.computed || 'Identifier' !== n || ('static' !== s && 'get' !== s && 'set' !== s) || e.value || e.typeAnnotation)) return !0;
         if (!t || t.static || t.accessibility || t.readonly) return !1;
         if (!t.computed) {
          let e = null == (r = t.key) ? void 0 : r.name;
          if ('in' === e || 'instanceof' === e) return !0;
         }
         if (ka(t) && t.variance && !t.static && !t.declare) return !0;
         switch (t.type) {
          case 'ClassProperty':
          case 'PropertyDefinition':
          case 'TSAbstractPropertyDefinition':
           return t.computed;
          case 'MethodDefinition':
          case 'TSAbstractMethodDefinition':
          case 'ClassMethod':
          case 'ClassPrivateMethod': {
           if ((t.value ? t.value.async : t.async) || 'get' === t.kind || 'set' === t.kind) return !1;
           let e = t.value ? t.value.generator : t.generator;
           return !(!t.computed && !e);
          }
          case 'TSIndexSignature':
           return !0;
         }
         return !1;
        })(e, n) &&
        s.push(';'),
       i || (s.push(pr), rt(e, t) && s.push(pr));
     }, 'body'),
     et(n, Qe.Dangling) && s.push(Ts(e, t)),
     ['{', s.length > 0 ? [Gt([pr, s]), pr] : '', '}']
    );
   }
   var Ra = $(['TSAsExpression', 'TSTypeAssertion', 'TSNonNullExpression', 'TSInstantiationExpression', 'TSSatisfiesExpression']);
   function qa(e) {
    return Ra(e) ? qa(e.expression) : e;
   }
   var Ua = $(['FunctionExpression', 'ArrowFunctionExpression']);
   function $a(e, t) {
    if (t.semi || za(e, t) || Va(e, t)) return !1;
    let { node: r, key: n, parent: s } = e;
    return !('ExpressionStatement' !== r.type || (('body' !== n || ('Program' !== s.type && 'BlockStatement' !== s.type && 'StaticBlock' !== s.type && 'TSModuleBlock' !== s.type)) && ('consequent' !== n || 'SwitchCase' !== s.type)) || !e.call(() => Ha(e, t), 'expression'));
   }
   function Ha(e, t) {
    let { node: r } = e;
    switch (r.type) {
     case 'ParenthesizedExpression':
     case 'TypeCastExpression':
     case 'ArrayExpression':
     case 'ArrayPattern':
     case 'TemplateLiteral':
     case 'TemplateElement':
     case 'RegExpLiteral':
      return !0;
     case 'ArrowFunctionExpression':
      if (!ha(e, t)) return !0;
      break;
     case 'UnaryExpression': {
      let { prefix: e, operator: t } = r;
      if (e && ('+' === t || '-' === t)) return !0;
      break;
     }
     case 'BindExpression':
      if (!r.object) return !0;
      break;
     case 'Literal':
      if (r.regex) return !0;
      break;
     default:
      if (pe(r)) return !0;
    }
    return !!bs(e, t) || (!!K(r) && e.call(() => Ha(e, t), ...X(r)));
   }
   function za({ node: e, parent: t }, r) {
    return ('markdown' === r.parentParser || 'mdx' === r.parentParser) && 'ExpressionStatement' === e.type && pe(e.expression) && 'Program' === t.type && 1 === t.body.length;
   }
   function Va({ node: e, parent: t }, r) {
    return ('__vue_event_binding' === r.parser || '__vue_ts_event_binding' === r.parser) && 'ExpressionStatement' === e.type && 'Program' === t.type && 1 === t.body.length;
   }
   function Wa(e, t, r) {
    let n = [r('expression')];
    if (Va(e, t)) {
     let t = qa(e.node.expression);
     (Ua(t) ||
      (function (e) {
       return 'MemberExpression' === e.type || 'OptionalMemberExpression' === e.type || ('Identifier' === e.type && 'undefined' !== e.name);
      })(t)) &&
      n.push(';');
    } else za(e, t) || (t.semi && n.push(';'));
    return n;
   }
   function Ja(e) {
    return e.toLowerCase();
   }
   function Ka({ pattern: e, flags: t }) {
    return `/${e}/${(t = [...t].sort().join(''))}`;
   }
   function Ga(e, t) {
    let r = e.slice(1, -1);
    if (r.includes('"') || r.includes("'")) return e;
    let n = t.singleQuote ? "'" : '"';
    return n + r + n;
   }
   var Xa = function (e, t, r) {
    let n = e.originalText.slice(t, r);
    for (let s of e[Symbol.for('comments')]) {
     let e = _(s);
     if (e > r) break;
     let i = L(s);
     if (i < t) continue;
     let a = i - e;
     n = n.slice(0, e - t) + ' '.repeat(a) + n.slice(i - t);
    }
    return n;
   };
   var Ya = (e) => 'ExportDefaultDeclaration' === e.type || ('DeclareExportDeclaration' === e.type && e.default);
   function Qa(e, t, r) {
    let { node: n } = e,
     s = [Gs(e, 0, r), Ui(e), 'export', Ya(n) ? ' default' : ''],
     { declaration: i, exported: a } = n;
    return (
     et(n, Qe.Dangling) && (s.push(' ', Ts(e, t)), ke(n) && s.push(pr)),
     i
      ? s.push(' ', r('declaration'))
      : (s.push(
         (function (e) {
          return eo(e.exportKind);
         })(n),
        ),
        'ExportAllDeclaration' === n.type || 'DeclareExportAllDeclaration' === n.type ? (s.push(' *'), a && s.push(' as ', r('exported'))) : s.push(no(e, t, r)),
        s.push(ro(e, t, r), io(e, t, r))),
     s.push(
      (function (e, t) {
       return t.semi && (!e.declaration || (Ya(e) && !Za(e.declaration))) ? ';' : '';
      })(n, t),
     ),
     s
    );
   }
   var Za = $(['ClassDeclaration', 'ComponentDeclaration', 'FunctionDeclaration', 'TSInterfaceDeclaration', 'DeclareClass', 'DeclareComponent', 'DeclareFunction', 'DeclareHook', 'HookDeclaration', 'TSDeclareFunction', 'EnumDeclaration']);
   function eo(e, t = !0) {
    return e && 'value' !== e ? `${t ? ' ' : ''}${e}${t ? '' : ' '}` : '';
   }
   function to(e, t) {
    return eo(e.importKind, t);
   }
   function ro(e, t, r) {
    let { node: n } = e;
    if (!n.source) return '';
    let s = [];
    return so(n, t) && s.push(' from'), s.push(' ', r('source')), s;
   }
   function no(e, t, r) {
    let { node: n } = e;
    if (!so(n, t)) return '';
    let s = [' '];
    if (A(n.specifiers)) {
     let i = [],
      a = [];
     e.each(() => {
      let t = e.node.type;
      if ('ExportNamespaceSpecifier' === t || 'ExportDefaultSpecifier' === t || 'ImportNamespaceSpecifier' === t || 'ImportDefaultSpecifier' === t) i.push(r());
      else {
       if ('ExportSpecifier' !== t && 'ImportSpecifier' !== t) throw new As(n, 'specifier');
       a.push(r());
      }
     }, 'specifiers'),
      s.push(dr(', ', i)),
      a.length > 0 && (i.length > 0 && s.push(', '), a.length > 1 || i.length > 0 || n.specifiers.some((e) => et(e)) ? s.push(Yt(['{', Gt([t.bracketSpacing ? ur : lr, dr([',', ur], a)]), rr(Le(t) ? ',' : ''), t.bracketSpacing ? ur : lr, '}'])) : s.push(['{', t.bracketSpacing ? ' ' : '', ...a, t.bracketSpacing ? ' ' : '', '}']));
    } else s.push('{}');
    return s;
   }
   function so(e, t) {
    return !('ImportDeclaration' === e.type && !A(e.specifiers) && 'type' !== e.importKind) || Xa(t, _(e), _(e.source)).trimEnd().endsWith('from');
   }
   function io(e, t, r) {
    let { node: n } = e;
    if (!n.source) return '';
    let s = (function (e, t) {
     var r, n;
     if (null != (r = e.extra) && r.deprecatedAssertSyntax) return 'assert';
     let s = Xa(t, L(e.source), null != (n = e.attributes) && n[0] ? _(e.attributes[0]) : L(e)).trimStart();
     return s.startsWith('assert') ? 'assert' : s.startsWith('with') || A(e.attributes) ? 'with' : void 0;
    })(n, t);
    if (!s) return '';
    let i = [` ${s} {`];
    return A(n.attributes) && (t.bracketSpacing && i.push(' '), i.push(dr(', ', e.map(r, 'attributes'))), t.bracketSpacing && i.push(' ')), i.push('}'), i;
   }
   function ao(e, t, r) {
    let { node: n } = e,
     { type: s } = n,
     i = s.startsWith('Import'),
     a = i ? 'imported' : 'local',
     o = i ? 'local' : 'exported',
     u = n[a],
     l = n[o],
     p = '',
     c = '';
    return (
     'ExportNamespaceSpecifier' === s || 'ImportNamespaceSpecifier' === s ? (p = '*') : u && (p = r(a)),
     l &&
      !(function (e) {
       if ('ImportSpecifier' !== e.type && 'ExportSpecifier' !== e.type) return !1;
       let { local: t, ['ImportSpecifier' === e.type ? 'imported' : 'exported']: r } = e;
       if (t.type !== r.type || !M(t, r)) return !1;
       if (ne(t)) return t.value === r.value && Be(t) === Be(r);
       if ('Identifier' === t.type) return t.name === r.name;
       return !1;
      })(n) &&
      (c = r(o)),
     [eo('ImportSpecifier' === s ? n.importKind : n.exportKind, !1), p, p && c ? ' as ' : '', c]
    );
   }
   function oo(e, t, r) {
    var n;
    let s = t.semi ? ';' : '',
     { node: i } = e,
     a = 'ObjectTypeAnnotation' === i.type,
     o = 'TSEnumDeclaration' === i.type || 'EnumBooleanBody' === i.type || 'EnumNumberBody' === i.type || 'EnumBigIntBody' === i.type || 'EnumStringBody' === i.type || 'EnumSymbolBody' === i.type,
     u = ['TSTypeLiteral' === i.type || o ? 'members' : 'TSInterfaceBody' === i.type ? 'body' : 'properties'];
    a && u.push('indexers', 'callProperties', 'internalSlots');
    let l = u.flatMap((t) => e.map(({ node: e }) => ({ node: e, printed: r(), loc: _(e) }), t));
    u.length > 1 && l.sort((e, t) => e.loc - t.loc);
    let { parent: p, key: h } = e,
     d = a && 'body' === h && ('InterfaceDeclaration' === p.type || 'DeclareInterface' === p.type || 'DeclareClass' === p.type),
     f = 'TSInterfaceBody' === i.type || o || d || ('ObjectPattern' === i.type && 'FunctionDeclaration' !== p.type && 'FunctionExpression' !== p.type && 'ArrowFunctionExpression' !== p.type && 'ObjectMethod' !== p.type && 'ClassMethod' !== p.type && 'ClassPrivateMethod' !== p.type && 'AssignmentPattern' !== p.type && 'CatchClause' !== p.type && i.properties.some((e) => e.value && ('ObjectPattern' === e.value.type || 'ArrayPattern' === e.value.type))) || ('ObjectPattern' !== i.type && 'preserve' === t.objectWrap && l.length > 0 && Tr(t.originalText, _(i), l[0].loc)),
     m = d ? ';' : 'TSInterfaceBody' === i.type || 'TSTypeLiteral' === i.type ? rr(s, ';') : ',',
     y = 'RecordExpression' === i.type ? '#{' : i.exact ? '{|' : '{',
     g = i.exact ? '|}' : '}',
     D = [],
     x = l.map((e) => {
      let r = [...D, Yt(e.printed)];
      return (D = [m, ur]), ('TSPropertySignature' === e.node.type || 'TSMethodSignature' === e.node.type || 'TSConstructSignatureDeclaration' === e.node.type || 'TSCallSignatureDeclaration' === e.node.type) && et(e.node, Qe.PrettierIgnore) && D.shift(), rt(e.node, t) && D.push(pr), r;
     });
    if (i.inexact || i.hasUnknownMembers) {
     let r;
     if (et(i, Qe.Dangling)) {
      let n = et(i, Qe.Line);
      r = [Ts(e, t), n || C(t.originalText, L(c(!1, tt(i), -1))) ? pr : ur, '...'];
     } else r = ['...'];
     x.push([...D, ...r]);
    }
    let b,
     v = null == (n = c(!1, l, -1)) ? void 0 : n.node,
     E = !(i.inexact || i.hasUnknownMembers || (v && ('RestElement' === v.type || (('TSPropertySignature' === v.type || 'TSCallSignatureDeclaration' === v.type || 'TSMethodSignature' === v.type || 'TSConstructSignatureDeclaration' === v.type) && et(v, Qe.PrettierIgnore)))));
    if (0 === x.length) {
     if (!et(i, Qe.Dangling)) return [y, g, Ni(e, r)];
     b = Yt([y, Ts(e, t, { indent: !0 }), lr, g, ji(e), Ni(e, r)]);
    } else b = [d && A(i.properties) ? Na(p) : '', y, Gt([t.bracketSpacing ? ur : lr, ...x]), rr(E && (',' !== m || Le(t)) ? m : ''), t.bracketSpacing ? ur : lr, g, ji(e), Ni(e, r)];
    return e.match((e) => 'ObjectPattern' === e.type && !A(e.decorators), uo) ||
     (oe(i) &&
      (e.match(
       void 0,
       (e, t) => 'typeAnnotation' === t,
       (e, t) => 'typeAnnotation' === t,
       uo,
      ) ||
       e.match(void 0, (e, t) => 'FunctionTypeParam' === e.type && 'typeAnnotation' === t, uo))) ||
     (!f &&
      e.match(
       (e) => 'ObjectPattern' === e.type,
       (e) => 'AssignmentExpression' === e.type || 'VariableDeclarator' === e.type,
      ))
     ? b
     : Yt(b, { shouldBreak: f });
   }
   function uo(e, t) {
    return ('params' === t || 'parameters' === t || 'this' === t || 'rest' === t) && gi(e);
   }
   function lo(e, t, r) {
    let { node: n } = e,
     s = 'ConditionalExpression' === n.type,
     i = s ? 'alternate' : 'falseType',
     { parent: a } = e,
     o = s ? r('test') : [r('checkType'), ' ', 'extends', ' ', r('extendsType')];
    return a.type === n.type && a[i] === n ? Xt(2, o) : o;
   }
   var po = new Map([
    ['AssignmentExpression', 'right'],
    ['VariableDeclarator', 'init'],
    ['ReturnStatement', 'argument'],
    ['ThrowStatement', 'argument'],
    ['UnaryExpression', 'argument'],
    ['YieldExpression', 'argument'],
    ['AwaitExpression', 'argument'],
   ]);
   function co(e, t, r) {
    let n,
     s,
     { node: i } = e,
     a = 'ConditionalExpression' === i.type,
     o = a ? 'consequent' : 'trueType',
     u = a ? 'alternate' : 'falseType',
     l = a ? ['test'] : ['checkType', 'extendsType'],
     p = i[o],
     c = i[u],
     h = [],
     d = !1,
     { parent: f } = e,
     m = f.type === i.type && l.some((e) => f[e] === i),
     y = f.type === i.type && !m,
     g = 0;
    do {
     (s = n || i), (n = e.getParentNode(g)), g++;
    } while (n && n.type === i.type && l.every((e) => n[e] !== s));
    let D = n || f,
     x = s;
    if (
     a &&
     (pe(i[l[0]]) ||
      pe(p) ||
      pe(c) ||
      (function (e) {
       let t = [e];
       for (let r = 0; r < t.length; r++) {
        let e = t[r];
        for (let r of ['test', 'consequent', 'alternate']) {
         let n = e[r];
         if (pe(n)) return !0;
         'ConditionalExpression' === n.type && t.push(n);
        }
       }
       return !1;
      })(x))
    ) {
     (d = !0), (y = !0);
     let e = (e) => [rr('('), Gt([lr, e]), lr, rr(')')],
      t = (e) => 'NullLiteral' === e.type || ('Literal' === e.type && null === e.value) || ('Identifier' === e.type && 'undefined' === e.name);
     h.push(' ? ', t(p) ? r(o) : e(r(o)), ' : ', c.type === i.type || t(c) ? r(u) : e(r(u)));
    } else {
     let e = (e) => (t.useTabs ? Gt(r(e)) : Xt(2, r(e))),
      n = [ur, '? ', p.type === i.type ? rr('', '(') : '', e(o), p.type === i.type ? rr('', ')') : '', ur, ': ', e(u)];
     h.push(f.type !== i.type || f[u] === i || m ? n : t.useTabs ? Zt(Gt(n)) : Xt(Math.max(0, t.tabWidth - 2), n));
    }
    let b = [o, u, ...l].some((e) => et(i[e], (e) => H(e) && Tr(t.originalText, _(e), L(e)))),
     v = !d && (ve(f) || ('NGPipeExpression' === f.type && f.left === i)) && !f.computed,
     E = (function (e) {
      let { node: t } = e;
      if ('ConditionalExpression' !== t.type) return !1;
      let r,
       n = t;
      for (let s = 0; !r; s++) {
       let t = e.getParentNode(s);
       ('ChainExpression' === t.type && t.expression === n) || (be(t) && t.callee === n) || (ve(t) && t.object === n) || ('TSNonNullExpression' === t.type && t.expression === n) ? (n = t) : ('NewExpression' === t.type && t.callee === n) || (it(t) && t.expression === n) ? ((r = e.getParentNode(s + 1)), (n = t)) : (r = t);
      }
      return n !== t && r[po.get(r.type)] === n;
     })(e),
     C = ((T = [lo(e, 0, r), y ? h : Gt(h), a && v && !E ? lr : '']), f === D ? Yt(T, { shouldBreak: b }) : b ? [T, ar] : T);
    var T;
    return m || E ? Yt([Gt([lr, C]), lr]) : C;
   }
   var ho = new Map([
    ['AssignmentExpression', 'right'],
    ['VariableDeclarator', 'init'],
    ['ReturnStatement', 'argument'],
    ['ThrowStatement', 'argument'],
    ['UnaryExpression', 'argument'],
    ['YieldExpression', 'argument'],
    ['AwaitExpression', 'argument'],
   ]);
   var fo = (e) => [rr('('), Gt([lr, e]), lr, rr(')')];
   function mo(e, t, r, n) {
    if (!t.experimentalTernaries) return co(e, t, r);
    let s,
     i,
     { node: a } = e,
     o = 'ConditionalExpression' === a.type,
     u = 'TSConditionalType' === a.type || 'ConditionalTypeAnnotation' === a.type,
     l = o ? 'consequent' : 'trueType',
     p = o ? 'alternate' : 'falseType',
     c = o ? ['test'] : ['checkType', 'extendsType'],
     h = a[l],
     d = a[p],
     f = c.map((e) => a[e]),
     { parent: m } = e,
     y = m.type === a.type,
     g = y && c.some((e) => m[e] === a),
     D = y && m[p] === a,
     x = h.type === a.type,
     b = d.type === a.type,
     v = b || D,
     E = t.tabWidth > 2 || t.useTabs,
     C = 0;
    do {
     (i = s || a), (s = e.getParentNode(C)), C++;
    } while (s && s.type === a.type && c.every((e) => s[e] !== i));
    let T = s || m,
     S = n && n.assignmentLayout && 'break-after-operator' !== n.assignmentLayout && ('AssignmentExpression' === m.type || 'VariableDeclarator' === m.type || 'ClassProperty' === m.type || 'PropertyDefinition' === m.type || 'ClassPrivateProperty' === m.type || 'ObjectProperty' === m.type || 'Property' === m.type),
     w = ('ReturnStatement' === m.type || 'ThrowStatement' === m.type) && !(x || b),
     A = o && 'JSXExpressionContainer' === T.type && 'JSXAttribute' !== e.grandparent.type,
     F = (function (e) {
      let { node: t } = e;
      if ('ConditionalExpression' !== t.type) return !1;
      let r,
       n = t;
      for (let s = 0; !r; s++) {
       let t = e.getParentNode(s);
       ('ChainExpression' === t.type && t.expression === n) || (be(t) && t.callee === n) || (ve(t) && t.object === n) || ('TSNonNullExpression' === t.type && t.expression === n) ? (n = t) : ('NewExpression' === t.type && t.callee === n) || (it(t) && t.expression === n) ? ((r = e.getParentNode(s + 1)), (n = t)) : (r = t);
      }
      return n !== t && r[ho.get(r.type)] === n;
     })(e),
     k = (function (e, t) {
      return (ve(t) || ('NGPipeExpression' === t.type && t.left === e)) && !t.computed;
     })(a, m),
     P = u && bs(e, t),
     I = E ? (t.useTabs ? '\t' : ' '.repeat(t.tabWidth - 1)) : '',
     N =
      (function (e, t, r, n) {
       return [...e.map((e) => tt(e)), tt(t), tt(r)].flat().some((e) => H(e) && Tr(n.originalText, _(e), L(e)));
      })(f, h, d, t) ||
      x ||
      b,
     B = !v && !y && !u && (A ? 'NullLiteral' === h.type || ('Literal' === h.type && null === h.value) : Se(h, t) && Ee(a.test, 3)),
     O = v || D || (u && !y) || (y && o && Ee(a.test, 1)) || B,
     M = [];
    !x &&
     et(h, Qe.Dangling) &&
     e.call((e) => {
      M.push(Ts(e, t), pr);
     }, 'consequent');
    let j = [];
    et(a.test, Qe.Dangling) &&
     e.call((e) => {
      j.push(Ts(e, t));
     }, 'test'),
     !b &&
      et(d, Qe.Dangling) &&
      e.call((e) => {
       j.push(Ts(e, t));
      }, 'alternate'),
     et(a, Qe.Dangling) && j.push(Ts(e, t));
    let R = Symbol('test'),
     q = Symbol('consequent'),
     U = Symbol('test-and-consequent'),
     $ = o ? [fo(r('test')), 'ConditionalExpression' === a.test.type ? ar : ''] : [r('checkType'), ' ', 'extends', ' ', 'TSConditionalType' === a.extendsType.type || 'ConditionalTypeAnnotation' === a.extendsType.type || 'TSMappedType' === a.extendsType.type ? r('extendsType') : Yt(fo(r('extendsType')))],
     z = Yt([$, ' ?'], { id: R }),
     V = r(l),
     W = Gt([x || (A && (pe(h) || y || v)) ? pr : ur, M, V]),
     J = O ? Yt([z, v ? W : rr(W, Yt(W, { id: q }), { groupId: R })], { id: U }) : [z, W],
     K = r(p),
     G = B ? rr(K, Zt(fo(K)), { groupId: U }) : K,
     X = [J, j.length > 0 ? [Gt([pr, j]), pr] : b ? pr : B ? rr(ur, ' ', { groupId: U }) : ur, ':', b ? ' ' : E ? (O ? rr(I, rr(v || B ? ' ' : I, ' '), { groupId: U }) : rr(I, ' ')) : ' ', b ? G : Yt([Gt(G), A && !B ? lr : '']), k && !F ? lr : '', N ? ar : ''];
    return S && !N ? Yt(Gt([lr, Yt(X)])) : S || w ? Yt(Gt(X)) : F || (u && g) ? Yt([Gt([lr, X]), P ? lr : '']) : m === T ? Yt(X) : X;
   }
   function yo(e, t, r, n) {
    let { node: s } = e;
    if (ie(s))
     return (function (e, t) {
      let { node: r } = e;
      switch (r.type) {
       case 'RegExpLiteral':
        return Ka(r);
       case 'BigIntLiteral':
        return Ja(r.extra.raw);
       case 'NumericLiteral':
        return ra(r.extra.raw);
       case 'StringLiteral':
        return Ut(B(r.extra.raw, t));
       case 'NullLiteral':
        return 'null';
       case 'BooleanLiteral':
        return String(r.value);
       case 'DirectiveLiteral':
        return Ga(r.extra.raw, t);
       case 'Literal': {
        if (r.regex) return Ka(r.regex);
        if (r.bigint) return Ja(r.raw);
        let { value: n } = r;
        return 'number' == typeof n
         ? ra(r.raw)
         : 'string' == typeof n
           ? (function (e) {
              if ('expression' !== e.key) return;
              let { parent: t } = e;
              return 'ExpressionStatement' === t.type && t.directive;
             })(e)
             ? Ga(r.raw, t)
             : Ut(B(r.raw, t))
           : String(n);
       }
      }
     })(e, t);
    let i = t.semi ? ';' : '',
     a = [];
    switch (s.type) {
     case 'JsExpressionRoot':
      return r('node');
     case 'JsonRoot':
      return [r('node'), pr];
     case 'File':
      return (
       (function (e, t, r) {
        if (t.__isVueBindings || t.__isVueForBindingLeft) {
         let n = e.map(r, 'program', 'body', 0, 'params');
         if (1 === n.length) return n[0];
         let s = dr([',', ur], n);
         return t.__isVueForBindingLeft ? ['(', Gt([lr, Yt(s)]), lr, ')'] : s;
        }
        if (t.__isEmbeddedTypescriptGenericParameters) {
         let t = e.map(r, 'program', 'body', 0, 'typeParameters', 'params');
         return dr([',', ur], t);
        }
       })(e, t, r) ?? r('program')
      );
     case 'EmptyStatement':
      return '';
     case 'ExpressionStatement':
      return Wa(e, t, r);
     case 'ChainExpression':
      return r('expression');
     case 'ParenthesizedExpression':
      return et(s.expression) || (!ee(s.expression) && !Z(s.expression)) ? Yt(['(', Gt([lr, r('expression')]), lr, ')']) : ['(', r('expression'), ')'];
     case 'AssignmentExpression':
      return (function (e, t, r) {
       let { node: n } = e;
       return ui(e, t, r, r('left'), [' ', n.operator], 'right');
      })(e, t, r);
     case 'VariableDeclarator':
      return (function (e, t, r) {
       return ui(e, t, r, r('id'), ' =', 'init');
      })(e, t, r);
     case 'BinaryExpression':
     case 'LogicalExpression':
      return Us(e, t, r);
     case 'AssignmentPattern':
      return [r('left'), ' = ', r('right')];
     case 'OptionalMemberExpression':
     case 'MemberExpression':
      return (function (e, t, r) {
       var n;
       let s = r('object'),
        i = si(e, 0, r),
        { node: a } = e,
        o = e.findAncestor((e) => !(ve(e) || 'TSNonNullExpression' === e.type)),
        u = e.findAncestor((e) => !('ChainExpression' === e.type || 'TSNonNullExpression' === e.type)),
        l = (o && ('NewExpression' === o.type || 'BindExpression' === o.type || ('AssignmentExpression' === o.type && 'Identifier' !== o.left.type))) || a.computed || ('Identifier' === a.object.type && 'Identifier' === a.property.type && !ve(u)) || (('AssignmentExpression' === u.type || 'VariableDeclarator' === u.type) && (ni(a.object) || (null == (n = s.label) ? void 0 : n.memberChain)));
       return fr(s.label, [s, l ? i : Yt(Gt([lr, i]))]);
      })(e, 0, r);
     case 'MetaProperty':
      return [r('meta'), '.', r('property')];
     case 'BindExpression':
      return s.object && a.push(r('object')), a.push(Yt(Gt([lr, Vi(0, 0, r)]))), a;
     case 'Identifier':
      return [s.name, ji(e), Ri(e), Ni(e, r)];
     case 'V8IntrinsicIdentifier':
      return ['%', s.name];
     case 'SpreadElement':
     case 'SpreadElementPattern':
     case 'SpreadPropertyPattern':
     case 'RestElement':
      return Ji(e, r);
     case 'FunctionDeclaration':
     case 'FunctionExpression':
      return la(e, r, t, n);
     case 'ArrowFunctionExpression':
      return Da(e, t, r, n);
     case 'YieldExpression':
      return a.push('yield'), s.delegate && a.push('*'), s.argument && a.push(' ', r('argument')), a;
     case 'AwaitExpression':
      if ((a.push('await'), s.argument)) {
       a.push(' ', r('argument'));
       let { parent: t } = e;
       if ((be(t) && t.callee === s) || (ve(t) && t.object === s)) {
        a = [Gt([lr, ...a]), lr];
        let t = e.findAncestor((e) => 'AwaitExpression' === e.type || 'BlockStatement' === e.type);
        if ('AwaitExpression' !== (null == t ? void 0 : t.type) || !Oe(t.argument, (e) => e === s)) return Yt(a);
       }
      }
      return a;
     case 'ExportDefaultDeclaration':
     case 'ExportNamedDeclaration':
     case 'ExportAllDeclaration':
      return Qa(e, t, r);
     case 'ImportDeclaration':
      return (function (e, t, r) {
       let { node: n } = e;
       return ['import', n.phase ? ` ${n.phase}` : '', to(n), no(e, t, r), ro(e, t, r), io(e, t, r), t.semi ? ';' : ''];
      })(e, t, r);
     case 'ImportSpecifier':
     case 'ExportSpecifier':
     case 'ImportNamespaceSpecifier':
     case 'ExportNamespaceSpecifier':
     case 'ImportDefaultSpecifier':
     case 'ExportDefaultSpecifier':
      return ao(e, 0, r);
     case 'ImportAttribute':
     case 'ObjectProperty':
      return oa(e, t, r);
     case 'Program':
     case 'BlockStatement':
     case 'StaticBlock':
      return va(e, t, r);
     case 'ClassBody':
      return ja(e, t, r);
     case 'ThrowStatement':
      return (function (e, t, r) {
       return ['throw', fa(e, t, r)];
      })(e, t, r);
     case 'ReturnStatement':
      return (function (e, t, r) {
       return ['return', fa(e, t, r)];
      })(e, t, r);
     case 'NewExpression':
     case 'ImportExpression':
     case 'OptionalCallExpression':
     case 'CallExpression':
      return ai(e, t, r);
     case 'ObjectExpression':
     case 'ObjectPattern':
     case 'RecordExpression':
      return oo(e, t, r);
     case 'Property':
      return ce(s) ? pa(e, t, r) : oa(e, t, r);
     case 'ObjectMethod':
      return pa(e, t, r);
     case 'Decorator':
      return ['@', r('expression')];
     case 'ArrayExpression':
     case 'ArrayPattern':
     case 'TupleExpression':
      return Gi(e, t, r);
     case 'SequenceExpression': {
      let { parent: t } = e;
      if ('ExpressionStatement' === t.type || 'ForStatement' === t.type) {
       let t = [];
       return (
        e.each(({ isFirst: e }) => {
         e ? t.push(r()) : t.push(',', Gt([ur, r()]));
        }, 'expressions'),
        Yt(t)
       );
      }
      return Yt(dr([',', ur], e.map(r, 'expressions')));
     }
     case 'ThisExpression':
      return 'this';
     case 'Super':
      return 'super';
     case 'Directive':
      return [r('value'), i];
     case 'UnaryExpression':
      return a.push(s.operator), /[a-z]$/u.test(s.operator) && a.push(' '), et(s.argument) ? a.push(Yt(['(', Gt([lr, r('argument')]), lr, ')'])) : a.push(r('argument')), a;
     case 'UpdateExpression':
      return [s.prefix ? s.operator : '', r('argument'), s.prefix ? '' : s.operator];
     case 'ConditionalExpression':
      return mo(e, t, r, n);
     case 'VariableDeclaration': {
      let t,
       n = e.map(r, 'declarations'),
       o = e.parent,
       u = 'ForStatement' === o.type || 'ForInStatement' === o.type || 'ForOfStatement' === o.type,
       l = s.declarations.some((e) => e.init);
      return 1 !== n.length || et(s.declarations[0]) ? n.length > 0 && (t = Gt(n[0])) : (t = n[0]), (a = [Ui(e), s.kind, t ? [' ', t] : '', Gt(n.slice(1).map((e) => [',', l && !u ? pr : ur, e]))]), (u && o.body !== s) || a.push(i), Yt(a);
     }
     case 'WithStatement':
      return Yt(['with (', r('object'), ')', Wi(s.body, r('body'))]);
     case 'IfStatement': {
      let n = Wi(s.consequent, r('consequent')),
       i = Yt(['if (', Yt([Gt([lr, r('test')]), lr]), ')', n]);
      if ((a.push(i), s.alternate)) {
       let n = et(s.consequent, Qe.Trailing | Qe.Line) || ke(s),
        i = 'BlockStatement' === s.consequent.type && !n;
       a.push(i ? ' ' : pr), et(s, Qe.Dangling) && a.push(Ts(e, t), n ? pr : ' '), a.push('else', Yt(Wi(s.alternate, r('alternate'), 'IfStatement' === s.alternate.type)));
      }
      return a;
     }
     case 'ForStatement': {
      let n = Wi(s.body, r('body')),
       i = Ts(e, t),
       a = i ? [i, lr] : '';
      return s.init || s.test || s.update ? [a, Yt(['for (', Yt([Gt([lr, r('init'), ';', ur, r('test'), ';', ur, r('update')]), lr]), ')', n])] : [a, Yt(['for (;;)', n])];
     }
     case 'WhileStatement':
      return Yt(['while (', Yt([Gt([lr, r('test')]), lr]), ')', Wi(s.body, r('body'))]);
     case 'ForInStatement':
      return Yt(['for (', r('left'), ' in ', r('right'), ')', Wi(s.body, r('body'))]);
     case 'ForOfStatement':
      return Yt(['for', s.await ? ' await' : '', ' (', r('left'), ' of ', r('right'), ')', Wi(s.body, r('body'))]);
     case 'DoWhileStatement':
      return (a = [Yt(['do', Wi(s.body, r('body'))])]), 'BlockStatement' === s.body.type ? a.push(' ') : a.push(pr), a.push('while (', Yt([Gt([lr, r('test')]), lr]), ')', i), a;
     case 'DoExpression':
      return [s.async ? 'async ' : '', 'do ', r('body')];
     case 'BreakStatement':
     case 'ContinueStatement':
      return a.push('BreakStatement' === s.type ? 'break' : 'continue'), s.label && a.push(' ', r('label')), a.push(i), a;
     case 'LabeledStatement':
      return 'EmptyStatement' === s.body.type ? [r('label'), ':;'] : [r('label'), ': ', r('body')];
     case 'TryStatement':
      return ['try ', r('block'), s.handler ? [' ', r('handler')] : '', s.finalizer ? [' finally ', r('finalizer')] : ''];
     case 'CatchClause':
      if (s.param) {
       let e = et(s.param, (e) => !H(e) || (e.leading && C(t.originalText, L(e))) || (e.trailing && C(t.originalText, _(e), { backwards: !0 }))),
        n = r('param');
       return ['catch ', e ? ['(', Gt([lr, n]), lr, ') '] : ['(', n, ') '], r('body')];
      }
      return ['catch ', r('body')];
     case 'SwitchStatement':
      return [
       Yt(['switch (', Gt([lr, r('discriminant')]), lr, ')']),
       ' {',
       s.cases.length > 0
        ? Gt([
           pr,
           dr(
            pr,
            e.map(({ node: e, isLast: n }) => [r(), !n && rt(e, t) ? pr : ''], 'cases'),
           ),
          ])
        : '',
       pr,
       '}',
      ];
     case 'SwitchCase': {
      s.test ? a.push('case ', r('test'), ':') : a.push('default:'), et(s, Qe.Dangling) && a.push(' ', Ts(e, t));
      let n = s.consequent.filter((e) => 'EmptyStatement' !== e.type);
      if (n.length > 0) {
       let s = ba(e, t, r, 'consequent');
       a.push(1 === n.length && 'BlockStatement' === n[0].type ? [' ', s] : Gt([pr, s]));
      }
      return a;
     }
     case 'DebuggerStatement':
      return ['debugger', i];
     case 'ClassDeclaration':
     case 'ClassExpression':
      return Pa(e, t, r);
     case 'ClassMethod':
     case 'ClassPrivateMethod':
     case 'MethodDefinition':
      return Oa(e, t, r);
     case 'ClassProperty':
     case 'PropertyDefinition':
     case 'ClassPrivateProperty':
     case 'ClassAccessorProperty':
     case 'AccessorProperty':
      return Ma(e, t, r);
     case 'TemplateElement':
      return Ut(s.value.raw);
     case 'TemplateLiteral':
      return Bn(e, r, t);
     case 'TaggedTemplateExpression':
      return (function (e, t) {
       let r = t('quasi');
       return fr(r.label && { tagged: !0, ...r.label }, [t('tag'), t(e.node.typeArguments ? 'typeArguments' : 'typeParameters'), ir, r]);
      })(e, r);
     case 'PrivateIdentifier':
      return ['#', s.name];
     case 'PrivateName':
      return ['#', r('id')];
     case 'TopicReference':
      return '%';
     case 'ArgumentPlaceholder':
      return '?';
     case 'ModuleExpression':
      return ['module ', r('body')];
     default:
      throw new As(s, 'ESTree');
    }
   }
   function go(e, t, r) {
    let { parent: n, node: s, key: i } = e,
     a = [r('expression')];
    switch (s.type) {
     case 'AsConstExpression':
      a.push(' as const');
      break;
     case 'AsExpression':
     case 'TSAsExpression':
      a.push(' as ', r('typeAnnotation'));
      break;
     case 'SatisfiesExpression':
     case 'TSSatisfiesExpression':
      a.push(' satisfies ', r('typeAnnotation'));
    }
    return ('callee' === i && be(n)) || ('object' === i && ve(n)) ? Yt([Gt([lr, ...a]), lr]) : a;
   }
   function Do(e, t, r) {
    let { node: n } = e,
     s = [Ui(e), 'component'];
    n.id && s.push(' ', r('id')), s.push(r('typeParameters'));
    let i = (function (e, t, r) {
     let { node: n } = e,
      s = n.params;
     if ((n.rest && (s = [...s, n.rest]), 0 === s.length)) return ['(', Ts(e, r, { filter: (e) => ')' === Cr(r.originalText, L(e)) }), ')'];
     let i = [];
     return (
      (function (e, t) {
       let { node: r } = e,
        n = 0,
        s = (e) => t(e, n++);
       e.each(s, 'params'), r.rest && e.call(s, 'rest');
      })(e, (e, a) => {
       let o = a === s.length - 1;
       o && n.rest && i.push('...'), i.push(t()), !o && (i.push(','), rt(s[a], r) ? i.push(pr, pr) : i.push(ur));
      }),
      ['(', Gt([lr, ...i]), rr(Le(r, 'all') && !xo(n, s) ? ',' : ''), lr, ')']
     );
    })(e, r, t);
    return n.rendersType ? s.push(Yt([i, ' ', r('rendersType')])) : s.push(Yt([i])), n.body && s.push(' ', r('body')), t.semi && 'DeclareComponent' === n.type && s.push(';'), s;
   }
   function xo(e, t) {
    var r;
    return e.rest || 'RestElement' === (null == (r = c(!1, t, -1)) ? void 0 : r.type);
   }
   function bo(e, t, r) {
    return oo(e, r, t);
   }
   function vo(e, t) {
    let { node: r } = e,
     n = t('id');
    r.computed && (n = ['[', n, ']']);
    let s = '';
    return r.initializer && (s = t('initializer')), r.init && (s = t('init')), s ? [n, ' = ', s] : n;
   }
   function Eo(e, t, r) {
    let { node: n } = e;
    return [Ui(e), n.const ? 'const ' : '', 'enum ', t('id'), ' ', 'TSEnumDeclaration' === n.type ? bo(e, t, r) : t('body')];
   }
   function Co(e) {
    var t;
    let { node: r } = e;
    return 'HookTypeAnnotation' === r.type && 'DeclareHook' === (null == (t = e.getParentNode(2)) ? void 0 : t.type);
   }
   function To(e, t, r) {
    let { node: n } = e,
     s = [Ui(e), 'interface'],
     i = [],
     a = [];
    'InterfaceTypeAnnotation' !== n.type && i.push(' ', r('id'), r('typeParameters'));
    let o = n.typeParameters && !et(n.typeParameters, Qe.Trailing | Qe.Line);
    return A(n.extends) && a.push(o ? rr(' ', ur, { groupId: Sa(n.typeParameters) }) : ur, 'extends ', (1 === n.extends.length ? _e : Gt)(dr([',', ur], e.map(r, 'extends')))), et(n.id, Qe.Trailing) || A(n.extends) ? (o ? s.push(Yt([...i, Gt(a)])) : s.push(Yt(Gt([...i, ...a])))) : s.push(...i, ...a), s.push(' ', r('body')), Yt(s);
   }
   function So(e, t, r) {
    let { node: n } = e;
    if (z(n)) return n.type.slice(0, -14).toLowerCase();
    let s = t.semi ? ';' : '';
    switch (n.type) {
     case 'ComponentDeclaration':
     case 'DeclareComponent':
     case 'ComponentTypeAnnotation':
      return Do(e, t, r);
     case 'ComponentParameter':
      return (function (e, t, r) {
       let { node: n } = e;
       return n.shorthand ? r('local') : [r('name'), ' as ', r('local')];
      })(e, 0, r);
     case 'ComponentTypeParameter':
      return (function (e, t, r) {
       let { node: n } = e,
        s = [];
       return n.name && s.push(r('name'), n.optional ? '?: ' : ': '), s.push(r('typeAnnotation')), s;
      })(e, 0, r);
     case 'HookDeclaration':
      return (function (e, t, r) {
       let { node: n } = e,
        s = ['hook'];
       n.id && s.push(' ', r('id'));
       let i = yi(e, r, t, !1, !0),
        a = da(e, r),
        o = Di(n, a);
       return s.push(Yt([o ? Yt(i) : i, a]), n.body ? ' ' : '', r('body')), s;
      })(e, t, r);
     case 'DeclareHook':
      return (function (e, t, r) {
       let { node: n } = e,
        s = [Ui(e), 'hook'];
       return n.id && s.push(' ', r('id')), t.semi && s.push(';'), s;
      })(e, t, r);
     case 'HookTypeAnnotation':
      return (function (e, t, r) {
       let { node: n } = e,
        s = [];
       s.push(Co(e) ? '' : 'hook ');
       let i = yi(e, r, t, !1, !0),
        a = [];
       return a.push(Co(e) ? ': ' : ' => ', r('returnType')), Di(n, a) && (i = Yt(i)), s.push(i, a), Yt(s);
      })(e, t, r);
     case 'DeclareClass':
      return Pa(e, t, r);
     case 'DeclareFunction':
      return [Ui(e), 'function ', r('id'), r('predicate'), s];
     case 'DeclareModule':
      return ['declare module ', r('id'), ' ', r('body')];
     case 'DeclareModuleExports':
      return ['declare module.exports', Ni(e, r), s];
     case 'DeclareNamespace':
      return ['declare namespace ', r('id'), ' ', r('body')];
     case 'DeclareVariable':
      return [Ui(e), n.kind ?? 'var', ' ', r('id'), s];
     case 'DeclareExportDeclaration':
     case 'DeclareExportAllDeclaration':
      return Qa(e, t, r);
     case 'DeclareOpaqueType':
     case 'OpaqueType':
      return (function (e, t, r) {
       let n = t.semi ? ';' : '',
        { node: s } = e,
        i = [Ui(e), 'opaque type ', r('id'), r('typeParameters')];
       return s.supertype && i.push(': ', r('supertype')), s.impltype && i.push(' = ', r('impltype')), i.push(n), i;
      })(e, t, r);
     case 'DeclareTypeAlias':
     case 'TypeAlias':
      return Ei(e, t, r);
     case 'IntersectionTypeAnnotation':
      return Ci(e, t, r);
     case 'UnionTypeAnnotation':
      return Ti(e, t, r);
     case 'ConditionalTypeAnnotation':
      return mo(e, t, r);
     case 'InferTypeAnnotation':
      return Ai(0, 0, r);
     case 'FunctionTypeAnnotation':
      return Si(e, t, r);
     case 'TupleTypeAnnotation':
      return Gi(e, t, r);
     case 'TupleTypeLabeledElement':
      return Pi(e, 0, r);
     case 'TupleTypeSpreadElement':
      return ki(e, 0, r);
     case 'GenericTypeAnnotation':
      return [r('id'), wa(e, t, r, 'typeParameters')];
     case 'IndexedAccessType':
     case 'OptionalIndexedAccessType':
      return wi(e, 0, r);
     case 'TypeAnnotation':
      return _i(e, 0, r);
     case 'TypeParameter':
      return Fa(e, 0, r);
     case 'TypeofTypeAnnotation':
      return Oi(e, r);
     case 'ExistsTypeAnnotation':
      return '*';
     case 'ArrayTypeAnnotation':
      return Li(r);
     case 'DeclareEnum':
     case 'EnumDeclaration':
      return Eo(e, r, t);
     case 'EnumBooleanBody':
     case 'EnumNumberBody':
     case 'EnumBigIntBody':
     case 'EnumStringBody':
     case 'EnumSymbolBody':
      return (function (e, t, r) {
       let n,
        { node: s } = e;
       if ('EnumSymbolBody' === s.type || s.explicitType)
        switch (s.type) {
         case 'EnumBooleanBody':
          n = 'boolean';
          break;
         case 'EnumNumberBody':
          n = 'number';
          break;
         case 'EnumBigIntBody':
          n = 'bigint';
          break;
         case 'EnumStringBody':
          n = 'string';
          break;
         case 'EnumSymbolBody':
          n = 'symbol';
        }
       return [n ? `of ${n} ` : '', bo(e, t, r)];
      })(e, r, t);
     case 'EnumBooleanMember':
     case 'EnumNumberMember':
     case 'EnumBigIntMember':
     case 'EnumStringMember':
     case 'EnumDefaultedMember':
      return vo(e, r);
     case 'FunctionTypeParam': {
      let t = n.name ? r('name') : e.parent.this === n ? 'this' : '';
      return [t, ji(e), t ? ': ' : '', r('typeAnnotation')];
     }
     case 'DeclareInterface':
     case 'InterfaceDeclaration':
     case 'InterfaceTypeAnnotation':
      return To(e, 0, r);
     case 'ClassImplements':
     case 'InterfaceExtends':
      return [r('id'), r('typeParameters')];
     case 'NullableTypeAnnotation':
      return ['?', r('typeAnnotation')];
     case 'Variance': {
      let { kind: e } = n;
      return k.ok('plus' === e || 'minus' === e), 'plus' === e ? '+' : '-';
     }
     case 'KeyofTypeAnnotation':
      return ['keyof ', r('argument')];
     case 'ObjectTypeCallProperty':
      return [n.static ? 'static ' : '', r('value')];
     case 'ObjectTypeMappedTypeProperty':
      return (function (e, t, r) {
       let { node: n } = e;
       return Yt([n.variance ? r('variance') : '', '[', Gt([r('keyTparam'), ' in ', r('sourceType')]), ']', Ca(n.optional), ': ', r('propType')]);
      })(e, 0, r);
     case 'ObjectTypeIndexer':
      return [n.static ? 'static ' : '', n.variance ? r('variance') : '', '[', r('id'), n.id ? ': ' : '', r('key'), ']: ', r('value')];
     case 'ObjectTypeProperty': {
      let s = '';
      return n.proto ? (s = 'proto ') : n.static && (s = 'static '), [s, 'init' !== n.kind ? n.kind + ' ' : '', n.variance ? r('variance') : '', aa(e, t, r), ji(e), ce(n) ? '' : ': ', r('value')];
     }
     case 'ObjectTypeAnnotation':
      return oo(e, t, r);
     case 'ObjectTypeInternalSlot':
      return [n.static ? 'static ' : '', '[[', r('id'), ']]', ji(e), n.method ? '' : ': ', r('value')];
     case 'ObjectTypeSpreadProperty':
      return Ji(e, r);
     case 'QualifiedTypeofIdentifier':
     case 'QualifiedTypeIdentifier':
      return [r('qualification'), '.', r('id')];
     case 'NullLiteralTypeAnnotation':
      return 'null';
     case 'BooleanLiteralTypeAnnotation':
      return String(n.value);
     case 'StringLiteralTypeAnnotation':
      return Ut(B(Be(n), t));
     case 'NumberLiteralTypeAnnotation':
      return ra(n.raw ?? n.extra.raw);
     case 'BigIntLiteralTypeAnnotation':
      return Ja(n.raw ?? n.extra.raw);
     case 'TypeCastExpression':
      return ['(', r('expression'), Ni(e, r), ')'];
     case 'TypePredicate':
      return Mi(e, r);
     case 'TypeOperator':
      return [n.operator, ' ', r('typeAnnotation')];
     case 'TypeParameterDeclaration':
     case 'TypeParameterInstantiation':
      return wa(e, t, r, 'params');
     case 'InferredPredicate':
     case 'DeclaredPredicate':
      return ['predicate' !== e.key || 'DeclareFunction' === e.parent.type || e.parent.returnType ? ' ' : ': ', '%checks', ...('DeclaredPredicate' === n.type ? ['(', r('value'), ')'] : [])];
     case 'AsExpression':
     case 'AsConstExpression':
     case 'SatisfiesExpression':
      return go(e, 0, r);
    }
   }
   function wo(e, t, r) {
    var n;
    let { node: s } = e;
    if (!s.type.startsWith('TS')) return;
    if (W(s)) return s.type.slice(2, -7).toLowerCase();
    let i = t.semi ? ';' : '',
     a = [];
    switch (s.type) {
     case 'TSThisType':
      return 'this';
     case 'TSTypeAssertion': {
      let e = !(Z(s.expression) || ee(s.expression)),
       t = Yt(['<', Gt([lr, r('typeAnnotation')]), lr, '>']),
       n = [rr('('), Gt([lr, r('expression')]), lr, rr(')')];
      return e
       ? er([
          [t, r('expression')],
          [t, Yt(n, { shouldBreak: !0 })],
          [t, r('expression')],
         ])
       : Yt([t, r('expression')]);
     }
     case 'TSDeclareFunction':
      return la(e, r, t);
     case 'TSExportAssignment':
      return ['export = ', r('expression'), i];
     case 'TSModuleBlock':
      return va(e, t, r);
     case 'TSInterfaceBody':
     case 'TSTypeLiteral':
      return oo(e, t, r);
     case 'TSTypeAliasDeclaration':
      return Ei(e, t, r);
     case 'TSQualifiedName':
      return [r('left'), '.', r('right')];
     case 'TSAbstractMethodDefinition':
     case 'TSDeclareMethod':
      return Oa(e, t, r);
     case 'TSAbstractAccessorProperty':
     case 'TSAbstractPropertyDefinition':
      return Ma(e, t, r);
     case 'TSInterfaceHeritage':
     case 'TSClassImplements':
     case 'TSExpressionWithTypeArguments':
     case 'TSInstantiationExpression':
      return [r('expression'), r(s.typeArguments ? 'typeArguments' : 'typeParameters')];
     case 'TSTemplateLiteralType':
      return Bn(e, r, t);
     case 'TSNamedTupleMember':
      return Pi(e, 0, r);
     case 'TSRestType':
      return ki(e, 0, r);
     case 'TSOptionalType':
      return [r('typeAnnotation'), '?'];
     case 'TSInterfaceDeclaration':
      return To(e, 0, r);
     case 'TSTypeParameterDeclaration':
     case 'TSTypeParameterInstantiation':
      return wa(e, t, r, 'params');
     case 'TSTypeParameter':
      return Fa(e, 0, r);
     case 'TSAsExpression':
     case 'TSSatisfiesExpression':
      return go(e, 0, r);
     case 'TSArrayType':
      return Li(r);
     case 'TSPropertySignature':
      return [s.readonly ? 'readonly ' : '', aa(e, t, r), ji(e), Ni(e, r)];
     case 'TSParameterProperty':
      return [Ki(s), s.static ? 'static ' : '', s.override ? 'override ' : '', s.readonly ? 'readonly ' : '', r('parameter')];
     case 'TSTypeQuery':
      return Oi(e, r);
     case 'TSIndexSignature': {
      let n = s.parameters.length > 1 ? rr(Le(t) ? ',' : '') : '',
       a = Yt([Gt([lr, dr([', ', lr], e.map(r, 'parameters'))]), n, lr]),
       o = 'ClassBody' === e.parent.type && 'body' === e.key;
      return [o && s.static ? 'static ' : '', s.readonly ? 'readonly ' : '', '[', s.parameters ? a : '', ']', Ni(e, r), o ? i : ''];
     }
     case 'TSTypePredicate':
      return Mi(e, r);
     case 'TSNonNullExpression':
      return [r('expression'), '!'];
     case 'TSImportType':
      return ['import(', r('argument'), ')', s.qualifier ? ['.', r('qualifier')] : '', wa(e, t, r, s.typeArguments ? 'typeArguments' : 'typeParameters')];
     case 'TSLiteralType':
      return r('literal');
     case 'TSIndexedAccessType':
      return wi(e, 0, r);
     case 'TSTypeOperator':
      return [s.operator, ' ', r('typeAnnotation')];
     case 'TSMappedType':
      return (function (e, t, r) {
       let { node: n } = e,
        s = 'preserve' === t.objectWrap && Tr(t.originalText, _(n), _(n.typeParameter));
       return Yt(['{', Gt([t.bracketSpacing ? ur : lr, Yt([r('typeParameter'), n.optional ? Ta(n.optional, '?') : '', n.typeAnnotation ? ': ' : '', r('typeAnnotation')]), t.semi ? rr(';') : '']), Ts(e, t), t.bracketSpacing ? ur : lr, '}'], { shouldBreak: s });
      })(e, t, r);
     case 'TSMethodSignature': {
      let n = s.kind && 'method' !== s.kind ? `${s.kind} ` : '';
      a.push(Ki(s), n, s.computed ? '[' : '', r('key'), s.computed ? ']' : '', ji(e));
      let i = yi(e, r, t, !1, !0),
       o = s.returnType ? 'returnType' : 'typeAnnotation',
       u = s[o],
       l = u ? Ni(e, r, o) : '',
       p = Di(s, l);
      return a.push(p ? Yt(i) : i), u && a.push(Yt(l)), Yt(a);
     }
     case 'TSNamespaceExportDeclaration':
      return ['export as namespace ', r('id'), t.semi ? ';' : ''];
     case 'TSEnumDeclaration':
      return Eo(e, r, t);
     case 'TSEnumMember':
      return vo(e, r);
     case 'TSImportEqualsDeclaration':
      return [s.isExport ? 'export ' : '', 'import ', to(s, !1), r('id'), ' = ', r('moduleReference'), t.semi ? ';' : ''];
     case 'TSExternalModuleReference':
      return ['require(', r('expression'), ')'];
     case 'TSModuleDeclaration': {
      let { parent: t } = e,
       o = 'TSModuleDeclaration' === t.type,
       u = 'TSModuleDeclaration' === (null == (n = s.body) ? void 0 : n.type);
      return o ? a.push('.') : (a.push(Ui(e)), 'global' !== s.kind && a.push(s.kind, ' ')), a.push(r('id')), u ? a.push(r('body')) : s.body ? a.push(' ', Yt(r('body'))) : a.push(i), a;
     }
     case 'TSConditionalType':
      return mo(e, t, r);
     case 'TSInferType':
      return Ai(0, 0, r);
     case 'TSIntersectionType':
      return Ci(e, t, r);
     case 'TSUnionType':
      return Ti(e, t, r);
     case 'TSFunctionType':
     case 'TSCallSignatureDeclaration':
     case 'TSConstructorType':
     case 'TSConstructSignatureDeclaration':
      return Si(e, t, r);
     case 'TSTupleType':
      return Gi(e, t, r);
     case 'TSTypeReference':
      return [r('typeName'), wa(e, t, r, s.typeArguments ? 'typeArguments' : 'typeParameters')];
     case 'TSTypeAnnotation':
      return _i(e, 0, r);
     case 'TSEmptyBodyFunctionExpression':
      return ca(e, t, r);
     case 'TSJSDocAllType':
      return '*';
     case 'TSJSDocUnknownType':
      return '?';
     case 'TSJSDocNullableType':
      return Fi(e, r, '?');
     case 'TSJSDocNonNullableType':
      return Fi(e, r, '!');
     default:
      throw new As(s, 'TypeScript');
    }
   }
   var Ao = $(['ClassMethod', 'ClassPrivateMethod', 'ClassProperty', 'ClassAccessorProperty', 'AccessorProperty', 'TSAbstractAccessorProperty', 'PropertyDefinition', 'TSAbstractPropertyDefinition', 'ClassPrivateProperty', 'MethodDefinition', 'TSAbstractMethodDefinition', 'TSDeclareMethod']);
   var Fo = function (e, t, r, n) {
     var s;
     e.isRoot && (null == (s = t.__onHtmlBindingRoot) || s.call(t, e.node, t));
     let i = (function (e, t, r, n) {
      if (Rs(e)) return fs(e, t);
      for (let s of [Vs, Ms, So, wo, yo]) {
       let i = s(e, t, r, n);
       if (void 0 !== i) return i;
      }
     })(e, t, r, n);
     if (!i) return '';
     let { node: a } = e;
     if (Ao(a)) return i;
     let o = A(a.decorators),
      u = (function (e, t, r) {
       let { node: n, parent: s } = e,
        { decorators: i } = n;
       if (!A(i) || Ys(s) || Rs(e)) return '';
       let a = 'ClassExpression' === n.type || 'ClassDeclaration' === n.type || Xs(n, t);
       return ['declaration' === e.key && Q(s) ? pr : a ? ar : '', dr(ur, e.map(r, 'decorators')), ur];
      })(e, t, r),
      l = 'ClassExpression' === a.type;
     if (o && !l) return Ht(i, (e) => Yt([u, e]));
     let p = bs(e, t),
      c = $a(e, t);
     return u || p || c ? Ht(i, (e) => [c ? ';' : '', p ? '(' : '', p && l && o ? [Gt([ur, u, e]), ur] : [u, e], p ? ')' : '']) : i;
    },
    ko = { avoidAstMutation: !0 },
    Po = {};
   i(Po, { getVisitorKeys: () => Io, massageAstNode: () => Lo, print: () => No });
   var Io = q({ JsonRoot: ['node'], ArrayExpression: ['elements'], ObjectExpression: ['properties'], ObjectProperty: ['key', 'value'], UnaryExpression: ['argument'], NullLiteral: [], BooleanLiteral: [], StringLiteral: [], NumericLiteral: [], Identifier: [], TemplateLiteral: ['quasis'], TemplateElement: [] });
   function No(e, t, r) {
    let { node: n } = e;
    switch (n.type) {
     case 'JsonRoot':
      return [r('node'), pr];
     case 'ArrayExpression': {
      if (0 === n.elements.length) return '[]';
      let t = e.map(() => (null === e.node ? 'null' : r()), 'elements');
      return ['[', Gt([pr, dr([',', pr], t)]), pr, ']'];
     }
     case 'ObjectExpression':
      return 0 === n.properties.length ? '{}' : ['{', Gt([pr, dr([',', pr], e.map(r, 'properties'))]), pr, '}'];
     case 'ObjectProperty':
      return [r('key'), ': ', r('value')];
     case 'UnaryExpression':
      return ['+' === n.operator ? '' : n.operator, r('argument')];
     case 'NullLiteral':
      return 'null';
     case 'BooleanLiteral':
      return n.value ? 'true' : 'false';
     case 'StringLiteral':
      return JSON.stringify(n.value);
     case 'NumericLiteral':
      return Bo(e) ? JSON.stringify(String(n.value)) : JSON.stringify(n.value);
     case 'Identifier':
      return Bo(e) ? JSON.stringify(n.name) : n.name;
     case 'TemplateLiteral':
      return r(['quasis', 0]);
     case 'TemplateElement':
      return JSON.stringify(n.value.cooked);
     default:
      throw new As(n, 'JSON');
    }
   }
   function Bo(e) {
    return 'key' === e.key && 'ObjectProperty' === e.parent.type;
   }
   var _o = new Set(['start', 'end', 'extra', 'loc', 'comments', 'leadingComments', 'trailingComments', 'innerComments', 'errors', 'range', 'tokens']);
   function Lo(e, t) {
    let { type: r } = e;
    if ('ObjectProperty' !== r) {
     if ('UnaryExpression' === r && '+' === e.operator) return t.argument;
     if ('ArrayExpression' !== r) return 'TemplateLiteral' === r ? { type: 'StringLiteral', value: e.quasis[0].value.cooked } : void 0;
     for (let [r, n] of e.elements.entries()) null === n && t.elements.splice(r, 0, { type: 'NullLiteral' });
    } else {
     let { key: r } = e;
     'Identifier' === r.type ? (t.key = { type: 'StringLiteral', value: r.name }) : 'NumericLiteral' === r.type && (t.key = { type: 'StringLiteral', value: String(r.value) });
    }
   }
   Lo.ignoredProperties = _o;
   var Oo = {
     bracketSpacing: { category: 'Common', type: 'boolean', default: !0, description: 'Print spaces between brackets.', oppositeDescription: 'Do not print spaces between brackets.' },
     objectWrap: {
      category: 'Common',
      type: 'choice',
      default: 'preserve',
      description: 'How to wrap object literals.',
      choices: [
       { value: 'preserve', description: 'Keep as multi-line, if there is a newline between the opening brace and first property.' },
       { value: 'collapse', description: 'Fit to a single line when possible.' },
      ],
     },
     singleQuote: { category: 'Common', type: 'boolean', default: !1, description: 'Use single quotes instead of double quotes.' },
     proseWrap: {
      category: 'Common',
      type: 'choice',
      default: 'preserve',
      description: 'How to wrap prose.',
      choices: [
       { value: 'always', description: 'Wrap prose if it exceeds the print width.' },
       { value: 'never', description: 'Do not wrap prose.' },
       { value: 'preserve', description: 'Wrap prose as-is.' },
      ],
     },
     bracketSameLine: { category: 'Common', type: 'boolean', default: !1, description: 'Put > of opening tags on the last line instead of on a new line.' },
     singleAttributePerLine: { category: 'Common', type: 'boolean', default: !1, description: 'Enforce single attribute per line in HTML, Vue and JSX.' },
    },
    Mo = 'JavaScript',
    jo = {
     arrowParens: {
      category: Mo,
      type: 'choice',
      default: 'always',
      description: 'Include parentheses around a sole arrow function parameter.',
      choices: [
       { value: 'always', description: 'Always include parens. Example: `(x) => x`' },
       { value: 'avoid', description: 'Omit parens when possible. Example: `x => x`' },
      ],
     },
     bracketSameLine: Oo.bracketSameLine,
     objectWrap: Oo.objectWrap,
     bracketSpacing: Oo.bracketSpacing,
     jsxBracketSameLine: { category: Mo, type: 'boolean', description: 'Put > on the last line instead of at a new line.', deprecated: '2.4.0' },
     semi: { category: Mo, type: 'boolean', default: !0, description: 'Print semicolons.', oppositeDescription: 'Do not print semicolons, except at the beginning of lines which may need them.' },
     experimentalOperatorPosition: {
      category: Mo,
      type: 'choice',
      default: 'end',
      description: 'Where to print operators when binary expressions wrap lines.',
      choices: [
       { value: 'start', description: 'Print operators at the start of new lines.' },
       { value: 'end', description: 'Print operators at the end of previous lines.' },
      ],
     },
     experimentalTernaries: { category: Mo, type: 'boolean', default: !1, description: 'Use curious ternaries, with the question mark after the condition.', oppositeDescription: 'Default behavior of ternaries; keep question marks on the same line as the consequent.' },
     singleQuote: Oo.singleQuote,
     jsxSingleQuote: { category: Mo, type: 'boolean', default: !1, description: 'Use single quotes in JSX.' },
     quoteProps: {
      category: Mo,
      type: 'choice',
      default: 'as-needed',
      description: 'Change when properties in objects are quoted.',
      choices: [
       { value: 'as-needed', description: 'Only add quotes around object properties where required.' },
       { value: 'consistent', description: 'If at least one property in an object requires quotes, quote all properties.' },
       { value: 'preserve', description: 'Respect the input use of quotes in object properties.' },
      ],
     },
     trailingComma: {
      category: Mo,
      type: 'choice',
      default: 'all',
      description: 'Print trailing commas wherever possible when multi-line.',
      choices: [
       { value: 'all', description: 'Trailing commas wherever possible (including function arguments).' },
       { value: 'es5', description: 'Trailing commas where valid in ES5 (objects, arrays, etc.)' },
       { value: 'none', description: 'No trailing commas.' },
      ],
     },
     singleAttributePerLine: Oo.singleAttributePerLine,
    },
    Ro = { estree: l, 'estree-json': Po },
    qo = [
     { linguistLanguageId: 183, name: 'JavaScript', type: 'programming', tmScope: 'source.js', aceMode: 'javascript', codemirrorMode: 'javascript', codemirrorMimeType: 'text/javascript', color: '#f1e05a', aliases: ['js', 'node'], extensions: ['.js', '._js', '.bones', '.cjs', '.es', '.es6', '.frag', '.gs', '.jake', '.javascript', '.jsb', '.jscad', '.jsfl', '.jslib', '.jsm', '.jspre', '.jss', '.mjs', '.njs', '.pac', '.sjs', '.ssjs', '.xsjs', '.xsjslib', '.wxs'], filenames: ['Jakefile'], interpreters: ['chakra', 'd8', 'gjs', 'js', 'node', 'nodejs', 'qjs', 'rhino', 'v8', 'v8-shell', 'zx'], parsers: ['babel', 'acorn', 'espree', 'meriyah', 'babel-flow', 'babel-ts', 'flow', 'typescript'], vscodeLanguageIds: ['javascript', 'mongo'] },
     { linguistLanguageId: 183, name: 'Flow', type: 'programming', tmScope: 'source.js', aceMode: 'javascript', codemirrorMode: 'javascript', codemirrorMimeType: 'text/javascript', color: '#f1e05a', aliases: [], extensions: ['.js.flow'], filenames: [], interpreters: ['chakra', 'd8', 'gjs', 'js', 'node', 'nodejs', 'qjs', 'rhino', 'v8', 'v8-shell'], parsers: ['flow', 'babel-flow'], vscodeLanguageIds: ['javascript'] },
     { linguistLanguageId: 183, name: 'JSX', type: 'programming', tmScope: 'source.js.jsx', aceMode: 'javascript', codemirrorMode: 'jsx', codemirrorMimeType: 'text/jsx', color: void 0, aliases: void 0, extensions: ['.jsx'], filenames: void 0, interpreters: void 0, parsers: ['babel', 'babel-flow', 'babel-ts', 'flow', 'typescript', 'espree', 'meriyah'], vscodeLanguageIds: ['javascriptreact'], group: 'JavaScript' },
     { linguistLanguageId: 378, name: 'TypeScript', type: 'programming', color: '#3178c6', aliases: ['ts'], interpreters: ['deno', 'ts-node'], extensions: ['.ts', '.cts', '.mts'], tmScope: 'source.ts', aceMode: 'typescript', codemirrorMode: 'javascript', codemirrorMimeType: 'application/typescript', parsers: ['typescript', 'babel-ts'], vscodeLanguageIds: ['typescript'] },
     { linguistLanguageId: 94901924, name: 'TSX', type: 'programming', color: '#3178c6', group: 'TypeScript', extensions: ['.tsx'], tmScope: 'source.tsx', aceMode: 'javascript', codemirrorMode: 'jsx', codemirrorMimeType: 'text/jsx', parsers: ['typescript', 'babel-ts'], vscodeLanguageIds: ['typescriptreact'] },
     { linguistLanguageId: 174, name: 'JSON.stringify', type: 'data', color: '#292929', tmScope: 'source.json', aceMode: 'json', codemirrorMode: 'javascript', codemirrorMimeType: 'application/json', aliases: ['geojson', 'jsonl', 'topojson'], extensions: ['.importmap'], filenames: ['package.json', 'package-lock.json', 'composer.json'], parsers: ['json-stringify'], vscodeLanguageIds: ['json'] },
     { linguistLanguageId: 174, name: 'JSON', type: 'data', color: '#292929', tmScope: 'source.json', aceMode: 'json', codemirrorMode: 'javascript', codemirrorMimeType: 'application/json', aliases: ['geojson', 'jsonl', 'topojson'], extensions: ['.json', '.4DForm', '.4DProject', '.avsc', '.geojson', '.gltf', '.har', '.ice', '.JSON-tmLanguage', '.mcmeta', '.tfstate', '.tfstate.backup', '.topojson', '.webapp', '.webmanifest', '.yy', '.yyp'], filenames: ['.all-contributorsrc', '.arcconfig', '.auto-changelog', '.c8rc', '.htmlhintrc', '.imgbotconfig', '.nycrc', '.tern-config', '.tern-project', '.watchmanconfig', 'Pipfile.lock', 'composer.lock', 'flake.lock', 'mcmod.info', '.babelrc', '.jscsrc', '.jshintrc', '.jslintrc', '.swcrc'], parsers: ['json'], vscodeLanguageIds: ['json'] },
     { linguistLanguageId: 423, name: 'JSON with Comments', type: 'data', color: '#292929', group: 'JSON', tmScope: 'source.js', aceMode: 'javascript', codemirrorMode: 'javascript', codemirrorMimeType: 'text/javascript', aliases: ['jsonc'], extensions: ['.jsonc', '.code-snippets', '.code-workspace', '.sublime-build', '.sublime-commands', '.sublime-completions', '.sublime-keymap', '.sublime-macro', '.sublime-menu', '.sublime-mousemap', '.sublime-project', '.sublime-settings', '.sublime-theme', '.sublime-workspace', '.sublime_metrics', '.sublime_session'], filenames: [], parsers: ['jsonc'], vscodeLanguageIds: ['jsonc'] },
     { linguistLanguageId: 175, name: 'JSON5', type: 'data', color: '#267CB9', extensions: ['.json5'], tmScope: 'source.js', aceMode: 'javascript', codemirrorMode: 'javascript', codemirrorMimeType: 'application/json', parsers: ['json5'], vscodeLanguageIds: ['json5'] },
    ],
    Uo = u;
  },
  86017: (e, t, r) => {
   r.d(t, { ZP: () => Cs });
   var n = Object.defineProperty,
    s = (e) => {
     throw TypeError(e);
    },
    i = (e, t) => {
     for (var r in t) n(e, r, { get: t[r], enumerable: !0 });
    },
    a = (e, t, r) => ((e, t, r) => (t in e ? n(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : (e[t] = r)))(e, 'symbol' != typeof t ? t + '' : t, r),
    o = (e, t, r) => t.has(e) || s('Cannot ' + r),
    u = (e, t, r) => (o(e, t, 'read from private field'), r ? r.call(e) : t.get(e)),
    l = (e, t, r) => (t.has(e) ? s('Cannot add the same private member more than once') : t instanceof WeakSet ? t.add(e) : t.set(e, r)),
    p = {};
   i(p, { languages: () => Pr, options: () => Br, parsers: () => _r, printers: () => Es });
   var c = (e, t, r, n) => {
     if (!e || null != t) return t.replaceAll ? t.replaceAll(r, n) : r.global ? t.replace(r, n) : t.split(r).join(n);
    },
    h = 'string',
    d = 'array',
    f = 'cursor',
    m = 'indent',
    y = 'align',
    g = 'trim',
    D = 'group',
    x = 'fill',
    b = 'if-break',
    v = 'indent-if-break',
    E = 'line-suffix',
    C = 'line-suffix-boundary',
    T = 'line',
    S = 'label',
    w = 'break-parent',
    A = new Set([f, m, y, g, D, x, b, v, E, C, T, S, w]),
    F = (e, t, r) => {
     if (!e || null != t) return Array.isArray(t) || 'string' == typeof t ? t[r < 0 ? t.length + r : r] : t.at(r);
    };
   var k = function (e) {
    if ('string' == typeof e) return h;
    if (Array.isArray(e)) return d;
    if (!e) return;
    let { type: t } = e;
    return A.has(t) ? t : void 0;
   };
   function P(e) {
    let t = null === e ? 'null' : typeof e;
    if ('string' !== t && 'object' !== t) return `Unexpected doc '${t}', \nExpected it to be 'string' or 'object'.`;
    if (k(e)) throw new Error('doc is valid.');
    let r = Object.prototype.toString.call(e);
    if ('[object Object]' !== r) return `Unexpected doc '${r}'.`;
    let n = ((e) => new Intl.ListFormat('en-US', { type: 'disjunction' }).format(e))([...A].map((e) => `'${e}'`));
    return `Unexpected doc.type '${e.type}'.\nExpected it to be ${n}.`;
   }
   var I = class extends Error {
    name = 'InvalidDocError';
    constructor(e) {
     super(P(e)), (this.doc = e);
    }
   };
   function N(e, t) {
    if ('string' == typeof e) return t(e);
    let r = new Map();
    return n(e);
    function n(e) {
     if (r.has(e)) return r.get(e);
     let s = (function (e) {
      switch (k(e)) {
       case d:
        return t(e.map(n));
       case x:
        return t({ ...e, parts: e.parts.map(n) });
       case b:
        return t({ ...e, breakContents: n(e.breakContents), flatContents: n(e.flatContents) });
       case D: {
        let { expandedStates: r, contents: s } = e;
        return r ? ((r = r.map(n)), (s = r[0])) : (s = n(s)), t({ ...e, contents: s, expandedStates: r });
       }
       case y:
       case m:
       case v:
       case S:
       case E:
        return t({ ...e, contents: n(e.contents) });
       case h:
       case f:
       case g:
       case C:
       case T:
       case w:
        return t(e);
       default:
        throw new I(e);
      }
     })(e);
     return r.set(e, s), s;
    }
   }
   function B(e, t = J) {
    return N(e, (e) => ('string' == typeof e ? K(t, e.split('\n')) : e));
   }
   var _ = () => {},
    L = _,
    O = _,
    M = _;
   function j(e) {
    return L(e), { type: m, contents: e };
   }
   function R(e, t) {
    return L(t), { type: y, contents: t, n: e };
   }
   function q(e, t = {}) {
    return L(e), O(t.expandedStates, !0), { type: D, id: t.id, contents: e, break: !!t.shouldBreak, expandedStates: t.expandedStates };
   }
   function U(e) {
    return M(e), { type: x, parts: e };
   }
   function $(e, t = '', r = {}) {
    return L(e), '' !== t && L(t), { type: b, breakContents: e, flatContents: t, groupId: r.groupId };
   }
   var H = { type: w },
    z = { type: T },
    V = { type: T, soft: !0 },
    W = [{ type: T, hard: !0 }, H],
    J = [{ type: T, hard: !0, literal: !0 }, H];
   function K(e, t) {
    L(e), O(t);
    let r = [];
    for (let n = 0; n < t.length; n++) 0 !== n && r.push(e), r.push(t[n]);
    return r;
   }
   var G = "'";
   var X = function (e, t) {
    let r = !0 === t || t === G ? G : '"',
     n = r === G ? '"' : G,
     s = 0,
     i = 0;
    for (let a of e) a === r ? s++ : a === n && i++;
    return s > i ? n : r;
   };
   var Y;
   Y = new WeakMap();
   var Q = class {
     constructor(e) {
      l(this, Y),
       ((e, t, r, n) => {
        o(e, t, 'write to private field'), n ? n.call(e, r) : t.set(e, r);
       })(this, Y, new Set(e));
     }
     getLeadingWhitespaceCount(e) {
      let t = u(this, Y),
       r = 0;
      for (let n = 0; n < e.length && t.has(e.charAt(n)); n++) r++;
      return r;
     }
     getTrailingWhitespaceCount(e) {
      let t = u(this, Y),
       r = 0;
      for (let n = e.length - 1; n >= 0 && t.has(e.charAt(n)); n--) r++;
      return r;
     }
     getLeadingWhitespace(e) {
      let t = this.getLeadingWhitespaceCount(e);
      return e.slice(0, t);
     }
     getTrailingWhitespace(e) {
      let t = this.getTrailingWhitespaceCount(e);
      return e.slice(e.length - t);
     }
     hasLeadingWhitespace(e) {
      return u(this, Y).has(e.charAt(0));
     }
     hasTrailingWhitespace(e) {
      return u(this, Y).has(F(!1, e, -1));
     }
     trimStart(e) {
      let t = this.getLeadingWhitespaceCount(e);
      return e.slice(t);
     }
     trimEnd(e) {
      let t = this.getTrailingWhitespaceCount(e);
      return e.slice(0, e.length - t);
     }
     trim(e) {
      return this.trimEnd(this.trimStart(e));
     }
     split(e, t = !1) {
      let r = `[${(function (e) {
        if ('string' != typeof e) throw new TypeError('Expected a string');
        return e.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&').replace(/-/g, '\\x2d');
       })([...u(this, Y)].join(''))}]+`,
       n = new RegExp(t ? `(${r})` : r, 'u');
      return e.split(n);
     }
     hasWhitespaceCharacter(e) {
      let t = u(this, Y);
      return Array.prototype.some.call(e, (e) => t.has(e));
     }
     hasNonWhitespaceCharacter(e) {
      let t = u(this, Y);
      return Array.prototype.some.call(e, (e) => !t.has(e));
     }
     isWhitespaceOnly(e) {
      let t = u(this, Y);
      return Array.prototype.every.call(e, (e) => t.has(e));
     }
    },
    Z = new Q(['\t', '\n', '\f', '\r', ' ']),
    ee = class extends Error {
     name = 'UnexpectedNodeError';
     constructor(e, t, r = 'type') {
      super(`Unexpected ${t} node ${r}: ${JSON.stringify(e[r])}.`), (this.node = e);
     }
    };
   var te = function (e) {
     return 'front-matter' === (null == e ? void 0 : e.type);
    },
    re = new Set(['sourceSpan', 'startSourceSpan', 'endSourceSpan', 'nameSpan', 'valueSpan', 'keySpan', 'tagDefinition', 'tokens', 'valueTokens', 'switchValueSourceSpan', 'expSourceSpan', 'valueSourceSpan']),
    ne = new Set(['if', 'else if', 'for', 'switch', 'case']);
   function se(e, t) {
    var r;
    if ('text' === e.type || 'comment' === e.type || te(e) || 'yaml' === e.type || 'toml' === e.type) return null;
    if (('attribute' === e.type && delete t.value, 'docType' === e.type && delete t.value, 'angularControlFlowBlock' === e.type && null != (r = e.parameters) && r.children)) for (let n of t.parameters.children) ne.has(e.name) ? delete n.expression : (n.expression = n.expression.trim());
    'angularIcuExpression' === e.type && (t.switchValue = e.switchValue.trim()), 'angularLetDeclarationInitializer' === e.type && delete t.value;
   }
   se.ignoredProperties = re;
   var ie = se;
   var ae = async function (e, t) {
    if ('yaml' === e.language) {
     let r = e.value.trim(),
      n = r ? await t(r, { parser: 'yaml' }) : '';
     return (function (e) {
      return R({ type: 'root' }, e);
     })([e.startDelimiter, e.explicitLanguage, W, n, n ? W : '', e.endDelimiter]);
    }
   };
   function oe(e, t = !0) {
    return [j([V, e]), t ? V : ''];
   }
   function ue(e, t) {
    let r = 'NGRoot' === e.type ? ('NGMicrosyntax' === e.node.type && 1 === e.node.body.length && 'NGMicrosyntaxExpression' === e.node.body[0].type ? e.node.body[0].expression : e.node) : 'JsExpressionRoot' === e.type ? e.node : e;
    return r && ('ObjectExpression' === r.type || 'ArrayExpression' === r.type || (('__vue_expression' === t.parser || '__vue_ts_expression' === t.parser) && ('TemplateLiteral' === r.type || 'StringLiteral' === r.type)));
   }
   async function le(e, t, r, n) {
    r = { __isInHtmlAttribute: !0, __embeddedInHtml: !0, ...r };
    let s = !0;
    n &&
     (r.__onHtmlBindingRoot = (e, t) => {
      s = n(e, t);
     });
    let i = await t(e, r, t);
    return s ? q(i) : oe(i);
   }
   var pe = function (e, t, r, n) {
     let { node: s } = r,
      i = n.originalText.slice(s.sourceSpan.start.offset, s.sourceSpan.end.offset);
     return /^\s*$/u.test(i) ? '' : le(i, e, { parser: '__ng_directive', __isInHtmlAttribute: !1 }, ue);
    },
    ce = (e) => String(e).split(/[/\\]/u).pop();
   function he(e, t) {
    if (!t) return;
    let r = ce(t).toLowerCase();
    return e.find(({ filenames: e }) => (null == e ? void 0 : e.some((e) => e.toLowerCase() === r))) ?? e.find(({ extensions: e }) => (null == e ? void 0 : e.some((e) => r.endsWith(e))));
   }
   var de = function (e, t) {
     let r = e.plugins.flatMap((e) => e.languages ?? []),
      n =
       (function (e, t) {
        if (t) return e.find(({ name: e }) => e.toLowerCase() === t) ?? e.find(({ aliases: e }) => (null == e ? void 0 : e.includes(t))) ?? e.find(({ extensions: e }) => (null == e ? void 0 : e.includes(`.${t}`)));
       })(r, t.language) ??
       he(r, t.physicalFile) ??
       he(r, t.file) ??
       void t.physicalFile;
     return null == n ? void 0 : n.parsers[0];
    },
    fe = 'inline',
    me = { area: 'none', base: 'none', basefont: 'none', datalist: 'none', head: 'none', link: 'none', meta: 'none', noembed: 'none', noframes: 'none', param: 'block', rp: 'none', script: 'block', style: 'none', template: 'inline', title: 'none', html: 'block', body: 'block', address: 'block', blockquote: 'block', center: 'block', dialog: 'block', div: 'block', figure: 'block', figcaption: 'block', footer: 'block', form: 'block', header: 'block', hr: 'block', legend: 'block', listing: 'block', main: 'block', p: 'block', plaintext: 'block', pre: 'block', search: 'block', xmp: 'block', slot: 'contents', ruby: 'ruby', rt: 'ruby-text', article: 'block', aside: 'block', h1: 'block', h2: 'block', h3: 'block', h4: 'block', h5: 'block', h6: 'block', hgroup: 'block', nav: 'block', section: 'block', dir: 'block', dd: 'block', dl: 'block', dt: 'block', menu: 'block', ol: 'block', ul: 'block', li: 'list-item', table: 'table', caption: 'table-caption', colgroup: 'table-column-group', col: 'table-column', thead: 'table-header-group', tbody: 'table-row-group', tfoot: 'table-footer-group', tr: 'table-row', td: 'table-cell', th: 'table-cell', input: 'inline-block', button: 'inline-block', fieldset: 'block', details: 'block', summary: 'block', marquee: 'inline-block', source: 'block', track: 'block', meter: 'inline-block', progress: 'inline-block', object: 'inline-block', video: 'inline-block', audio: 'inline-block', select: 'inline-block', option: 'block', optgroup: 'block' },
    ye = 'normal',
    ge = { listing: 'pre', plaintext: 'pre', pre: 'pre', xmp: 'pre', nobr: 'nowrap', table: 'initial', textarea: 'pre-wrap' };
   var De = function (e) {
     return 'element' === e.type && !e.hasExplicitNamespace && !['html', 'svg'].includes(e.namespace);
    },
    xe = (e) => ((e) => c(!1, e, /^[\t\f\r ]*\n/gu, ''))(Z.trimEnd(e)),
    be = (e) => {
     let t = e,
      r = Z.getLeadingWhitespace(t);
     r && (t = t.slice(r.length));
     let n = Z.getTrailingWhitespace(t);
     return n && (t = t.slice(0, -n.length)), { leadingWhitespace: r, trailingWhitespace: n, text: t };
    };
   function ve(e, t) {
    return !!(('ieConditionalComment' === e.type && e.lastChild && !e.lastChild.isSelfClosing && !e.lastChild.endSourceSpan) || ('ieConditionalComment' === e.type && !e.complete) || (Ue(e) && e.children.some((e) => 'text' !== e.type && 'interpolation' !== e.type)) || (Ge(e, t) && !Te(e) && 'interpolation' !== e.type));
   }
   function Ee(e) {
    return (
     !('attribute' === e.type || !e.parent || !e.prev) &&
     (function (e) {
      return 'comment' === e.type && 'prettier-ignore' === e.value.trim();
     })(e.prev)
    );
   }
   function Ce(e) {
    return 'text' === e.type || 'comment' === e.type;
   }
   function Te(e) {
    return 'element' === e.type && ('script' === e.fullName || 'style' === e.fullName || 'svg:style' === e.fullName || 'svg:script' === e.fullName || (De(e) && ('script' === e.name || 'style' === e.name)));
   }
   function Se(e) {
    return $e(e).startsWith('pre');
   }
   function we(e, t) {
    var r, n;
    let s = !(
     te(e) ||
     'angularControlFlowBlock' === e.type ||
     ((('text' !== e.type && 'interpolation' !== e.type) || !e.prev || ('text' !== e.prev.type && 'interpolation' !== e.prev.type)) &&
      (!e.parent ||
       'none' === e.parent.cssDisplay ||
       (!Ue(e.parent) &&
        ((!e.prev &&
         ('root' === e.parent.type ||
          (Ue(e) && e.parent) ||
          Te(e.parent) ||
          Je(e.parent, t) ||
          !(function (e) {
           return !qe(e) && 'inline-block' !== e;
          })(e.parent.cssDisplay))) ||
         (e.prev &&
          !(function (e) {
           return !qe(e);
          })(e.prev.cssDisplay))))))
    );
    return s && !e.prev && null != (n = null == (r = e.parent) ? void 0 : r.tagDefinition) && n.ignoreFirstLf ? 'interpolation' === e.type : s;
   }
   function Ae(e, t) {
    return (
     !te(e) &&
     'angularControlFlowBlock' !== e.type &&
     (!(('text' !== e.type && 'interpolation' !== e.type) || !e.next || ('text' !== e.next.type && 'interpolation' !== e.next.type)) ||
      (!(!e.parent || 'none' === e.parent.cssDisplay) &&
       (!!Ue(e.parent) ||
        !(
         (!e.next &&
          ('root' === e.parent.type ||
           (Ue(e) && e.parent) ||
           Te(e.parent) ||
           Je(e.parent, t) ||
           !(function (e) {
            return !qe(e) && 'inline-block' !== e;
           })(e.parent.cssDisplay))) ||
         (e.next &&
          !(function (e) {
           return !qe(e);
          })(e.next.cssDisplay))
        ))))
    );
   }
   function Fe(e) {
    return (
     (function (e) {
      return !qe(e) && 'inline-block' !== e;
     })(e.cssDisplay) && !Te(e)
    );
   }
   function ke(e) {
    return te(e) || (e.next && e.sourceSpan.end && e.sourceSpan.end.line + 1 < e.next.sourceSpan.start.line);
   }
   function Pe(e) {
    return (
     Ie(e) ||
     ('element' === e.type &&
      e.children.length > 0 &&
      (['body', 'script', 'style'].includes(e.name) ||
       e.children.some((e) =>
        (function (e) {
         var t;
         return null == (t = e.children) ? void 0 : t.some((e) => 'text' !== e.type);
        })(e),
       ))) ||
     (e.firstChild && e.firstChild === e.lastChild && 'text' !== e.firstChild.type && _e(e.firstChild) && (!e.lastChild.isTrailingSpaceSensitive || Le(e.lastChild)))
    );
   }
   function Ie(e) {
    return 'element' === e.type && e.children.length > 0 && (['html', 'head', 'ul', 'ol', 'select'].includes(e.name) || (e.cssDisplay.startsWith('table') && 'table-cell' !== e.cssDisplay));
   }
   function Ne(e) {
    return (
     Oe(e) ||
     (e.prev &&
      (function (e) {
       return Oe(e) || ('element' === e.type && 'br' === e.fullName) || Be(e);
      })(e.prev)) ||
     Be(e)
    );
   }
   function Be(e) {
    return _e(e) && Le(e);
   }
   function _e(e) {
    return e.hasLeadingSpaces && (e.prev ? e.prev.sourceSpan.end.line < e.sourceSpan.start.line : 'root' === e.parent.type || e.parent.startSourceSpan.end.line < e.sourceSpan.start.line);
   }
   function Le(e) {
    return e.hasTrailingSpaces && (e.next ? e.next.sourceSpan.start.line > e.sourceSpan.end.line : 'root' === e.parent.type || (e.parent.endSourceSpan && e.parent.endSourceSpan.start.line > e.sourceSpan.end.line));
   }
   function Oe(e) {
    switch (e.type) {
     case 'ieConditionalComment':
     case 'comment':
     case 'directive':
      return !0;
     case 'element':
      return ['script', 'select'].includes(e.name);
    }
    return !1;
   }
   function Me(e) {
    return e.lastChild ? Me(e.lastChild) : e;
   }
   function je(e) {
    if (e)
     switch (e) {
      case 'module':
      case 'text/javascript':
      case 'text/babel':
      case 'application/javascript':
       return 'babel';
      case 'application/x-typescript':
       return 'typescript';
      case 'text/markdown':
       return 'markdown';
      case 'text/html':
       return 'html';
      case 'text/x-handlebars-template':
       return 'glimmer';
      default:
       if (e.endsWith('json') || e.endsWith('importmap') || 'speculationrules' === e) return 'json';
     }
   }
   function Re(e, t) {
    return (
     (function (e, t) {
      let { name: r, attrMap: n } = e;
      if ('script' !== r || Object.prototype.hasOwnProperty.call(n, 'src')) return;
      let { type: s, lang: i } = e.attrMap;
      return i || s ? (de(t, { language: i }) ?? je(s)) : 'babel';
     })(e, t) ??
     (function (e, t) {
      if ('style' !== e.name) return;
      let { lang: r } = e.attrMap;
      return r ? de(t, { language: r }) : 'css';
     })(e, t) ??
     (function (e, t) {
      if (!Ge(e, t)) return;
      let { attrMap: r } = e;
      if (Object.prototype.hasOwnProperty.call(r, 'src')) return;
      let { type: n, lang: s } = r;
      return de(t, { language: s }) ?? je(n);
     })(e, t)
    );
   }
   function qe(e) {
    return 'block' === e || 'list-item' === e || e.startsWith('table');
   }
   function Ue(e) {
    return $e(e).startsWith('pre');
   }
   function $e(e) {
    return ('element' === e.type && (!e.namespace || De(e)) && ge[e.name]) || ye;
   }
   function He(
    e,
    t = (function (e) {
     let t = Number.POSITIVE_INFINITY;
     for (let r of e.split('\n')) {
      if (0 === r.length) continue;
      let e = Z.getLeadingWhitespaceCount(r);
      if (0 === e) return 0;
      r.length !== e && e < t && (t = e);
     }
     return t === Number.POSITIVE_INFINITY ? 0 : t;
    })(e),
   ) {
    return 0 === t
     ? e
     : e
        .split('\n')
        .map((e) => e.slice(t))
        .join('\n');
   }
   function ze(e) {
    return c(!1, c(!1, e, '&apos;', "'"), '&quot;', '"');
   }
   function Ve(e) {
    return ze(e.value);
   }
   var We = new Set(['template', 'style', 'script']);
   function Je(e, t) {
    return Ke(e, t) && !We.has(e.fullName);
   }
   function Ke(e, t) {
    return 'vue' === t.parser && 'element' === e.type && 'root' === e.parent.type && 'html' !== e.fullName.toLowerCase();
   }
   function Ge(e, t) {
    return Ke(e, t) && (Je(e, t) || (e.attrMap.lang && 'html' !== e.attrMap.lang));
   }
   function Xe(e, t = e.value) {
    return e.parent.isWhitespaceSensitive ? (e.parent.isIndentationSensitive ? B(t) : B(He(xe(t)), W)) : K(z, Z.split(t));
   }
   function Ye(e, t) {
    return Ke(e, t) && 'script' === e.name;
   }
   var Qe = /\{\{(.+?)\}\}/su;
   function Ze({ parser: e }) {
    return (t, r, n) => le(Ve(n.node), t, { parser: e }, ue);
   }
   var et = Ze({ parser: '__ng_action' }),
    tt = Ze({ parser: '__ng_binding' }),
    rt = Ze({ parser: '__ng_directive' });
   var nt = function (e, t) {
    if ('angular' !== t.parser) return;
    let { node: r } = e,
     n = r.fullName;
    if ((n.startsWith('(') && n.endsWith(')')) || n.startsWith('on-')) return et;
    if ((n.startsWith('[') && n.endsWith(']')) || /^bind(?:on)?-/u.test(n) || /^ng-(?:if|show|hide|class|style)$/u.test(n)) return tt;
    if (n.startsWith('*')) return rt;
    let s = Ve(r);
    return /^i18n(?:-.+)?$/u.test(n)
     ? () => oe(U(Xe(r, s.trim())), !s.includes('@@'))
     : Qe.test(s)
       ? (e) =>
          (async function (e, t) {
           let r = [];
           for (let [n, s] of e.split(Qe).entries())
            if (n % 2 == 0) r.push(B(s));
            else
             try {
              r.push(q(['{{', j([z, await le(s, t, { parser: '__ng_interpolation', __isInHtmlInterpolation: !0 })]), z, '}}']));
             } catch {
              r.push('{{', B(s), '}}');
             }
           return r;
          })(s, e)
       : void 0;
   };
   var st = function (e, t) {
    let { node: r } = e,
     n = Ve(r);
    if ('class' === r.fullName && !t.parentParser && !n.includes('{{')) return () => n.trim().split(/\s+/u).join(' ');
   };
   function it(e) {
    return '\t' === e || '\n' === e || '\f' === e || '\r' === e || ' ' === e;
   }
   var at = /^[ \t\n\r\u000c]+/,
    ot = /^[, \t\n\r\u000c]+/,
    ut = /^[^ \t\n\r\u000c]+/,
    lt = /[,]+$/,
    pt = /^\d+$/,
    ct = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/;
   var ht = function (e) {
    let t,
     r,
     n,
     s,
     i,
     a,
     o = e.length,
     u = 0;
    function l(t) {
     let r,
      n = t.exec(e.substring(u));
     if (n) return ([r] = n), (u += r.length), r;
    }
    let p = [];
    for (;;) {
     if ((l(ot), u >= o)) {
      if (0 === p.length) throw new Error('Must contain one or more image candidate strings.');
      return p;
     }
     (a = u), (t = l(ut)), (r = []), ',' === t.slice(-1) ? ((t = t.replace(lt, '')), h()) : c();
    }
    function c() {
     for (l(at), n = '', s = 'in descriptor'; ; ) {
      if (((i = e.charAt(u)), 'in descriptor' === s))
       if (it(i)) n && (r.push(n), (n = ''), (s = 'after descriptor'));
       else {
        if (',' === i) return (u += 1), n && r.push(n), void h();
        if ('(' === i) (n += i), (s = 'in parens');
        else {
         if ('' === i) return n && r.push(n), void h();
         n += i;
        }
       }
      else if ('in parens' === s)
       if (')' === i) (n += i), (s = 'in descriptor');
       else {
        if ('' === i) return r.push(n), void h();
        n += i;
       }
      else if ('after descriptor' === s && !it(i)) {
       if ('' === i) return void h();
       (s = 'in descriptor'), (u -= 1);
      }
      u += 1;
     }
    }
    function h() {
     let n,
      s,
      i,
      o,
      u,
      l,
      c,
      h,
      d,
      f = !1,
      m = {};
     for (o = 0; o < r.length; o++) (u = r[o]), (l = u[u.length - 1]), (c = u.substring(0, u.length - 1)), (h = parseInt(c, 10)), (d = parseFloat(c)), pt.test(c) && 'w' === l ? ((n || s) && (f = !0), 0 === h ? (f = !0) : (n = h)) : ct.test(c) && 'x' === l ? ((n || s || i) && (f = !0), d < 0 ? (f = !0) : (s = d)) : pt.test(c) && 'h' === l ? ((i || s) && (f = !0), 0 === h ? (f = !0) : (i = h)) : (f = !0);
     if (f) throw new Error(`Invalid srcset descriptor found in "${e}" at "${u}".`);
     (m.source = { value: t, startOffset: a }), n && (m.width = { value: n }), s && (m.density = { value: s }), i && (m.height = { value: i }), p.push(m);
    }
   };
   var dt = { width: 'w', height: 'h', density: 'x' },
    ft = Object.keys(dt);
   var mt = function (e) {
    if ('srcset' === e.node.fullName && ('img' === e.parent.fullName || 'source' === e.parent.fullName))
     return () =>
      (function (e) {
       let t = ht(e),
        r = ft.filter((e) => t.some((t) => Object.prototype.hasOwnProperty.call(t, e)));
       if (r.length > 1) throw new Error('Mixed descriptor in srcset is not supported');
       let [n] = r,
        s = dt[n],
        i = t.map((e) => e.source.value),
        a = Math.max(...i.map((e) => e.length)),
        o = t.map((e) => (e[n] ? String(e[n].value) : '')),
        u = o.map((e) => {
         let t = e.indexOf('.');
         return -1 === t ? e.length : t;
        }),
        l = Math.max(...u);
       return oe(
        K(
         [',', z],
         i.map((e, t) => {
          let r = [e],
           n = o[t];
          if (n) {
           let i = a - e.length + 1,
            o = l - u[t],
            p = ' '.repeat(i + o);
           r.push($(p, ' '), n + s);
          }
          return r;
         }),
        ),
       );
      })(Ve(e.node));
   };
   function yt(e, t) {
    let { node: r } = e,
     n = Ve(e.node).trim();
    if ('style' === r.fullName && !t.parentParser && !n.includes('{{')) return async (e) => oe(await e(n, { parser: 'css', __isHTMLStyleAttribute: !0 }));
   }
   var gt = new WeakMap();
   var Dt = function (e, t) {
    let { root: r } = e;
    return (
     gt.has(r) ||
      gt.set(
       r,
       r.children.some((e) => Ye(e, t) && ['ts', 'typescript'].includes(e.attrMap.lang)),
      ),
     gt.get(r)
    );
   };
   function xt(e, t, r) {
    let { node: n } = r;
    return le(`type T<${Ve(n)}> = any`, e, { parser: 'babel-ts', __isEmbeddedTypescriptGenericParameters: !0 }, ue);
   }
   async function bt(e, t, r, n) {
    let s = Ve(r.node),
     {
      left: i,
      operator: a,
      right: o,
     } = (function (e) {
      let t = /(.*?)\s+(in|of)\s+(.*)/su,
       r = /,([^,\]}]*)(?:,([^,\]}]*))?$/u,
       n = /^\(|\)$/gu,
       s = e.match(t);
      if (!s) return;
      let i = {};
      if (((i.for = s[3].trim()), !i.for)) return;
      let a = c(!1, s[1].trim(), n, ''),
       o = a.match(r);
      o ? ((i.alias = a.replace(r, '')), (i.iterator1 = o[1].trim()), o[2] && (i.iterator2 = o[2].trim())) : (i.alias = a);
      let u = [i.alias, i.iterator1, i.iterator2];
      if (!u.some((e, t) => !e && (0 === t || u.slice(t + 1).some(Boolean)))) return { left: u.filter(Boolean).join(','), operator: s[2], right: i.for };
     })(s),
     u = Dt(r, n);
    return [q(await le(`function _(${i}) {}`, e, { parser: u ? 'babel-ts' : 'babel', __isVueForBindingLeft: !0 })), ' ', a, ' ', await le(o, e, { parser: u ? '__ts_expression' : '__js_expression' })];
   }
   function vt(e, t, { parseWithTs: r }) {
    return le(e, t, { parser: r ? '__ts_expression' : '__js_expression' }, ue);
   }
   var Et = function (e, t) {
    if ('vue' !== t.parser) return;
    let { node: r } = e,
     n = r.fullName;
    if ('v-for' === n) return bt;
    if ('generic' === n && Ye(r.parent, t)) return xt;
    let s = Ve(r),
     i = Dt(e, t);
    return (function (e) {
     let t = e.fullName;
     return '#' === t.charAt(0) || 'slot-scope' === t || 'v-slot' === t || t.startsWith('v-slot:');
    })(r) ||
     (function (e, t) {
      let r = e.parent;
      if (!Ke(r, t)) return !1;
      let n = r.fullName,
       s = e.fullName;
      return ('script' === n && 'setup' === s) || ('style' === n && 'vars' === s);
     })(r, t)
     ? (e) =>
        (function (e, t, { parseWithTs: r }) {
         return le(`function _(${e}) {}`, t, { parser: r ? 'babel-ts' : 'babel', __isVueBindings: !0 });
        })(s, e, { parseWithTs: i })
     : n.startsWith('@') || n.startsWith('v-on:')
       ? (e) =>
          (async function (e, t, { parseWithTs: r }) {
           var n;
           try {
            return await vt(e, t, { parseWithTs: r });
           } catch (s) {
            if ('BABEL_PARSER_SYNTAX_ERROR' !== (null == (n = s.cause) ? void 0 : n.code)) throw s;
           }
           return le(e, t, { parser: r ? '__vue_ts_event_binding' : '__vue_event_binding' }, ue);
          })(s, e, { parseWithTs: i })
       : n.startsWith(':') || n.startsWith('.') || n.startsWith('v-bind:')
         ? (e) =>
            (function (e, t, { parseWithTs: r }) {
             return le(e, t, { parser: r ? '__vue_ts_expression' : '__vue_expression' }, ue);
            })(s, e, { parseWithTs: i })
         : n.startsWith('v-')
           ? (e) => vt(s, e, { parseWithTs: i })
           : void 0;
   };
   function Ct(e) {
    return async (t, r, n, s) => {
     let i = await e(t, r, n, s);
     if (i) return (i = N(i, (e) => ('string' == typeof e ? c(!1, e, '"', '&quot;') : e))), [n.node.rawName, '="', q(i), '"'];
    };
   }
   var Tt = function (e, t) {
     let { node: r } = e;
     if (r.value) {
      if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/u.test(t.originalText.slice(r.valueSpan.start.offset, r.valueSpan.end.offset)) || ('lwc' === t.parser && r.value.startsWith('{') && r.value.endsWith('}'))) return [r.rawName, '=', r.value];
      for (let r of [mt, yt, st, Et, nt]) {
       let n = r(e, t);
       if (n) return Ct(n);
      }
     }
    },
    St = new Proxy(() => {}, { get: () => St }),
    wt = St;
   var At = function (e) {
    return Array.isArray(e) && e.length > 0;
   };
   function Ft(e) {
    return e.sourceSpan.start.offset;
   }
   function kt(e) {
    return e.sourceSpan.end.offset;
   }
   function Pt(e, t) {
    return [e.isSelfClosing ? '' : It(e, t), Nt(e, t)];
   }
   function It(e, t) {
    return e.lastChild && qt(e.lastChild) ? '' : [Bt(e, t), Lt(e, t)];
   }
   function Nt(e, t) {
    return (e.next ? jt(e.next) : Rt(e.parent)) ? '' : [Ot(e, t), _t(e, t)];
   }
   function Bt(e, t) {
    return Rt(e) ? Ot(e.lastChild, t) : '';
   }
   function _t(e, t) {
    return qt(e) ? Lt(e.parent, t) : Ut(e) ? Gt(e.next, t) : '';
   }
   function Lt(e, t) {
    if ((wt(!e.isSelfClosing), Mt(e, t))) return '';
    switch (e.type) {
     case 'ieConditionalComment':
      return '<!';
     case 'element':
      if (e.hasHtmComponentClosingTag) return '<//';
     default:
      return `</${e.rawName}`;
    }
   }
   function Ot(e, t) {
    if (Mt(e, t)) return '';
    switch (e.type) {
     case 'ieConditionalComment':
     case 'ieConditionalEndComment':
      return '[endif]--\x3e';
     case 'ieConditionalStartComment':
      return ']>\x3c!--\x3e';
     case 'interpolation':
      return '}}';
     case 'angularIcuExpression':
      return '}';
     case 'element':
      if (e.isSelfClosing) return '/>';
     default:
      return '>';
    }
   }
   function Mt(e, t) {
    return !e.isSelfClosing && !e.endSourceSpan && (Ee(e) || ve(e.parent, t));
   }
   function jt(e) {
    return e.prev && 'docType' !== e.prev.type && 'angularControlFlowBlock' !== e.type && !Ce(e.prev) && e.isLeadingSpaceSensitive && !e.hasLeadingSpaces;
   }
   function Rt(e) {
    var t;
    return (null == (t = e.lastChild) ? void 0 : t.isTrailingSpaceSensitive) && !e.lastChild.hasTrailingSpaces && !Ce(Me(e.lastChild)) && !Ue(e);
   }
   function qt(e) {
    return !e.next && !e.hasTrailingSpaces && e.isTrailingSpaceSensitive && Ce(Me(e));
   }
   function Ut(e) {
    return e.next && !Ce(e.next) && Ce(e) && e.isTrailingSpaceSensitive && !e.hasTrailingSpaces;
   }
   function $t(e) {
    return !e.prev && e.isLeadingSpaceSensitive && !e.hasLeadingSpaces;
   }
   function Ht(e, t, r) {
    var n;
    let { node: s } = e;
    if (!At(s.attrs)) return s.isSelfClosing ? ' ' : '';
    let i =
      'comment' === (null == (n = s.prev) ? void 0 : n.type) &&
      (function (e) {
       let t = e.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/su);
       return !!t && (!t[1] || t[1].split(/\s+/u));
      })(s.prev.value),
     a = 'boolean' == typeof i ? () => i : Array.isArray(i) ? (e) => i.includes(e.rawName) : () => !1,
     o = e.map(({ node: e }) => (a(e) ? B(t.originalText.slice(Ft(e), kt(e))) : r()), 'attrs'),
     u = 'element' === s.type && 'script' === s.fullName && 1 === s.attrs.length && 'src' === s.attrs[0].fullName && 0 === s.children.length,
     l = t.singleAttributePerLine && s.attrs.length > 1 && !Ke(s, t) ? W : z,
     p = [j([u ? ' ' : z, K(l, o)])];
    return (s.firstChild && $t(s.firstChild)) || (s.isSelfClosing && Rt(s.parent)) || u ? p.push(s.isSelfClosing ? ' ' : '') : p.push(t.bracketSameLine ? (s.isSelfClosing ? ' ' : '') : s.isSelfClosing ? z : V), p;
   }
   function zt(e) {
    return e.firstChild && $t(e.firstChild) ? '' : Xt(e);
   }
   function Vt(e, t, r) {
    let { node: n } = e;
    return [Wt(n, t), Ht(e, t, r), n.isSelfClosing ? '' : zt(n)];
   }
   function Wt(e, t) {
    return e.prev && Ut(e.prev) ? '' : [Jt(e, t), Gt(e, t)];
   }
   function Jt(e, t) {
    return $t(e) ? Xt(e.parent) : jt(e) ? Ot(e.prev, t) : '';
   }
   var Kt = '<!doctype';
   function Gt(e, t) {
    switch (e.type) {
     case 'ieConditionalComment':
     case 'ieConditionalStartComment':
      return `\x3c!--[if ${e.condition}`;
     case 'ieConditionalEndComment':
      return '\x3c!--<!';
     case 'interpolation':
      return '{{';
     case 'docType':
      if ('html' === e.value) {
       let e = t.filepath ?? '';
       if (/\.html?$/u.test(e)) return Kt;
      }
      return t.originalText.slice(Ft(e), kt(e)).slice(0, Kt.length);
     case 'angularIcuExpression':
      return '{';
     case 'element':
      if (e.condition) return `\x3c!--[if ${e.condition}]>\x3c!--\x3e<${e.rawName}`;
     default:
      return `<${e.rawName}`;
    }
   }
   function Xt(e) {
    switch ((wt(!e.isSelfClosing), e.type)) {
     case 'ieConditionalComment':
      return ']>';
     case 'element':
      if (e.condition) return '>\x3c!--<![endif]--\x3e';
     default:
      return '>';
    }
   }
   var Yt = function (e, t) {
     if (!e.endSourceSpan) return '';
     let r = e.startSourceSpan.end.offset;
     e.firstChild && $t(e.firstChild) && (r -= Xt(e).length);
     let n = e.endSourceSpan.start.offset;
     return e.lastChild && qt(e.lastChild) ? (n += Lt(e, t).length) : Rt(e) && (n -= Ot(e.lastChild, t).length), t.originalText.slice(r, n);
    },
    Qt = new Set(['if', 'else if', 'for', 'switch', 'case']);
   var Zt = function (e, t) {
     let { node: r } = e;
     switch (r.type) {
      case 'element':
       if (Te(r) || 'interpolation' === r.type) return;
       if (!r.isSelfClosing && Ge(r, t)) {
        let n = Re(r, t);
        return n
         ? async (s, i) => {
            let a = Yt(r, t),
             o = /^\s*$/u.test(a),
             u = '';
            return o || ((u = await s(xe(a), { parser: n, __embeddedInHtml: !0 })), (o = '' === u)), [Jt(r, t), q(Vt(e, t, i)), o ? '' : W, u, o ? '' : W, Pt(r, t), _t(r, t)];
           }
         : void 0;
       }
       break;
      case 'text':
       if (Te(r.parent)) {
        let e = Re(r.parent, t);
        if (e)
         return async (n) => {
          let s = 'markdown' === e ? He(r.value.replace(/^[^\S\n]*\n/u, '')) : r.value,
           i = { parser: e, __embeddedInHtml: !0 };
          if ('html' === t.parser && 'babel' === e) {
           let e = 'script',
            { attrMap: t } = r.parent;
           t && ('module' === t.type || ('text/babel' === t.type && 'module' === t['data-type'])) && (e = 'module'), (i.__babelSourceType = e);
          }
          return [H, Jt(r, t), await n(s, i), _t(r, t)];
         };
       } else if ('interpolation' === r.parent.type)
        return async (n) => {
         let s = { __isInHtmlInterpolation: !0, __embeddedInHtml: !0 };
         return 'angular' === t.parser ? (s.parser = '__ng_interpolation') : 'vue' === t.parser ? (s.parser = Dt(e, t) ? '__vue_ts_expression' : '__vue_expression') : (s.parser = '__js_expression'), [j([z, await n(r.value, s)]), r.parent.next && jt(r.parent.next) ? ' ' : z];
        };
       break;
      case 'attribute':
       return Tt(e, t);
      case 'front-matter':
       return (e) => ae(r, e);
      case 'angularControlFlowBlockParameters':
       return Qt.has(e.parent.name) ? pe : void 0;
      case 'angularLetDeclarationInitializer':
       return (e) => le(r.value, e, { parser: '__ng_binding', __isInHtmlAttribute: !1 });
     }
    },
    er = null;
   function tr(e) {
    if (null !== er && (er.property, 1)) {
     let e = er;
     return (er = tr.prototype = null), e;
    }
    return (er = tr.prototype = e ?? Object.create(null)), new tr();
   }
   for (let Ts = 0; Ts <= 10; Ts++) tr();
   var rr = function (e, t = 'type') {
     return (
      (function (e) {
       tr(e);
      })(e),
      function (r) {
       let n = r[t],
        s = e[n];
       if (!Array.isArray(s)) throw Object.assign(new Error(`Missing visitor keys for '${n}'.`), { node: r });
       return s;
      }
     );
    },
    nr = rr({ 'front-matter': [], root: ['children'], element: ['attrs', 'children'], ieConditionalComment: ['children'], ieConditionalStartComment: [], ieConditionalEndComment: [], interpolation: ['children'], text: ['children'], docType: [], comment: [], attribute: [], cdata: [], angularControlFlowBlock: ['children', 'parameters'], angularControlFlowBlockParameters: ['children'], angularControlFlowBlockParameter: [], angularLetDeclaration: ['init'], angularLetDeclarationInitializer: [], angularIcuExpression: ['cases'], angularIcuCase: ['expression'] });
   function sr(e) {
    return /^\s*<!--\s*@(?:format|prettier)\s*-->/u.test(e);
   }
   var ir = new Map([
    ['if', new Set(['else if', 'else'])],
    ['else if', new Set(['else if', 'else'])],
    ['for', new Set(['empty'])],
    ['defer', new Set(['placeholder', 'error', 'loading'])],
    ['placeholder', new Set(['placeholder', 'error', 'loading'])],
    ['error', new Set(['placeholder', 'error', 'loading'])],
    ['loading', new Set(['placeholder', 'error', 'loading'])],
   ]);
   function ar(e) {
    let t = kt(e);
    return 'element' === e.type && !e.endSourceSpan && At(e.children) ? Math.max(t, ar(F(!1, e.children, -1))) : t;
   }
   function or(e, t, r) {
    let n = e.node;
    if (Ee(n)) {
     let e = ar(n);
     return [Jt(n, t), B(Z.trimEnd(t.originalText.slice(Ft(n) + (n.prev && Ut(n.prev) ? Gt(n).length : 0), e - (n.next && jt(n.next) ? Ot(n, t).length : 0)))), _t(n, t)];
    }
    return r();
   }
   function ur(e, t) {
    return Ce(e) && Ce(t) ? (e.isTrailingSpaceSensitive ? (e.hasTrailingSpaces ? (Ne(t) ? W : z) : '') : Ne(t) ? W : V) : (Ut(e) && (Ee(t) || t.firstChild || t.isSelfClosing || ('element' === t.type && t.attrs.length > 0))) || ('element' === e.type && e.isSelfClosing && jt(t)) ? '' : !t.isLeadingSpaceSensitive || Ne(t) || (jt(t) && e.lastChild && qt(e.lastChild) && e.lastChild.lastChild && qt(e.lastChild.lastChild)) ? W : t.hasLeadingSpaces ? z : V;
   }
   function lr(e, t, r) {
    let { node: n } = e;
    if (Ie(n))
     return [
      H,
      ...e.map((e) => {
       let n = e.node,
        s = n.prev ? ur(n.prev, n) : '';
       return [s ? [s, ke(n.prev) ? W : ''] : '', or(e, t, r)];
      }, 'children'),
     ];
    let s = n.children.map(() => Symbol(''));
    return e.map((e, n) => {
     let i = e.node;
     if (Ce(i)) {
      if (i.prev && Ce(i.prev)) {
       let n = ur(i.prev, i);
       if (n) return ke(i.prev) ? [W, W, or(e, t, r)] : [n, or(e, t, r)];
      }
      return or(e, t, r);
     }
     let a = [],
      o = [],
      u = [],
      l = [],
      p = i.prev ? ur(i.prev, i) : '',
      c = i.next ? ur(i, i.next) : '';
     return p && (ke(i.prev) ? a.push(W, W) : p === W ? a.push(W) : Ce(i.prev) ? o.push(p) : o.push($('', V, { groupId: s[n - 1] }))), c && (ke(i) ? Ce(i.next) && l.push(W, W) : c === W ? Ce(i.next) && l.push(W) : u.push(c)), [...a, q([...o, q([or(e, t, r), ...u], { id: s[n] })]), ...l];
    }, 'children');
   }
   function pr(e, t, r) {
    let { node: n } = e,
     s = [];
    (function (e) {
     let { previous: t } = e;
     return 'angularControlFlowBlock' === (null == t ? void 0 : t.type) && !Ee(t) && !cr(t);
    })(e) && s.push('} '),
     s.push('@', n.name),
     n.parameters && s.push(' (', q(r('parameters')), ')'),
     s.push(' {');
    let i = cr(n);
    return n.children.length > 0 ? ((n.firstChild.hasLeadingSpaces = !0), (n.lastChild.hasTrailingSpaces = !0), s.push(j([W, lr(e, t, r)])), i && s.push(W, '}')) : i && s.push('}'), q(s, { shouldBreak: !0 });
   }
   function cr(e) {
    var t, r;
    return !('angularControlFlowBlock' === (null == (t = e.next) ? void 0 : t.type) && null != (r = ir.get(e.name)) && r.has(e.next.name));
   }
   function hr(e, t, r) {
    let { node: n } = e;
    if (ve(n, t)) return [Jt(n, t), q(Vt(e, t, r)), B(Yt(n, t)), ...Pt(n, t), _t(n, t)];
    let s = 1 === n.children.length && ('interpolation' === n.firstChild.type || 'angularIcuExpression' === n.firstChild.type) && n.firstChild.isLeadingSpaceSensitive && !n.firstChild.hasLeadingSpaces && n.lastChild.isTrailingSpaceSensitive && !n.lastChild.hasTrailingSpaces,
     i = Symbol('element-attr-group-id'),
     a = (s) => q([q(Vt(e, t, r), { id: i }), s, Pt(n, t)]);
    return 0 === n.children.length
     ? a(n.hasDanglingSpaces && n.isDanglingSpaceSensitive ? z : '')
     : a([
        Pe(n) ? H : '',
        ((o = [
         s
          ? $(V, '', { groupId: i })
          : n.firstChild.hasLeadingSpaces && n.firstChild.isLeadingSpaceSensitive
            ? z
            : 'text' === n.firstChild.type && n.isWhitespaceSensitive && n.isIndentationSensitive
              ? (function (e) {
                 return R(Number.NEGATIVE_INFINITY, e);
                })(V)
              : V,
         lr(e, t, r),
        ]),
        s
         ? (function (e, t) {
            return L(e), { type: v, contents: e, groupId: t.groupId, negate: t.negate };
           })(o, { groupId: i })
         : (!Te(n) && !Je(n, t)) || 'root' !== n.parent.type || 'vue' !== t.parser || t.vueIndentScriptAndStyle
           ? j(o)
           : o),
        (n.next ? jt(n.next) : Rt(n.parent)) ? (n.lastChild.hasTrailingSpaces && n.lastChild.isTrailingSpaceSensitive ? ' ' : '') : s ? $(V, '', { groupId: i }) : n.lastChild.hasTrailingSpaces && n.lastChild.isTrailingSpaceSensitive ? z : ('comment' === n.lastChild.type || ('text' === n.lastChild.type && n.isWhitespaceSensitive && n.isIndentationSensitive)) && new RegExp(`\\n[\\t ]{${t.tabWidth * (e.ancestors.length - 1)}}$`, 'u').test(n.lastChild.value) ? '' : V,
       ]);
    var o;
   }
   function dr(e) {
    return (e >= 9 && e <= 32) || 160 == e;
   }
   function fr(e) {
    return 48 <= e && e <= 57;
   }
   function mr(e) {
    return (e >= 97 && e <= 122) || (e >= 65 && e <= 90);
   }
   function yr(e) {
    return 10 === e || 13 === e;
   }
   function gr(e) {
    return 48 <= e && e <= 55;
   }
   function Dr(e) {
    return 39 === e || 34 === e || 96 === e;
   }
   var xr = /-+([a-z0-9])/g;
   var br,
    vr,
    Er = class e {
     constructor(e, t, r, n) {
      (this.file = e), (this.offset = t), (this.line = r), (this.col = n);
     }
     toString() {
      return null != this.offset ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;
     }
     moveBy(t) {
      let r = this.file.content,
       n = r.length,
       s = this.offset,
       i = this.line,
       a = this.col;
      for (; s > 0 && t < 0; )
       if ((s--, t++, 10 == r.charCodeAt(s))) {
        i--;
        let e = r.substring(0, s - 1).lastIndexOf(String.fromCharCode(10));
        a = e > 0 ? s - e : s;
       } else a--;
      for (; s < n && t > 0; ) {
       let e = r.charCodeAt(s);
       s++, t--, 10 == e ? (i++, (a = 0)) : a++;
      }
      return new e(this.file, s, i, a);
     }
     getContext(e, t) {
      let r = this.file.content,
       n = this.offset;
      if (null != n) {
       n > r.length - 1 && (n = r.length - 1);
       let s = n,
        i = 0,
        a = 0;
       for (; i < e && n > 0 && (n--, i++, '\n' != r[n] || ++a != t); );
       for (i = 0, a = 0; i < e && s < r.length - 1 && (s++, i++, '\n' != r[s] || ++a != t); );
       return { before: r.substring(n, this.offset), after: r.substring(this.offset, s + 1) };
      }
      return null;
     }
    },
    Cr = class {
     constructor(e, t) {
      (this.content = e), (this.url = t);
     }
    },
    Tr = class {
     constructor(e, t, r = e, n = null) {
      (this.start = e), (this.end = t), (this.fullStart = r), (this.details = n);
     }
     toString() {
      return this.start.file.content.substring(this.start.offset, this.end.offset);
     }
    };
   ((vr = br || (br = {}))[(vr.WARNING = 0)] = 'WARNING'), (vr[(vr.ERROR = 1)] = 'ERROR');
   var Sr = class {
     constructor(e, t, r = br.ERROR) {
      (this.span = e), (this.msg = t), (this.level = r);
     }
     contextualMessage() {
      let e = this.span.start.getContext(100, 3);
      return e ? `${this.msg} ("${e.before}[${br[this.level]} ->]${e.after}")` : this.msg;
     }
     toString() {
      let e = this.span.details ? `, ${this.span.details}` : '';
      return `${this.contextualMessage()}: ${this.span.start}${e}`;
     }
    },
    wr = [
     function (e) {
      e.walk((e) => {
       if ('element' === e.type && e.tagDefinition.ignoreFirstLf && e.children.length > 0 && 'text' === e.children[0].type && '\n' === e.children[0].value[0]) {
        let t = e.children[0];
        1 === t.value.length ? e.removeChild(t) : (t.value = t.value.slice(1));
       }
      });
     },
     function (e) {
      let t = (e) => {
       var t, r;
       return 'element' === e.type && 'ieConditionalStartComment' === (null == (t = e.prev) ? void 0 : t.type) && e.prev.sourceSpan.end.offset === e.startSourceSpan.start.offset && 'ieConditionalEndComment' === (null == (r = e.firstChild) ? void 0 : r.type) && e.firstChild.sourceSpan.start.offset === e.startSourceSpan.end.offset;
      };
      e.walk((e) => {
       if (e.children)
        for (let r = 0; r < e.children.length; r++) {
         let n = e.children[r];
         if (!t(n)) continue;
         let s = n.prev,
          i = n.firstChild;
         e.removeChild(s), r--;
         let a = new Tr(s.sourceSpan.start, i.sourceSpan.end),
          o = new Tr(a.start, n.sourceSpan.end);
         (n.condition = s.condition), (n.sourceSpan = o), (n.startSourceSpan = a), n.removeChild(i);
        }
      });
     },
     function (e) {
      return (function (e, t, r) {
       e.walk((e) => {
        if (e.children)
         for (let n = 0; n < e.children.length; n++) {
          let s = e.children[n];
          if ('text' !== s.type && !t(s)) continue;
          'text' !== s.type && ((s.type = 'text'), (s.value = r(s)));
          let i = s.prev;
          !i || 'text' !== i.type || ((i.value += s.value), (i.sourceSpan = new Tr(i.sourceSpan.start, s.sourceSpan.end)), e.removeChild(s), n--);
         }
       });
      })(
       e,
       (e) => 'cdata' === e.type,
       (e) => `<![CDATA[${e.value}]]>`,
      );
     },
     function (e, t) {
      if ('html' === t.parser) return;
      let r = /\{\{(.+?)\}\}/su;
      e.walk((e) => {
       if (
        (function (e) {
         return e.children && !Te(e);
        })(e)
       )
        for (let t of e.children) {
         if ('text' !== t.type) continue;
         let n = t.sourceSpan.start,
          s = null,
          i = t.value.split(r);
         for (let r = 0; r < i.length; r++, n = s) {
          let a = i[r];
          r % 2 != 0 ? ((s = n.moveBy(a.length + 4)), e.insertChildBefore(t, { type: 'interpolation', sourceSpan: new Tr(n, s), children: 0 === a.length ? [] : [{ type: 'text', value: a, sourceSpan: new Tr(n.moveBy(2), s.moveBy(-2)) }] })) : ((s = n.moveBy(a.length)), a.length > 0 && e.insertChildBefore(t, { type: 'text', value: a, sourceSpan: new Tr(n, s) }));
         }
         e.removeChild(t);
        }
      });
     },
     function (e) {
      e.walk((e) => {
       let t = e.$children;
       if (!t) return;
       if (0 === t.length || (1 === t.length && 'text' === t[0].type && 0 === Z.trim(t[0].value).length)) return (e.hasDanglingSpaces = t.length > 0), void (e.$children = []);
       let r = (function (e) {
         return Te(e) || 'interpolation' === e.type || Se(e);
        })(e),
        n = Se(e);
       if (!r)
        for (let s = 0; s < t.length; s++) {
         let r = t[s];
         if ('text' !== r.type) continue;
         let { leadingWhitespace: n, text: i, trailingWhitespace: a } = be(r.value),
          o = r.prev,
          u = r.next;
         i ? ((r.value = i), (r.sourceSpan = new Tr(r.sourceSpan.start.moveBy(n.length), r.sourceSpan.end.moveBy(-a.length))), n && (o && (o.hasTrailingSpaces = !0), (r.hasLeadingSpaces = !0)), a && ((r.hasTrailingSpaces = !0), u && (u.hasLeadingSpaces = !0))) : (e.removeChild(r), s--, (n || a) && (o && (o.hasTrailingSpaces = !0), u && (u.hasLeadingSpaces = !0)));
        }
       (e.isWhitespaceSensitive = r), (e.isIndentationSensitive = n);
      });
     },
     function (e, t) {
      e.walk((e) => {
       e.cssDisplay = (function (e, t) {
        var r;
        if (Ke(e, t)) return 'block';
        if ('comment' === (null == (r = e.prev) ? void 0 : r.type)) {
         let t = e.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/u);
         if (t) return t[1];
        }
        let n = !1;
        if ('element' === e.type && 'svg' === e.namespace) {
         if (
          !(function (e, t) {
           let r = e;
           for (; r; ) {
            if (t(r)) return !0;
            r = r.parent;
           }
           return !1;
          })(e, (e) => 'svg:foreignObject' === e.fullName)
         )
          return 'svg' === e.name ? 'inline-block' : 'block';
         n = !0;
        }
        switch (t.htmlWhitespaceSensitivity) {
         case 'strict':
          return 'inline';
         case 'ignore':
          return 'block';
         default:
          return ('element' === e.type && (!e.namespace || n || De(e)) && me[e.name]) || fe;
        }
       })(e, t);
      });
     },
     function (e) {
      e.walk((e) => {
       e.isSelfClosing = !e.children || ('element' === e.type && (e.tagDefinition.isVoid || (e.endSourceSpan && e.startSourceSpan.start === e.endSourceSpan.start && e.startSourceSpan.end === e.endSourceSpan.end)));
      });
     },
     function (e, t) {
      e.walk((e) => {
       'element' === e.type && (e.hasHtmComponentClosingTag = e.endSourceSpan && /^<\s*\/\s*\/\s*>$/u.test(t.originalText.slice(e.endSourceSpan.start.offset, e.endSourceSpan.end.offset)));
      });
     },
     function (e, t) {
      e.walk((e) => {
       let { children: r } = e;
       if (r) {
        if (0 === r.length) return void (e.isDanglingSpaceSensitive = Fe(e));
        for (let e of r) (e.isLeadingSpaceSensitive = we(e, t)), (e.isTrailingSpaceSensitive = Ae(e, t));
        for (let e = 0; e < r.length; e++) {
         let t = r[e];
         (t.isLeadingSpaceSensitive = (0 === e || t.prev.isTrailingSpaceSensitive) && t.isLeadingSpaceSensitive), (t.isTrailingSpaceSensitive = (e === r.length - 1 || t.next.isLeadingSpaceSensitive) && t.isTrailingSpaceSensitive);
        }
       }
      });
     },
     function (e) {
      let t = (e) => {
       var t, r;
       return 'element' === e.type && 0 === e.attrs.length && 1 === e.children.length && 'text' === e.firstChild.type && !Z.hasWhitespaceCharacter(e.children[0].value) && !e.firstChild.hasLeadingSpaces && !e.firstChild.hasTrailingSpaces && e.isLeadingSpaceSensitive && !e.hasLeadingSpaces && e.isTrailingSpaceSensitive && !e.hasTrailingSpaces && 'text' === (null == (t = e.prev) ? void 0 : t.type) && 'text' === (null == (r = e.next) ? void 0 : r.type);
      };
      e.walk((e) => {
       if (e.children)
        for (let r = 0; r < e.children.length; r++) {
         let n = e.children[r];
         if (!t(n)) continue;
         let s = n.prev,
          i = n.next;
         (s.value += `<${n.rawName}>` + n.firstChild.value + `</${n.rawName}>` + i.value), (s.sourceSpan = new Tr(s.sourceSpan.start, i.sourceSpan.end)), (s.isTrailingSpaceSensitive = i.isTrailingSpaceSensitive), (s.hasTrailingSpaces = i.hasTrailingSpaces), e.removeChild(n), r--, e.removeChild(i);
        }
      });
     },
    ];
   var Ar = function (e, t) {
    for (let r of wr) r(e, t);
    return e;
   };
   var Fr = {
     preprocess: Ar,
     print: function (e, t, r) {
      let { node: n } = e;
      switch (n.type) {
       case 'front-matter':
        return B(n.raw);
       case 'root':
        return t.__onHtmlRoot && t.__onHtmlRoot(n), [q(lr(e, t, r)), W];
       case 'element':
       case 'ieConditionalComment':
        return hr(e, t, r);
       case 'angularControlFlowBlock':
        return pr(e, t, r);
       case 'angularControlFlowBlockParameters':
        return (function (e, t, r) {
         return [j([V, K([';', z], e.map(r, 'children'))]), V];
        })(e, 0, r);
       case 'angularControlFlowBlockParameter':
        return Z.trim(n.expression);
       case 'angularLetDeclaration':
        return q(['@let ', q([n.id, ' =', q(j([z, r('init')]))]), ';']);
       case 'angularLetDeclarationInitializer':
        return n.value;
       case 'angularIcuExpression':
        return (function (e, t, r) {
         let { node: n } = e;
         return [Wt(n, t), q([n.switchValue.trim(), ', ', n.clause, n.cases.length > 0 ? [',', j([z, K(z, e.map(r, 'cases'))])] : '', V]), Nt(n, t)];
        })(e, t, r);
       case 'angularIcuCase':
        return (function (e, t, r) {
         let { node: n } = e;
         return [
          n.value,
          ' {',
          q([
           j([
            V,
            e.map(({ node: e, isLast: t }) => {
             let n = [r()];
             return 'text' === e.type && (e.hasLeadingSpaces && n.unshift(z), e.hasTrailingSpaces && !t && n.push(z)), n;
            }, 'expression'),
           ]),
           V,
          ]),
          '}',
         ];
        })(e, 0, r);
       case 'ieConditionalStartComment':
       case 'ieConditionalEndComment':
        return [Wt(n), Nt(n)];
       case 'interpolation':
        return [Wt(n, t), ...e.map(r, 'children'), Nt(n, t)];
       case 'text': {
        if ('interpolation' === n.parent.type) {
         let e = /\n[^\S\n]*$/u,
          t = e.test(n.value);
         return [B(t ? n.value.replace(e, '') : n.value), t ? W : ''];
        }
        let e = Jt(n, t),
         r = Xe(n),
         s = _t(n, t);
        return (r[0] = [e, r[0]]), r.push([r.pop(), s]), U(r);
       }
       case 'docType':
        return [q([Wt(n, t), ' ', c(!1, n.value.replace(/^html\b/iu, 'html'), /\s+/gu, ' ')]), Nt(n, t)];
       case 'comment':
        return [Jt(n, t), B(t.originalText.slice(Ft(n), kt(n))), _t(n, t)];
       case 'attribute': {
        if (null === n.value) return n.rawName;
        let e = ze(n.value),
         t = X(e, '"');
        return [n.rawName, '=', t, B('"' === t ? c(!1, e, '"', '&quot;') : c(!1, e, "'", '&apos;')), t];
       }
       default:
        throw new ee(n, 'HTML');
      }
     },
     insertPragma: function (e) {
      return '\x3c!-- @format --\x3e\n\n' + e;
     },
     massageAstNode: ie,
     embed: Zt,
     getVisitorKeys: nr,
    },
    kr = Fr,
    Pr = [
     { linguistLanguageId: 146, name: 'Angular', type: 'markup', tmScope: 'text.html.basic', aceMode: 'html', codemirrorMode: 'htmlmixed', codemirrorMimeType: 'text/html', color: '#e34c26', aliases: ['xhtml'], extensions: ['.component.html'], parsers: ['angular'], vscodeLanguageIds: ['html'], filenames: [] },
     { linguistLanguageId: 146, name: 'HTML', type: 'markup', tmScope: 'text.html.basic', aceMode: 'html', codemirrorMode: 'htmlmixed', codemirrorMimeType: 'text/html', color: '#e34c26', aliases: ['xhtml'], extensions: ['.html', '.hta', '.htm', '.html.hl', '.inc', '.xht', '.xhtml', '.mjml'], parsers: ['html'], vscodeLanguageIds: ['html'] },
     { linguistLanguageId: 146, name: 'Lightning Web Components', type: 'markup', tmScope: 'text.html.basic', aceMode: 'html', codemirrorMode: 'htmlmixed', codemirrorMimeType: 'text/html', color: '#e34c26', aliases: ['xhtml'], extensions: [], parsers: ['lwc'], vscodeLanguageIds: ['html'], filenames: [] },
     { linguistLanguageId: 391, name: 'Vue', type: 'markup', color: '#41b883', extensions: ['.vue'], tmScope: 'text.html.vue', aceMode: 'html', parsers: ['vue'], vscodeLanguageIds: ['vue'] },
    ],
    Ir = {
     bracketSpacing: { category: 'Common', type: 'boolean', default: !0, description: 'Print spaces between brackets.', oppositeDescription: 'Do not print spaces between brackets.' },
     objectWrap: {
      category: 'Common',
      type: 'choice',
      default: 'preserve',
      description: 'How to wrap object literals.',
      choices: [
       { value: 'preserve', description: 'Keep as multi-line, if there is a newline between the opening brace and first property.' },
       { value: 'collapse', description: 'Fit to a single line when possible.' },
      ],
     },
     singleQuote: { category: 'Common', type: 'boolean', default: !1, description: 'Use single quotes instead of double quotes.' },
     proseWrap: {
      category: 'Common',
      type: 'choice',
      default: 'preserve',
      description: 'How to wrap prose.',
      choices: [
       { value: 'always', description: 'Wrap prose if it exceeds the print width.' },
       { value: 'never', description: 'Do not wrap prose.' },
       { value: 'preserve', description: 'Wrap prose as-is.' },
      ],
     },
     bracketSameLine: { category: 'Common', type: 'boolean', default: !1, description: 'Put > of opening tags on the last line instead of on a new line.' },
     singleAttributePerLine: { category: 'Common', type: 'boolean', default: !1, description: 'Enforce single attribute per line in HTML, Vue and JSX.' },
    },
    Nr = 'HTML',
    Br = {
     bracketSameLine: Ir.bracketSameLine,
     htmlWhitespaceSensitivity: {
      category: Nr,
      type: 'choice',
      default: 'css',
      description: 'How to handle whitespaces in HTML.',
      choices: [
       { value: 'css', description: 'Respect the default value of CSS display property.' },
       { value: 'strict', description: 'Whitespaces are considered sensitive.' },
       { value: 'ignore', description: 'Whitespaces are considered insensitive.' },
      ],
     },
     singleAttributePerLine: Ir.singleAttributePerLine,
     vueIndentScriptAndStyle: { category: Nr, type: 'boolean', default: !1, description: 'Indent script and style tags in Vue files.' },
    },
    _r = {};
   i(_r, { angular: () => xs, html: () => Ds, lwc: () => vs, vue: () => bs });
   var Lr, Or, Mr;
   !(function (e) {
    (e[(e.Emulated = 0)] = 'Emulated'), (e[(e.None = 2)] = 'None'), (e[(e.ShadowDom = 3)] = 'ShadowDom');
   })(Lr || (Lr = {})),
    (function (e) {
     (e[(e.OnPush = 0)] = 'OnPush'), (e[(e.Default = 1)] = 'Default');
    })(Or || (Or = {})),
    (function (e) {
     (e[(e.None = 0)] = 'None'), (e[(e.SignalBased = 1)] = 'SignalBased'), (e[(e.HasDecoratorInputTransform = 2)] = 'HasDecoratorInputTransform');
    })(Mr || (Mr = {}));
   var jr,
    Rr,
    qr,
    Ur,
    $r = 'custom-elements',
    Hr = 'no-errors-schema';
   function zr(e, t = !0) {
    if (':' != e[0]) return [null, e];
    let r = e.indexOf(':', 1);
    if (-1 === r) {
     if (t) throw new Error(`Unsupported format "${e}" expecting ":namespace:name"`);
     return [null, e];
    }
    return [e.slice(1, r), e.slice(r + 1)];
   }
   function Vr(e) {
    return 'ng-container' === zr(e)[1];
   }
   function Wr(e) {
    return 'ng-content' === zr(e)[1];
   }
   function Jr(e) {
    return null === e ? null : zr(e)[0];
   }
   function Kr(e, t) {
    return e ? `:${e}:${t}` : t;
   }
   function Gr() {
    return Ur || ((Ur = {}), Xr(jr.HTML, ['iframe|srcdoc', '*|innerHTML', '*|outerHTML']), Xr(jr.STYLE, ['*|style']), Xr(jr.URL, ['*|formAction', 'area|href', 'area|ping', 'audio|src', 'a|href', 'a|ping', 'blockquote|cite', 'body|background', 'del|cite', 'form|action', 'img|src', 'input|src', 'ins|cite', 'q|cite', 'source|src', 'track|src', 'video|poster', 'video|src']), Xr(jr.RESOURCE_URL, ['applet|code', 'applet|codebase', 'base|href', 'embed|src', 'frame|src', 'head|profile', 'html|manifest', 'iframe|src', 'link|href', 'media|src', 'object|codebase', 'object|data', 'script|src'])), Ur;
   }
   function Xr(e, t) {
    for (let r of t) Ur[r.toLowerCase()] = e;
   }
   !(function (e) {
    (e[(e.NONE = 0)] = 'NONE'), (e[(e.HTML = 1)] = 'HTML'), (e[(e.STYLE = 2)] = 'STYLE'), (e[(e.SCRIPT = 3)] = 'SCRIPT'), (e[(e.URL = 4)] = 'URL'), (e[(e.RESOURCE_URL = 5)] = 'RESOURCE_URL');
   })(jr || (jr = {})),
    (function (e) {
     (e[(e.Error = 0)] = 'Error'), (e[(e.Warning = 1)] = 'Warning'), (e[(e.Ignore = 2)] = 'Ignore');
    })(Rr || (Rr = {})),
    (function (e) {
     (e[(e.RAW_TEXT = 0)] = 'RAW_TEXT'), (e[(e.ESCAPABLE_RAW_TEXT = 1)] = 'ESCAPABLE_RAW_TEXT'), (e[(e.PARSABLE_DATA = 2)] = 'PARSABLE_DATA');
    })(qr || (qr = {}));
   var Yr = class {},
    Qr = ['[Element]|textContent,%ariaAtomic,%ariaAutoComplete,%ariaBusy,%ariaChecked,%ariaColCount,%ariaColIndex,%ariaColSpan,%ariaCurrent,%ariaDescription,%ariaDisabled,%ariaExpanded,%ariaHasPopup,%ariaHidden,%ariaKeyShortcuts,%ariaLabel,%ariaLevel,%ariaLive,%ariaModal,%ariaMultiLine,%ariaMultiSelectable,%ariaOrientation,%ariaPlaceholder,%ariaPosInSet,%ariaPressed,%ariaReadOnly,%ariaRelevant,%ariaRequired,%ariaRoleDescription,%ariaRowCount,%ariaRowIndex,%ariaRowSpan,%ariaSelected,%ariaSetSize,%ariaSort,%ariaValueMax,%ariaValueMin,%ariaValueNow,%ariaValueText,%classList,className,elementTiming,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*fullscreenchange,*fullscreenerror,*search,*webkitfullscreenchange,*webkitfullscreenerror,outerHTML,%part,#scrollLeft,#scrollTop,slot,*message,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored', '[HTMLElement]^[Element]|accessKey,autocapitalize,!autofocus,contentEditable,dir,!draggable,enterKeyHint,!hidden,!inert,innerText,inputMode,lang,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate,virtualKeyboardPolicy', 'abbr,address,article,aside,b,bdi,bdo,cite,content,code,dd,dfn,dt,em,figcaption,figure,footer,header,hgroup,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,autocapitalize,!autofocus,contentEditable,dir,!draggable,enterKeyHint,!hidden,innerText,inputMode,lang,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,outerText,!spellcheck,%style,#tabIndex,title,!translate,virtualKeyboardPolicy', 'media^[HTMLElement]|!autoplay,!controls,%controlsList,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,*waitingforkey,#playbackRate,preload,!preservesPitch,src,%srcObject,#volume', ':svg:^[HTMLElement]|!autofocus,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,%style,#tabIndex', ':svg:graphics^:svg:|', ':svg:animation^:svg:|*begin,*end,*repeat', ':svg:geometry^:svg:|', ':svg:componentTransferFunction^:svg:|', ':svg:gradient^:svg:|', ':svg:textContent^:svg:graphics|', ':svg:textPositioning^:svg:textContent|', 'a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,%relList,rev,search,shape,target,text,type,username', 'area^[HTMLElement]|alt,coords,download,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,rel,%relList,search,shape,target,username', 'audio^media|', 'br^[HTMLElement]|clear', 'base^[HTMLElement]|href,target', 'body^[HTMLElement]|aLink,background,bgColor,link,*afterprint,*beforeprint,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*messageerror,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink', 'button^[HTMLElement]|!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value', 'canvas^[HTMLElement]|#height,#width', 'content^[HTMLElement]|select', 'dl^[HTMLElement]|!compact', 'data^[HTMLElement]|value', 'datalist^[HTMLElement]|', 'details^[HTMLElement]|!open', 'dialog^[HTMLElement]|!open,returnValue', 'dir^[HTMLElement]|!compact', 'div^[HTMLElement]|align', 'embed^[HTMLElement]|align,height,name,src,type,width', 'fieldset^[HTMLElement]|!disabled,name', 'font^[HTMLElement]|color,face,size', 'form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target', 'frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src', 'frameset^[HTMLElement]|cols,*afterprint,*beforeprint,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*messageerror,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows', 'hr^[HTMLElement]|align,color,!noShade,size,width', 'head^[HTMLElement]|', 'h1,h2,h3,h4,h5,h6^[HTMLElement]|align', 'html^[HTMLElement]|version', 'iframe^[HTMLElement]|align,allow,!allowFullscreen,!allowPaymentRequest,csp,frameBorder,height,loading,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width', 'img^[HTMLElement]|align,alt,border,%crossOrigin,decoding,#height,#hspace,!isMap,loading,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width', 'input^[HTMLElement]|accept,align,alt,autocomplete,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width', 'li^[HTMLElement]|type,#value', 'label^[HTMLElement]|htmlFor', 'legend^[HTMLElement]|align', 'link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,imageSizes,imageSrcset,integrity,media,referrerPolicy,rel,%relList,rev,%sizes,target,type', 'map^[HTMLElement]|name', 'marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width', 'menu^[HTMLElement]|!compact', 'meta^[HTMLElement]|content,httpEquiv,media,name,scheme', 'meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value', 'ins,del^[HTMLElement]|cite,dateTime', 'ol^[HTMLElement]|!compact,!reversed,#start,type', 'object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width', 'optgroup^[HTMLElement]|!disabled,label', 'option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value', 'output^[HTMLElement]|defaultValue,%htmlFor,name,value', 'p^[HTMLElement]|align', 'param^[HTMLElement]|name,type,value,valueType', 'picture^[HTMLElement]|', 'pre^[HTMLElement]|#width', 'progress^[HTMLElement]|#max,#value', 'q,blockquote,cite^[HTMLElement]|', 'script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,!noModule,%referrerPolicy,src,text,type', 'select^[HTMLElement]|autocomplete,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value', 'slot^[HTMLElement]|name', 'source^[HTMLElement]|#height,media,sizes,src,srcset,type,#width', 'span^[HTMLElement]|', 'style^[HTMLElement]|!disabled,media,type', 'caption^[HTMLElement]|align', 'th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width', 'col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width', 'table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width', 'tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign', 'tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign', 'template^[HTMLElement]|', 'textarea^[HTMLElement]|autocomplete,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap', 'time^[HTMLElement]|dateTime', 'title^[HTMLElement]|text', 'track^[HTMLElement]|!default,kind,label,src,srclang', 'ul^[HTMLElement]|!compact,type', 'unknown^[HTMLElement]|', 'video^media|!disablePictureInPicture,#height,*enterpictureinpicture,*leavepictureinpicture,!playsInline,poster,#width', ':svg:a^:svg:graphics|', ':svg:animate^:svg:animation|', ':svg:animateMotion^:svg:animation|', ':svg:animateTransform^:svg:animation|', ':svg:circle^:svg:geometry|', ':svg:clipPath^:svg:graphics|', ':svg:defs^:svg:graphics|', ':svg:desc^:svg:|', ':svg:discard^:svg:|', ':svg:ellipse^:svg:geometry|', ':svg:feBlend^:svg:|', ':svg:feColorMatrix^:svg:|', ':svg:feComponentTransfer^:svg:|', ':svg:feComposite^:svg:|', ':svg:feConvolveMatrix^:svg:|', ':svg:feDiffuseLighting^:svg:|', ':svg:feDisplacementMap^:svg:|', ':svg:feDistantLight^:svg:|', ':svg:feDropShadow^:svg:|', ':svg:feFlood^:svg:|', ':svg:feFuncA^:svg:componentTransferFunction|', ':svg:feFuncB^:svg:componentTransferFunction|', ':svg:feFuncG^:svg:componentTransferFunction|', ':svg:feFuncR^:svg:componentTransferFunction|', ':svg:feGaussianBlur^:svg:|', ':svg:feImage^:svg:|', ':svg:feMerge^:svg:|', ':svg:feMergeNode^:svg:|', ':svg:feMorphology^:svg:|', ':svg:feOffset^:svg:|', ':svg:fePointLight^:svg:|', ':svg:feSpecularLighting^:svg:|', ':svg:feSpotLight^:svg:|', ':svg:feTile^:svg:|', ':svg:feTurbulence^:svg:|', ':svg:filter^:svg:|', ':svg:foreignObject^:svg:graphics|', ':svg:g^:svg:graphics|', ':svg:image^:svg:graphics|decoding', ':svg:line^:svg:geometry|', ':svg:linearGradient^:svg:gradient|', ':svg:mpath^:svg:|', ':svg:marker^:svg:|', ':svg:mask^:svg:|', ':svg:metadata^:svg:|', ':svg:path^:svg:geometry|', ':svg:pattern^:svg:|', ':svg:polygon^:svg:geometry|', ':svg:polyline^:svg:geometry|', ':svg:radialGradient^:svg:gradient|', ':svg:rect^:svg:geometry|', ':svg:svg^:svg:graphics|#currentScale,#zoomAndPan', ':svg:script^:svg:|type', ':svg:set^:svg:animation|', ':svg:stop^:svg:|', ':svg:style^:svg:|!disabled,media,title,type', ':svg:switch^:svg:graphics|', ':svg:symbol^:svg:|', ':svg:tspan^:svg:textPositioning|', ':svg:text^:svg:textPositioning|', ':svg:textPath^:svg:textContent|', ':svg:title^:svg:|', ':svg:use^:svg:graphics|', ':svg:view^:svg:|#zoomAndPan', 'data^[HTMLElement]|value', 'keygen^[HTMLElement]|!autofocus,challenge,!disabled,form,keytype,name', 'menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default', 'summary^[HTMLElement]|', 'time^[HTMLElement]|dateTime', ':svg:cursor^:svg:|', ':math:^[HTMLElement]|!autofocus,nonce,*abort,*animationend,*animationiteration,*animationstart,*auxclick,*beforeinput,*beforematch,*beforetoggle,*beforexrselect,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contentvisibilityautostatechange,*contextlost,*contextmenu,*contextrestored,*copy,*cuechange,*cut,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*formdata,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*paste,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerrawupdate,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*scrollend,*securitypolicyviolation,*seeked,*seeking,*select,*selectionchange,*selectstart,*slotchange,*stalled,*submit,*suspend,*timeupdate,*toggle,*transitioncancel,*transitionend,*transitionrun,*transitionstart,*volumechange,*waiting,*webkitanimationend,*webkitanimationiteration,*webkitanimationstart,*webkittransitionend,*wheel,%style,#tabIndex', ':math:math^:math:|', ':math:maction^:math:|', ':math:menclose^:math:|', ':math:merror^:math:|', ':math:mfenced^:math:|', ':math:mfrac^:math:|', ':math:mi^:math:|', ':math:mmultiscripts^:math:|', ':math:mn^:math:|', ':math:mo^:math:|', ':math:mover^:math:|', ':math:mpadded^:math:|', ':math:mphantom^:math:|', ':math:mroot^:math:|', ':math:mrow^:math:|', ':math:ms^:math:|', ':math:mspace^:math:|', ':math:msqrt^:math:|', ':math:mstyle^:math:|', ':math:msub^:math:|', ':math:msubsup^:math:|', ':math:msup^:math:|', ':math:mtable^:math:|', ':math:mtd^:math:|', ':math:mtext^:math:|', ':math:mtr^:math:|', ':math:munder^:math:|', ':math:munderover^:math:|', ':math:semantics^:math:|'],
    Zr = new Map(Object.entries({ class: 'className', for: 'htmlFor', formaction: 'formAction', innerHtml: 'innerHTML', readonly: 'readOnly', tabindex: 'tabIndex' })),
    en = Array.from(Zr).reduce((e, [t, r]) => (e.set(t, r), e), new Map()),
    tn = class extends Yr {
     constructor() {
      super(),
       (this._schema = new Map()),
       (this._eventSchema = new Map()),
       Qr.forEach((e) => {
        let t = new Map(),
         r = new Set(),
         [n, s] = e.split('|'),
         i = s.split(','),
         [a, o] = n.split('^');
        a.split(',').forEach((e) => {
         this._schema.set(e.toLowerCase(), t), this._eventSchema.set(e.toLowerCase(), r);
        });
        let u = o && this._schema.get(o.toLowerCase());
        if (u) {
         for (let [e, r] of u) t.set(e, r);
         for (let e of this._eventSchema.get(o.toLowerCase())) r.add(e);
        }
        i.forEach((e) => {
         if (e.length > 0)
          switch (e[0]) {
           case '*':
            r.add(e.substring(1));
            break;
           case '!':
            t.set(e.substring(1), 'boolean');
            break;
           case '#':
            t.set(e.substring(1), 'number');
            break;
           case '%':
            t.set(e.substring(1), 'object');
            break;
           default:
            t.set(e, 'string');
          }
        });
       });
     }
     hasProperty(e, t, r) {
      if (r.some((e) => e.name === Hr)) return !0;
      if (e.indexOf('-') > -1) {
       if (Vr(e) || Wr(e)) return !1;
       if (r.some((e) => e.name === $r)) return !0;
      }
      return (this._schema.get(e.toLowerCase()) || this._schema.get('unknown')).has(t);
     }
     hasElement(e, t) {
      return !!(t.some((e) => e.name === Hr) || (e.indexOf('-') > -1 && (Vr(e) || Wr(e) || t.some((e) => e.name === $r)))) || this._schema.has(e.toLowerCase());
     }
     securityContext(e, t, r) {
      r && (t = this.getMappedPropName(t)), (e = e.toLowerCase()), (t = t.toLowerCase());
      let n = Gr()[e + '|' + t];
      return n || ((n = Gr()['*|' + t]), n || jr.NONE);
     }
     getMappedPropName(e) {
      return Zr.get(e) ?? e;
     }
     getDefaultComponentElementName() {
      return 'ng-component';
     }
     validateProperty(e) {
      return e.toLowerCase().startsWith('on') ? { error: !0, msg: `Binding to event property '${e}' is disallowed for security reasons, please use (${e.slice(2)})=...\nIf '${e}' is a directive input, make sure the directive is imported by the current module.` } : { error: !1 };
     }
     validateAttribute(e) {
      return e.toLowerCase().startsWith('on') ? { error: !0, msg: `Binding to event attribute '${e}' is disallowed for security reasons, please use (${e.slice(2)})=...` } : { error: !1 };
     }
     allKnownElementNames() {
      return Array.from(this._schema.keys());
     }
     allKnownAttributesOfElement(e) {
      let t = this._schema.get(e.toLowerCase()) || this._schema.get('unknown');
      return Array.from(t.keys()).map((e) => en.get(e) ?? e);
     }
     allKnownEventsOfElement(e) {
      return Array.from(this._eventSchema.get(e.toLowerCase()) ?? []);
     }
     normalizeAnimationStyleProperty(e) {
      return (function (e) {
       return e.replace(xr, (...e) => e[1].toUpperCase());
      })(e);
     }
     normalizeAnimationStyleValue(e, t, r) {
      let n = '',
       s = r.toString().trim(),
       i = null;
      if (
       (function (e) {
        switch (e) {
         case 'width':
         case 'height':
         case 'minWidth':
         case 'minHeight':
         case 'maxWidth':
         case 'maxHeight':
         case 'left':
         case 'top':
         case 'bottom':
         case 'right':
         case 'fontSize':
         case 'outlineWidth':
         case 'outlineOffset':
         case 'paddingTop':
         case 'paddingLeft':
         case 'paddingBottom':
         case 'paddingRight':
         case 'marginTop':
         case 'marginLeft':
         case 'marginBottom':
         case 'marginRight':
         case 'borderRadius':
         case 'borderWidth':
         case 'borderTopWidth':
         case 'borderLeftWidth':
         case 'borderRightWidth':
         case 'borderBottomWidth':
         case 'textIndent':
          return !0;
         default:
          return !1;
        }
       })(e) &&
       0 !== r &&
       '0' !== r
      )
       if ('number' == typeof r) n = 'px';
       else {
        let e = r.match(/^[+-]?[\d\.]+([a-z]*)$/);
        e && 0 == e[1].length && (i = `Please provide a CSS unit value for ${t}:${r}`);
       }
      return { error: i, value: s + n };
     }
    };
   var rn,
    nn,
    sn = class {
     constructor({ closedByChildren: e, implicitNamespacePrefix: t, contentType: r = qr.PARSABLE_DATA, closedByParent: n = !1, isVoid: s = !1, ignoreFirstLf: i = !1, preventNamespaceInheritance: a = !1, canSelfClose: o = !1 } = {}) {
      (this.closedByChildren = {}), (this.closedByParent = !1), e && e.length > 0 && e.forEach((e) => (this.closedByChildren[e] = !0)), (this.isVoid = s), (this.closedByParent = n || s), (this.implicitNamespacePrefix = t || null), (this.contentType = r), (this.ignoreFirstLf = i), (this.preventNamespaceInheritance = a), (this.canSelfClose = o ?? s);
     }
     isClosedByChild(e) {
      return this.isVoid || e.toLowerCase() in this.closedByChildren;
     }
     getContentType(e) {
      return 'object' == typeof this.contentType ? ((void 0 === e ? void 0 : this.contentType[e]) ?? this.contentType.default) : this.contentType;
     }
    };
   function an(e) {
    return (
     nn ||
      ((rn = new sn({ canSelfClose: !0 })),
      (nn = Object.assign(Object.create(null), { base: new sn({ isVoid: !0 }), meta: new sn({ isVoid: !0 }), area: new sn({ isVoid: !0 }), embed: new sn({ isVoid: !0 }), link: new sn({ isVoid: !0 }), img: new sn({ isVoid: !0 }), input: new sn({ isVoid: !0 }), param: new sn({ isVoid: !0 }), hr: new sn({ isVoid: !0 }), br: new sn({ isVoid: !0 }), source: new sn({ isVoid: !0 }), track: new sn({ isVoid: !0 }), wbr: new sn({ isVoid: !0 }), p: new sn({ closedByChildren: ['address', 'article', 'aside', 'blockquote', 'div', 'dl', 'fieldset', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hgroup', 'hr', 'main', 'nav', 'ol', 'p', 'pre', 'section', 'table', 'ul'], closedByParent: !0 }), thead: new sn({ closedByChildren: ['tbody', 'tfoot'] }), tbody: new sn({ closedByChildren: ['tbody', 'tfoot'], closedByParent: !0 }), tfoot: new sn({ closedByChildren: ['tbody'], closedByParent: !0 }), tr: new sn({ closedByChildren: ['tr'], closedByParent: !0 }), td: new sn({ closedByChildren: ['td', 'th'], closedByParent: !0 }), th: new sn({ closedByChildren: ['td', 'th'], closedByParent: !0 }), col: new sn({ isVoid: !0 }), svg: new sn({ implicitNamespacePrefix: 'svg' }), foreignObject: new sn({ implicitNamespacePrefix: 'svg', preventNamespaceInheritance: !0 }), math: new sn({ implicitNamespacePrefix: 'math' }), li: new sn({ closedByChildren: ['li'], closedByParent: !0 }), dt: new sn({ closedByChildren: ['dt', 'dd'] }), dd: new sn({ closedByChildren: ['dt', 'dd'], closedByParent: !0 }), rb: new sn({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: !0 }), rt: new sn({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: !0 }), rtc: new sn({ closedByChildren: ['rb', 'rtc', 'rp'], closedByParent: !0 }), rp: new sn({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: !0 }), optgroup: new sn({ closedByChildren: ['optgroup'], closedByParent: !0 }), option: new sn({ closedByChildren: ['option', 'optgroup'], closedByParent: !0 }), pre: new sn({ ignoreFirstLf: !0 }), listing: new sn({ ignoreFirstLf: !0 }), style: new sn({ contentType: qr.RAW_TEXT }), script: new sn({ contentType: qr.RAW_TEXT }), title: new sn({ contentType: { default: qr.ESCAPABLE_RAW_TEXT, svg: qr.PARSABLE_DATA } }), textarea: new sn({ contentType: qr.ESCAPABLE_RAW_TEXT, ignoreFirstLf: !0 }) })),
      new tn().allKnownElementNames().forEach((e) => {
       !nn[e] && null === Jr(e) && (nn[e] = new sn({ canSelfClose: !1 }));
      })),
     nn[e] ?? rn
    );
   }
   var on = class {
     constructor(e, t) {
      (this.sourceSpan = e), (this.i18n = t);
     }
    },
    un = class extends on {
     constructor(e, t, r, n) {
      super(t, n), (this.value = e), (this.tokens = r), (this.type = 'text');
     }
     visit(e, t) {
      return e.visitText(this, t);
     }
    },
    ln = class extends on {
     constructor(e, t, r, n) {
      super(t, n), (this.value = e), (this.tokens = r), (this.type = 'cdata');
     }
     visit(e, t) {
      return e.visitCdata(this, t);
     }
    },
    pn = class extends on {
     constructor(e, t, r, n, s, i) {
      super(n, i), (this.switchValue = e), (this.type = t), (this.cases = r), (this.switchValueSourceSpan = s);
     }
     visit(e, t) {
      return e.visitExpansion(this, t);
     }
    },
    cn = class {
     constructor(e, t, r, n, s) {
      (this.value = e), (this.expression = t), (this.sourceSpan = r), (this.valueSourceSpan = n), (this.expSourceSpan = s), (this.type = 'expansionCase');
     }
     visit(e, t) {
      return e.visitExpansionCase(this, t);
     }
    },
    hn = class extends on {
     constructor(e, t, r, n, s, i, a) {
      super(r, a), (this.name = e), (this.value = t), (this.keySpan = n), (this.valueSpan = s), (this.valueTokens = i), (this.type = 'attribute');
     }
     visit(e, t) {
      return e.visitAttribute(this, t);
     }
     get nameSpan() {
      return this.keySpan;
     }
    },
    dn = class extends on {
     constructor(e, t, r, n, s, i = null, a = null, o) {
      super(n, o), (this.name = e), (this.attrs = t), (this.children = r), (this.startSourceSpan = s), (this.endSourceSpan = i), (this.nameSpan = a), (this.type = 'element');
     }
     visit(e, t) {
      return e.visitElement(this, t);
     }
    },
    fn = class {
     constructor(e, t) {
      (this.value = e), (this.sourceSpan = t), (this.type = 'comment');
     }
     visit(e, t) {
      return e.visitComment(this, t);
     }
    },
    mn = class {
     constructor(e, t) {
      (this.value = e), (this.sourceSpan = t), (this.type = 'docType');
     }
     visit(e, t) {
      return e.visitDocType(this, t);
     }
    },
    yn = class extends on {
     constructor(e, t, r, n, s, i, a = null, o) {
      super(n, o), (this.name = e), (this.parameters = t), (this.children = r), (this.nameSpan = s), (this.startSourceSpan = i), (this.endSourceSpan = a), (this.type = 'block');
     }
     visit(e, t) {
      return e.visitBlock(this, t);
     }
    },
    gn = class {
     constructor(e, t) {
      (this.expression = e), (this.sourceSpan = t), (this.type = 'blockParameter'), (this.startSourceSpan = null), (this.endSourceSpan = null);
     }
     visit(e, t) {
      return e.visitBlockParameter(this, t);
     }
    },
    Dn = class {
     constructor(e, t, r, n, s) {
      (this.name = e), (this.value = t), (this.sourceSpan = r), (this.nameSpan = n), (this.valueSpan = s), (this.type = 'letDeclaration'), (this.startSourceSpan = null), (this.endSourceSpan = null);
     }
     visit(e, t) {
      return e.visitLetDeclaration(this, t);
     }
    };
   function xn(e, t, r = null) {
    let n = [],
     s = e.visit ? (t) => e.visit(t, r) || t.visit(e, r) : (t) => t.visit(e, r);
    return (
     t.forEach((e) => {
      let t = s(e);
      t && n.push(t);
     }),
     n
    );
   }
   var bn = class {
     constructor() {}
     visitElement(e, t) {
      this.visitChildren(t, (t) => {
       t(e.attrs), t(e.children);
      });
     }
     visitAttribute(e, t) {}
     visitText(e, t) {}
     visitCdata(e, t) {}
     visitComment(e, t) {}
     visitDocType(e, t) {}
     visitExpansion(e, t) {
      return this.visitChildren(t, (t) => {
       t(e.cases);
      });
     }
     visitExpansionCase(e, t) {}
     visitBlock(e, t) {
      this.visitChildren(t, (t) => {
       t(e.parameters), t(e.children);
      });
     }
     visitBlockParameter(e, t) {}
     visitLetDeclaration(e, t) {}
     visitChildren(e, t) {
      let r = [],
       n = this;
      return (
       t(function (t) {
        t && r.push(xn(n, t, e));
       }),
       Array.prototype.concat.apply([], r)
      );
     }
    },
    vn = { AElig: '\xc6', AMP: '&', amp: '&', Aacute: '\xc1', Abreve: '\u0102', Acirc: '\xc2', Acy: '\u0410', Afr: '\ud835\udd04', Agrave: '\xc0', Alpha: '\u0391', Amacr: '\u0100', And: '\u2a53', Aogon: '\u0104', Aopf: '\ud835\udd38', ApplyFunction: '\u2061', af: '\u2061', Aring: '\xc5', angst: '\xc5', Ascr: '\ud835\udc9c', Assign: '\u2254', colone: '\u2254', coloneq: '\u2254', Atilde: '\xc3', Auml: '\xc4', Backslash: '\u2216', setminus: '\u2216', setmn: '\u2216', smallsetminus: '\u2216', ssetmn: '\u2216', Barv: '\u2ae7', Barwed: '\u2306', doublebarwedge: '\u2306', Bcy: '\u0411', Because: '\u2235', becaus: '\u2235', because: '\u2235', Bernoullis: '\u212c', Bscr: '\u212c', bernou: '\u212c', Beta: '\u0392', Bfr: '\ud835\udd05', Bopf: '\ud835\udd39', Breve: '\u02d8', breve: '\u02d8', Bumpeq: '\u224e', HumpDownHump: '\u224e', bump: '\u224e', CHcy: '\u0427', COPY: '\xa9', copy: '\xa9', Cacute: '\u0106', Cap: '\u22d2', CapitalDifferentialD: '\u2145', DD: '\u2145', Cayleys: '\u212d', Cfr: '\u212d', Ccaron: '\u010c', Ccedil: '\xc7', Ccirc: '\u0108', Cconint: '\u2230', Cdot: '\u010a', Cedilla: '\xb8', cedil: '\xb8', CenterDot: '\xb7', centerdot: '\xb7', middot: '\xb7', Chi: '\u03a7', CircleDot: '\u2299', odot: '\u2299', CircleMinus: '\u2296', ominus: '\u2296', CirclePlus: '\u2295', oplus: '\u2295', CircleTimes: '\u2297', otimes: '\u2297', ClockwiseContourIntegral: '\u2232', cwconint: '\u2232', CloseCurlyDoubleQuote: '\u201d', rdquo: '\u201d', rdquor: '\u201d', CloseCurlyQuote: '\u2019', rsquo: '\u2019', rsquor: '\u2019', Colon: '\u2237', Proportion: '\u2237', Colone: '\u2a74', Congruent: '\u2261', equiv: '\u2261', Conint: '\u222f', DoubleContourIntegral: '\u222f', ContourIntegral: '\u222e', conint: '\u222e', oint: '\u222e', Copf: '\u2102', complexes: '\u2102', Coproduct: '\u2210', coprod: '\u2210', CounterClockwiseContourIntegral: '\u2233', awconint: '\u2233', Cross: '\u2a2f', Cscr: '\ud835\udc9e', Cup: '\u22d3', CupCap: '\u224d', asympeq: '\u224d', DDotrahd: '\u2911', DJcy: '\u0402', DScy: '\u0405', DZcy: '\u040f', Dagger: '\u2021', ddagger: '\u2021', Darr: '\u21a1', Dashv: '\u2ae4', DoubleLeftTee: '\u2ae4', Dcaron: '\u010e', Dcy: '\u0414', Del: '\u2207', nabla: '\u2207', Delta: '\u0394', Dfr: '\ud835\udd07', DiacriticalAcute: '\xb4', acute: '\xb4', DiacriticalDot: '\u02d9', dot: '\u02d9', DiacriticalDoubleAcute: '\u02dd', dblac: '\u02dd', DiacriticalGrave: '`', grave: '`', DiacriticalTilde: '\u02dc', tilde: '\u02dc', Diamond: '\u22c4', diam: '\u22c4', diamond: '\u22c4', DifferentialD: '\u2146', dd: '\u2146', Dopf: '\ud835\udd3b', Dot: '\xa8', DoubleDot: '\xa8', die: '\xa8', uml: '\xa8', DotDot: '\u20dc', DotEqual: '\u2250', doteq: '\u2250', esdot: '\u2250', DoubleDownArrow: '\u21d3', Downarrow: '\u21d3', dArr: '\u21d3', DoubleLeftArrow: '\u21d0', Leftarrow: '\u21d0', lArr: '\u21d0', DoubleLeftRightArrow: '\u21d4', Leftrightarrow: '\u21d4', hArr: '\u21d4', iff: '\u21d4', DoubleLongLeftArrow: '\u27f8', Longleftarrow: '\u27f8', xlArr: '\u27f8', DoubleLongLeftRightArrow: '\u27fa', Longleftrightarrow: '\u27fa', xhArr: '\u27fa', DoubleLongRightArrow: '\u27f9', Longrightarrow: '\u27f9', xrArr: '\u27f9', DoubleRightArrow: '\u21d2', Implies: '\u21d2', Rightarrow: '\u21d2', rArr: '\u21d2', DoubleRightTee: '\u22a8', vDash: '\u22a8', DoubleUpArrow: '\u21d1', Uparrow: '\u21d1', uArr: '\u21d1', DoubleUpDownArrow: '\u21d5', Updownarrow: '\u21d5', vArr: '\u21d5', DoubleVerticalBar: '\u2225', par: '\u2225', parallel: '\u2225', shortparallel: '\u2225', spar: '\u2225', DownArrow: '\u2193', ShortDownArrow: '\u2193', darr: '\u2193', downarrow: '\u2193', DownArrowBar: '\u2913', DownArrowUpArrow: '\u21f5', duarr: '\u21f5', DownBreve: '\u0311', DownLeftRightVector: '\u2950', DownLeftTeeVector: '\u295e', DownLeftVector: '\u21bd', leftharpoondown: '\u21bd', lhard: '\u21bd', DownLeftVectorBar: '\u2956', DownRightTeeVector: '\u295f', DownRightVector: '\u21c1', rhard: '\u21c1', rightharpoondown: '\u21c1', DownRightVectorBar: '\u2957', DownTee: '\u22a4', top: '\u22a4', DownTeeArrow: '\u21a7', mapstodown: '\u21a7', Dscr: '\ud835\udc9f', Dstrok: '\u0110', ENG: '\u014a', ETH: '\xd0', Eacute: '\xc9', Ecaron: '\u011a', Ecirc: '\xca', Ecy: '\u042d', Edot: '\u0116', Efr: '\ud835\udd08', Egrave: '\xc8', Element: '\u2208', in: '\u2208', isin: '\u2208', isinv: '\u2208', Emacr: '\u0112', EmptySmallSquare: '\u25fb', EmptyVerySmallSquare: '\u25ab', Eogon: '\u0118', Eopf: '\ud835\udd3c', Epsilon: '\u0395', Equal: '\u2a75', EqualTilde: '\u2242', eqsim: '\u2242', esim: '\u2242', Equilibrium: '\u21cc', rightleftharpoons: '\u21cc', rlhar: '\u21cc', Escr: '\u2130', expectation: '\u2130', Esim: '\u2a73', Eta: '\u0397', Euml: '\xcb', Exists: '\u2203', exist: '\u2203', ExponentialE: '\u2147', ee: '\u2147', exponentiale: '\u2147', Fcy: '\u0424', Ffr: '\ud835\udd09', FilledSmallSquare: '\u25fc', FilledVerySmallSquare: '\u25aa', blacksquare: '\u25aa', squarf: '\u25aa', squf: '\u25aa', Fopf: '\ud835\udd3d', ForAll: '\u2200', forall: '\u2200', Fouriertrf: '\u2131', Fscr: '\u2131', GJcy: '\u0403', GT: '>', gt: '>', Gamma: '\u0393', Gammad: '\u03dc', Gbreve: '\u011e', Gcedil: '\u0122', Gcirc: '\u011c', Gcy: '\u0413', Gdot: '\u0120', Gfr: '\ud835\udd0a', Gg: '\u22d9', ggg: '\u22d9', Gopf: '\ud835\udd3e', GreaterEqual: '\u2265', ge: '\u2265', geq: '\u2265', GreaterEqualLess: '\u22db', gel: '\u22db', gtreqless: '\u22db', GreaterFullEqual: '\u2267', gE: '\u2267', geqq: '\u2267', GreaterGreater: '\u2aa2', GreaterLess: '\u2277', gl: '\u2277', gtrless: '\u2277', GreaterSlantEqual: '\u2a7e', geqslant: '\u2a7e', ges: '\u2a7e', GreaterTilde: '\u2273', gsim: '\u2273', gtrsim: '\u2273', Gscr: '\ud835\udca2', Gt: '\u226b', NestedGreaterGreater: '\u226b', gg: '\u226b', HARDcy: '\u042a', Hacek: '\u02c7', caron: '\u02c7', Hat: '^', Hcirc: '\u0124', Hfr: '\u210c', Poincareplane: '\u210c', HilbertSpace: '\u210b', Hscr: '\u210b', hamilt: '\u210b', Hopf: '\u210d', quaternions: '\u210d', HorizontalLine: '\u2500', boxh: '\u2500', Hstrok: '\u0126', HumpEqual: '\u224f', bumpe: '\u224f', bumpeq: '\u224f', IEcy: '\u0415', IJlig: '\u0132', IOcy: '\u0401', Iacute: '\xcd', Icirc: '\xce', Icy: '\u0418', Idot: '\u0130', Ifr: '\u2111', Im: '\u2111', image: '\u2111', imagpart: '\u2111', Igrave: '\xcc', Imacr: '\u012a', ImaginaryI: '\u2148', ii: '\u2148', Int: '\u222c', Integral: '\u222b', int: '\u222b', Intersection: '\u22c2', bigcap: '\u22c2', xcap: '\u22c2', InvisibleComma: '\u2063', ic: '\u2063', InvisibleTimes: '\u2062', it: '\u2062', Iogon: '\u012e', Iopf: '\ud835\udd40', Iota: '\u0399', Iscr: '\u2110', imagline: '\u2110', Itilde: '\u0128', Iukcy: '\u0406', Iuml: '\xcf', Jcirc: '\u0134', Jcy: '\u0419', Jfr: '\ud835\udd0d', Jopf: '\ud835\udd41', Jscr: '\ud835\udca5', Jsercy: '\u0408', Jukcy: '\u0404', KHcy: '\u0425', KJcy: '\u040c', Kappa: '\u039a', Kcedil: '\u0136', Kcy: '\u041a', Kfr: '\ud835\udd0e', Kopf: '\ud835\udd42', Kscr: '\ud835\udca6', LJcy: '\u0409', LT: '<', lt: '<', Lacute: '\u0139', Lambda: '\u039b', Lang: '\u27ea', Laplacetrf: '\u2112', Lscr: '\u2112', lagran: '\u2112', Larr: '\u219e', twoheadleftarrow: '\u219e', Lcaron: '\u013d', Lcedil: '\u013b', Lcy: '\u041b', LeftAngleBracket: '\u27e8', lang: '\u27e8', langle: '\u27e8', LeftArrow: '\u2190', ShortLeftArrow: '\u2190', larr: '\u2190', leftarrow: '\u2190', slarr: '\u2190', LeftArrowBar: '\u21e4', larrb: '\u21e4', LeftArrowRightArrow: '\u21c6', leftrightarrows: '\u21c6', lrarr: '\u21c6', LeftCeiling: '\u2308', lceil: '\u2308', LeftDoubleBracket: '\u27e6', lobrk: '\u27e6', LeftDownTeeVector: '\u2961', LeftDownVector: '\u21c3', dharl: '\u21c3', downharpoonleft: '\u21c3', LeftDownVectorBar: '\u2959', LeftFloor: '\u230a', lfloor: '\u230a', LeftRightArrow: '\u2194', harr: '\u2194', leftrightarrow: '\u2194', LeftRightVector: '\u294e', LeftTee: '\u22a3', dashv: '\u22a3', LeftTeeArrow: '\u21a4', mapstoleft: '\u21a4', LeftTeeVector: '\u295a', LeftTriangle: '\u22b2', vartriangleleft: '\u22b2', vltri: '\u22b2', LeftTriangleBar: '\u29cf', LeftTriangleEqual: '\u22b4', ltrie: '\u22b4', trianglelefteq: '\u22b4', LeftUpDownVector: '\u2951', LeftUpTeeVector: '\u2960', LeftUpVector: '\u21bf', uharl: '\u21bf', upharpoonleft: '\u21bf', LeftUpVectorBar: '\u2958', LeftVector: '\u21bc', leftharpoonup: '\u21bc', lharu: '\u21bc', LeftVectorBar: '\u2952', LessEqualGreater: '\u22da', leg: '\u22da', lesseqgtr: '\u22da', LessFullEqual: '\u2266', lE: '\u2266', leqq: '\u2266', LessGreater: '\u2276', lessgtr: '\u2276', lg: '\u2276', LessLess: '\u2aa1', LessSlantEqual: '\u2a7d', leqslant: '\u2a7d', les: '\u2a7d', LessTilde: '\u2272', lesssim: '\u2272', lsim: '\u2272', Lfr: '\ud835\udd0f', Ll: '\u22d8', Lleftarrow: '\u21da', lAarr: '\u21da', Lmidot: '\u013f', LongLeftArrow: '\u27f5', longleftarrow: '\u27f5', xlarr: '\u27f5', LongLeftRightArrow: '\u27f7', longleftrightarrow: '\u27f7', xharr: '\u27f7', LongRightArrow: '\u27f6', longrightarrow: '\u27f6', xrarr: '\u27f6', Lopf: '\ud835\udd43', LowerLeftArrow: '\u2199', swarr: '\u2199', swarrow: '\u2199', LowerRightArrow: '\u2198', searr: '\u2198', searrow: '\u2198', Lsh: '\u21b0', lsh: '\u21b0', Lstrok: '\u0141', Lt: '\u226a', NestedLessLess: '\u226a', ll: '\u226a', Map: '\u2905', Mcy: '\u041c', MediumSpace: '\u205f', Mellintrf: '\u2133', Mscr: '\u2133', phmmat: '\u2133', Mfr: '\ud835\udd10', MinusPlus: '\u2213', mnplus: '\u2213', mp: '\u2213', Mopf: '\ud835\udd44', Mu: '\u039c', NJcy: '\u040a', Nacute: '\u0143', Ncaron: '\u0147', Ncedil: '\u0145', Ncy: '\u041d', NegativeMediumSpace: '\u200b', NegativeThickSpace: '\u200b', NegativeThinSpace: '\u200b', NegativeVeryThinSpace: '\u200b', ZeroWidthSpace: '\u200b', NewLine: '\n', Nfr: '\ud835\udd11', NoBreak: '\u2060', NonBreakingSpace: '\xa0', nbsp: '\xa0', Nopf: '\u2115', naturals: '\u2115', Not: '\u2aec', NotCongruent: '\u2262', nequiv: '\u2262', NotCupCap: '\u226d', NotDoubleVerticalBar: '\u2226', npar: '\u2226', nparallel: '\u2226', nshortparallel: '\u2226', nspar: '\u2226', NotElement: '\u2209', notin: '\u2209', notinva: '\u2209', NotEqual: '\u2260', ne: '\u2260', NotEqualTilde: '\u2242\u0338', nesim: '\u2242\u0338', NotExists: '\u2204', nexist: '\u2204', nexists: '\u2204', NotGreater: '\u226f', ngt: '\u226f', ngtr: '\u226f', NotGreaterEqual: '\u2271', nge: '\u2271', ngeq: '\u2271', NotGreaterFullEqual: '\u2267\u0338', ngE: '\u2267\u0338', ngeqq: '\u2267\u0338', NotGreaterGreater: '\u226b\u0338', nGtv: '\u226b\u0338', NotGreaterLess: '\u2279', ntgl: '\u2279', NotGreaterSlantEqual: '\u2a7e\u0338', ngeqslant: '\u2a7e\u0338', nges: '\u2a7e\u0338', NotGreaterTilde: '\u2275', ngsim: '\u2275', NotHumpDownHump: '\u224e\u0338', nbump: '\u224e\u0338', NotHumpEqual: '\u224f\u0338', nbumpe: '\u224f\u0338', NotLeftTriangle: '\u22ea', nltri: '\u22ea', ntriangleleft: '\u22ea', NotLeftTriangleBar: '\u29cf\u0338', NotLeftTriangleEqual: '\u22ec', nltrie: '\u22ec', ntrianglelefteq: '\u22ec', NotLess: '\u226e', nless: '\u226e', nlt: '\u226e', NotLessEqual: '\u2270', nle: '\u2270', nleq: '\u2270', NotLessGreater: '\u2278', ntlg: '\u2278', NotLessLess: '\u226a\u0338', nLtv: '\u226a\u0338', NotLessSlantEqual: '\u2a7d\u0338', nleqslant: '\u2a7d\u0338', nles: '\u2a7d\u0338', NotLessTilde: '\u2274', nlsim: '\u2274', NotNestedGreaterGreater: '\u2aa2\u0338', NotNestedLessLess: '\u2aa1\u0338', NotPrecedes: '\u2280', npr: '\u2280', nprec: '\u2280', NotPrecedesEqual: '\u2aaf\u0338', npre: '\u2aaf\u0338', npreceq: '\u2aaf\u0338', NotPrecedesSlantEqual: '\u22e0', nprcue: '\u22e0', NotReverseElement: '\u220c', notni: '\u220c', notniva: '\u220c', NotRightTriangle: '\u22eb', nrtri: '\u22eb', ntriangleright: '\u22eb', NotRightTriangleBar: '\u29d0\u0338', NotRightTriangleEqual: '\u22ed', nrtrie: '\u22ed', ntrianglerighteq: '\u22ed', NotSquareSubset: '\u228f\u0338', NotSquareSubsetEqual: '\u22e2', nsqsube: '\u22e2', NotSquareSuperset: '\u2290\u0338', NotSquareSupersetEqual: '\u22e3', nsqsupe: '\u22e3', NotSubset: '\u2282\u20d2', nsubset: '\u2282\u20d2', vnsub: '\u2282\u20d2', NotSubsetEqual: '\u2288', nsube: '\u2288', nsubseteq: '\u2288', NotSucceeds: '\u2281', nsc: '\u2281', nsucc: '\u2281', NotSucceedsEqual: '\u2ab0\u0338', nsce: '\u2ab0\u0338', nsucceq: '\u2ab0\u0338', NotSucceedsSlantEqual: '\u22e1', nsccue: '\u22e1', NotSucceedsTilde: '\u227f\u0338', NotSuperset: '\u2283\u20d2', nsupset: '\u2283\u20d2', vnsup: '\u2283\u20d2', NotSupersetEqual: '\u2289', nsupe: '\u2289', nsupseteq: '\u2289', NotTilde: '\u2241', nsim: '\u2241', NotTildeEqual: '\u2244', nsime: '\u2244', nsimeq: '\u2244', NotTildeFullEqual: '\u2247', ncong: '\u2247', NotTildeTilde: '\u2249', nap: '\u2249', napprox: '\u2249', NotVerticalBar: '\u2224', nmid: '\u2224', nshortmid: '\u2224', nsmid: '\u2224', Nscr: '\ud835\udca9', Ntilde: '\xd1', Nu: '\u039d', OElig: '\u0152', Oacute: '\xd3', Ocirc: '\xd4', Ocy: '\u041e', Odblac: '\u0150', Ofr: '\ud835\udd12', Ograve: '\xd2', Omacr: '\u014c', Omega: '\u03a9', ohm: '\u03a9', Omicron: '\u039f', Oopf: '\ud835\udd46', OpenCurlyDoubleQuote: '\u201c', ldquo: '\u201c', OpenCurlyQuote: '\u2018', lsquo: '\u2018', Or: '\u2a54', Oscr: '\ud835\udcaa', Oslash: '\xd8', Otilde: '\xd5', Otimes: '\u2a37', Ouml: '\xd6', OverBar: '\u203e', oline: '\u203e', OverBrace: '\u23de', OverBracket: '\u23b4', tbrk: '\u23b4', OverParenthesis: '\u23dc', PartialD: '\u2202', part: '\u2202', Pcy: '\u041f', Pfr: '\ud835\udd13', Phi: '\u03a6', Pi: '\u03a0', PlusMinus: '\xb1', plusmn: '\xb1', pm: '\xb1', Popf: '\u2119', primes: '\u2119', Pr: '\u2abb', Precedes: '\u227a', pr: '\u227a', prec: '\u227a', PrecedesEqual: '\u2aaf', pre: '\u2aaf', preceq: '\u2aaf', PrecedesSlantEqual: '\u227c', prcue: '\u227c', preccurlyeq: '\u227c', PrecedesTilde: '\u227e', precsim: '\u227e', prsim: '\u227e', Prime: '\u2033', Product: '\u220f', prod: '\u220f', Proportional: '\u221d', prop: '\u221d', propto: '\u221d', varpropto: '\u221d', vprop: '\u221d', Pscr: '\ud835\udcab', Psi: '\u03a8', QUOT: '"', quot: '"', Qfr: '\ud835\udd14', Qopf: '\u211a', rationals: '\u211a', Qscr: '\ud835\udcac', RBarr: '\u2910', drbkarow: '\u2910', REG: '\xae', circledR: '\xae', reg: '\xae', Racute: '\u0154', Rang: '\u27eb', Rarr: '\u21a0', twoheadrightarrow: '\u21a0', Rarrtl: '\u2916', Rcaron: '\u0158', Rcedil: '\u0156', Rcy: '\u0420', Re: '\u211c', Rfr: '\u211c', real: '\u211c', realpart: '\u211c', ReverseElement: '\u220b', SuchThat: '\u220b', ni: '\u220b', niv: '\u220b', ReverseEquilibrium: '\u21cb', leftrightharpoons: '\u21cb', lrhar: '\u21cb', ReverseUpEquilibrium: '\u296f', duhar: '\u296f', Rho: '\u03a1', RightAngleBracket: '\u27e9', rang: '\u27e9', rangle: '\u27e9', RightArrow: '\u2192', ShortRightArrow: '\u2192', rarr: '\u2192', rightarrow: '\u2192', srarr: '\u2192', RightArrowBar: '\u21e5', rarrb: '\u21e5', RightArrowLeftArrow: '\u21c4', rightleftarrows: '\u21c4', rlarr: '\u21c4', RightCeiling: '\u2309', rceil: '\u2309', RightDoubleBracket: '\u27e7', robrk: '\u27e7', RightDownTeeVector: '\u295d', RightDownVector: '\u21c2', dharr: '\u21c2', downharpoonright: '\u21c2', RightDownVectorBar: '\u2955', RightFloor: '\u230b', rfloor: '\u230b', RightTee: '\u22a2', vdash: '\u22a2', RightTeeArrow: '\u21a6', map: '\u21a6', mapsto: '\u21a6', RightTeeVector: '\u295b', RightTriangle: '\u22b3', vartriangleright: '\u22b3', vrtri: '\u22b3', RightTriangleBar: '\u29d0', RightTriangleEqual: '\u22b5', rtrie: '\u22b5', trianglerighteq: '\u22b5', RightUpDownVector: '\u294f', RightUpTeeVector: '\u295c', RightUpVector: '\u21be', uharr: '\u21be', upharpoonright: '\u21be', RightUpVectorBar: '\u2954', RightVector: '\u21c0', rharu: '\u21c0', rightharpoonup: '\u21c0', RightVectorBar: '\u2953', Ropf: '\u211d', reals: '\u211d', RoundImplies: '\u2970', Rrightarrow: '\u21db', rAarr: '\u21db', Rscr: '\u211b', realine: '\u211b', Rsh: '\u21b1', rsh: '\u21b1', RuleDelayed: '\u29f4', SHCHcy: '\u0429', SHcy: '\u0428', SOFTcy: '\u042c', Sacute: '\u015a', Sc: '\u2abc', Scaron: '\u0160', Scedil: '\u015e', Scirc: '\u015c', Scy: '\u0421', Sfr: '\ud835\udd16', ShortUpArrow: '\u2191', UpArrow: '\u2191', uarr: '\u2191', uparrow: '\u2191', Sigma: '\u03a3', SmallCircle: '\u2218', compfn: '\u2218', Sopf: '\ud835\udd4a', Sqrt: '\u221a', radic: '\u221a', Square: '\u25a1', squ: '\u25a1', square: '\u25a1', SquareIntersection: '\u2293', sqcap: '\u2293', SquareSubset: '\u228f', sqsub: '\u228f', sqsubset: '\u228f', SquareSubsetEqual: '\u2291', sqsube: '\u2291', sqsubseteq: '\u2291', SquareSuperset: '\u2290', sqsup: '\u2290', sqsupset: '\u2290', SquareSupersetEqual: '\u2292', sqsupe: '\u2292', sqsupseteq: '\u2292', SquareUnion: '\u2294', sqcup: '\u2294', Sscr: '\ud835\udcae', Star: '\u22c6', sstarf: '\u22c6', Sub: '\u22d0', Subset: '\u22d0', SubsetEqual: '\u2286', sube: '\u2286', subseteq: '\u2286', Succeeds: '\u227b', sc: '\u227b', succ: '\u227b', SucceedsEqual: '\u2ab0', sce: '\u2ab0', succeq: '\u2ab0', SucceedsSlantEqual: '\u227d', sccue: '\u227d', succcurlyeq: '\u227d', SucceedsTilde: '\u227f', scsim: '\u227f', succsim: '\u227f', Sum: '\u2211', sum: '\u2211', Sup: '\u22d1', Supset: '\u22d1', Superset: '\u2283', sup: '\u2283', supset: '\u2283', SupersetEqual: '\u2287', supe: '\u2287', supseteq: '\u2287', THORN: '\xde', TRADE: '\u2122', trade: '\u2122', TSHcy: '\u040b', TScy: '\u0426', Tab: '\t', Tau: '\u03a4', Tcaron: '\u0164', Tcedil: '\u0162', Tcy: '\u0422', Tfr: '\ud835\udd17', Therefore: '\u2234', there4: '\u2234', therefore: '\u2234', Theta: '\u0398', ThickSpace: '\u205f\u200a', ThinSpace: '\u2009', thinsp: '\u2009', Tilde: '\u223c', sim: '\u223c', thicksim: '\u223c', thksim: '\u223c', TildeEqual: '\u2243', sime: '\u2243', simeq: '\u2243', TildeFullEqual: '\u2245', cong: '\u2245', TildeTilde: '\u2248', ap: '\u2248', approx: '\u2248', asymp: '\u2248', thickapprox: '\u2248', thkap: '\u2248', Topf: '\ud835\udd4b', TripleDot: '\u20db', tdot: '\u20db', Tscr: '\ud835\udcaf', Tstrok: '\u0166', Uacute: '\xda', Uarr: '\u219f', Uarrocir: '\u2949', Ubrcy: '\u040e', Ubreve: '\u016c', Ucirc: '\xdb', Ucy: '\u0423', Udblac: '\u0170', Ufr: '\ud835\udd18', Ugrave: '\xd9', Umacr: '\u016a', UnderBar: '_', lowbar: '_', UnderBrace: '\u23df', UnderBracket: '\u23b5', bbrk: '\u23b5', UnderParenthesis: '\u23dd', Union: '\u22c3', bigcup: '\u22c3', xcup: '\u22c3', UnionPlus: '\u228e', uplus: '\u228e', Uogon: '\u0172', Uopf: '\ud835\udd4c', UpArrowBar: '\u2912', UpArrowDownArrow: '\u21c5', udarr: '\u21c5', UpDownArrow: '\u2195', updownarrow: '\u2195', varr: '\u2195', UpEquilibrium: '\u296e', udhar: '\u296e', UpTee: '\u22a5', bot: '\u22a5', bottom: '\u22a5', perp: '\u22a5', UpTeeArrow: '\u21a5', mapstoup: '\u21a5', UpperLeftArrow: '\u2196', nwarr: '\u2196', nwarrow: '\u2196', UpperRightArrow: '\u2197', nearr: '\u2197', nearrow: '\u2197', Upsi: '\u03d2', upsih: '\u03d2', Upsilon: '\u03a5', Uring: '\u016e', Uscr: '\ud835\udcb0', Utilde: '\u0168', Uuml: '\xdc', VDash: '\u22ab', Vbar: '\u2aeb', Vcy: '\u0412', Vdash: '\u22a9', Vdashl: '\u2ae6', Vee: '\u22c1', bigvee: '\u22c1', xvee: '\u22c1', Verbar: '\u2016', Vert: '\u2016', VerticalBar: '\u2223', mid: '\u2223', shortmid: '\u2223', smid: '\u2223', VerticalLine: '|', verbar: '|', vert: '|', VerticalSeparator: '\u2758', VerticalTilde: '\u2240', wr: '\u2240', wreath: '\u2240', VeryThinSpace: '\u200a', hairsp: '\u200a', Vfr: '\ud835\udd19', Vopf: '\ud835\udd4d', Vscr: '\ud835\udcb1', Vvdash: '\u22aa', Wcirc: '\u0174', Wedge: '\u22c0', bigwedge: '\u22c0', xwedge: '\u22c0', Wfr: '\ud835\udd1a', Wopf: '\ud835\udd4e', Wscr: '\ud835\udcb2', Xfr: '\ud835\udd1b', Xi: '\u039e', Xopf: '\ud835\udd4f', Xscr: '\ud835\udcb3', YAcy: '\u042f', YIcy: '\u0407', YUcy: '\u042e', Yacute: '\xdd', Ycirc: '\u0176', Ycy: '\u042b', Yfr: '\ud835\udd1c', Yopf: '\ud835\udd50', Yscr: '\ud835\udcb4', Yuml: '\u0178', ZHcy: '\u0416', Zacute: '\u0179', Zcaron: '\u017d', Zcy: '\u0417', Zdot: '\u017b', Zeta: '\u0396', Zfr: '\u2128', zeetrf: '\u2128', Zopf: '\u2124', integers: '\u2124', Zscr: '\ud835\udcb5', aacute: '\xe1', abreve: '\u0103', ac: '\u223e', mstpos: '\u223e', acE: '\u223e\u0333', acd: '\u223f', acirc: '\xe2', acy: '\u0430', aelig: '\xe6', afr: '\ud835\udd1e', agrave: '\xe0', alefsym: '\u2135', aleph: '\u2135', alpha: '\u03b1', amacr: '\u0101', amalg: '\u2a3f', and: '\u2227', wedge: '\u2227', andand: '\u2a55', andd: '\u2a5c', andslope: '\u2a58', andv: '\u2a5a', ang: '\u2220', angle: '\u2220', ange: '\u29a4', angmsd: '\u2221', measuredangle: '\u2221', angmsdaa: '\u29a8', angmsdab: '\u29a9', angmsdac: '\u29aa', angmsdad: '\u29ab', angmsdae: '\u29ac', angmsdaf: '\u29ad', angmsdag: '\u29ae', angmsdah: '\u29af', angrt: '\u221f', angrtvb: '\u22be', angrtvbd: '\u299d', angsph: '\u2222', angzarr: '\u237c', aogon: '\u0105', aopf: '\ud835\udd52', apE: '\u2a70', apacir: '\u2a6f', ape: '\u224a', approxeq: '\u224a', apid: '\u224b', apos: "'", aring: '\xe5', ascr: '\ud835\udcb6', ast: '*', midast: '*', atilde: '\xe3', auml: '\xe4', awint: '\u2a11', bNot: '\u2aed', backcong: '\u224c', bcong: '\u224c', backepsilon: '\u03f6', bepsi: '\u03f6', backprime: '\u2035', bprime: '\u2035', backsim: '\u223d', bsim: '\u223d', backsimeq: '\u22cd', bsime: '\u22cd', barvee: '\u22bd', barwed: '\u2305', barwedge: '\u2305', bbrktbrk: '\u23b6', bcy: '\u0431', bdquo: '\u201e', ldquor: '\u201e', bemptyv: '\u29b0', beta: '\u03b2', beth: '\u2136', between: '\u226c', twixt: '\u226c', bfr: '\ud835\udd1f', bigcirc: '\u25ef', xcirc: '\u25ef', bigodot: '\u2a00', xodot: '\u2a00', bigoplus: '\u2a01', xoplus: '\u2a01', bigotimes: '\u2a02', xotime: '\u2a02', bigsqcup: '\u2a06', xsqcup: '\u2a06', bigstar: '\u2605', starf: '\u2605', bigtriangledown: '\u25bd', xdtri: '\u25bd', bigtriangleup: '\u25b3', xutri: '\u25b3', biguplus: '\u2a04', xuplus: '\u2a04', bkarow: '\u290d', rbarr: '\u290d', blacklozenge: '\u29eb', lozf: '\u29eb', blacktriangle: '\u25b4', utrif: '\u25b4', blacktriangledown: '\u25be', dtrif: '\u25be', blacktriangleleft: '\u25c2', ltrif: '\u25c2', blacktriangleright: '\u25b8', rtrif: '\u25b8', blank: '\u2423', blk12: '\u2592', blk14: '\u2591', blk34: '\u2593', block: '\u2588', bne: '=\u20e5', bnequiv: '\u2261\u20e5', bnot: '\u2310', bopf: '\ud835\udd53', bowtie: '\u22c8', boxDL: '\u2557', boxDR: '\u2554', boxDl: '\u2556', boxDr: '\u2553', boxH: '\u2550', boxHD: '\u2566', boxHU: '\u2569', boxHd: '\u2564', boxHu: '\u2567', boxUL: '\u255d', boxUR: '\u255a', boxUl: '\u255c', boxUr: '\u2559', boxV: '\u2551', boxVH: '\u256c', boxVL: '\u2563', boxVR: '\u2560', boxVh: '\u256b', boxVl: '\u2562', boxVr: '\u255f', boxbox: '\u29c9', boxdL: '\u2555', boxdR: '\u2552', boxdl: '\u2510', boxdr: '\u250c', boxhD: '\u2565', boxhU: '\u2568', boxhd: '\u252c', boxhu: '\u2534', boxminus: '\u229f', minusb: '\u229f', boxplus: '\u229e', plusb: '\u229e', boxtimes: '\u22a0', timesb: '\u22a0', boxuL: '\u255b', boxuR: '\u2558', boxul: '\u2518', boxur: '\u2514', boxv: '\u2502', boxvH: '\u256a', boxvL: '\u2561', boxvR: '\u255e', boxvh: '\u253c', boxvl: '\u2524', boxvr: '\u251c', brvbar: '\xa6', bscr: '\ud835\udcb7', bsemi: '\u204f', bsol: '\\', bsolb: '\u29c5', bsolhsub: '\u27c8', bull: '\u2022', bullet: '\u2022', bumpE: '\u2aae', cacute: '\u0107', cap: '\u2229', capand: '\u2a44', capbrcup: '\u2a49', capcap: '\u2a4b', capcup: '\u2a47', capdot: '\u2a40', caps: '\u2229\ufe00', caret: '\u2041', ccaps: '\u2a4d', ccaron: '\u010d', ccedil: '\xe7', ccirc: '\u0109', ccups: '\u2a4c', ccupssm: '\u2a50', cdot: '\u010b', cemptyv: '\u29b2', cent: '\xa2', cfr: '\ud835\udd20', chcy: '\u0447', check: '\u2713', checkmark: '\u2713', chi: '\u03c7', cir: '\u25cb', cirE: '\u29c3', circ: '\u02c6', circeq: '\u2257', cire: '\u2257', circlearrowleft: '\u21ba', olarr: '\u21ba', circlearrowright: '\u21bb', orarr: '\u21bb', circledS: '\u24c8', oS: '\u24c8', circledast: '\u229b', oast: '\u229b', circledcirc: '\u229a', ocir: '\u229a', circleddash: '\u229d', odash: '\u229d', cirfnint: '\u2a10', cirmid: '\u2aef', cirscir: '\u29c2', clubs: '\u2663', clubsuit: '\u2663', colon: ':', comma: ',', commat: '@', comp: '\u2201', complement: '\u2201', congdot: '\u2a6d', copf: '\ud835\udd54', copysr: '\u2117', crarr: '\u21b5', cross: '\u2717', cscr: '\ud835\udcb8', csub: '\u2acf', csube: '\u2ad1', csup: '\u2ad0', csupe: '\u2ad2', ctdot: '\u22ef', cudarrl: '\u2938', cudarrr: '\u2935', cuepr: '\u22de', curlyeqprec: '\u22de', cuesc: '\u22df', curlyeqsucc: '\u22df', cularr: '\u21b6', curvearrowleft: '\u21b6', cularrp: '\u293d', cup: '\u222a', cupbrcap: '\u2a48', cupcap: '\u2a46', cupcup: '\u2a4a', cupdot: '\u228d', cupor: '\u2a45', cups: '\u222a\ufe00', curarr: '\u21b7', curvearrowright: '\u21b7', curarrm: '\u293c', curlyvee: '\u22ce', cuvee: '\u22ce', curlywedge: '\u22cf', cuwed: '\u22cf', curren: '\xa4', cwint: '\u2231', cylcty: '\u232d', dHar: '\u2965', dagger: '\u2020', daleth: '\u2138', dash: '\u2010', hyphen: '\u2010', dbkarow: '\u290f', rBarr: '\u290f', dcaron: '\u010f', dcy: '\u0434', ddarr: '\u21ca', downdownarrows: '\u21ca', ddotseq: '\u2a77', eDDot: '\u2a77', deg: '\xb0', delta: '\u03b4', demptyv: '\u29b1', dfisht: '\u297f', dfr: '\ud835\udd21', diamondsuit: '\u2666', diams: '\u2666', digamma: '\u03dd', gammad: '\u03dd', disin: '\u22f2', div: '\xf7', divide: '\xf7', divideontimes: '\u22c7', divonx: '\u22c7', djcy: '\u0452', dlcorn: '\u231e', llcorner: '\u231e', dlcrop: '\u230d', dollar: '$', dopf: '\ud835\udd55', doteqdot: '\u2251', eDot: '\u2251', dotminus: '\u2238', minusd: '\u2238', dotplus: '\u2214', plusdo: '\u2214', dotsquare: '\u22a1', sdotb: '\u22a1', drcorn: '\u231f', lrcorner: '\u231f', drcrop: '\u230c', dscr: '\ud835\udcb9', dscy: '\u0455', dsol: '\u29f6', dstrok: '\u0111', dtdot: '\u22f1', dtri: '\u25bf', triangledown: '\u25bf', dwangle: '\u29a6', dzcy: '\u045f', dzigrarr: '\u27ff', eacute: '\xe9', easter: '\u2a6e', ecaron: '\u011b', ecir: '\u2256', eqcirc: '\u2256', ecirc: '\xea', ecolon: '\u2255', eqcolon: '\u2255', ecy: '\u044d', edot: '\u0117', efDot: '\u2252', fallingdotseq: '\u2252', efr: '\ud835\udd22', eg: '\u2a9a', egrave: '\xe8', egs: '\u2a96', eqslantgtr: '\u2a96', egsdot: '\u2a98', el: '\u2a99', elinters: '\u23e7', ell: '\u2113', els: '\u2a95', eqslantless: '\u2a95', elsdot: '\u2a97', emacr: '\u0113', empty: '\u2205', emptyset: '\u2205', emptyv: '\u2205', varnothing: '\u2205', emsp13: '\u2004', emsp14: '\u2005', emsp: '\u2003', eng: '\u014b', ensp: '\u2002', eogon: '\u0119', eopf: '\ud835\udd56', epar: '\u22d5', eparsl: '\u29e3', eplus: '\u2a71', epsi: '\u03b5', epsilon: '\u03b5', epsiv: '\u03f5', straightepsilon: '\u03f5', varepsilon: '\u03f5', equals: '=', equest: '\u225f', questeq: '\u225f', equivDD: '\u2a78', eqvparsl: '\u29e5', erDot: '\u2253', risingdotseq: '\u2253', erarr: '\u2971', escr: '\u212f', eta: '\u03b7', eth: '\xf0', euml: '\xeb', euro: '\u20ac', excl: '!', fcy: '\u0444', female: '\u2640', ffilig: '\ufb03', fflig: '\ufb00', ffllig: '\ufb04', ffr: '\ud835\udd23', filig: '\ufb01', fjlig: 'fj', flat: '\u266d', fllig: '\ufb02', fltns: '\u25b1', fnof: '\u0192', fopf: '\ud835\udd57', fork: '\u22d4', pitchfork: '\u22d4', forkv: '\u2ad9', fpartint: '\u2a0d', frac12: '\xbd', half: '\xbd', frac13: '\u2153', frac14: '\xbc', frac15: '\u2155', frac16: '\u2159', frac18: '\u215b', frac23: '\u2154', frac25: '\u2156', frac34: '\xbe', frac35: '\u2157', frac38: '\u215c', frac45: '\u2158', frac56: '\u215a', frac58: '\u215d', frac78: '\u215e', frasl: '\u2044', frown: '\u2322', sfrown: '\u2322', fscr: '\ud835\udcbb', gEl: '\u2a8c', gtreqqless: '\u2a8c', gacute: '\u01f5', gamma: '\u03b3', gap: '\u2a86', gtrapprox: '\u2a86', gbreve: '\u011f', gcirc: '\u011d', gcy: '\u0433', gdot: '\u0121', gescc: '\u2aa9', gesdot: '\u2a80', gesdoto: '\u2a82', gesdotol: '\u2a84', gesl: '\u22db\ufe00', gesles: '\u2a94', gfr: '\ud835\udd24', gimel: '\u2137', gjcy: '\u0453', glE: '\u2a92', gla: '\u2aa5', glj: '\u2aa4', gnE: '\u2269', gneqq: '\u2269', gnap: '\u2a8a', gnapprox: '\u2a8a', gne: '\u2a88', gneq: '\u2a88', gnsim: '\u22e7', gopf: '\ud835\udd58', gscr: '\u210a', gsime: '\u2a8e', gsiml: '\u2a90', gtcc: '\u2aa7', gtcir: '\u2a7a', gtdot: '\u22d7', gtrdot: '\u22d7', gtlPar: '\u2995', gtquest: '\u2a7c', gtrarr: '\u2978', gvertneqq: '\u2269\ufe00', gvnE: '\u2269\ufe00', hardcy: '\u044a', harrcir: '\u2948', harrw: '\u21ad', leftrightsquigarrow: '\u21ad', hbar: '\u210f', hslash: '\u210f', planck: '\u210f', plankv: '\u210f', hcirc: '\u0125', hearts: '\u2665', heartsuit: '\u2665', hellip: '\u2026', mldr: '\u2026', hercon: '\u22b9', hfr: '\ud835\udd25', hksearow: '\u2925', searhk: '\u2925', hkswarow: '\u2926', swarhk: '\u2926', hoarr: '\u21ff', homtht: '\u223b', hookleftarrow: '\u21a9', larrhk: '\u21a9', hookrightarrow: '\u21aa', rarrhk: '\u21aa', hopf: '\ud835\udd59', horbar: '\u2015', hscr: '\ud835\udcbd', hstrok: '\u0127', hybull: '\u2043', iacute: '\xed', icirc: '\xee', icy: '\u0438', iecy: '\u0435', iexcl: '\xa1', ifr: '\ud835\udd26', igrave: '\xec', iiiint: '\u2a0c', qint: '\u2a0c', iiint: '\u222d', tint: '\u222d', iinfin: '\u29dc', iiota: '\u2129', ijlig: '\u0133', imacr: '\u012b', imath: '\u0131', inodot: '\u0131', imof: '\u22b7', imped: '\u01b5', incare: '\u2105', infin: '\u221e', infintie: '\u29dd', intcal: '\u22ba', intercal: '\u22ba', intlarhk: '\u2a17', intprod: '\u2a3c', iprod: '\u2a3c', iocy: '\u0451', iogon: '\u012f', iopf: '\ud835\udd5a', iota: '\u03b9', iquest: '\xbf', iscr: '\ud835\udcbe', isinE: '\u22f9', isindot: '\u22f5', isins: '\u22f4', isinsv: '\u22f3', itilde: '\u0129', iukcy: '\u0456', iuml: '\xef', jcirc: '\u0135', jcy: '\u0439', jfr: '\ud835\udd27', jmath: '\u0237', jopf: '\ud835\udd5b', jscr: '\ud835\udcbf', jsercy: '\u0458', jukcy: '\u0454', kappa: '\u03ba', kappav: '\u03f0', varkappa: '\u03f0', kcedil: '\u0137', kcy: '\u043a', kfr: '\ud835\udd28', kgreen: '\u0138', khcy: '\u0445', kjcy: '\u045c', kopf: '\ud835\udd5c', kscr: '\ud835\udcc0', lAtail: '\u291b', lBarr: '\u290e', lEg: '\u2a8b', lesseqqgtr: '\u2a8b', lHar: '\u2962', lacute: '\u013a', laemptyv: '\u29b4', lambda: '\u03bb', langd: '\u2991', lap: '\u2a85', lessapprox: '\u2a85', laquo: '\xab', larrbfs: '\u291f', larrfs: '\u291d', larrlp: '\u21ab', looparrowleft: '\u21ab', larrpl: '\u2939', larrsim: '\u2973', larrtl: '\u21a2', leftarrowtail: '\u21a2', lat: '\u2aab', latail: '\u2919', late: '\u2aad', lates: '\u2aad\ufe00', lbarr: '\u290c', lbbrk: '\u2772', lbrace: '{', lcub: '{', lbrack: '[', lsqb: '[', lbrke: '\u298b', lbrksld: '\u298f', lbrkslu: '\u298d', lcaron: '\u013e', lcedil: '\u013c', lcy: '\u043b', ldca: '\u2936', ldrdhar: '\u2967', ldrushar: '\u294b', ldsh: '\u21b2', le: '\u2264', leq: '\u2264', leftleftarrows: '\u21c7', llarr: '\u21c7', leftthreetimes: '\u22cb', lthree: '\u22cb', lescc: '\u2aa8', lesdot: '\u2a7f', lesdoto: '\u2a81', lesdotor: '\u2a83', lesg: '\u22da\ufe00', lesges: '\u2a93', lessdot: '\u22d6', ltdot: '\u22d6', lfisht: '\u297c', lfr: '\ud835\udd29', lgE: '\u2a91', lharul: '\u296a', lhblk: '\u2584', ljcy: '\u0459', llhard: '\u296b', lltri: '\u25fa', lmidot: '\u0140', lmoust: '\u23b0', lmoustache: '\u23b0', lnE: '\u2268', lneqq: '\u2268', lnap: '\u2a89', lnapprox: '\u2a89', lne: '\u2a87', lneq: '\u2a87', lnsim: '\u22e6', loang: '\u27ec', loarr: '\u21fd', longmapsto: '\u27fc', xmap: '\u27fc', looparrowright: '\u21ac', rarrlp: '\u21ac', lopar: '\u2985', lopf: '\ud835\udd5d', loplus: '\u2a2d', lotimes: '\u2a34', lowast: '\u2217', loz: '\u25ca', lozenge: '\u25ca', lpar: '(', lparlt: '\u2993', lrhard: '\u296d', lrm: '\u200e', lrtri: '\u22bf', lsaquo: '\u2039', lscr: '\ud835\udcc1', lsime: '\u2a8d', lsimg: '\u2a8f', lsquor: '\u201a', sbquo: '\u201a', lstrok: '\u0142', ltcc: '\u2aa6', ltcir: '\u2a79', ltimes: '\u22c9', ltlarr: '\u2976', ltquest: '\u2a7b', ltrPar: '\u2996', ltri: '\u25c3', triangleleft: '\u25c3', lurdshar: '\u294a', luruhar: '\u2966', lvertneqq: '\u2268\ufe00', lvnE: '\u2268\ufe00', mDDot: '\u223a', macr: '\xaf', strns: '\xaf', male: '\u2642', malt: '\u2720', maltese: '\u2720', marker: '\u25ae', mcomma: '\u2a29', mcy: '\u043c', mdash: '\u2014', mfr: '\ud835\udd2a', mho: '\u2127', micro: '\xb5', midcir: '\u2af0', minus: '\u2212', minusdu: '\u2a2a', mlcp: '\u2adb', models: '\u22a7', mopf: '\ud835\udd5e', mscr: '\ud835\udcc2', mu: '\u03bc', multimap: '\u22b8', mumap: '\u22b8', nGg: '\u22d9\u0338', nGt: '\u226b\u20d2', nLeftarrow: '\u21cd', nlArr: '\u21cd', nLeftrightarrow: '\u21ce', nhArr: '\u21ce', nLl: '\u22d8\u0338', nLt: '\u226a\u20d2', nRightarrow: '\u21cf', nrArr: '\u21cf', nVDash: '\u22af', nVdash: '\u22ae', nacute: '\u0144', nang: '\u2220\u20d2', napE: '\u2a70\u0338', napid: '\u224b\u0338', napos: '\u0149', natur: '\u266e', natural: '\u266e', ncap: '\u2a43', ncaron: '\u0148', ncedil: '\u0146', ncongdot: '\u2a6d\u0338', ncup: '\u2a42', ncy: '\u043d', ndash: '\u2013', neArr: '\u21d7', nearhk: '\u2924', nedot: '\u2250\u0338', nesear: '\u2928', toea: '\u2928', nfr: '\ud835\udd2b', nharr: '\u21ae', nleftrightarrow: '\u21ae', nhpar: '\u2af2', nis: '\u22fc', nisd: '\u22fa', njcy: '\u045a', nlE: '\u2266\u0338', nleqq: '\u2266\u0338', nlarr: '\u219a', nleftarrow: '\u219a', nldr: '\u2025', nopf: '\ud835\udd5f', not: '\xac', notinE: '\u22f9\u0338', notindot: '\u22f5\u0338', notinvb: '\u22f7', notinvc: '\u22f6', notnivb: '\u22fe', notnivc: '\u22fd', nparsl: '\u2afd\u20e5', npart: '\u2202\u0338', npolint: '\u2a14', nrarr: '\u219b', nrightarrow: '\u219b', nrarrc: '\u2933\u0338', nrarrw: '\u219d\u0338', nscr: '\ud835\udcc3', nsub: '\u2284', nsubE: '\u2ac5\u0338', nsubseteqq: '\u2ac5\u0338', nsup: '\u2285', nsupE: '\u2ac6\u0338', nsupseteqq: '\u2ac6\u0338', ntilde: '\xf1', nu: '\u03bd', num: '#', numero: '\u2116', numsp: '\u2007', nvDash: '\u22ad', nvHarr: '\u2904', nvap: '\u224d\u20d2', nvdash: '\u22ac', nvge: '\u2265\u20d2', nvgt: '>\u20d2', nvinfin: '\u29de', nvlArr: '\u2902', nvle: '\u2264\u20d2', nvlt: '<\u20d2', nvltrie: '\u22b4\u20d2', nvrArr: '\u2903', nvrtrie: '\u22b5\u20d2', nvsim: '\u223c\u20d2', nwArr: '\u21d6', nwarhk: '\u2923', nwnear: '\u2927', oacute: '\xf3', ocirc: '\xf4', ocy: '\u043e', odblac: '\u0151', odiv: '\u2a38', odsold: '\u29bc', oelig: '\u0153', ofcir: '\u29bf', ofr: '\ud835\udd2c', ogon: '\u02db', ograve: '\xf2', ogt: '\u29c1', ohbar: '\u29b5', olcir: '\u29be', olcross: '\u29bb', olt: '\u29c0', omacr: '\u014d', omega: '\u03c9', omicron: '\u03bf', omid: '\u29b6', oopf: '\ud835\udd60', opar: '\u29b7', operp: '\u29b9', or: '\u2228', vee: '\u2228', ord: '\u2a5d', order: '\u2134', orderof: '\u2134', oscr: '\u2134', ordf: '\xaa', ordm: '\xba', origof: '\u22b6', oror: '\u2a56', orslope: '\u2a57', orv: '\u2a5b', oslash: '\xf8', osol: '\u2298', otilde: '\xf5', otimesas: '\u2a36', ouml: '\xf6', ovbar: '\u233d', para: '\xb6', parsim: '\u2af3', parsl: '\u2afd', pcy: '\u043f', percnt: '%', period: '.', permil: '\u2030', pertenk: '\u2031', pfr: '\ud835\udd2d', phi: '\u03c6', phiv: '\u03d5', straightphi: '\u03d5', varphi: '\u03d5', phone: '\u260e', pi: '\u03c0', piv: '\u03d6', varpi: '\u03d6', planckh: '\u210e', plus: '+', plusacir: '\u2a23', pluscir: '\u2a22', plusdu: '\u2a25', pluse: '\u2a72', plussim: '\u2a26', plustwo: '\u2a27', pointint: '\u2a15', popf: '\ud835\udd61', pound: '\xa3', prE: '\u2ab3', prap: '\u2ab7', precapprox: '\u2ab7', precnapprox: '\u2ab9', prnap: '\u2ab9', precneqq: '\u2ab5', prnE: '\u2ab5', precnsim: '\u22e8', prnsim: '\u22e8', prime: '\u2032', profalar: '\u232e', profline: '\u2312', profsurf: '\u2313', prurel: '\u22b0', pscr: '\ud835\udcc5', psi: '\u03c8', puncsp: '\u2008', qfr: '\ud835\udd2e', qopf: '\ud835\udd62', qprime: '\u2057', qscr: '\ud835\udcc6', quatint: '\u2a16', quest: '?', rAtail: '\u291c', rHar: '\u2964', race: '\u223d\u0331', racute: '\u0155', raemptyv: '\u29b3', rangd: '\u2992', range: '\u29a5', raquo: '\xbb', rarrap: '\u2975', rarrbfs: '\u2920', rarrc: '\u2933', rarrfs: '\u291e', rarrpl: '\u2945', rarrsim: '\u2974', rarrtl: '\u21a3', rightarrowtail: '\u21a3', rarrw: '\u219d', rightsquigarrow: '\u219d', ratail: '\u291a', ratio: '\u2236', rbbrk: '\u2773', rbrace: '}', rcub: '}', rbrack: ']', rsqb: ']', rbrke: '\u298c', rbrksld: '\u298e', rbrkslu: '\u2990', rcaron: '\u0159', rcedil: '\u0157', rcy: '\u0440', rdca: '\u2937', rdldhar: '\u2969', rdsh: '\u21b3', rect: '\u25ad', rfisht: '\u297d', rfr: '\ud835\udd2f', rharul: '\u296c', rho: '\u03c1', rhov: '\u03f1', varrho: '\u03f1', rightrightarrows: '\u21c9', rrarr: '\u21c9', rightthreetimes: '\u22cc', rthree: '\u22cc', ring: '\u02da', rlm: '\u200f', rmoust: '\u23b1', rmoustache: '\u23b1', rnmid: '\u2aee', roang: '\u27ed', roarr: '\u21fe', ropar: '\u2986', ropf: '\ud835\udd63', roplus: '\u2a2e', rotimes: '\u2a35', rpar: ')', rpargt: '\u2994', rppolint: '\u2a12', rsaquo: '\u203a', rscr: '\ud835\udcc7', rtimes: '\u22ca', rtri: '\u25b9', triangleright: '\u25b9', rtriltri: '\u29ce', ruluhar: '\u2968', rx: '\u211e', sacute: '\u015b', scE: '\u2ab4', scap: '\u2ab8', succapprox: '\u2ab8', scaron: '\u0161', scedil: '\u015f', scirc: '\u015d', scnE: '\u2ab6', succneqq: '\u2ab6', scnap: '\u2aba', succnapprox: '\u2aba', scnsim: '\u22e9', succnsim: '\u22e9', scpolint: '\u2a13', scy: '\u0441', sdot: '\u22c5', sdote: '\u2a66', seArr: '\u21d8', sect: '\xa7', semi: ';', seswar: '\u2929', tosa: '\u2929', sext: '\u2736', sfr: '\ud835\udd30', sharp: '\u266f', shchcy: '\u0449', shcy: '\u0448', shy: '\xad', sigma: '\u03c3', sigmaf: '\u03c2', sigmav: '\u03c2', varsigma: '\u03c2', simdot: '\u2a6a', simg: '\u2a9e', simgE: '\u2aa0', siml: '\u2a9d', simlE: '\u2a9f', simne: '\u2246', simplus: '\u2a24', simrarr: '\u2972', smashp: '\u2a33', smeparsl: '\u29e4', smile: '\u2323', ssmile: '\u2323', smt: '\u2aaa', smte: '\u2aac', smtes: '\u2aac\ufe00', softcy: '\u044c', sol: '/', solb: '\u29c4', solbar: '\u233f', sopf: '\ud835\udd64', spades: '\u2660', spadesuit: '\u2660', sqcaps: '\u2293\ufe00', sqcups: '\u2294\ufe00', sscr: '\ud835\udcc8', star: '\u2606', sub: '\u2282', subset: '\u2282', subE: '\u2ac5', subseteqq: '\u2ac5', subdot: '\u2abd', subedot: '\u2ac3', submult: '\u2ac1', subnE: '\u2acb', subsetneqq: '\u2acb', subne: '\u228a', subsetneq: '\u228a', subplus: '\u2abf', subrarr: '\u2979', subsim: '\u2ac7', subsub: '\u2ad5', subsup: '\u2ad3', sung: '\u266a', sup1: '\xb9', sup2: '\xb2', sup3: '\xb3', supE: '\u2ac6', supseteqq: '\u2ac6', supdot: '\u2abe', supdsub: '\u2ad8', supedot: '\u2ac4', suphsol: '\u27c9', suphsub: '\u2ad7', suplarr: '\u297b', supmult: '\u2ac2', supnE: '\u2acc', supsetneqq: '\u2acc', supne: '\u228b', supsetneq: '\u228b', supplus: '\u2ac0', supsim: '\u2ac8', supsub: '\u2ad4', supsup: '\u2ad6', swArr: '\u21d9', swnwar: '\u292a', szlig: '\xdf', target: '\u2316', tau: '\u03c4', tcaron: '\u0165', tcedil: '\u0163', tcy: '\u0442', telrec: '\u2315', tfr: '\ud835\udd31', theta: '\u03b8', thetasym: '\u03d1', thetav: '\u03d1', vartheta: '\u03d1', thorn: '\xfe', times: '\xd7', timesbar: '\u2a31', timesd: '\u2a30', topbot: '\u2336', topcir: '\u2af1', topf: '\ud835\udd65', topfork: '\u2ada', tprime: '\u2034', triangle: '\u25b5', utri: '\u25b5', triangleq: '\u225c', trie: '\u225c', tridot: '\u25ec', triminus: '\u2a3a', triplus: '\u2a39', trisb: '\u29cd', tritime: '\u2a3b', trpezium: '\u23e2', tscr: '\ud835\udcc9', tscy: '\u0446', tshcy: '\u045b', tstrok: '\u0167', uHar: '\u2963', uacute: '\xfa', ubrcy: '\u045e', ubreve: '\u016d', ucirc: '\xfb', ucy: '\u0443', udblac: '\u0171', ufisht: '\u297e', ufr: '\ud835\udd32', ugrave: '\xf9', uhblk: '\u2580', ulcorn: '\u231c', ulcorner: '\u231c', ulcrop: '\u230f', ultri: '\u25f8', umacr: '\u016b', uogon: '\u0173', uopf: '\ud835\udd66', upsi: '\u03c5', upsilon: '\u03c5', upuparrows: '\u21c8', uuarr: '\u21c8', urcorn: '\u231d', urcorner: '\u231d', urcrop: '\u230e', uring: '\u016f', urtri: '\u25f9', uscr: '\ud835\udcca', utdot: '\u22f0', utilde: '\u0169', uuml: '\xfc', uwangle: '\u29a7', vBar: '\u2ae8', vBarv: '\u2ae9', vangrt: '\u299c', varsubsetneq: '\u228a\ufe00', vsubne: '\u228a\ufe00', varsubsetneqq: '\u2acb\ufe00', vsubnE: '\u2acb\ufe00', varsupsetneq: '\u228b\ufe00', vsupne: '\u228b\ufe00', varsupsetneqq: '\u2acc\ufe00', vsupnE: '\u2acc\ufe00', vcy: '\u0432', veebar: '\u22bb', veeeq: '\u225a', vellip: '\u22ee', vfr: '\ud835\udd33', vopf: '\ud835\udd67', vscr: '\ud835\udccb', vzigzag: '\u299a', wcirc: '\u0175', wedbar: '\u2a5f', wedgeq: '\u2259', weierp: '\u2118', wp: '\u2118', wfr: '\ud835\udd34', wopf: '\ud835\udd68', wscr: '\ud835\udccc', xfr: '\ud835\udd35', xi: '\u03be', xnis: '\u22fb', xopf: '\ud835\udd69', xscr: '\ud835\udccd', yacute: '\xfd', yacy: '\u044f', ycirc: '\u0177', ycy: '\u044b', yen: '\xa5', yfr: '\ud835\udd36', yicy: '\u0457', yopf: '\ud835\udd6a', yscr: '\ud835\udcce', yucy: '\u044e', yuml: '\xff', zacute: '\u017a', zcaron: '\u017e', zcy: '\u0437', zdot: '\u017c', zeta: '\u03b6', zfr: '\ud835\udd37', zhcy: '\u0436', zigrarr: '\u21dd', zopf: '\ud835\udd6b', zscr: '\ud835\udccf', zwj: '\u200d', zwnj: '\u200c' };
   vn.ngsp = '\ue500';
   var En = null;
   var Cn = new (class e {
     static fromArray(t) {
      return t
       ? ((function (e, t) {
          if (null != t && (!Array.isArray(t) || 2 != t.length)) throw new Error(`Expected '${e}' to be an array, [start, end].`);
          if (null != t) {
           let e = t[0],
            r = t[1];
           En.forEach((t) => {
            if (t.test(e) || t.test(r)) throw new Error(`['${e}', '${r}'] contains unusable interpolation symbol.`);
           });
          }
         })('interpolation', t),
         new e(t[0], t[1]))
       : Cn;
     }
     constructor(e, t) {
      (this.start = e), (this.end = t);
     }
    })('{{', '}}'),
    Tn = class extends Sr {
     constructor(e, t, r) {
      super(r, e), (this.tokenType = t);
     }
    },
    Sn = class {
     constructor(e, t, r) {
      (this.tokens = e), (this.errors = t), (this.nonNormalizedIcuExpressions = r);
     }
    };
   var wn,
    An = /\r\n?/g;
   function Fn(e) {
    return `Unexpected character "${0 === e ? 'EOF' : String.fromCharCode(e)}"`;
   }
   function kn(e) {
    return `Unknown entity "${e}" - use the "&#<decimal>;" or  "&#x<hex>;" syntax`;
   }
   !(function (e) {
    (e.HEX = 'hexadecimal'), (e.DEC = 'decimal');
   })(wn || (wn = {}));
   var Pn = class {
     constructor(e) {
      this.error = e;
     }
    },
    In = class {
     constructor(e, t, r) {
      (this._getTagContentType = t), (this._currentTokenStart = null), (this._currentTokenType = null), (this._expansionCaseStack = []), (this._inInterpolation = !1), (this._fullNameStack = []), (this.tokens = []), (this.errors = []), (this.nonNormalizedIcuExpressions = []), (this._tokenizeIcu = r.tokenizeExpansionForms || !1), (this._interpolationConfig = r.interpolationConfig || Cn), (this._leadingTriviaCodePoints = r.leadingTriviaChars && r.leadingTriviaChars.map((e) => e.codePointAt(0) || 0)), (this._canSelfClose = r.canSelfClose || !1), (this._allowHtmComponentClosingTags = r.allowHtmComponentClosingTags || !1);
      let n = r.range || { endPos: e.content.length, startPos: 0, startLine: 0, startCol: 0 };
      (this._cursor = r.escapedString ? new Un(e, n) : new qn(e, n)), (this._preserveLineEndings = r.preserveLineEndings || !1), (this._i18nNormalizeLineEndingsInICUs = r.i18nNormalizeLineEndingsInICUs || !1), (this._tokenizeBlocks = r.tokenizeBlocks ?? !0), (this._tokenizeLet = r.tokenizeLet ?? !0);
      try {
       this._cursor.init();
      } catch (s) {
       this.handleError(s);
      }
     }
     _processCarriageReturns(e) {
      return this._preserveLineEndings ? e : e.replace(An, '\n');
     }
     tokenize() {
      for (; 0 !== this._cursor.peek(); ) {
       let t = this._cursor.clone();
       try {
        if (this._attemptCharCode(60))
         if (this._attemptCharCode(33)) this._attemptStr('[CDATA[') ? this._consumeCdata(t) : this._attemptStr('--') ? this._consumeComment(t) : this._attemptStrCaseInsensitive('doctype') ? this._consumeDocType(t) : this._consumeBogusComment(t);
         else if (this._attemptCharCode(47)) this._consumeTagClose(t);
         else {
          let e = this._cursor.clone();
          this._attemptCharCode(63) ? ((this._cursor = e), this._consumeBogusComment(t)) : this._consumeTagOpen(t);
         }
        else
         this._tokenizeLet && 64 === this._cursor.peek() && !this._inInterpolation && this._attemptStr('@let')
          ? this._consumeLetDeclaration(t)
          : this._tokenizeBlocks && this._attemptCharCode(64)
            ? this._consumeBlockStart(t)
            : !this._tokenizeBlocks || this._inInterpolation || this._isInExpansionCase() || this._isInExpansionForm() || !this._attemptCharCode(125)
              ? (this._tokenizeIcu && this._tokenizeExpansionForm()) ||
                this._consumeWithInterpolation(
                 5,
                 8,
                 () => this._isTextEnd(),
                 () => this._isTagStart(),
                )
              : this._consumeBlockEnd(t);
       } catch (e) {
        this.handleError(e);
       }
      }
      this._beginToken(34), this._endToken([]);
     }
     _getBlockName() {
      let e = !1,
       t = this._cursor.clone();
      return this._attemptCharCodeUntilFn((t) => (dr(t) ? !e : !jn(t) || ((e = !0), !1))), this._cursor.getChars(t).trim();
     }
     _consumeBlockStart(e) {
      this._beginToken(25, e);
      let t = this._endToken([this._getBlockName()]);
      if (40 === this._cursor.peek()) {
       if ((this._cursor.advance(), this._consumeBlockParameters(), this._attemptCharCodeUntilFn(Nn), !this._attemptCharCode(41))) return void (t.type = 29);
       this._attemptCharCodeUntilFn(Nn);
      }
      this._attemptCharCode(123) ? (this._beginToken(26), this._endToken([])) : (t.type = 29);
     }
     _consumeBlockEnd(e) {
      this._beginToken(27, e), this._endToken([]);
     }
     _consumeBlockParameters() {
      for (this._attemptCharCodeUntilFn(Rn); 41 !== this._cursor.peek() && 0 !== this._cursor.peek(); ) {
       this._beginToken(28);
       let e = this._cursor.clone(),
        t = null,
        r = 0;
       for (; (59 !== this._cursor.peek() && 0 !== this._cursor.peek()) || null !== t; ) {
        let e = this._cursor.peek();
        if (92 === e) this._cursor.advance();
        else if (e === t) t = null;
        else if (null === t && Dr(e)) t = e;
        else if (40 === e && null === t) r++;
        else if (41 === e && null === t) {
         if (0 === r) break;
         r > 0 && r--;
        }
        this._cursor.advance();
       }
       this._endToken([this._cursor.getChars(e)]), this._attemptCharCodeUntilFn(Rn);
      }
     }
     _consumeLetDeclaration(e) {
      if ((this._beginToken(30, e), !dr(this._cursor.peek()))) {
       return void (this._endToken([this._cursor.getChars(e)]).type = 33);
      }
      this._attemptCharCodeUntilFn(Nn);
      let t = this._endToken([this._getLetDeclarationName()]);
      this._attemptCharCodeUntilFn(Nn), this._attemptCharCode(61) ? (this._attemptCharCodeUntilFn((e) => Nn(e) && !yr(e)), this._consumeLetDeclarationValue(), 59 === this._cursor.peek() ? (this._beginToken(32), this._endToken([]), this._cursor.advance()) : ((t.type = 33), (t.sourceSpan = this._cursor.getSpan(e)))) : (t.type = 33);
     }
     _getLetDeclarationName() {
      let e = this._cursor.clone(),
       t = !1;
      return this._attemptCharCodeUntilFn((e) => !(mr(e) || 36 === e || 95 === e || (t && fr(e))) || ((t = !0), !1)), this._cursor.getChars(e).trim();
     }
     _consumeLetDeclarationValue() {
      let e = this._cursor.clone();
      for (this._beginToken(31, e); 0 !== this._cursor.peek(); ) {
       let e = this._cursor.peek();
       if (59 === e) break;
       Dr(e) && (this._cursor.advance(), this._attemptCharCodeUntilFn((t) => (92 === t ? (this._cursor.advance(), !1) : t === e))), this._cursor.advance();
      }
      this._endToken([this._cursor.getChars(e)]);
     }
     _tokenizeExpansionForm() {
      if (this.isExpansionFormStart()) return this._consumeExpansionFormStart(), !0;
      if (
       (function (e) {
        return 125 !== e;
       })(this._cursor.peek()) &&
       this._isInExpansionForm()
      )
       return this._consumeExpansionCaseStart(), !0;
      if (125 === this._cursor.peek()) {
       if (this._isInExpansionCase()) return this._consumeExpansionCaseEnd(), !0;
       if (this._isInExpansionForm()) return this._consumeExpansionFormEnd(), !0;
      }
      return !1;
     }
     _beginToken(e, t = this._cursor.clone()) {
      (this._currentTokenStart = t), (this._currentTokenType = e);
     }
     _endToken(e, t) {
      if (null === this._currentTokenStart) throw new Tn('Programming error - attempted to end a token when there was no start to the token', this._currentTokenType, this._cursor.getSpan(t));
      if (null === this._currentTokenType) throw new Tn('Programming error - attempted to end a token which has no token type', null, this._cursor.getSpan(this._currentTokenStart));
      let r = { type: this._currentTokenType, parts: e, sourceSpan: (t ?? this._cursor).getSpan(this._currentTokenStart, this._leadingTriviaCodePoints) };
      return this.tokens.push(r), (this._currentTokenStart = null), (this._currentTokenType = null), r;
     }
     _createError(e, t) {
      this._isInExpansionForm() && (e += ' (Do you have an unescaped "{" in your template? Use "{{ \'{\' }}") to escape it.)');
      let r = new Tn(e, this._currentTokenType, t);
      return (this._currentTokenStart = null), (this._currentTokenType = null), new Pn(r);
     }
     handleError(e) {
      if ((e instanceof $n && (e = this._createError(e.msg, this._cursor.getSpan(e.cursor))), !(e instanceof Pn))) throw e;
      this.errors.push(e.error);
     }
     _attemptCharCode(e) {
      return this._cursor.peek() === e && (this._cursor.advance(), !0);
     }
     _attemptCharCodeCaseInsensitive(e) {
      return (
       !!(function (e, t) {
        return Mn(e) === Mn(t);
       })(this._cursor.peek(), e) && (this._cursor.advance(), !0)
      );
     }
     _requireCharCode(e) {
      let t = this._cursor.clone();
      if (!this._attemptCharCode(e)) throw this._createError(Fn(this._cursor.peek()), this._cursor.getSpan(t));
     }
     _attemptStr(e) {
      let t = e.length;
      if (this._cursor.charsLeft() < t) return !1;
      let r = this._cursor.clone();
      for (let n = 0; n < t; n++) if (!this._attemptCharCode(e.charCodeAt(n))) return (this._cursor = r), !1;
      return !0;
     }
     _attemptStrCaseInsensitive(e) {
      for (let t = 0; t < e.length; t++) if (!this._attemptCharCodeCaseInsensitive(e.charCodeAt(t))) return !1;
      return !0;
     }
     _requireStr(e) {
      let t = this._cursor.clone();
      if (!this._attemptStr(e)) throw this._createError(Fn(this._cursor.peek()), this._cursor.getSpan(t));
     }
     _requireStrCaseInsensitive(e) {
      let t = this._cursor.clone();
      if (!this._attemptStrCaseInsensitive(e)) throw this._createError(Fn(this._cursor.peek()), this._cursor.getSpan(t));
     }
     _attemptCharCodeUntilFn(e) {
      for (; !e(this._cursor.peek()); ) this._cursor.advance();
     }
     _requireCharCodeUntilFn(e, t) {
      let r = this._cursor.clone();
      if ((this._attemptCharCodeUntilFn(e), this._cursor.diff(r) < t)) throw this._createError(Fn(this._cursor.peek()), this._cursor.getSpan(r));
     }
     _attemptUntilChar(e) {
      for (; this._cursor.peek() !== e; ) this._cursor.advance();
     }
     _readChar() {
      let e = String.fromCodePoint(this._cursor.peek());
      return this._cursor.advance(), e;
     }
     _consumeEntity(e) {
      this._beginToken(9);
      let t = this._cursor.clone();
      if ((this._cursor.advance(), this._attemptCharCode(35))) {
       let e = this._attemptCharCode(120) || this._attemptCharCode(88),
        r = this._cursor.clone();
       if ((this._attemptCharCodeUntilFn(Ln), 59 != this._cursor.peek())) {
        this._cursor.advance();
        let r = e ? wn.HEX : wn.DEC;
        throw this._createError(
         (function (e, t) {
          return `Unable to parse entity "${t}" - ${e} character reference entities must end with ";"`;
         })(r, this._cursor.getChars(t)),
         this._cursor.getSpan(),
        );
       }
       let n = this._cursor.getChars(r);
       this._cursor.advance();
       try {
        let r = parseInt(n, e ? 16 : 10);
        this._endToken([String.fromCharCode(r), this._cursor.getChars(t)]);
       } catch {
        throw this._createError(kn(this._cursor.getChars(t)), this._cursor.getSpan());
       }
      } else {
       let r = this._cursor.clone();
       if ((this._attemptCharCodeUntilFn(On), 59 != this._cursor.peek())) this._beginToken(e, t), (this._cursor = r), this._endToken(['&']);
       else {
        let e = this._cursor.getChars(r);
        this._cursor.advance();
        let n = vn[e];
        if (!n) throw this._createError(kn(e), this._cursor.getSpan(t));
        this._endToken([n, `&${e};`]);
       }
      }
     }
     _consumeRawText(e, t) {
      this._beginToken(e ? 6 : 7);
      let r = [];
      for (;;) {
       let n = this._cursor.clone(),
        s = t();
       if (((this._cursor = n), s)) break;
       e && 38 === this._cursor.peek() ? (this._endToken([this._processCarriageReturns(r.join(''))]), (r.length = 0), this._consumeEntity(6), this._beginToken(6)) : r.push(this._readChar());
      }
      this._endToken([this._processCarriageReturns(r.join(''))]);
     }
     _consumeComment(e) {
      this._beginToken(10, e), this._endToken([]), this._consumeRawText(!1, () => this._attemptStr('--\x3e')), this._beginToken(11), this._requireStr('--\x3e'), this._endToken([]);
     }
     _consumeBogusComment(e) {
      this._beginToken(10, e), this._endToken([]), this._consumeRawText(!1, () => 62 === this._cursor.peek()), this._beginToken(11), this._cursor.advance(), this._endToken([]);
     }
     _consumeCdata(e) {
      this._beginToken(12, e), this._endToken([]), this._consumeRawText(!1, () => this._attemptStr(']]>')), this._beginToken(13), this._requireStr(']]>'), this._endToken([]);
     }
     _consumeDocType(e) {
      this._beginToken(18, e), this._endToken([]), this._consumeRawText(!1, () => 62 === this._cursor.peek()), this._beginToken(19), this._cursor.advance(), this._endToken([]);
     }
     _consumePrefixAndName() {
      let e,
       t = this._cursor.clone(),
       r = '';
      for (; 58 !== this._cursor.peek() && !_n(this._cursor.peek()); ) this._cursor.advance();
      return 58 === this._cursor.peek() ? ((r = this._cursor.getChars(t)), this._cursor.advance(), (e = this._cursor.clone())) : (e = t), this._requireCharCodeUntilFn(Bn, '' === r ? 0 : 1), [r, this._cursor.getChars(e)];
     }
     _consumeTagOpen(e) {
      let t,
       r,
       n,
       s = [];
      try {
       if (!mr(this._cursor.peek())) throw this._createError(Fn(this._cursor.peek()), this._cursor.getSpan(e));
       for (n = this._consumeTagOpenStart(e), r = n.parts[0], t = n.parts[1], this._attemptCharCodeUntilFn(Nn); 47 !== this._cursor.peek() && 62 !== this._cursor.peek() && 60 !== this._cursor.peek() && 0 !== this._cursor.peek(); ) {
        let [e, t] = this._consumeAttributeName();
        if ((this._attemptCharCodeUntilFn(Nn), this._attemptCharCode(61))) {
         this._attemptCharCodeUntilFn(Nn);
         let r = this._consumeAttributeValue();
         s.push({ prefix: e, name: t, value: r });
        } else s.push({ prefix: e, name: t });
        this._attemptCharCodeUntilFn(Nn);
       }
       this._consumeTagOpenEnd();
      } catch (a) {
       if (a instanceof Pn) return void (n ? (n.type = 4) : (this._beginToken(5, e), this._endToken(['<'])));
       throw a;
      }
      if (this._canSelfClose && 2 === this.tokens[this.tokens.length - 1].type) return;
      let i = this._getTagContentType(t, r, this._fullNameStack.length > 0, s);
      this._handleFullNameStackForTagOpen(r, t), i === qr.RAW_TEXT ? this._consumeRawTextWithTagClose(r, t, !1) : i === qr.ESCAPABLE_RAW_TEXT && this._consumeRawTextWithTagClose(r, t, !0);
     }
     _consumeRawTextWithTagClose(e, t, r) {
      this._consumeRawText(r, () => !!(this._attemptCharCode(60) && this._attemptCharCode(47) && (this._attemptCharCodeUntilFn(Nn), this._attemptStrCaseInsensitive(e ? `${e}:${t}` : t))) && (this._attemptCharCodeUntilFn(Nn), this._attemptCharCode(62))), this._beginToken(3), this._requireCharCodeUntilFn((e) => 62 === e, 3), this._cursor.advance(), this._endToken([e, t]), this._handleFullNameStackForTagClose(e, t);
     }
     _consumeTagOpenStart(e) {
      this._beginToken(0, e);
      let t = this._consumePrefixAndName();
      return this._endToken(t);
     }
     _consumeAttributeName() {
      let e = this._cursor.peek();
      if (39 === e || 34 === e) throw this._createError(Fn(e), this._cursor.getSpan());
      this._beginToken(14);
      let t = this._consumePrefixAndName();
      return this._endToken(t), t;
     }
     _consumeAttributeValue() {
      let e;
      if (39 === this._cursor.peek() || 34 === this._cursor.peek()) {
       let t = this._cursor.peek();
       this._consumeQuote(t);
       let r = () => this._cursor.peek() === t;
       (e = this._consumeWithInterpolation(16, 17, r, r)), this._consumeQuote(t);
      } else {
       let t = () => Bn(this._cursor.peek());
       e = this._consumeWithInterpolation(16, 17, t, t);
      }
      return e;
     }
     _consumeQuote(e) {
      this._beginToken(15), this._requireCharCode(e), this._endToken([String.fromCodePoint(e)]);
     }
     _consumeTagOpenEnd() {
      let e = this._attemptCharCode(47) ? 2 : 1;
      this._beginToken(e), this._requireCharCode(62), this._endToken([]);
     }
     _consumeTagClose(e) {
      if ((this._beginToken(3, e), this._attemptCharCodeUntilFn(Nn), this._allowHtmComponentClosingTags && this._attemptCharCode(47))) this._attemptCharCodeUntilFn(Nn), this._requireCharCode(62), this._endToken([]);
      else {
       let [e, t] = this._consumePrefixAndName();
       this._attemptCharCodeUntilFn(Nn), this._requireCharCode(62), this._endToken([e, t]), this._handleFullNameStackForTagClose(e, t);
      }
     }
     _consumeExpansionFormStart() {
      this._beginToken(20), this._requireCharCode(123), this._endToken([]), this._expansionCaseStack.push(20), this._beginToken(7);
      let e = this._readUntil(44),
       t = this._processCarriageReturns(e);
      if (this._i18nNormalizeLineEndingsInICUs) this._endToken([t]);
      else {
       let r = this._endToken([e]);
       t !== e && this.nonNormalizedIcuExpressions.push(r);
      }
      this._requireCharCode(44), this._attemptCharCodeUntilFn(Nn), this._beginToken(7);
      let r = this._readUntil(44);
      this._endToken([r]), this._requireCharCode(44), this._attemptCharCodeUntilFn(Nn);
     }
     _consumeExpansionCaseStart() {
      this._beginToken(21);
      let e = this._readUntil(123).trim();
      this._endToken([e]), this._attemptCharCodeUntilFn(Nn), this._beginToken(22), this._requireCharCode(123), this._endToken([]), this._attemptCharCodeUntilFn(Nn), this._expansionCaseStack.push(22);
     }
     _consumeExpansionCaseEnd() {
      this._beginToken(23), this._requireCharCode(125), this._endToken([]), this._attemptCharCodeUntilFn(Nn), this._expansionCaseStack.pop();
     }
     _consumeExpansionFormEnd() {
      this._beginToken(24), this._requireCharCode(125), this._endToken([]), this._expansionCaseStack.pop();
     }
     _consumeWithInterpolation(e, t, r, n) {
      this._beginToken(e);
      let s = [];
      for (; !r(); ) {
       let r = this._cursor.clone();
       this._interpolationConfig && this._attemptStr(this._interpolationConfig.start) ? (this._endToken([this._processCarriageReturns(s.join(''))], r), (s.length = 0), this._consumeInterpolation(t, r, n), this._beginToken(e)) : 38 === this._cursor.peek() ? (this._endToken([this._processCarriageReturns(s.join(''))]), (s.length = 0), this._consumeEntity(e), this._beginToken(e)) : s.push(this._readChar());
      }
      this._inInterpolation = !1;
      let i = this._processCarriageReturns(s.join(''));
      return this._endToken([i]), i;
     }
     _consumeInterpolation(e, t, r) {
      let n = [];
      this._beginToken(e, t), n.push(this._interpolationConfig.start);
      let s = this._cursor.clone(),
       i = null,
       a = !1;
      for (; 0 !== this._cursor.peek() && (null === r || !r()); ) {
       let e = this._cursor.clone();
       if (this._isTagStart()) return (this._cursor = e), n.push(this._getProcessedChars(s, e)), void this._endToken(n);
       if (null === i) {
        if (this._attemptStr(this._interpolationConfig.end)) return n.push(this._getProcessedChars(s, e)), n.push(this._interpolationConfig.end), void this._endToken(n);
        this._attemptStr('//') && (a = !0);
       }
       let t = this._cursor.peek();
       this._cursor.advance(), 92 === t ? this._cursor.advance() : t === i ? (i = null) : !a && null === i && Dr(t) && (i = t);
      }
      n.push(this._getProcessedChars(s, this._cursor)), this._endToken(n);
     }
     _getProcessedChars(e, t) {
      return this._processCarriageReturns(t.getChars(e));
     }
     _isTextEnd() {
      return !!(this._isTagStart() || 0 === this._cursor.peek() || (this._tokenizeIcu && !this._inInterpolation && (this.isExpansionFormStart() || (125 === this._cursor.peek() && this._isInExpansionCase()))) || (this._tokenizeBlocks && !this._inInterpolation && !this._isInExpansion() && (this._isBlockStart() || 64 === this._cursor.peek() || 125 === this._cursor.peek())));
     }
     _isTagStart() {
      if (60 === this._cursor.peek()) {
       let e = this._cursor.clone();
       e.advance();
       let t = e.peek();
       if ((97 <= t && t <= 122) || (65 <= t && t <= 90) || 47 === t || 33 === t) return !0;
      }
      return !1;
     }
     _isBlockStart() {
      if (this._tokenizeBlocks && 64 === this._cursor.peek()) {
       let e = this._cursor.clone();
       if ((e.advance(), jn(e.peek()))) return !0;
      }
      return !1;
     }
     _readUntil(e) {
      let t = this._cursor.clone();
      return this._attemptUntilChar(e), this._cursor.getChars(t);
     }
     _isInExpansion() {
      return this._isInExpansionCase() || this._isInExpansionForm();
     }
     _isInExpansionCase() {
      return this._expansionCaseStack.length > 0 && 22 === this._expansionCaseStack[this._expansionCaseStack.length - 1];
     }
     _isInExpansionForm() {
      return this._expansionCaseStack.length > 0 && 20 === this._expansionCaseStack[this._expansionCaseStack.length - 1];
     }
     isExpansionFormStart() {
      if (123 !== this._cursor.peek()) return !1;
      if (this._interpolationConfig) {
       let e = this._cursor.clone(),
        t = this._attemptStr(this._interpolationConfig.start);
       return (this._cursor = e), !t;
      }
      return !0;
     }
     _handleFullNameStackForTagOpen(e, t) {
      let r = Kr(e, t);
      (0 === this._fullNameStack.length || this._fullNameStack[this._fullNameStack.length - 1] === r) && this._fullNameStack.push(r);
     }
     _handleFullNameStackForTagClose(e, t) {
      let r = Kr(e, t);
      0 !== this._fullNameStack.length && this._fullNameStack[this._fullNameStack.length - 1] === r && this._fullNameStack.pop();
     }
    };
   function Nn(e) {
    return !dr(e) || 0 === e;
   }
   function Bn(e) {
    return dr(e) || 62 === e || 60 === e || 47 === e || 39 === e || 34 === e || 61 === e || 0 === e;
   }
   function _n(e) {
    return (e < 97 || 122 < e) && (e < 65 || 90 < e) && (e < 48 || e > 57);
   }
   function Ln(e) {
    return (
     59 === e ||
     0 === e ||
     !(function (e) {
      return (e >= 97 && e <= 102) || (e >= 65 && e <= 70) || fr(e);
     })(e)
    );
   }
   function On(e) {
    return 59 === e || 0 === e || !mr(e);
   }
   function Mn(e) {
    return e >= 97 && e <= 122 ? e - 97 + 65 : e;
   }
   function jn(e) {
    return mr(e) || fr(e) || 95 === e;
   }
   function Rn(e) {
    return 59 !== e && Nn(e);
   }
   var qn = class e {
     constructor(t, r) {
      if (t instanceof e) {
       (this.file = t.file), (this.input = t.input), (this.end = t.end);
       let e = t.state;
       this.state = { peek: e.peek, offset: e.offset, line: e.line, column: e.column };
      } else {
       if (!r) throw new Error('Programming error: the range argument must be provided with a file argument.');
       (this.file = t), (this.input = t.content), (this.end = r.endPos), (this.state = { peek: -1, offset: r.startPos, line: r.startLine, column: r.startCol });
      }
     }
     clone() {
      return new e(this);
     }
     peek() {
      return this.state.peek;
     }
     charsLeft() {
      return this.end - this.state.offset;
     }
     diff(e) {
      return this.state.offset - e.state.offset;
     }
     advance() {
      this.advanceState(this.state);
     }
     init() {
      this.updatePeek(this.state);
     }
     getSpan(e, t) {
      let r = (e = e || this);
      if (t) for (; this.diff(e) > 0 && -1 !== t.indexOf(e.peek()); ) r === e && (e = e.clone()), e.advance();
      let n = this.locationFromCursor(e),
       s = this.locationFromCursor(this),
       i = r !== e ? this.locationFromCursor(r) : n;
      return new Tr(n, s, i);
     }
     getChars(e) {
      return this.input.substring(e.state.offset, this.state.offset);
     }
     charAt(e) {
      return this.input.charCodeAt(e);
     }
     advanceState(e) {
      if (e.offset >= this.end) throw ((this.state = e), new $n('Unexpected character "EOF"', this));
      let t = this.charAt(e.offset);
      10 === t ? (e.line++, (e.column = 0)) : yr(t) || e.column++, e.offset++, this.updatePeek(e);
     }
     updatePeek(e) {
      e.peek = e.offset >= this.end ? 0 : this.charAt(e.offset);
     }
     locationFromCursor(e) {
      return new Er(e.file, e.state.offset, e.state.line, e.state.column);
     }
    },
    Un = class e extends qn {
     constructor(t, r) {
      t instanceof e ? (super(t), (this.internalState = { ...t.internalState })) : (super(t, r), (this.internalState = this.state));
     }
     advance() {
      (this.state = this.internalState), super.advance(), this.processEscapeSequence();
     }
     init() {
      super.init(), this.processEscapeSequence();
     }
     clone() {
      return new e(this);
     }
     getChars(e) {
      let t = e.clone(),
       r = '';
      for (; t.internalState.offset < this.internalState.offset; ) (r += String.fromCodePoint(t.peek())), t.advance();
      return r;
     }
     processEscapeSequence() {
      let e = () => this.internalState.peek;
      if (92 === e())
       if (((this.internalState = { ...this.state }), this.advanceState(this.internalState), 110 === e())) this.state.peek = 10;
       else if (114 === e()) this.state.peek = 13;
       else if (118 === e()) this.state.peek = 11;
       else if (116 === e()) this.state.peek = 9;
       else if (98 === e()) this.state.peek = 8;
       else if (102 === e()) this.state.peek = 12;
       else if (117 === e())
        if ((this.advanceState(this.internalState), 123 === e())) {
         this.advanceState(this.internalState);
         let t = this.clone(),
          r = 0;
         for (; 125 !== e(); ) this.advanceState(this.internalState), r++;
         this.state.peek = this.decodeHexDigits(t, r);
        } else {
         let e = this.clone();
         this.advanceState(this.internalState), this.advanceState(this.internalState), this.advanceState(this.internalState), (this.state.peek = this.decodeHexDigits(e, 4));
        }
       else if (120 === e()) {
        this.advanceState(this.internalState);
        let e = this.clone();
        this.advanceState(this.internalState), (this.state.peek = this.decodeHexDigits(e, 2));
       } else if (gr(e())) {
        let t = '',
         r = 0,
         n = this.clone();
        for (; gr(e()) && r < 3; ) (n = this.clone()), (t += String.fromCodePoint(e())), this.advanceState(this.internalState), r++;
        (this.state.peek = parseInt(t, 8)), (this.internalState = n.internalState);
       } else yr(this.internalState.peek) ? (this.advanceState(this.internalState), (this.state = this.internalState)) : (this.state.peek = this.internalState.peek);
     }
     decodeHexDigits(e, t) {
      let r = this.input.slice(e.internalState.offset, e.internalState.offset + t),
       n = parseInt(r, 16);
      if (isNaN(n)) throw ((e.state = e.internalState), new $n('Invalid hexadecimal escape sequence', e));
      return n;
     }
    },
    $n = class {
     constructor(e, t) {
      (this.msg = e), (this.cursor = t);
     }
    },
    Hn = class e extends Sr {
     static create(t, r, n) {
      return new e(t, r, n);
     }
     constructor(e, t, r) {
      super(t, r), (this.elementName = e);
     }
    },
    zn = class {
     constructor(e, t) {
      (this.rootNodes = e), (this.errors = t);
     }
    },
    Vn = class {
     constructor(e) {
      this.getTagDefinition = e;
     }
     parse(e, t, r, n = !1, s) {
      let i =
        (e) =>
        (t, ...r) =>
         e(t.toLowerCase(), ...r),
       a = n ? this.getTagDefinition : i(this.getTagDefinition),
       o = (e) => a(e).getContentType(),
       u = n ? s : i(s),
       l = (function (e, t, r, n = {}) {
        let s = new In(new Cr(e, t), r, n);
        return (
         s.tokenize(),
         new Sn(
          (function (e) {
           let t,
            r = [];
           for (let n = 0; n < e.length; n++) {
            let s = e[n];
            (t && 5 === t.type && 5 === s.type) || (t && 16 === t.type && 16 === s.type) ? ((t.parts[0] += s.parts[0]), (t.sourceSpan.end = s.sourceSpan.end)) : ((t = s), r.push(t));
           }
           return r;
          })(s.tokens),
          s.errors,
          s.nonNormalizedIcuExpressions,
         )
        );
       })(
        e,
        t,
        s
         ? (e, t, r, n) => {
            let s = u(e, t, r, n);
            return void 0 !== s ? s : o(e);
           }
         : o,
        r,
       ),
       p = (r && r.canSelfClose) || !1,
       c = (r && r.allowHtmComponentClosingTags) || !1,
       h = new Wn(l.tokens, a, p, c, n);
      return h.build(), new zn(h.rootNodes, l.errors.concat(h.errors));
     }
    },
    Wn = class e {
     constructor(e, t, r, n, s) {
      (this.tokens = e), (this.getTagDefinition = t), (this.canSelfClose = r), (this.allowHtmComponentClosingTags = n), (this.isTagNameCaseSensitive = s), (this._index = -1), (this._containerStack = []), (this.rootNodes = []), (this.errors = []), this._advance();
     }
     build() {
      for (; 34 !== this._peek.type; ) 0 === this._peek.type || 4 === this._peek.type ? this._consumeStartTag(this._advance()) : 3 === this._peek.type ? (this._closeVoidElement(), this._consumeEndTag(this._advance())) : 12 === this._peek.type ? (this._closeVoidElement(), this._consumeCdata(this._advance())) : 10 === this._peek.type ? (this._closeVoidElement(), this._consumeComment(this._advance())) : 5 === this._peek.type || 7 === this._peek.type || 6 === this._peek.type ? (this._closeVoidElement(), this._consumeText(this._advance())) : 20 === this._peek.type ? this._consumeExpansion(this._advance()) : 25 === this._peek.type ? (this._closeVoidElement(), this._consumeBlockOpen(this._advance())) : 27 === this._peek.type ? (this._closeVoidElement(), this._consumeBlockClose(this._advance())) : 29 === this._peek.type ? (this._closeVoidElement(), this._consumeIncompleteBlock(this._advance())) : 30 === this._peek.type ? (this._closeVoidElement(), this._consumeLet(this._advance())) : 18 === this._peek.type ? this._consumeDocType(this._advance()) : 33 === this._peek.type ? (this._closeVoidElement(), this._consumeIncompleteLet(this._advance())) : this._advance();
      for (let e of this._containerStack) e instanceof yn && this.errors.push(Hn.create(e.name, e.sourceSpan, `Unclosed block "${e.name}"`));
     }
     _advance() {
      let e = this._peek;
      return this._index < this.tokens.length - 1 && this._index++, (this._peek = this.tokens[this._index]), e;
     }
     _advanceIf(e) {
      return this._peek.type === e ? this._advance() : null;
     }
     _consumeCdata(e) {
      let t = this._advance(),
       r = this._getText(t),
       n = this._advanceIf(13);
      this._addToParent(new ln(r, new Tr(e.sourceSpan.start, (n || t).sourceSpan.end), [t]));
     }
     _consumeComment(e) {
      let t = this._advanceIf(7),
       r = this._advanceIf(11),
       n = null != t ? t.parts[0].trim() : null,
       s = null == r ? e.sourceSpan : new Tr(e.sourceSpan.start, r.sourceSpan.end, e.sourceSpan.fullStart);
      this._addToParent(new fn(n, s));
     }
     _consumeDocType(e) {
      let t = this._advanceIf(7),
       r = this._advanceIf(19),
       n = null != t ? t.parts[0].trim() : null,
       s = new Tr(e.sourceSpan.start, (r || t || e).sourceSpan.end);
      this._addToParent(new mn(n, s));
     }
     _consumeExpansion(e) {
      let t = this._advance(),
       r = this._advance(),
       n = [];
      for (; 21 === this._peek.type; ) {
       let e = this._parseExpansionCase();
       if (!e) return;
       n.push(e);
      }
      if (24 !== this._peek.type) return void this.errors.push(Hn.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '}'."));
      let s = new Tr(e.sourceSpan.start, this._peek.sourceSpan.end, e.sourceSpan.fullStart);
      this._addToParent(new pn(t.parts[0], r.parts[0], n, s, t.sourceSpan)), this._advance();
     }
     _parseExpansionCase() {
      let t = this._advance();
      if (22 !== this._peek.type) return this.errors.push(Hn.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '{'.")), null;
      let r = this._advance(),
       n = this._collectExpansionExpTokens(r);
      if (!n) return null;
      let s = this._advance();
      n.push({ type: 34, parts: [], sourceSpan: s.sourceSpan });
      let i = new e(n, this.getTagDefinition, this.canSelfClose, this.allowHtmComponentClosingTags, this.isTagNameCaseSensitive);
      if ((i.build(), i.errors.length > 0)) return (this.errors = this.errors.concat(i.errors)), null;
      let a = new Tr(t.sourceSpan.start, s.sourceSpan.end, t.sourceSpan.fullStart),
       o = new Tr(r.sourceSpan.start, s.sourceSpan.end, r.sourceSpan.fullStart);
      return new cn(t.parts[0], i.rootNodes, a, t.sourceSpan, o);
     }
     _collectExpansionExpTokens(e) {
      let t = [],
       r = [22];
      for (;;) {
       if (((20 === this._peek.type || 22 === this._peek.type) && r.push(this._peek.type), 23 === this._peek.type)) {
        if (!Jn(r, 22)) return this.errors.push(Hn.create(null, e.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
        if ((r.pop(), 0 === r.length)) return t;
       }
       if (24 === this._peek.type) {
        if (!Jn(r, 20)) return this.errors.push(Hn.create(null, e.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
        r.pop();
       }
       if (34 === this._peek.type) return this.errors.push(Hn.create(null, e.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
       t.push(this._advance());
      }
     }
     _getText(e) {
      let t = e.parts[0];
      if (t.length > 0 && '\n' == t[0]) {
       let e = this._getClosestParentElement();
       null != e && 0 == e.children.length && this.getTagDefinition(e.name).ignoreFirstLf && (t = t.substring(1));
      }
      return t;
     }
     _consumeText(e) {
      let t = [e],
       r = e.sourceSpan,
       n = e.parts[0];
      if (n.length > 0 && '\n' === n[0]) {
       let r = this._getContainer();
       null != r && 0 === r.children.length && this.getTagDefinition(r.name).ignoreFirstLf && ((n = n.substring(1)), (t[0] = { type: e.type, sourceSpan: e.sourceSpan, parts: [n] }));
      }
      for (; 8 === this._peek.type || 5 === this._peek.type || 9 === this._peek.type; ) (e = this._advance()), t.push(e), 8 === e.type ? (n += e.parts.join('').replace(/&([^;]+);/g, Kn)) : 9 === e.type ? (n += e.parts[0]) : (n += e.parts.join(''));
      if (n.length > 0) {
       let s = e.sourceSpan;
       this._addToParent(new un(n, new Tr(r.start, s.end, r.fullStart, r.details), t));
      }
     }
     _closeVoidElement() {
      let e = this._getContainer();
      e instanceof dn && this.getTagDefinition(e.name).isVoid && this._containerStack.pop();
     }
     _consumeStartTag(e) {
      let [t, r] = e.parts,
       n = [];
      for (; 14 === this._peek.type; ) n.push(this._consumeAttr(this._advance()));
      let s = this._getElementFullName(t, r, this._getClosestParentElement()),
       i = !1;
      if (2 === this._peek.type) {
       this._advance(), (i = !0);
       let t = this.getTagDefinition(s);
       this.canSelfClose || t.canSelfClose || null !== Jr(s) || t.isVoid || this.errors.push(Hn.create(s, e.sourceSpan, `Only void, custom and foreign elements can be self closed "${e.parts[1]}"`));
      } else 1 === this._peek.type && (this._advance(), (i = !1));
      let a = this._peek.sourceSpan.fullStart,
       o = new Tr(e.sourceSpan.start, a, e.sourceSpan.fullStart),
       u = new Tr(e.sourceSpan.start, a, e.sourceSpan.fullStart),
       l = new Tr(e.sourceSpan.start.moveBy(1), e.sourceSpan.end),
       p = new dn(s, n, [], o, u, void 0, l),
       c = this._getContainer();
      this._pushContainer(p, c instanceof dn && this.getTagDefinition(c.name).isClosedByChild(p.name)), i ? this._popContainer(s, dn, o) : 4 === e.type && (this._popContainer(s, dn, null), this.errors.push(Hn.create(s, o, `Opening tag "${s}" not terminated.`)));
     }
     _pushContainer(e, t) {
      t && this._containerStack.pop(), this._addToParent(e), this._containerStack.push(e);
     }
     _consumeEndTag(e) {
      let t = this.allowHtmComponentClosingTags && 0 === e.parts.length ? null : this._getElementFullName(e.parts[0], e.parts[1], this._getClosestParentElement());
      if (t && this.getTagDefinition(t).isVoid) this.errors.push(Hn.create(t, e.sourceSpan, `Void elements do not have end tags "${e.parts[1]}"`));
      else if (!this._popContainer(t, dn, e.sourceSpan)) {
       let r = `Unexpected closing tag "${t}". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags`;
       this.errors.push(Hn.create(t, e.sourceSpan, r));
      }
     }
     _popContainer(e, t, r) {
      let n = !1;
      for (let s = this._containerStack.length - 1; s >= 0; s--) {
       let i = this._containerStack[s];
       if (Jr(i.name) ? i.name === e : (null == e || i.name.toLowerCase() === e.toLowerCase()) && i instanceof t) return (i.endSourceSpan = r), (i.sourceSpan.end = null !== r ? r.end : i.sourceSpan.end), this._containerStack.splice(s, this._containerStack.length - s), !n;
       (i instanceof yn || (i instanceof dn && !this.getTagDefinition(i.name).closedByParent)) && (n = !0);
      }
      return !1;
     }
     _consumeAttr(e) {
      let t,
       r = Kr(e.parts[0], e.parts[1]),
       n = e.sourceSpan.end;
      15 === this._peek.type && (t = this._advance());
      let s,
       i,
       a = '',
       o = [];
      if (16 === this._peek.type)
       for (s = this._peek.sourceSpan, i = this._peek.sourceSpan.end; 16 === this._peek.type || 17 === this._peek.type || 9 === this._peek.type; ) {
        let e = this._advance();
        o.push(e), 17 === e.type ? (a += e.parts.join('').replace(/&([^;]+);/g, Kn)) : 9 === e.type ? (a += e.parts[0]) : (a += e.parts.join('')), (i = n = e.sourceSpan.end);
       }
      15 === this._peek.type && (i = n = this._advance().sourceSpan.end);
      let u = s && i && new Tr((null == t ? void 0 : t.sourceSpan.start) ?? s.start, i, (null == t ? void 0 : t.sourceSpan.fullStart) ?? s.fullStart);
      return new hn(r, a, new Tr(e.sourceSpan.start, n, e.sourceSpan.fullStart), e.sourceSpan, u, o.length > 0 ? o : void 0, void 0);
     }
     _consumeBlockOpen(e) {
      let t = [];
      for (; 28 === this._peek.type; ) {
       let e = this._advance();
       t.push(new gn(e.parts[0], e.sourceSpan));
      }
      26 === this._peek.type && this._advance();
      let r = this._peek.sourceSpan.fullStart,
       n = new Tr(e.sourceSpan.start, r, e.sourceSpan.fullStart),
       s = new Tr(e.sourceSpan.start, r, e.sourceSpan.fullStart),
       i = new yn(e.parts[0], t, [], n, e.sourceSpan, s);
      this._pushContainer(i, !1);
     }
     _consumeBlockClose(e) {
      this._popContainer(null, yn, e.sourceSpan) || this.errors.push(Hn.create(null, e.sourceSpan, 'Unexpected closing block. The block may have been closed earlier. If you meant to write the } character, you should use the "&#125;" HTML entity instead.'));
     }
     _consumeIncompleteBlock(e) {
      let t = [];
      for (; 28 === this._peek.type; ) {
       let e = this._advance();
       t.push(new gn(e.parts[0], e.sourceSpan));
      }
      let r = this._peek.sourceSpan.fullStart,
       n = new Tr(e.sourceSpan.start, r, e.sourceSpan.fullStart),
       s = new Tr(e.sourceSpan.start, r, e.sourceSpan.fullStart),
       i = new yn(e.parts[0], t, [], n, e.sourceSpan, s);
      this._pushContainer(i, !1), this._popContainer(null, yn, null), this.errors.push(Hn.create(e.parts[0], n, `Incomplete block "${e.parts[0]}". If you meant to write the @ character, you should use the "&#64;" HTML entity instead.`));
     }
     _consumeLet(e) {
      let t,
       r,
       n = e.parts[0];
      if (31 !== this._peek.type) return void this.errors.push(Hn.create(e.parts[0], e.sourceSpan, `Invalid @let declaration "${n}". Declaration must have a value.`));
      if (((t = this._advance()), 32 !== this._peek.type)) return void this.errors.push(Hn.create(e.parts[0], e.sourceSpan, `Unterminated @let declaration "${n}". Declaration must be terminated with a semicolon.`));
      r = this._advance();
      let s = r.sourceSpan.fullStart,
       i = new Tr(e.sourceSpan.start, s, e.sourceSpan.fullStart),
       a = e.sourceSpan.toString().lastIndexOf(n),
       o = e.sourceSpan.start.moveBy(a),
       u = new Tr(o, e.sourceSpan.end),
       l = new Dn(n, t.parts[0], i, u, t.sourceSpan);
      this._addToParent(l);
     }
     _consumeIncompleteLet(e) {
      let t = e.parts[0] ?? '',
       r = t ? ` "${t}"` : '';
      if (t.length > 0) {
       let r = e.sourceSpan.toString().lastIndexOf(t),
        n = e.sourceSpan.start.moveBy(r),
        s = new Tr(n, e.sourceSpan.end),
        i = new Tr(e.sourceSpan.start, e.sourceSpan.start.moveBy(0)),
        a = new Dn(t, '', e.sourceSpan, s, i);
       this._addToParent(a);
      }
      this.errors.push(Hn.create(e.parts[0], e.sourceSpan, `Incomplete @let declaration${r}. @let declarations must be written as \`@let <name> = <value>;\``));
     }
     _getContainer() {
      return this._containerStack.length > 0 ? this._containerStack[this._containerStack.length - 1] : null;
     }
     _getClosestParentElement() {
      for (let e = this._containerStack.length - 1; e > -1; e--) if (this._containerStack[e] instanceof dn) return this._containerStack[e];
      return null;
     }
     _addToParent(e) {
      let t = this._getContainer();
      null === t ? this.rootNodes.push(e) : t.children.push(e);
     }
     _getElementFullName(e, t, r) {
      if ('' === e && '' === (e = this.getTagDefinition(t).implicitNamespacePrefix || '') && null != r) {
       let t = zr(r.name)[1];
       this.getTagDefinition(t).preventNamespaceInheritance || (e = Jr(r.name));
      }
      return Kr(e, t);
     }
    };
   function Jn(e, t) {
    return e.length > 0 && e[e.length - 1] === t;
   }
   function Kn(e, t) {
    return void 0 !== vn[t] ? vn[t] || e : /^#x[a-f0-9]+$/i.test(t) ? String.fromCodePoint(parseInt(t.slice(2), 16)) : /^#\d+$/.test(t) ? String.fromCodePoint(parseInt(t.slice(1), 10)) : e;
   }
   var Gn = class extends Vn {
     constructor() {
      super(an);
     }
     parse(e, t, r, n = !1, s) {
      return super.parse(e, t, r, n, s);
     }
    },
    Xn = null,
    Yn = () => (Xn || (Xn = new Gn()), Xn);
   function Qn(e, t = {}) {
    let { canSelfClose: r = !1, allowHtmComponentClosingTags: n = !1, isTagNameCaseSensitive: s = !1, getTagContentType: i, tokenizeAngularBlocks: a = !1, tokenizeAngularLetDeclaration: o = !1 } = t;
    return Yn().parse(e, 'angular-html-parser', { tokenizeExpansionForms: a, interpolationConfig: void 0, canSelfClose: r, allowHtmComponentClosingTags: n, tokenizeBlocks: a, tokenizeLet: o }, s, i);
   }
   var Zn = function (e, t) {
     let r = new SyntaxError(e + ' (' + t.loc.start.line + ':' + t.loc.start.column + ')');
     return Object.assign(r, t);
    },
    es = 3;
   var ts,
    rs,
    ns,
    ss = function (e) {
     let t = (function (e) {
      let t = e.slice(0, es);
      if ('---' !== t && '+++' !== t) return;
      let r = e.indexOf('\n', es);
      if (-1 === r) return;
      let n = e.slice(es, r).trim(),
       s = e.indexOf(`\n${t}`, r),
       i = n;
      if ((i || (i = '+++' === t ? 'toml' : 'yaml'), -1 === s && '---' === t && 'yaml' === i && (s = e.indexOf('\n...', r)), -1 === s)) return;
      let a = s + 1 + es,
       o = e.charAt(a + 1);
      if (!/\s?/u.test(o)) return;
      let u = e.slice(0, a);
      return { type: 'front-matter', language: i, explicitLanguage: n, value: e.slice(r + 1, s), startDelimiter: t, endDelimiter: u.slice(-es), raw: u };
     })(e);
     if (!t) return { content: e };
     let { raw: r } = t;
     return { frontMatter: t, content: c(!1, r, /[^\n]/gu, ' ') + e.slice(r.length) };
    },
    is = { attrs: !0, children: !0, cases: !0, expression: !0 },
    as = new Set(['parent']);
   (ts = new WeakSet()),
    (rs = function () {
     return 'angularIcuCase' === this.type ? 'expression' : 'angularIcuExpression' === this.type ? 'cases' : 'children';
    }),
    (ns = function () {
     var e;
     return (null == (e = this.parent) ? void 0 : e.$children) ?? [];
    });
   var os = class e {
    constructor(e = {}) {
     l(this, ts), a(this, 'type'), a(this, 'parent');
     for (let t of new Set([...as, ...Object.keys(e)])) this.setProperty(t, e[t]);
    }
    setProperty(e, t) {
     if (this[e] !== t) {
      if ((e in is && (t = t.map((e) => this.createChild(e))), !as.has(e))) return void (this[e] = t);
      Object.defineProperty(this, e, { value: t, enumerable: !1, configurable: !0 });
     }
    }
    map(t) {
     let r;
     for (let n in is) {
      let s = this[n];
      if (s) {
       let i = us(s, (e) => e.map(t));
       r !== s && (r || (r = new e({ parent: this.parent })), r.setProperty(n, i));
      }
     }
     if (r) for (let e in this) e in is || (r[e] = this[e]);
     return t(r || this);
    }
    walk(e) {
     for (let t in is) {
      let r = this[t];
      if (r) for (let t = 0; t < r.length; t++) r[t].walk(e);
     }
     e(this);
    }
    createChild(t) {
     let r = t instanceof e ? t.clone() : new e(t);
     return r.setProperty('parent', this), r;
    }
    insertChildBefore(e, t) {
     let r = this.$children;
     r.splice(r.indexOf(e), 0, this.createChild(t));
    }
    removeChild(e) {
     let t = this.$children;
     t.splice(t.indexOf(e), 1);
    }
    replaceChild(e, t) {
     let r = this.$children;
     r[r.indexOf(e)] = this.createChild(t);
    }
    clone() {
     return new e(this);
    }
    get $children() {
     return this[u(this, ts, rs)];
    }
    set $children(e) {
     this[u(this, ts, rs)] = e;
    }
    get firstChild() {
     var e;
     return null == (e = this.$children) ? void 0 : e[0];
    }
    get lastChild() {
     return F(!0, this.$children, -1);
    }
    get prev() {
     let e = u(this, ts, ns);
     return e[e.indexOf(this) - 1];
    }
    get next() {
     let e = u(this, ts, ns);
     return e[e.indexOf(this) + 1];
    }
    get rawName() {
     return this.hasExplicitNamespace ? this.fullName : this.name;
    }
    get fullName() {
     return this.namespace ? this.namespace + ':' + this.name : this.name;
    }
    get attrMap() {
     return Object.fromEntries(this.attrs.map((e) => [e.fullName, e.value]));
    }
   };
   function us(e, t) {
    let r = e.map(t);
    return r.some((t, r) => t !== e[r]) ? r : e;
   }
   var ls = [
    {
     regex: /^(\[if([^\]]*)\]>)(.*?)<!\s*\[endif\]$/su,
     parse: function (e, t, r) {
      let [, n, s, i] = r,
       a = 4 + n.length,
       o = e.sourceSpan.start.moveBy(a),
       u = o.moveBy(i.length),
       [l, p] = (() => {
        try {
         return [!0, t(i, o).children];
        } catch {
         return [!1, [{ type: 'text', value: i, sourceSpan: new Tr(o, u) }]];
        }
       })();
      return { type: 'ieConditionalComment', complete: l, children: p, condition: c(!1, s.trim(), /\s+/gu, ' '), sourceSpan: e.sourceSpan, startSourceSpan: new Tr(e.sourceSpan.start, o), endSourceSpan: new Tr(u, e.sourceSpan.end) };
     },
    },
    {
     regex: /^\[if([^\]]*)\]><!$/u,
     parse: function (e, t, r) {
      let [, n] = r;
      return { type: 'ieConditionalStartComment', condition: c(!1, n.trim(), /\s+/gu, ' '), sourceSpan: e.sourceSpan };
     },
    },
    {
     regex: /^<!\s*\[endif\]$/u,
     parse: function (e) {
      return { type: 'ieConditionalEndComment', sourceSpan: e.sourceSpan };
     },
    },
   ];
   var ps = new Map([
     ['*', new Set(['accesskey', 'autocapitalize', 'autofocus', 'class', 'contenteditable', 'dir', 'draggable', 'enterkeyhint', 'hidden', 'id', 'inert', 'inputmode', 'is', 'itemid', 'itemprop', 'itemref', 'itemscope', 'itemtype', 'lang', 'nonce', 'popover', 'slot', 'spellcheck', 'style', 'tabindex', 'title', 'translate', 'writingsuggestions'])],
     ['a', new Set(['charset', 'coords', 'download', 'href', 'hreflang', 'name', 'ping', 'referrerpolicy', 'rel', 'rev', 'shape', 'target', 'type'])],
     ['applet', new Set(['align', 'alt', 'archive', 'code', 'codebase', 'height', 'hspace', 'name', 'object', 'vspace', 'width'])],
     ['area', new Set(['alt', 'coords', 'download', 'href', 'hreflang', 'nohref', 'ping', 'referrerpolicy', 'rel', 'shape', 'target', 'type'])],
     ['audio', new Set(['autoplay', 'controls', 'crossorigin', 'loop', 'muted', 'preload', 'src'])],
     ['base', new Set(['href', 'target'])],
     ['basefont', new Set(['color', 'face', 'size'])],
     ['blockquote', new Set(['cite'])],
     ['body', new Set(['alink', 'background', 'bgcolor', 'link', 'text', 'vlink'])],
     ['br', new Set(['clear'])],
     ['button', new Set(['disabled', 'form', 'formaction', 'formenctype', 'formmethod', 'formnovalidate', 'formtarget', 'name', 'popovertarget', 'popovertargetaction', 'type', 'value'])],
     ['canvas', new Set(['height', 'width'])],
     ['caption', new Set(['align'])],
     ['col', new Set(['align', 'char', 'charoff', 'span', 'valign', 'width'])],
     ['colgroup', new Set(['align', 'char', 'charoff', 'span', 'valign', 'width'])],
     ['data', new Set(['value'])],
     ['del', new Set(['cite', 'datetime'])],
     ['details', new Set(['name', 'open'])],
     ['dialog', new Set(['open'])],
     ['dir', new Set(['compact'])],
     ['div', new Set(['align'])],
     ['dl', new Set(['compact'])],
     ['embed', new Set(['height', 'src', 'type', 'width'])],
     ['fieldset', new Set(['disabled', 'form', 'name'])],
     ['font', new Set(['color', 'face', 'size'])],
     ['form', new Set(['accept', 'accept-charset', 'action', 'autocomplete', 'enctype', 'method', 'name', 'novalidate', 'target'])],
     ['frame', new Set(['frameborder', 'longdesc', 'marginheight', 'marginwidth', 'name', 'noresize', 'scrolling', 'src'])],
     ['frameset', new Set(['cols', 'rows'])],
     ['h1', new Set(['align'])],
     ['h2', new Set(['align'])],
     ['h3', new Set(['align'])],
     ['h4', new Set(['align'])],
     ['h5', new Set(['align'])],
     ['h6', new Set(['align'])],
     ['head', new Set(['profile'])],
     ['hr', new Set(['align', 'noshade', 'size', 'width'])],
     ['html', new Set(['manifest', 'version'])],
     ['iframe', new Set(['align', 'allow', 'allowfullscreen', 'allowpaymentrequest', 'allowusermedia', 'frameborder', 'height', 'loading', 'longdesc', 'marginheight', 'marginwidth', 'name', 'referrerpolicy', 'sandbox', 'scrolling', 'src', 'srcdoc', 'width'])],
     ['img', new Set(['align', 'alt', 'border', 'crossorigin', 'decoding', 'fetchpriority', 'height', 'hspace', 'ismap', 'loading', 'longdesc', 'name', 'referrerpolicy', 'sizes', 'src', 'srcset', 'usemap', 'vspace', 'width'])],
     ['input', new Set(['accept', 'align', 'alt', 'autocomplete', 'checked', 'dirname', 'disabled', 'form', 'formaction', 'formenctype', 'formmethod', 'formnovalidate', 'formtarget', 'height', 'ismap', 'list', 'max', 'maxlength', 'min', 'minlength', 'multiple', 'name', 'pattern', 'placeholder', 'popovertarget', 'popovertargetaction', 'readonly', 'required', 'size', 'src', 'step', 'type', 'usemap', 'value', 'width'])],
     ['ins', new Set(['cite', 'datetime'])],
     ['isindex', new Set(['prompt'])],
     ['label', new Set(['for', 'form'])],
     ['legend', new Set(['align'])],
     ['li', new Set(['type', 'value'])],
     ['link', new Set(['as', 'blocking', 'charset', 'color', 'crossorigin', 'disabled', 'fetchpriority', 'href', 'hreflang', 'imagesizes', 'imagesrcset', 'integrity', 'media', 'referrerpolicy', 'rel', 'rev', 'sizes', 'target', 'type'])],
     ['map', new Set(['name'])],
     ['menu', new Set(['compact'])],
     ['meta', new Set(['charset', 'content', 'http-equiv', 'media', 'name', 'scheme'])],
     ['meter', new Set(['high', 'low', 'max', 'min', 'optimum', 'value'])],
     ['object', new Set(['align', 'archive', 'border', 'classid', 'codebase', 'codetype', 'data', 'declare', 'form', 'height', 'hspace', 'name', 'standby', 'type', 'typemustmatch', 'usemap', 'vspace', 'width'])],
     ['ol', new Set(['compact', 'reversed', 'start', 'type'])],
     ['optgroup', new Set(['disabled', 'label'])],
     ['option', new Set(['disabled', 'label', 'selected', 'value'])],
     ['output', new Set(['for', 'form', 'name'])],
     ['p', new Set(['align'])],
     ['param', new Set(['name', 'type', 'value', 'valuetype'])],
     ['pre', new Set(['width'])],
     ['progress', new Set(['max', 'value'])],
     ['q', new Set(['cite'])],
     ['script', new Set(['async', 'blocking', 'charset', 'crossorigin', 'defer', 'fetchpriority', 'integrity', 'language', 'nomodule', 'referrerpolicy', 'src', 'type'])],
     ['select', new Set(['autocomplete', 'disabled', 'form', 'multiple', 'name', 'required', 'size'])],
     ['slot', new Set(['name'])],
     ['source', new Set(['height', 'media', 'sizes', 'src', 'srcset', 'type', 'width'])],
     ['style', new Set(['blocking', 'media', 'type'])],
     ['table', new Set(['align', 'bgcolor', 'border', 'cellpadding', 'cellspacing', 'frame', 'rules', 'summary', 'width'])],
     ['tbody', new Set(['align', 'char', 'charoff', 'valign'])],
     ['td', new Set(['abbr', 'align', 'axis', 'bgcolor', 'char', 'charoff', 'colspan', 'headers', 'height', 'nowrap', 'rowspan', 'scope', 'valign', 'width'])],
     ['template', new Set(['shadowrootclonable', 'shadowrootdelegatesfocus', 'shadowrootmode'])],
     ['textarea', new Set(['autocomplete', 'cols', 'dirname', 'disabled', 'form', 'maxlength', 'minlength', 'name', 'placeholder', 'readonly', 'required', 'rows', 'wrap'])],
     ['tfoot', new Set(['align', 'char', 'charoff', 'valign'])],
     ['th', new Set(['abbr', 'align', 'axis', 'bgcolor', 'char', 'charoff', 'colspan', 'headers', 'height', 'nowrap', 'rowspan', 'scope', 'valign', 'width'])],
     ['thead', new Set(['align', 'char', 'charoff', 'valign'])],
     ['time', new Set(['datetime'])],
     ['tr', new Set(['align', 'bgcolor', 'char', 'charoff', 'valign'])],
     ['track', new Set(['default', 'kind', 'label', 'src', 'srclang'])],
     ['ul', new Set(['compact', 'type'])],
     ['video', new Set(['autoplay', 'controls', 'crossorigin', 'height', 'loop', 'muted', 'playsinline', 'poster', 'preload', 'src', 'width'])],
    ]),
    cs = new Set(['a', 'abbr', 'acronym', 'address', 'applet', 'area', 'article', 'aside', 'audio', 'b', 'base', 'basefont', 'bdi', 'bdo', 'bgsound', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'command', 'content', 'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'embed', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'iframe', 'image', 'img', 'input', 'ins', 'isindex', 'kbd', 'keygen', 'label', 'legend', 'li', 'link', 'listing', 'main', 'map', 'mark', 'marquee', 'math', 'menu', 'menuitem', 'meta', 'meter', 'multicol', 'nav', 'nextid', 'nobr', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'picture', 'plaintext', 'pre', 'progress', 'q', 'rb', 'rbc', 'rp', 'rt', 'rtc', 'ruby', 's', 'samp', 'script', 'search', 'section', 'select', 'shadow', 'slot', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'svg', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr', 'xmp']);
   function hs(e, t, r) {
    let { name: n, canSelfClose: s = !0, normalizeTagName: i = !1, normalizeAttributeName: a = !1, allowHtmComponentClosingTags: o = !1, isTagNameCaseSensitive: u = !1, shouldParseAsRawText: l } = t,
     { rootNodes: p, errors: c } = Qn(e, { canSelfClose: s, allowHtmComponentClosingTags: o, isTagNameCaseSensitive: u, getTagContentType: l ? (...e) => (l(...e) ? qr.RAW_TEXT : void 0) : void 0, tokenizeAngularBlocks: 'angular' === n || void 0, tokenizeAngularLetDeclaration: 'angular' === n || void 0 });
    if ('vue' === n) {
     if (p.some((e) => ('docType' === e.type && 'html' === e.value) || ('element' === e.type && 'html' === e.name.toLowerCase()))) return hs(e, gs, r);
     let t,
      n = () => t ?? (t = Qn(e, { canSelfClose: s, allowHtmComponentClosingTags: o, isTagNameCaseSensitive: u })),
      i = (e) => n().rootNodes.find(({ startSourceSpan: t }) => t && t.start.offset === e.startSourceSpan.start.offset) ?? e;
     for (let [e, s] of p.entries()) {
      let { endSourceSpan: t, startSourceSpan: a } = s;
      if (null === t) (c = n().errors), (p[e] = i(s));
      else if (ds(s, r)) {
       let r = n().errors.find((e) => e.span.start.offset > a.start.offset && e.span.start.offset < t.end.offset);
       r && fs(r), (p[e] = i(s));
      }
     }
    }
    c.length > 0 && fs(c[0]);
    let h = (e) => {
      let t = e.name.startsWith(':') ? e.name.slice(1).split(':')[0] : null,
       r = e.nameSpan.toString(),
       n = null !== t && r.startsWith(`${t}:`),
       s = n ? r.slice(t.length + 1) : r;
      (e.name = s), (e.namespace = t), (e.hasExplicitNamespace = n);
     },
     d = (e, t) => {
      let r = e.toLowerCase();
      return t(r) ? r : e;
     };
    return (
     xn(
      new (class extends bn {
       visitExpansionCase(e, t) {
        'angular' === n &&
         this.visitChildren(t, (t) => {
          t(e.expression);
         });
       }
       visit(e) {
        ((e) => {
         switch (e.type) {
          case 'element':
           h(e);
           for (let t of e.attrs) h(t), t.valueSpan ? ((t.value = t.valueSpan.toString()), /["']/u.test(t.value[0]) && (t.value = t.value.slice(1, -1))) : (t.value = null);
           break;
          case 'comment':
           e.value = e.sourceSpan.toString().slice(4, -3);
           break;
          case 'text':
           e.value = e.sourceSpan.toString();
         }
        })(e),
         ((e) => {
          if ('element' === e.type) {
           let t = an(u ? e.name : e.name.toLowerCase());
           !e.namespace || e.namespace === t.implicitNamespacePrefix || De(e) ? (e.tagDefinition = t) : (e.tagDefinition = an(''));
          }
         })(e),
         ((e) => {
          if ('element' === e.type && (i && (!e.namespace || e.namespace === e.tagDefinition.implicitNamespacePrefix || De(e)) && (e.name = d(e.name, (e) => cs.has(e))), a)) for (let t of e.attrs) t.namespace || (t.name = d(t.name, (t) => ps.has(e.name) && (ps.get('*').has(t) || ps.get(e.name).has(t))));
         })(e),
         ((e) => {
          e.sourceSpan && e.endSourceSpan && (e.sourceSpan = new Tr(e.sourceSpan.start, e.endSourceSpan.end));
         })(e);
       }
      })(),
      p,
     ),
     p
    );
   }
   function ds(e, t) {
    var r;
    if ('element' !== e.type || 'template' !== e.name) return !1;
    let n = null == (r = e.attrs.find((e) => 'lang' === e.name)) ? void 0 : r.value;
    return !n || 'html' === de(t, { language: n });
   }
   function fs(e) {
    let {
     msg: t,
     span: { start: r, end: n },
    } = e;
    throw Zn(t, { loc: { start: { line: r.line + 1, column: r.col + 1 }, end: { line: n.line + 1, column: n.col + 1 } }, cause: e });
   }
   function ms(e, t, r = {}, n = !0) {
    let { frontMatter: s, content: i } = n ? ss(e) : { frontMatter: null, content: e },
     a = new Cr(e, r.filepath),
     o = new Er(a, 0, 0, 0),
     u = o.moveBy(e.length),
     l = { type: 'root', sourceSpan: new Tr(o, u), children: hs(i, t, r) };
    if (s) {
     let e = new Er(a, 0, 0, 0),
      t = e.moveBy(s.raw.length);
     (s.sourceSpan = new Tr(e, t)), l.children.unshift(s);
    }
    let p = new os(l),
     h = (n, s) => {
      let { offset: i } = s,
       a = ms(c(!1, e.slice(0, i), /[^\n\r]/gu, ' ') + n, t, r, !1);
      a.sourceSpan = new Tr(s, F(!1, a.children, -1).sourceSpan.end);
      let o = a.children[0];
      return o.length === i ? a.children.shift() : ((o.sourceSpan = new Tr(o.sourceSpan.start.moveBy(i), o.sourceSpan.end)), (o.value = o.value.slice(i))), a;
     };
    return (
     p.walk((e) => {
      if ('comment' === e.type) {
       let t = (function (e, t) {
        if (e.value)
         for (let { regex: r, parse: n } of ls) {
          let s = e.value.match(r);
          if (s) return n(e, t, s);
         }
        return null;
       })(e, h);
       t && e.parent.replaceChild(e, t);
      }
      (function (e) {
       if ('block' === e.type) {
        if (((e.name = c(!1, e.name.toLowerCase(), /\s+/gu, ' ').trim()), (e.type = 'angularControlFlowBlock'), !At(e.parameters))) return void delete e.parameters;
        for (let t of e.parameters) t.type = 'angularControlFlowBlockParameter';
        e.parameters = { type: 'angularControlFlowBlockParameters', children: e.parameters, sourceSpan: new Tr(e.parameters[0].sourceSpan.start, F(!1, e.parameters, -1).sourceSpan.end) };
       }
      })(e),
       (function (e) {
        'letDeclaration' === e.type && ((e.type = 'angularLetDeclaration'), (e.id = e.name), (e.init = { type: 'angularLetDeclarationInitializer', sourceSpan: new Tr(e.valueSpan.start, e.valueSpan.end), value: e.value }), delete e.name, delete e.value);
       })(e),
       (function (e) {
        ('plural' === e.type || 'select' === e.type) && ((e.clause = e.type), (e.type = 'angularIcuExpression')), 'expansionCase' === e.type && (e.type = 'angularIcuCase');
       })(e);
     }),
     p
    );
   }
   function ys(e) {
    return { parse: (t, r) => ms(t, e, r), hasPragma: sr, astFormat: 'html', locStart: Ft, locEnd: kt };
   }
   var gs = { name: 'html', normalizeTagName: !0, normalizeAttributeName: !0, allowHtmComponentClosingTags: !0 },
    Ds = ys(gs),
    xs = ys({ name: 'angular' }),
    bs = ys({ name: 'vue', isTagNameCaseSensitive: !0, shouldParseAsRawText: (e, t, r, n) => 'html' !== e.toLowerCase() && !r && ('template' !== e || n.some(({ name: e, value: t }) => 'lang' === e && 'html' !== t && '' !== t && void 0 !== t)) }),
    vs = ys({ name: 'lwc', canSelfClose: !1 }),
    Es = { html: kr },
    Cs = p;
  },
  48231: (e, t, r) => {
   r.d(t, { ZP: () => ys });
   var n = Object.create,
    s = Object.defineProperty,
    i = Object.getOwnPropertyDescriptor,
    a = Object.getOwnPropertyNames,
    o = Object.getPrototypeOf,
    u = Object.prototype.hasOwnProperty,
    l = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports),
    p = (e, t) => {
     for (var r in t) s(e, r, { get: t[r], enumerable: !0 });
    },
    c = (e, t, r) => (
     (r = null != e ? n(o(e)) : {}),
     ((e, t, r, n) => {
      if ((t && 'object' == typeof t) || 'function' == typeof t) for (let o of a(t)) !u.call(e, o) && o !== r && s(e, o, { get: () => t[o], enumerable: !(n = i(t, o)) || n.enumerable });
      return e;
     })(!t && e && e.__esModule ? r : s(r, 'default', { value: e, enumerable: !0 }), e)
    ),
    h = l((e, t) => {
     var r = String,
      n = function () {
       return { isColorSupported: !1, reset: r, bold: r, dim: r, italic: r, underline: r, inverse: r, hidden: r, strikethrough: r, black: r, red: r, green: r, yellow: r, blue: r, magenta: r, cyan: r, white: r, gray: r, bgBlack: r, bgRed: r, bgGreen: r, bgYellow: r, bgBlue: r, bgMagenta: r, bgCyan: r, bgWhite: r, blackBright: r, redBright: r, greenBright: r, yellowBright: r, blueBright: r, magentaBright: r, cyanBright: r, whiteBright: r, bgBlackBright: r, bgRedBright: r, bgGreenBright: r, bgYellowBright: r, bgBlueBright: r, bgMagentaBright: r, bgCyanBright: r, bgWhiteBright: r };
      };
     (t.exports = n()), (t.exports.createColors = n);
    }),
    d = l(() => {}),
    f = l((e, t) => {
     var r = h(),
      n = d(),
      s = class e extends Error {
       constructor(t, r, n, s, i, a) {
        super(t), (this.name = 'CssSyntaxError'), (this.reason = t), i && (this.file = i), s && (this.source = s), a && (this.plugin = a), typeof r < 'u' && typeof n < 'u' && ('number' == typeof r ? ((this.line = r), (this.column = n)) : ((this.line = r.line), (this.column = r.column), (this.endLine = n.line), (this.endColumn = n.column))), this.setMessage(), Error.captureStackTrace && Error.captureStackTrace(this, e);
       }
       setMessage() {
        (this.message = this.plugin ? this.plugin + ': ' : ''), (this.message += this.file ? this.file : '<css input>'), typeof this.line < 'u' && (this.message += ':' + this.line + ':' + this.column), (this.message += ': ' + this.reason);
       }
       showSourceCode(e) {
        if (!this.source) return '';
        let t = this.source;
        null == e && (e = r.isColorSupported);
        let s = (e) => e,
         i = (e) => e,
         a = (e) => e;
        if (e) {
         let { bold: e, gray: t, red: o } = r.createColors(!0);
         (i = (t) => e(o(t))), (s = (e) => t(e)), n && (a = (e) => n(e));
        }
        let o = t.split(/\r?\n/),
         u = Math.max(this.line - 3, 0),
         l = Math.min(this.line + 2, o.length),
         p = String(l).length;
        return o
         .slice(u, l)
         .map((e, t) => {
          let r = u + 1 + t,
           n = ' ' + (' ' + r).slice(-p) + ' | ';
          if (r === this.line) {
           if (e.length > 160) {
            let t = 20,
             r = Math.max(0, this.column - t),
             o = Math.max(this.column + t, this.endColumn + t),
             u = e.slice(r, o),
             l = s(n.replace(/\d/g, ' ')) + e.slice(0, Math.min(this.column - 1, t - 1)).replace(/[^\t]/g, ' ');
            return i('>') + s(n) + a(u) + '\n ' + l + i('^');
           }
           let t = s(n.replace(/\d/g, ' ')) + e.slice(0, this.column - 1).replace(/[^\t]/g, ' ');
           return i('>') + s(n) + a(e) + '\n ' + t + i('^');
          }
          return ' ' + s(n) + a(e);
         })
         .join('\n');
       }
       toString() {
        let e = this.showSourceCode();
        return e && (e = '\n\n' + e + '\n'), this.name + ': ' + this.message + e;
       }
      };
     (t.exports = s), (s.default = s);
    }),
    m = l((e, t) => {
     var r = { after: '\n', beforeClose: '\n', beforeComment: '\n', beforeDecl: '\n', beforeOpen: ' ', beforeRule: '\n', colon: ': ', commentLeft: ' ', commentRight: ' ', emptyBody: '', indent: '    ', semicolon: !1 };
     var n = class {
      constructor(e) {
       this.builder = e;
      }
      atrule(e, t) {
       let r = '@' + e.name,
        n = e.params ? this.rawValue(e, 'params') : '';
       if ((typeof e.raws.afterName < 'u' ? (r += e.raws.afterName) : n && (r += ' '), e.nodes)) this.block(e, r + n);
       else {
        let s = (e.raws.between || '') + (t ? ';' : '');
        this.builder(r + n + s, e);
       }
      }
      beforeAfter(e, t) {
       let r;
       r = 'decl' === e.type ? this.raw(e, null, 'beforeDecl') : 'comment' === e.type ? this.raw(e, null, 'beforeComment') : 'before' === t ? this.raw(e, null, 'beforeRule') : this.raw(e, null, 'beforeClose');
       let n = e.parent,
        s = 0;
       for (; n && 'root' !== n.type; ) (s += 1), (n = n.parent);
       if (r.includes('\n')) {
        let t = this.raw(e, null, 'indent');
        if (t.length) for (let e = 0; e < s; e++) r += t;
       }
       return r;
      }
      block(e, t) {
       let r,
        n = this.raw(e, 'between', 'beforeOpen');
       this.builder(t + n + '{', e, 'start'), e.nodes && e.nodes.length ? (this.body(e), (r = this.raw(e, 'after'))) : (r = this.raw(e, 'after', 'emptyBody')), r && this.builder(r), this.builder('}', e, 'end');
      }
      body(e) {
       let t = e.nodes.length - 1;
       for (; t > 0 && 'comment' === e.nodes[t].type; ) t -= 1;
       let r = this.raw(e, 'semicolon');
       for (let n = 0; n < e.nodes.length; n++) {
        let s = e.nodes[n],
         i = this.raw(s, 'before');
        i && this.builder(i), this.stringify(s, t !== n || r);
       }
      }
      comment(e) {
       let t = this.raw(e, 'left', 'commentLeft'),
        r = this.raw(e, 'right', 'commentRight');
       this.builder('/*' + t + e.text + r + '*/', e);
      }
      decl(e, t) {
       let r = this.raw(e, 'between', 'colon'),
        n = e.prop + r + this.rawValue(e, 'value');
       e.important && (n += e.raws.important || ' !important'), t && (n += ';'), this.builder(n, e);
      }
      document(e) {
       this.body(e);
      }
      raw(e, t, n) {
       let s;
       if ((n || (n = t), t && ((s = e.raws[t]), typeof s < 'u'))) return s;
       let i = e.parent;
       if ('before' === n && (!i || ('root' === i.type && i.first === e) || (i && 'document' === i.type))) return '';
       if (!i) return r[n];
       let a = e.root();
       if ((a.rawCache || (a.rawCache = {}), typeof a.rawCache[n] < 'u')) return a.rawCache[n];
       if ('before' === n || 'after' === n) return this.beforeAfter(e, n);
       {
        let r = 'raw' + ((o = n)[0].toUpperCase() + o.slice(1));
        this[r]
         ? (s = this[r](a, e))
         : a.walk((e) => {
            if (((s = e.raws[t]), typeof s < 'u')) return !1;
           });
       }
       var o;
       return typeof s > 'u' && (s = r[n]), (a.rawCache[n] = s), s;
      }
      rawBeforeClose(e) {
       let t;
       return (
        e.walk((e) => {
         if (e.nodes && e.nodes.length > 0 && typeof e.raws.after < 'u') return (t = e.raws.after), t.includes('\n') && (t = t.replace(/[^\n]+$/, '')), !1;
        }),
        t && (t = t.replace(/\S/g, '')),
        t
       );
      }
      rawBeforeComment(e, t) {
       let r;
       return (
        e.walkComments((e) => {
         if (typeof e.raws.before < 'u') return (r = e.raws.before), r.includes('\n') && (r = r.replace(/[^\n]+$/, '')), !1;
        }),
        typeof r > 'u' ? (r = this.raw(t, null, 'beforeDecl')) : r && (r = r.replace(/\S/g, '')),
        r
       );
      }
      rawBeforeDecl(e, t) {
       let r;
       return (
        e.walkDecls((e) => {
         if (typeof e.raws.before < 'u') return (r = e.raws.before), r.includes('\n') && (r = r.replace(/[^\n]+$/, '')), !1;
        }),
        typeof r > 'u' ? (r = this.raw(t, null, 'beforeRule')) : r && (r = r.replace(/\S/g, '')),
        r
       );
      }
      rawBeforeOpen(e) {
       let t;
       return (
        e.walk((e) => {
         if ('decl' !== e.type && ((t = e.raws.between), typeof t < 'u')) return !1;
        }),
        t
       );
      }
      rawBeforeRule(e) {
       let t;
       return (
        e.walk((r) => {
         if (r.nodes && (r.parent !== e || e.first !== r) && typeof r.raws.before < 'u') return (t = r.raws.before), t.includes('\n') && (t = t.replace(/[^\n]+$/, '')), !1;
        }),
        t && (t = t.replace(/\S/g, '')),
        t
       );
      }
      rawColon(e) {
       let t;
       return (
        e.walkDecls((e) => {
         if (typeof e.raws.between < 'u') return (t = e.raws.between.replace(/[^\s:]/g, '')), !1;
        }),
        t
       );
      }
      rawEmptyBody(e) {
       let t;
       return (
        e.walk((e) => {
         if (e.nodes && 0 === e.nodes.length && ((t = e.raws.after), typeof t < 'u')) return !1;
        }),
        t
       );
      }
      rawIndent(e) {
       if (e.raws.indent) return e.raws.indent;
       let t;
       return (
        e.walk((r) => {
         let n = r.parent;
         if (n && n !== e && n.parent && n.parent === e && typeof r.raws.before < 'u') {
          let e = r.raws.before.split('\n');
          return (t = e[e.length - 1]), (t = t.replace(/\S/g, '')), !1;
         }
        }),
        t
       );
      }
      rawSemicolon(e) {
       let t;
       return (
        e.walk((e) => {
         if (e.nodes && e.nodes.length && 'decl' === e.last.type && ((t = e.raws.semicolon), typeof t < 'u')) return !1;
        }),
        t
       );
      }
      rawValue(e, t) {
       let r = e[t],
        n = e.raws[t];
       return n && n.value === r ? n.raw : r;
      }
      root(e) {
       this.body(e), e.raws.after && this.builder(e.raws.after);
      }
      rule(e) {
       this.block(e, this.rawValue(e, 'selector')), e.raws.ownSemicolon && this.builder(e.raws.ownSemicolon, e, 'end');
      }
      stringify(e, t) {
       if (!this[e.type]) throw new Error('Unknown AST node type ' + e.type + '. Maybe you need to change PostCSS stringifier.');
       this[e.type](e, t);
      }
     };
     (t.exports = n), (n.default = n);
    }),
    y = l((e, t) => {
     var r = m();
     function n(e, t) {
      new r(t).stringify(e);
     }
     (t.exports = n), (n.default = n);
    }),
    g = l((e, t) => {
     (t.exports.isClean = Symbol('isClean')), (t.exports.my = Symbol('my'));
    }),
    D = l((e, t) => {
     var r = f(),
      n = m(),
      s = y(),
      { isClean: i, my: a } = g();
     function o(e, t) {
      let r = new e.constructor();
      for (let n in e) {
       if (!Object.prototype.hasOwnProperty.call(e, n) || 'proxyCache' === n) continue;
       let s = e[n],
        i = typeof s;
       'parent' === n && 'object' === i ? t && (r[n] = t) : 'source' === n ? (r[n] = s) : Array.isArray(s) ? (r[n] = s.map((e) => o(e, r))) : ('object' === i && null !== s && (s = o(s)), (r[n] = s));
      }
      return r;
     }
     function u(e, t) {
      if (t && typeof t.offset < 'u') return t.offset;
      let r = 1,
       n = 1,
       s = 0;
      for (let i = 0; i < e.length; i++) {
       if (n === t.line && r === t.column) {
        s = i;
        break;
       }
       '\n' === e[i] ? ((r = 1), (n += 1)) : (r += 1);
      }
      return s;
     }
     var l = class {
      constructor(e = {}) {
       (this.raws = {}), (this[i] = !1), (this[a] = !0);
       for (let t in e)
        if ('nodes' === t) {
         this.nodes = [];
         for (let r of e[t]) 'function' == typeof r.clone ? this.append(r.clone()) : this.append(r);
        } else this[t] = e[t];
      }
      addToError(e) {
       if (((e.postcssNode = this), e.stack && this.source && /\n\s{4}at /.test(e.stack))) {
        let t = this.source;
        e.stack = e.stack.replace(/\n\s{4}at /, `$&${t.input.from}:${t.start.line}:${t.start.column}$&`);
       }
       return e;
      }
      after(e) {
       return this.parent.insertAfter(this, e), this;
      }
      assign(e = {}) {
       for (let t in e) this[t] = e[t];
       return this;
      }
      before(e) {
       return this.parent.insertBefore(this, e), this;
      }
      cleanRaws(e) {
       delete this.raws.before, delete this.raws.after, e || delete this.raws.between;
      }
      clone(e = {}) {
       let t = o(this);
       for (let r in e) t[r] = e[r];
       return t;
      }
      cloneAfter(e = {}) {
       let t = this.clone(e);
       return this.parent.insertAfter(this, t), t;
      }
      cloneBefore(e = {}) {
       let t = this.clone(e);
       return this.parent.insertBefore(this, t), t;
      }
      error(e, t = {}) {
       if (this.source) {
        let { end: r, start: n } = this.rangeBy(t);
        return this.source.input.error(e, { column: n.column, line: n.line }, { column: r.column, line: r.line }, t);
       }
       return new r(e);
      }
      getProxyProcessor() {
       return { get: (e, t) => ('proxyOf' === t ? e : 'root' === t ? () => e.root().toProxy() : e[t]), set: (e, t, r) => (e[t] === r || ((e[t] = r), ('prop' === t || 'value' === t || 'name' === t || 'params' === t || 'important' === t || 'text' === t) && e.markDirty()), !0) };
      }
      markClean() {
       this[i] = !0;
      }
      markDirty() {
       if (this[i]) {
        this[i] = !1;
        let e = this;
        for (; (e = e.parent); ) e[i] = !1;
       }
      }
      next() {
       if (!this.parent) return;
       let e = this.parent.index(this);
       return this.parent.nodes[e + 1];
      }
      positionBy(e) {
       let t = this.source.start;
       if (e.index) t = this.positionInside(e.index);
       else if (e.word) {
        let r = 'document' in this.source.input ? this.source.input.document : this.source.input.css,
         n = r.slice(u(r, this.source.start), u(r, this.source.end)).indexOf(e.word);
        -1 !== n && (t = this.positionInside(n));
       }
       return t;
      }
      positionInside(e) {
       let t = this.source.start.column,
        r = this.source.start.line,
        n = 'document' in this.source.input ? this.source.input.document : this.source.input.css,
        s = u(n, this.source.start),
        i = s + e;
       for (let a = s; a < i; a++) '\n' === n[a] ? ((t = 1), (r += 1)) : (t += 1);
       return { column: t, line: r };
      }
      prev() {
       if (!this.parent) return;
       let e = this.parent.index(this);
       return this.parent.nodes[e - 1];
      }
      rangeBy(e) {
       let t = { column: this.source.start.column, line: this.source.start.line },
        r = this.source.end ? { column: this.source.end.column + 1, line: this.source.end.line } : { column: t.column + 1, line: t.line };
       if (e.word) {
        let n = 'document' in this.source.input ? this.source.input.document : this.source.input.css,
         s = n.slice(u(n, this.source.start), u(n, this.source.end)).indexOf(e.word);
        -1 !== s && ((t = this.positionInside(s)), (r = this.positionInside(s + e.word.length)));
       } else e.start ? (t = { column: e.start.column, line: e.start.line }) : e.index && (t = this.positionInside(e.index)), e.end ? (r = { column: e.end.column, line: e.end.line }) : 'number' == typeof e.endIndex ? (r = this.positionInside(e.endIndex)) : e.index && (r = this.positionInside(e.index + 1));
       return (r.line < t.line || (r.line === t.line && r.column <= t.column)) && (r = { column: t.column + 1, line: t.line }), { end: r, start: t };
      }
      raw(e, t) {
       return new n().raw(this, e, t);
      }
      remove() {
       return this.parent && this.parent.removeChild(this), (this.parent = void 0), this;
      }
      replaceWith(...e) {
       if (this.parent) {
        let t = this,
         r = !1;
        for (let n of e) n === this ? (r = !0) : r ? (this.parent.insertAfter(t, n), (t = n)) : this.parent.insertBefore(t, n);
        r || this.remove();
       }
       return this;
      }
      root() {
       let e = this;
       for (; e.parent && 'document' !== e.parent.type; ) e = e.parent;
       return e;
      }
      toJSON(e, t) {
       let r = {},
        n = null == t;
       t = t || new Map();
       let s = 0;
       for (let i in this) {
        if (!Object.prototype.hasOwnProperty.call(this, i) || 'parent' === i || 'proxyCache' === i) continue;
        let e = this[i];
        if (Array.isArray(e)) r[i] = e.map((e) => ('object' == typeof e && e.toJSON ? e.toJSON(null, t) : e));
        else if ('object' == typeof e && e.toJSON) r[i] = e.toJSON(null, t);
        else if ('source' === i) {
         let n = t.get(e.input);
         null == n && ((n = s), t.set(e.input, s), s++), (r[i] = { end: e.end, inputId: n, start: e.start });
        } else r[i] = e;
       }
       return n && (r.inputs = [...t.keys()].map((e) => e.toJSON())), r;
      }
      toProxy() {
       return this.proxyCache || (this.proxyCache = new Proxy(this, this.getProxyProcessor())), this.proxyCache;
      }
      toString(e = s) {
       e.stringify && (e = e.stringify);
       let t = '';
       return (
        e(this, (e) => {
         t += e;
        }),
        t
       );
      }
      warn(e, t, r) {
       let n = { node: this };
       for (let s in r) n[s] = r[s];
       return e.warn(t, n);
      }
      get proxyOf() {
       return this;
      }
     };
     (t.exports = l), (l.default = l);
    }),
    x = l((e, t) => {
     var r = D(),
      n = class extends r {
       constructor(e) {
        super(e), (this.type = 'comment');
       }
      };
     (t.exports = n), (n.default = n);
    }),
    b = l((e, t) => {
     var r = D(),
      n = class extends r {
       constructor(e) {
        e && typeof e.value < 'u' && 'string' != typeof e.value && (e = { ...e, value: String(e.value) }), super(e), (this.type = 'decl');
       }
       get variable() {
        return this.prop.startsWith('--') || '$' === this.prop[0];
       }
      };
     (t.exports = n), (n.default = n);
    }),
    v = l((e, t) => {
     var r,
      n,
      s,
      i,
      a = x(),
      o = b(),
      u = D(),
      { isClean: l, my: p } = g();
     function c(e) {
      return e.map((e) => (e.nodes && (e.nodes = c(e.nodes)), delete e.source, e));
     }
     function h(e) {
      if (((e[l] = !1), e.proxyOf.nodes)) for (let t of e.proxyOf.nodes) h(t);
     }
     var d = class e extends u {
      append(...e) {
       for (let t of e) {
        let e = this.normalize(t, this.last);
        for (let t of e) this.proxyOf.nodes.push(t);
       }
       return this.markDirty(), this;
      }
      cleanRaws(e) {
       if ((super.cleanRaws(e), this.nodes)) for (let t of this.nodes) t.cleanRaws(e);
      }
      each(e) {
       if (!this.proxyOf.nodes) return;
       let t,
        r,
        n = this.getIterator();
       for (; this.indexes[n] < this.proxyOf.nodes.length && ((t = this.indexes[n]), (r = e(this.proxyOf.nodes[t], t)), !1 !== r); ) this.indexes[n] += 1;
       return delete this.indexes[n], r;
      }
      every(e) {
       return this.nodes.every(e);
      }
      getIterator() {
       this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), (this.lastEach += 1);
       let e = this.lastEach;
       return (this.indexes[e] = 0), e;
      }
      getProxyProcessor() {
       return { get: (e, t) => ('proxyOf' === t ? e : e[t] ? ('each' === t || ('string' == typeof t && t.startsWith('walk')) ? (...r) => e[t](...r.map((e) => ('function' == typeof e ? (t, r) => e(t.toProxy(), r) : e))) : 'every' === t || 'some' === t ? (r) => e[t]((e, ...t) => r(e.toProxy(), ...t)) : 'root' === t ? () => e.root().toProxy() : 'nodes' === t ? e.nodes.map((e) => e.toProxy()) : 'first' === t || 'last' === t ? e[t].toProxy() : e[t]) : e[t]), set: (e, t, r) => (e[t] === r || ((e[t] = r), ('name' === t || 'params' === t || 'selector' === t) && e.markDirty()), !0) };
      }
      index(e) {
       return 'number' == typeof e ? e : (e.proxyOf && (e = e.proxyOf), this.proxyOf.nodes.indexOf(e));
      }
      insertAfter(e, t) {
       let r,
        n = this.index(e),
        s = this.normalize(t, this.proxyOf.nodes[n]).reverse();
       n = this.index(e);
       for (let i of s) this.proxyOf.nodes.splice(n + 1, 0, i);
       for (let i in this.indexes) (r = this.indexes[i]), n < r && (this.indexes[i] = r + s.length);
       return this.markDirty(), this;
      }
      insertBefore(e, t) {
       let r,
        n = this.index(e),
        s = 0 === n && 'prepend',
        i = this.normalize(t, this.proxyOf.nodes[n], s).reverse();
       n = this.index(e);
       for (let a of i) this.proxyOf.nodes.splice(n, 0, a);
       for (let a in this.indexes) (r = this.indexes[a]), n <= r && (this.indexes[a] = r + i.length);
       return this.markDirty(), this;
      }
      normalize(t, s) {
       if ('string' == typeof t) t = c(n(t).nodes);
       else if (typeof t > 'u') t = [];
       else if (Array.isArray(t)) {
        t = t.slice(0);
        for (let e of t) e.parent && e.parent.removeChild(e, 'ignore');
       } else if ('root' === t.type && 'document' !== this.type) {
        t = t.nodes.slice(0);
        for (let e of t) e.parent && e.parent.removeChild(e, 'ignore');
       } else if (t.type) t = [t];
       else if (t.prop) {
        if (typeof t.value > 'u') throw new Error('Value field is missed in node creation');
        'string' != typeof t.value && (t.value = String(t.value)), (t = [new o(t)]);
       } else if (t.selector || t.selectors) t = [new i(t)];
       else if (t.name) t = [new r(t)];
       else {
        if (!t.text) throw new Error('Unknown node type in node creation');
        t = [new a(t)];
       }
       return t.map((t) => (t[p] || e.rebuild(t), (t = t.proxyOf).parent && t.parent.removeChild(t), t[l] && h(t), t.raws || (t.raws = {}), typeof t.raws.before > 'u' && s && typeof s.raws.before < 'u' && (t.raws.before = s.raws.before.replace(/\S/g, '')), (t.parent = this.proxyOf), t));
      }
      prepend(...e) {
       e = e.reverse();
       for (let t of e) {
        let e = this.normalize(t, this.first, 'prepend').reverse();
        for (let t of e) this.proxyOf.nodes.unshift(t);
        for (let t in this.indexes) this.indexes[t] = this.indexes[t] + e.length;
       }
       return this.markDirty(), this;
      }
      push(e) {
       return (e.parent = this), this.proxyOf.nodes.push(e), this;
      }
      removeAll() {
       for (let e of this.proxyOf.nodes) e.parent = void 0;
       return (this.proxyOf.nodes = []), this.markDirty(), this;
      }
      removeChild(e) {
       let t;
       (e = this.index(e)), (this.proxyOf.nodes[e].parent = void 0), this.proxyOf.nodes.splice(e, 1);
       for (let r in this.indexes) (t = this.indexes[r]), t >= e && (this.indexes[r] = t - 1);
       return this.markDirty(), this;
      }
      replaceValues(e, t, r) {
       return (
        r || ((r = t), (t = {})),
        this.walkDecls((n) => {
         (t.props && !t.props.includes(n.prop)) || (t.fast && !n.value.includes(t.fast)) || (n.value = n.value.replace(e, r));
        }),
        this.markDirty(),
        this
       );
      }
      some(e) {
       return this.nodes.some(e);
      }
      walk(e) {
       return this.each((t, r) => {
        let n;
        try {
         n = e(t, r);
        } catch (s) {
         throw t.addToError(s);
        }
        return !1 !== n && t.walk && (n = t.walk(e)), n;
       });
      }
      walkAtRules(e, t) {
       return t
        ? e instanceof RegExp
          ? this.walk((r, n) => {
             if ('atrule' === r.type && e.test(r.name)) return t(r, n);
            })
          : this.walk((r, n) => {
             if ('atrule' === r.type && r.name === e) return t(r, n);
            })
        : ((t = e),
          this.walk((e, r) => {
           if ('atrule' === e.type) return t(e, r);
          }));
      }
      walkComments(e) {
       return this.walk((t, r) => {
        if ('comment' === t.type) return e(t, r);
       });
      }
      walkDecls(e, t) {
       return t
        ? e instanceof RegExp
          ? this.walk((r, n) => {
             if ('decl' === r.type && e.test(r.prop)) return t(r, n);
            })
          : this.walk((r, n) => {
             if ('decl' === r.type && r.prop === e) return t(r, n);
            })
        : ((t = e),
          this.walk((e, r) => {
           if ('decl' === e.type) return t(e, r);
          }));
      }
      walkRules(e, t) {
       return t
        ? e instanceof RegExp
          ? this.walk((r, n) => {
             if ('rule' === r.type && e.test(r.selector)) return t(r, n);
            })
          : this.walk((r, n) => {
             if ('rule' === r.type && r.selector === e) return t(r, n);
            })
        : ((t = e),
          this.walk((e, r) => {
           if ('rule' === e.type) return t(e, r);
          }));
      }
      get first() {
       if (this.proxyOf.nodes) return this.proxyOf.nodes[0];
      }
      get last() {
       if (this.proxyOf.nodes) return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
      }
     };
     (d.registerParse = (e) => {
      n = e;
     }),
      (d.registerRule = (e) => {
       i = e;
      }),
      (d.registerAtRule = (e) => {
       r = e;
      }),
      (d.registerRoot = (e) => {
       s = e;
      }),
      (t.exports = d),
      (d.default = d),
      (d.rebuild = (e) => {
       'atrule' === e.type ? Object.setPrototypeOf(e, r.prototype) : 'rule' === e.type ? Object.setPrototypeOf(e, i.prototype) : 'decl' === e.type ? Object.setPrototypeOf(e, o.prototype) : 'comment' === e.type ? Object.setPrototypeOf(e, a.prototype) : 'root' === e.type && Object.setPrototypeOf(e, s.prototype),
        (e[p] = !0),
        e.nodes &&
         e.nodes.forEach((e) => {
          d.rebuild(e);
         });
      });
    }),
    E = l((e, t) => {
     t.exports = {
      nanoid: (e = 21) => {
       let t = '',
        r = 0 | e;
       for (; r--; ) t += 'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'[(64 * Math.random()) | 0];
       return t;
      },
      customAlphabet:
       (e, t = 21) =>
       (r = t) => {
        let n = '',
         s = 0 | r;
        for (; s--; ) n += e[(Math.random() * e.length) | 0];
        return n;
       },
     };
    }),
    C = l(() => {}),
    T = l((e, t) => {
     t.exports = class {};
    }),
    S = l((e, t) => {
     var { nanoid: r } = E(),
      { isAbsolute: n, resolve: s } = {},
      { SourceMapConsumer: i, SourceMapGenerator: a } = C(),
      { fileURLToPath: o, pathToFileURL: u } = {},
      l = f(),
      p = T(),
      c = d(),
      h = Symbol('fromOffsetCache'),
      m = !(!i || !a),
      y = !(!s || !n),
      g = class {
       constructor(e, t = {}) {
        if (null === e || typeof e > 'u' || ('object' == typeof e && !e.toString)) throw new Error(`PostCSS received ${e} instead of CSS string`);
        if (((this.css = e.toString()), '\ufeff' === this.css[0] || '\ufffe' === this.css[0] ? ((this.hasBOM = !0), (this.css = this.css.slice(1))) : (this.hasBOM = !1), (this.document = this.css), t.document && (this.document = t.document.toString()), t.from && (!y || /^\w+:\/\//.test(t.from) || n(t.from) ? (this.file = t.from) : (this.file = s(t.from))), y && m)) {
         let e = new p(this.css, t);
         if (e.text) {
          this.map = e;
          let t = e.consumer().file;
          !this.file && t && (this.file = this.mapResolve(t));
         }
        }
        this.file || (this.id = '<input css ' + r(6) + '>'), this.map && (this.map.file = this.from);
       }
       error(e, t, r, n = {}) {
        let s, i, a;
        if (t && 'object' == typeof t) {
         let e = t,
          n = r;
         if ('number' == typeof e.offset) {
          let n = this.fromOffset(e.offset);
          (t = n.line), (r = n.col);
         } else (t = e.line), (r = e.column);
         if ('number' == typeof n.offset) {
          let e = this.fromOffset(n.offset);
          (i = e.line), (s = e.col);
         } else (i = n.line), (s = n.column);
        } else if (!r) {
         let e = this.fromOffset(t);
         (t = e.line), (r = e.col);
        }
        let o = this.origin(t, r, i, s);
        return (a = o ? new l(e, void 0 === o.endLine ? o.line : { column: o.column, line: o.line }, void 0 === o.endLine ? o.column : { column: o.endColumn, line: o.endLine }, o.source, o.file, n.plugin) : new l(e, void 0 === i ? t : { column: r, line: t }, void 0 === i ? r : { column: s, line: i }, this.css, this.file, n.plugin)), (a.input = { column: r, endColumn: s, endLine: i, line: t, source: this.css }), this.file && (u && (a.input.url = u(this.file).toString()), (a.input.file = this.file)), a;
       }
       fromOffset(e) {
        let t, r;
        if (this[h]) r = this[h];
        else {
         let e = this.css.split('\n');
         r = new Array(e.length);
         let t = 0;
         for (let n = 0, s = e.length; n < s; n++) (r[n] = t), (t += e[n].length + 1);
         this[h] = r;
        }
        t = r[r.length - 1];
        let n = 0;
        if (e >= t) n = r.length - 1;
        else {
         let t,
          s = r.length - 2;
         for (; n < s; )
          if (((t = n + ((s - n) >> 1)), e < r[t])) s = t - 1;
          else {
           if (!(e >= r[t + 1])) {
            n = t;
            break;
           }
           n = t + 1;
          }
        }
        return { col: e - r[n] + 1, line: n + 1 };
       }
       mapResolve(e) {
        return /^\w+:\/\//.test(e) ? e : s(this.map.consumer().sourceRoot || this.map.root || '.', e);
       }
       origin(e, t, r, s) {
        if (!this.map) return !1;
        let i,
         a,
         l = this.map.consumer(),
         p = l.originalPositionFor({ column: t, line: e });
        if (!p.source) return !1;
        'number' == typeof r && (i = l.originalPositionFor({ column: s, line: r })), (a = n(p.source) ? u(p.source) : new URL(p.source, this.map.consumer().sourceRoot || u(this.map.mapFile)));
        let c = { column: p.column, endColumn: i && i.column, endLine: i && i.line, line: p.line, url: a.toString() };
        if ('file:' === a.protocol) {
         if (!o) throw new Error('file: protocol is not available in this PostCSS build');
         c.file = o(a);
        }
        let h = l.sourceContentFor(p.source);
        return h && (c.source = h), c;
       }
       toJSON() {
        let e = {};
        for (let t of ['hasBOM', 'css', 'file', 'id']) null != this[t] && (e[t] = this[t]);
        return this.map && ((e.map = { ...this.map }), e.map.consumerCache && (e.map.consumerCache = void 0)), e;
       }
       get from() {
        return this.file || this.id;
       }
      };
     (t.exports = g), (g.default = g), c && c.registerInput && c.registerInput(g);
    }),
    w = l((e, t) => {
     var r = v(),
      n = class extends r {
       constructor(e) {
        super(e), (this.type = 'atrule');
       }
       append(...e) {
        return this.proxyOf.nodes || (this.nodes = []), super.append(...e);
       }
       prepend(...e) {
        return this.proxyOf.nodes || (this.nodes = []), super.prepend(...e);
       }
      };
     (t.exports = n), (n.default = n), r.registerAtRule(n);
    }),
    A = l((e, t) => {
     var r,
      n,
      s = v(),
      i = class extends s {
       constructor(e) {
        super(e), (this.type = 'root'), this.nodes || (this.nodes = []);
       }
       normalize(e, t, r) {
        let n = super.normalize(e);
        if (t)
         if ('prepend' === r) this.nodes.length > 1 ? (t.raws.before = this.nodes[1].raws.before) : delete t.raws.before;
         else if (this.first !== t) for (let s of n) s.raws.before = t.raws.before;
        return n;
       }
       removeChild(e, t) {
        let r = this.index(e);
        return !t && 0 === r && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[r].raws.before), super.removeChild(e);
       }
       toResult(e = {}) {
        return new r(new n(), this, e).stringify();
       }
      };
     (i.registerLazyResult = (e) => {
      r = e;
     }),
      (i.registerProcessor = (e) => {
       n = e;
      }),
      (t.exports = i),
      (i.default = i),
      s.registerRoot(i);
    }),
    F = l((e, t) => {
     var r = {
      comma: (e) => r.split(e, [','], !0),
      space(e) {
       let t = [' ', '\n', '\t'];
       return r.split(e, t);
      },
      split(e, t, r) {
       let n = [],
        s = '',
        i = !1,
        a = 0,
        o = !1,
        u = '',
        l = !1;
       for (let p of e) l ? (l = !1) : '\\' === p ? (l = !0) : o ? p === u && (o = !1) : '"' === p || "'" === p ? ((o = !0), (u = p)) : '(' === p ? (a += 1) : ')' === p ? a > 0 && (a -= 1) : 0 === a && t.includes(p) && (i = !0), i ? ('' !== s && n.push(s.trim()), (s = ''), (i = !1)) : (s += p);
       return (r || '' !== s) && n.push(s.trim()), n;
      },
     };
     (t.exports = r), (r.default = r);
    }),
    k = l((e, t) => {
     var r = v(),
      n = F(),
      s = class extends r {
       constructor(e) {
        super(e), (this.type = 'rule'), this.nodes || (this.nodes = []);
       }
       get selectors() {
        return n.comma(this.selector);
       }
       set selectors(e) {
        let t = this.selector ? this.selector.match(/,\s*/) : null,
         r = t ? t[0] : ',' + this.raw('between', 'beforeOpen');
        this.selector = e.join(r);
       }
      };
     (t.exports = s), (s.default = s), r.registerRule(s);
    }),
    P = l((e, t) => {
     var r = /[\t\n\f\r "#'()/;[\\\]{}]/g,
      n = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g,
      s = /.[\r\n"'(/\\]/,
      i = /[\da-f]/i;
     t.exports = function (e, t = {}) {
      let a,
       o,
       u,
       l,
       p,
       c,
       h,
       d,
       f,
       m,
       y = e.css.valueOf(),
       g = t.ignoreErrors,
       D = y.length,
       x = 0,
       b = [],
       v = [];
      function E(t) {
       throw e.error('Unclosed ' + t, x);
      }
      return {
       back: function (e) {
        v.push(e);
       },
       endOfFile: function () {
        return 0 === v.length && x >= D;
       },
       nextToken: function (e) {
        if (v.length) return v.pop();
        if (x >= D) return;
        let t = !!e && e.ignoreUnclosed;
        switch (((a = y.charCodeAt(x)), a)) {
         case 10:
         case 32:
         case 9:
         case 13:
         case 12:
          l = x;
          do {
           (l += 1), (a = y.charCodeAt(l));
          } while (32 === a || 10 === a || 9 === a || 13 === a || 12 === a);
          (c = ['space', y.slice(x, l)]), (x = l - 1);
          break;
         case 91:
         case 93:
         case 123:
         case 125:
         case 58:
         case 59:
         case 41: {
          let e = String.fromCharCode(a);
          c = [e, e, x];
          break;
         }
         case 40:
          if (((m = b.length ? b.pop()[1] : ''), (f = y.charCodeAt(x + 1)), 'url' === m && 39 !== f && 34 !== f && 32 !== f && 10 !== f && 9 !== f && 12 !== f && 13 !== f)) {
           l = x;
           do {
            if (((h = !1), (l = y.indexOf(')', l + 1)), -1 === l)) {
             if (g || t) {
              l = x;
              break;
             }
             E('bracket');
            }
            for (d = l; 92 === y.charCodeAt(d - 1); ) (d -= 1), (h = !h);
           } while (h);
           (c = ['brackets', y.slice(x, l + 1), x, l]), (x = l);
          } else (l = y.indexOf(')', x + 1)), (o = y.slice(x, l + 1)), -1 === l || s.test(o) ? (c = ['(', '(', x]) : ((c = ['brackets', o, x, l]), (x = l));
          break;
         case 39:
         case 34:
          (p = 39 === a ? "'" : '"'), (l = x);
          do {
           if (((h = !1), (l = y.indexOf(p, l + 1)), -1 === l)) {
            if (g || t) {
             l = x + 1;
             break;
            }
            E('string');
           }
           for (d = l; 92 === y.charCodeAt(d - 1); ) (d -= 1), (h = !h);
          } while (h);
          (c = ['string', y.slice(x, l + 1), x, l]), (x = l);
          break;
         case 64:
          (r.lastIndex = x + 1), r.test(y), (l = 0 === r.lastIndex ? y.length - 1 : r.lastIndex - 2), (c = ['at-word', y.slice(x, l + 1), x, l]), (x = l);
          break;
         case 92:
          for (l = x, u = !0; 92 === y.charCodeAt(l + 1); ) (l += 1), (u = !u);
          if (((a = y.charCodeAt(l + 1)), u && 47 !== a && 32 !== a && 10 !== a && 9 !== a && 13 !== a && 12 !== a && ((l += 1), i.test(y.charAt(l))))) {
           for (; i.test(y.charAt(l + 1)); ) l += 1;
           32 === y.charCodeAt(l + 1) && (l += 1);
          }
          (c = ['word', y.slice(x, l + 1), x, l]), (x = l);
          break;
         default:
          47 === a && 42 === y.charCodeAt(x + 1) ? ((l = y.indexOf('*/', x + 2) + 1), 0 === l && (g || t ? (l = y.length) : E('comment')), (c = ['comment', y.slice(x, l + 1), x, l]), (x = l)) : ((n.lastIndex = x + 1), n.test(y), (l = 0 === n.lastIndex ? y.length - 1 : n.lastIndex - 2), (c = ['word', y.slice(x, l + 1), x, l]), b.push(c), (x = l));
        }
        return x++, c;
       },
       position: function () {
        return x;
       },
      };
     };
    }),
    I = l((e, t) => {
     var r = w(),
      n = x(),
      s = b(),
      i = A(),
      a = k(),
      o = P(),
      u = { empty: !0, space: !0 };
     t.exports = class {
      constructor(e) {
       (this.input = e), (this.root = new i()), (this.current = this.root), (this.spaces = ''), (this.semicolon = !1), this.createTokenizer(), (this.root.source = { input: e, start: { column: 1, line: 1, offset: 0 } });
      }
      atrule(e) {
       let t = new r();
       (t.name = e[1].slice(1)), '' === t.name && this.unnamedAtrule(t, e), this.init(t, e[2]);
       let n,
        s,
        i,
        a = !1,
        o = !1,
        u = [],
        l = [];
       for (; !this.tokenizer.endOfFile(); ) {
        if (((n = (e = this.tokenizer.nextToken())[0]), '(' === n || '[' === n ? l.push('(' === n ? ')' : ']') : '{' === n && l.length > 0 ? l.push('}') : n === l[l.length - 1] && l.pop(), 0 === l.length)) {
         if (';' === n) {
          (t.source.end = this.getPosition(e[2])), t.source.end.offset++, (this.semicolon = !0);
          break;
         }
         if ('{' === n) {
          o = !0;
          break;
         }
         if ('}' === n) {
          if (u.length > 0) {
           for (i = u.length - 1, s = u[i]; s && 'space' === s[0]; ) s = u[--i];
           s && ((t.source.end = this.getPosition(s[3] || s[2])), t.source.end.offset++);
          }
          this.end(e);
          break;
         }
         u.push(e);
        } else u.push(e);
        if (this.tokenizer.endOfFile()) {
         a = !0;
         break;
        }
       }
       (t.raws.between = this.spacesAndCommentsFromEnd(u)), u.length ? ((t.raws.afterName = this.spacesAndCommentsFromStart(u)), this.raw(t, 'params', u), a && ((e = u[u.length - 1]), (t.source.end = this.getPosition(e[3] || e[2])), t.source.end.offset++, (this.spaces = t.raws.between), (t.raws.between = ''))) : ((t.raws.afterName = ''), (t.params = '')), o && ((t.nodes = []), (this.current = t));
      }
      checkMissedSemicolon(e) {
       let t = this.colon(e);
       if (!1 === t) return;
       let r,
        n = 0;
       for (let s = t - 1; s >= 0 && ((r = e[s]), 'space' === r[0] || ((n += 1), 2 !== n)); s--);
       throw this.input.error('Missed semicolon', 'word' === r[0] ? r[3] + 1 : r[2]);
      }
      colon(e) {
       let t,
        r,
        n,
        s = 0;
       for (let [i, a] of e.entries()) {
        if (((r = a), (n = r[0]), '(' === n && (s += 1), ')' === n && (s -= 1), 0 === s && ':' === n)) {
         if (t) {
          if ('word' === t[0] && 'progid' === t[1]) continue;
          return i;
         }
         this.doubleColon(r);
        }
        t = r;
       }
       return !1;
      }
      comment(e) {
       let t = new n();
       this.init(t, e[2]), (t.source.end = this.getPosition(e[3] || e[2])), t.source.end.offset++;
       let r = e[1].slice(2, -2);
       if (/^\s*$/.test(r)) (t.text = ''), (t.raws.left = r), (t.raws.right = '');
       else {
        let e = r.match(/^(\s*)([^]*\S)(\s*)$/);
        (t.text = e[2]), (t.raws.left = e[1]), (t.raws.right = e[3]);
       }
      }
      createTokenizer() {
       this.tokenizer = o(this.input);
      }
      decl(e, t) {
       let r = new s();
       this.init(r, e[0][2]);
       let n,
        i = e[e.length - 1];
       for (
        ';' === i[0] && ((this.semicolon = !0), e.pop()),
         r.source.end = this.getPosition(
          i[3] ||
           i[2] ||
           (function (e) {
            for (let t = e.length - 1; t >= 0; t--) {
             let r = e[t],
              n = r[3] || r[2];
             if (n) return n;
            }
           })(e),
         ),
         r.source.end.offset++;
        'word' !== e[0][0];

       )
        1 === e.length && this.unknownWord(e), (r.raws.before += e.shift()[1]);
       for (r.source.start = this.getPosition(e[0][2]), r.prop = ''; e.length; ) {
        let t = e[0][0];
        if (':' === t || 'space' === t || 'comment' === t) break;
        r.prop += e.shift()[1];
       }
       for (r.raws.between = ''; e.length; ) {
        if (((n = e.shift()), ':' === n[0])) {
         r.raws.between += n[1];
         break;
        }
        'word' === n[0] && /\w/.test(n[1]) && this.unknownWord([n]), (r.raws.between += n[1]);
       }
       ('_' === r.prop[0] || '*' === r.prop[0]) && ((r.raws.before += r.prop[0]), (r.prop = r.prop.slice(1)));
       let a,
        o = [];
       for (; e.length && ((a = e[0][0]), 'space' === a || 'comment' === a); ) o.push(e.shift());
       this.precheckMissedSemicolon(e);
       for (let s = e.length - 1; s >= 0; s--) {
        if (((n = e[s]), '!important' === n[1].toLowerCase())) {
         r.important = !0;
         let t = this.stringFrom(e, s);
         (t = this.spacesFromEnd(e) + t), ' !important' !== t && (r.raws.important = t);
         break;
        }
        if ('important' === n[1].toLowerCase()) {
         let t = e.slice(0),
          n = '';
         for (let e = s; e > 0; e--) {
          let r = t[e][0];
          if (n.trim().startsWith('!') && 'space' !== r) break;
          n = t.pop()[1] + n;
         }
         n.trim().startsWith('!') && ((r.important = !0), (r.raws.important = n), (e = t));
        }
        if ('space' !== n[0] && 'comment' !== n[0]) break;
       }
       e.some((e) => 'space' !== e[0] && 'comment' !== e[0]) && ((r.raws.between += o.map((e) => e[1]).join('')), (o = [])), this.raw(r, 'value', o.concat(e), t), r.value.includes(':') && !t && this.checkMissedSemicolon(e);
      }
      doubleColon(e) {
       throw this.input.error('Double colon', { offset: e[2] }, { offset: e[2] + e[1].length });
      }
      emptyRule(e) {
       let t = new a();
       this.init(t, e[2]), (t.selector = ''), (t.raws.between = ''), (this.current = t);
      }
      end(e) {
       this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), (this.semicolon = !1), (this.current.raws.after = (this.current.raws.after || '') + this.spaces), (this.spaces = ''), this.current.parent ? ((this.current.source.end = this.getPosition(e[2])), this.current.source.end.offset++, (this.current = this.current.parent)) : this.unexpectedClose(e);
      }
      endFile() {
       this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), (this.current.raws.after = (this.current.raws.after || '') + this.spaces), (this.root.source.end = this.getPosition(this.tokenizer.position()));
      }
      freeSemicolon(e) {
       if (((this.spaces += e[1]), this.current.nodes)) {
        let e = this.current.nodes[this.current.nodes.length - 1];
        e && 'rule' === e.type && !e.raws.ownSemicolon && ((e.raws.ownSemicolon = this.spaces), (this.spaces = ''));
       }
      }
      getPosition(e) {
       let t = this.input.fromOffset(e);
       return { column: t.col, line: t.line, offset: e };
      }
      init(e, t) {
       this.current.push(e), (e.source = { input: this.input, start: this.getPosition(t) }), (e.raws.before = this.spaces), (this.spaces = ''), 'comment' !== e.type && (this.semicolon = !1);
      }
      other(e) {
       let t = !1,
        r = null,
        n = !1,
        s = null,
        i = [],
        a = e[1].startsWith('--'),
        o = [],
        u = e;
       for (; u; ) {
        if (((r = u[0]), o.push(u), '(' === r || '[' === r)) s || (s = u), i.push('(' === r ? ')' : ']');
        else if (a && n && '{' === r) s || (s = u), i.push('}');
        else if (0 === i.length) {
         if (';' === r) {
          if (n) return void this.decl(o, a);
          break;
         }
         if ('{' === r) return void this.rule(o);
         if ('}' === r) {
          this.tokenizer.back(o.pop()), (t = !0);
          break;
         }
         ':' === r && (n = !0);
        } else r === i[i.length - 1] && (i.pop(), 0 === i.length && (s = null));
        u = this.tokenizer.nextToken();
       }
       if ((this.tokenizer.endOfFile() && (t = !0), i.length > 0 && this.unclosedBracket(s), t && n)) {
        if (!a) for (; o.length && ((u = o[o.length - 1][0]), 'space' === u || 'comment' === u); ) this.tokenizer.back(o.pop());
        this.decl(o, a);
       } else this.unknownWord(o);
      }
      parse() {
       let e;
       for (; !this.tokenizer.endOfFile(); )
        switch (((e = this.tokenizer.nextToken()), e[0])) {
         case 'space':
          this.spaces += e[1];
          break;
         case ';':
          this.freeSemicolon(e);
          break;
         case '}':
          this.end(e);
          break;
         case 'comment':
          this.comment(e);
          break;
         case 'at-word':
          this.atrule(e);
          break;
         case '{':
          this.emptyRule(e);
          break;
         default:
          this.other(e);
        }
       this.endFile();
      }
      precheckMissedSemicolon() {}
      raw(e, t, r, n) {
       let s,
        i,
        a,
        o,
        l = r.length,
        p = '',
        c = !0;
       for (let h = 0; h < l; h += 1) (s = r[h]), (i = s[0]), 'space' !== i || h !== l - 1 || n ? ('comment' === i ? ((o = r[h - 1] ? r[h - 1][0] : 'empty'), (a = r[h + 1] ? r[h + 1][0] : 'empty'), u[o] || u[a] || ',' === p.slice(-1) ? (c = !1) : (p += s[1])) : (p += s[1])) : (c = !1);
       if (!c) {
        let n = r.reduce((e, t) => e + t[1], '');
        e.raws[t] = { raw: n, value: p };
       }
       e[t] = p;
      }
      rule(e) {
       e.pop();
       let t = new a();
       this.init(t, e[0][2]), (t.raws.between = this.spacesAndCommentsFromEnd(e)), this.raw(t, 'selector', e), (this.current = t);
      }
      spacesAndCommentsFromEnd(e) {
       let t,
        r = '';
       for (; e.length && ((t = e[e.length - 1][0]), 'space' === t || 'comment' === t); ) r = e.pop()[1] + r;
       return r;
      }
      spacesAndCommentsFromStart(e) {
       let t,
        r = '';
       for (; e.length && ((t = e[0][0]), 'space' === t || 'comment' === t); ) r += e.shift()[1];
       return r;
      }
      spacesFromEnd(e) {
       let t,
        r = '';
       for (; e.length && ((t = e[e.length - 1][0]), 'space' === t); ) r = e.pop()[1] + r;
       return r;
      }
      stringFrom(e, t) {
       let r = '';
       for (let n = t; n < e.length; n++) r += e[n][1];
       return e.splice(t, e.length - t), r;
      }
      unclosedBlock() {
       let e = this.current.source.start;
       throw this.input.error('Unclosed block', e.line, e.column);
      }
      unclosedBracket(e) {
       throw this.input.error('Unclosed bracket', { offset: e[2] }, { offset: e[2] + 1 });
      }
      unexpectedClose(e) {
       throw this.input.error('Unexpected }', { offset: e[2] }, { offset: e[2] + 1 });
      }
      unknownWord(e) {
       throw this.input.error('Unknown word', { offset: e[0][2] }, { offset: e[0][2] + e[0][1].length });
      }
      unnamedAtrule(e, t) {
       throw this.input.error('At-rule without name', { offset: t[2] }, { offset: t[2] + t[1].length });
      }
     };
    }),
    N = l((e, t) => {
     var r = v(),
      n = S(),
      s = I();
     function i(e, t) {
      let r = new n(e, t),
       i = new s(r);
      try {
       i.parse();
      } catch (a) {
       throw a;
      }
      return i.root;
     }
     (t.exports = i), (i.default = i), r.registerParse(i);
    }),
    B = l((e, t) => {
     var r = P(),
      n = S();
     t.exports = {
      isInlineComment(e) {
       if ('word' === e[0] && '//' === e[1].slice(0, 2)) {
        let t,
         s,
         i = e,
         a = [];
        for (; e; ) {
         if (/\r?\n/.test(e[1])) {
          if (/['"].*\r?\n/.test(e[1])) {
           a.push(e[1].substring(0, e[1].indexOf('\n'))), (s = e[1].substring(e[1].indexOf('\n')));
           let r = this.input.css.valueOf().substring(this.tokenizer.position());
           (s += r), (t = e[3] + r.length - s.length);
          } else this.tokenizer.back(e);
          break;
         }
         a.push(e[1]), (t = e[2]), (e = this.tokenizer.nextToken({ ignoreUnclosed: !0 }));
        }
        let o = ['comment', a.join(''), i[2], t];
        return this.inlineComment(o), s && ((this.input = new n(s)), (this.tokenizer = r(this.input))), !0;
       }
       if ('/' === e[1]) {
        let r = this.tokenizer.nextToken({ ignoreUnclosed: !0 });
        if ('comment' === r[0] && /^\/\*/.test(r[1])) return (r[0] = 'word'), (r[1] = r[1].slice(1)), (e[1] = '//'), this.tokenizer.back(r), t.exports.isInlineComment.bind(this)(e);
       }
       return !1;
      },
     };
    }),
    _ = l((e, t) => {
     t.exports = {
      interpolation(e) {
       let t = [e, this.tokenizer.nextToken()],
        r = ['word', '}'];
       if (t[0][1].length > 1 || '{' !== t[1][0]) return this.tokenizer.back(t[1]), !1;
       for (e = this.tokenizer.nextToken(); e && r.includes(e[0]); ) t.push(e), (e = this.tokenizer.nextToken());
       let n = t.map((e) => e[1]),
        [s] = t,
        i = t.pop(),
        a = ['word', n.join(''), s[2], i[2]];
       return this.tokenizer.back(e), this.tokenizer.back(a), !0;
      },
     };
    }),
    L = l((e, t) => {
     var r = /^#[0-9a-fA-F]{6}$|^#[0-9a-fA-F]{3}$/,
      n = /\.[0-9]/;
     t.exports = {
      isMixinToken: (e) => {
       let [, t] = e,
        [s] = t;
       return ('.' === s || '#' === s) && !1 === r.test(t) && !1 === n.test(t);
      },
     };
    }),
    O = l((e, t) => {
     var r = P(),
      n = /^url\((.+)\)/;
     t.exports = (e) => {
      let { name: t, params: s = '' } = e;
      if ('import' === t && s.length) {
       e.import = !0;
       let t = r({ css: s });
       for (e.filename = s.replace(n, '$1'); !t.endOfFile(); ) {
        let [r, n] = t.nextToken();
        if ('word' === r && 'url' === n) return;
        if ('brackets' === r) {
         (e.options = n), (e.filename = s.replace(n, '').trim());
         break;
        }
       }
      }
     };
    }),
    M = l((e, t) => {
     var r = /:$/,
      n = /^:(\s+)?/;
     t.exports = (e) => {
      let { name: t, params: s = '' } = e;
      if (':' === e.name.slice(-1)) {
       if (r.test(t)) {
        let [n] = t.match(r);
        (e.name = t.replace(n, '')), (e.raws.afterName = n + (e.raws.afterName || '')), (e.variable = !0), (e.value = e.params);
       }
       if (n.test(s)) {
        let [t] = s.match(n);
        (e.value = s.replace(t, '')), (e.raws.afterName = (e.raws.afterName || '') + t), (e.variable = !0);
       }
      }
     };
    }),
    j = l((e, t) => {
     var r = x(),
      n = I(),
      { isInlineComment: s } = B(),
      { interpolation: i } = _(),
      { isMixinToken: a } = L(),
      o = O(),
      u = M(),
      l = /(!\s*important)$/i;
     t.exports = class extends n {
      constructor(...e) {
       super(...e), (this.lastNode = null);
      }
      atrule(e) {
       i.bind(this)(e) || (super.atrule(e), o(this.lastNode), u(this.lastNode));
      }
      decl(...e) {
       super.decl(...e), /extend\(.+\)/i.test(this.lastNode.value) && (this.lastNode.extend = !0);
      }
      each(e) {
       e[0][1] = ` ${e[0][1]}`;
       let t = e.findIndex((e) => '(' === e[0]),
        r = e.reverse().find((e) => ')' === e[0]),
        n = e.reverse().indexOf(r),
        s = e
         .splice(t, n)
         .map((e) => e[1])
         .join('');
       for (let i of e.reverse()) this.tokenizer.back(i);
       this.atrule(this.tokenizer.nextToken()), (this.lastNode.function = !0), (this.lastNode.params = s);
      }
      init(e, t, r) {
       super.init(e, t, r), (this.lastNode = e);
      }
      inlineComment(e) {
       let t = new r(),
        n = e[1].slice(2);
       if ((this.init(t, e[2]), (t.source.end = this.getPosition(e[3] || e[2])), (t.inline = !0), (t.raws.begin = '//'), /^\s*$/.test(n))) (t.text = ''), (t.raws.left = n), (t.raws.right = '');
       else {
        let e = n.match(/^(\s*)([^]*[^\s])(\s*)$/);
        [, t.raws.left, t.text, t.raws.right] = e;
       }
      }
      mixin(e) {
       let [t] = e,
        r = t[1].slice(0, 1),
        n = e.findIndex((e) => 'brackets' === e[0]),
        s = e.findIndex((e) => '(' === e[0]),
        i = '';
       if ((n < 0 || n > 3) && s > 0) {
        let t = e.reduce((e, t, r) => (')' === t[0] ? r : e)),
         r = e
          .slice(s, t + s)
          .map((e) => e[1])
          .join(''),
         [n] = e.slice(s),
         i = [n[2], n[3]],
         [a] = e.slice(t, t + 1),
         o = [a[2], a[3]],
         u = ['brackets', r].concat(i, o),
         l = e.slice(0, s),
         p = e.slice(t + 1);
        (e = l).push(u), (e = e.concat(p));
       }
       let a = [];
       for (let u of e) if ((('!' === u[1] || a.length) && a.push(u), 'important' === u[1])) break;
       if (a.length) {
        let [t] = a,
         r = e.indexOf(t),
         n = a[a.length - 1],
         s = [t[2], t[3]],
         i = [n[4], n[5]],
         o = ['word', a.map((e) => e[1]).join('')].concat(s, i);
        e.splice(r, a.length, o);
       }
       let o = e.findIndex((e) => l.test(e[1]));
       o > 0 && (([, i] = e[o]), e.splice(o, 1));
       for (let u of e.reverse()) this.tokenizer.back(u);
       this.atrule(this.tokenizer.nextToken()), (this.lastNode.mixin = !0), (this.lastNode.raws.identifier = r), i && ((this.lastNode.important = !0), (this.lastNode.raws.important = i));
      }
      other(e) {
       s.bind(this)(e) || super.other(e);
      }
      rule(e) {
       let t = e[e.length - 1],
        r = e[e.length - 2];
       if ('at-word' === r[0] && '{' === t[0] && (this.tokenizer.back(t), i.bind(this)(r))) {
        let t = this.tokenizer.nextToken();
        e = e.slice(0, e.length - 2).concat([t]);
        for (let r of e.reverse()) this.tokenizer.back(r);
       } else super.rule(e), /:extend\(.+\)/i.test(this.lastNode.selector) && (this.lastNode.extend = !0);
      }
      unknownWord(e) {
       let [t] = e;
       'each' !== e[0][1] || '(' !== e[1][0] ? (a(t) ? this.mixin(e) : super.unknownWord(e)) : this.each(e);
      }
     };
    }),
    R = l((e, t) => {
     var r = m();
     t.exports = class extends r {
      atrule(e, t) {
       if (!e.mixin && !e.variable && !e.function) return void super.atrule(e, t);
       let r = `${e.function ? '' : e.raws.identifier || '@'}${e.name}`,
        n = e.params ? this.rawValue(e, 'params') : '',
        s = e.raws.important || '';
       if ((e.variable && (n = e.value), typeof e.raws.afterName < 'u' ? (r += e.raws.afterName) : n && (r += ' '), e.nodes)) this.block(e, r + n + s);
       else {
        let i = (e.raws.between || '') + s + (t ? ';' : '');
        this.builder(r + n + i, e);
       }
      }
      comment(e) {
       if (e.inline) {
        let t = this.raw(e, 'left', 'commentLeft'),
         r = this.raw(e, 'right', 'commentRight');
        this.builder(`//${t}${e.text}${r}`, e);
       } else super.comment(e);
      }
     };
    }),
    q = l((e, t) => {
     var r = S(),
      n = j(),
      s = R();
     t.exports = {
      parse(e, t) {
       let s = new r(e, t),
        i = new n(s);
       return (
        i.parse(),
        i.root.walk((e) => {
         let t = s.css.lastIndexOf(e.source.input.css);
         if (0 === t) return;
         if (t + e.source.input.css.length !== s.css.length) throw new Error('Invalid state detected in postcss-less');
         let r = t + e.source.start.offset,
          n = s.fromOffset(t + e.source.start.offset);
         if (((e.source.start = { offset: r, line: n.line, column: n.col }), e.source.end)) {
          let r = t + e.source.end.offset,
           n = s.fromOffset(t + e.source.end.offset);
          e.source.end = { offset: r, line: n.line, column: n.col };
         }
        }),
        i.root
       );
      },
      stringify(e, t) {
       new s(t).stringify(e);
      },
      nodeToString(e) {
       let r = '';
       return (
        t.exports.stringify(e, (e) => {
         r += e;
        }),
        r
       );
      },
     };
    }),
    U = l((e, t) => {
     var r,
      n,
      s = v(),
      i = class extends s {
       constructor(e) {
        super({ type: 'document', ...e }), this.nodes || (this.nodes = []);
       }
       toResult(e = {}) {
        return new r(new n(), this, e).stringify();
       }
      };
     (i.registerLazyResult = (e) => {
      r = e;
     }),
      (i.registerProcessor = (e) => {
       n = e;
      }),
      (t.exports = i),
      (i.default = i);
    }),
    $ = l((e, t) => {
     var r = w(),
      n = x(),
      s = b(),
      i = S(),
      a = T(),
      o = A(),
      u = k();
     function l(e, t) {
      if (Array.isArray(e)) return e.map((e) => l(e));
      let { inputs: p, ...c } = e;
      if (p) {
       t = [];
       for (let e of p) {
        let r = { ...e, __proto__: i.prototype };
        r.map && (r.map = { ...r.map, __proto__: a.prototype }), t.push(r);
       }
      }
      if ((c.nodes && (c.nodes = e.nodes.map((e) => l(e, t))), c.source)) {
       let { inputId: e, ...r } = c.source;
       (c.source = r), null != e && (c.source.input = t[e]);
      }
      if ('root' === c.type) return new o(c);
      if ('decl' === c.type) return new s(c);
      if ('rule' === c.type) return new u(c);
      if ('comment' === c.type) return new n(c);
      if ('atrule' === c.type) return new r(c);
      throw new Error('Unknown node type: ' + e.type);
     }
     (t.exports = l), (l.default = l);
    }),
    H = l((e, t) => {
     t.exports = class {
      generate() {}
     };
    }),
    z = l((e, t) => {
     var r = class {
      constructor(e, t = {}) {
       if (((this.type = 'warning'), (this.text = e), t.node && t.node.source)) {
        let e = t.node.rangeBy(t);
        (this.line = e.start.line), (this.column = e.start.column), (this.endLine = e.end.line), (this.endColumn = e.end.column);
       }
       for (let r in t) this[r] = t[r];
      }
      toString() {
       return this.node ? this.node.error(this.text, { index: this.index, plugin: this.plugin, word: this.word }).message : this.plugin ? this.plugin + ': ' + this.text : this.text;
      }
     };
     (t.exports = r), (r.default = r);
    }),
    V = l((e, t) => {
     var r = z(),
      n = class {
       constructor(e, t, r) {
        (this.processor = e), (this.messages = []), (this.root = t), (this.opts = r), (this.css = void 0), (this.map = void 0);
       }
       toString() {
        return this.css;
       }
       warn(e, t = {}) {
        t.plugin || (this.lastPlugin && this.lastPlugin.postcssPlugin && (t.plugin = this.lastPlugin.postcssPlugin));
        let n = new r(e, t);
        return this.messages.push(n), n;
       }
       warnings() {
        return this.messages.filter((e) => 'warning' === e.type);
       }
       get content() {
        return this.css;
       }
      };
     (t.exports = n), (n.default = n);
    }),
    W = l((e, t) => {
     var r = {};
     t.exports = function (e) {
      r[e] || ((r[e] = !0), typeof console < 'u' && console.warn && console.warn(e));
     };
    }),
    J = l((e, t) => {
     var r = v(),
      n = U(),
      s = H(),
      i = N(),
      a = V(),
      o = A(),
      u = y(),
      { isClean: l, my: p } = g(),
      c = (W(), { atrule: 'AtRule', comment: 'Comment', decl: 'Declaration', document: 'Document', root: 'Root', rule: 'Rule' }),
      h = { AtRule: !0, AtRuleExit: !0, Comment: !0, CommentExit: !0, Declaration: !0, DeclarationExit: !0, Document: !0, DocumentExit: !0, Once: !0, OnceExit: !0, postcssPlugin: !0, prepare: !0, Root: !0, RootExit: !0, Rule: !0, RuleExit: !0 },
      d = { Once: !0, postcssPlugin: !0, prepare: !0 },
      f = 0;
     function m(e) {
      return 'object' == typeof e && 'function' == typeof e.then;
     }
     function D(e) {
      let t = !1,
       r = c[e.type];
      return 'decl' === e.type ? (t = e.prop.toLowerCase()) : 'atrule' === e.type && (t = e.name.toLowerCase()), t && e.append ? [r, r + '-' + t, f, r + 'Exit', r + 'Exit-' + t] : t ? [r, r + '-' + t, r + 'Exit', r + 'Exit-' + t] : e.append ? [r, f, r + 'Exit'] : [r, r + 'Exit'];
     }
     function x(e) {
      let t;
      return (t = 'document' === e.type ? ['Document', f, 'DocumentExit'] : 'root' === e.type ? ['Root', f, 'RootExit'] : D(e)), { eventIndex: 0, events: t, iterator: 0, node: e, visitorIndex: 0, visitors: [] };
     }
     function b(e) {
      return (e[l] = !1), e.nodes && e.nodes.forEach((e) => b(e)), e;
     }
     var E = {},
      C = class e {
       constructor(t, n, s) {
        let o;
        if (((this.stringified = !1), (this.processed = !1), 'object' != typeof n || null === n || ('root' !== n.type && 'document' !== n.type)))
         if (n instanceof e || n instanceof a) (o = b(n.root)), n.map && (typeof s.map > 'u' && (s.map = {}), s.map.inline || (s.map.inline = !1), (s.map.prev = n.map));
         else {
          let e = i;
          s.syntax && (e = s.syntax.parse), s.parser && (e = s.parser), e.parse && (e = e.parse);
          try {
           o = e(n, s);
          } catch (u) {
           (this.processed = !0), (this.error = u);
          }
          o && !o[p] && r.rebuild(o);
         }
        else o = b(n);
        (this.result = new a(t, o, s)), (this.helpers = { ...E, postcss: E, result: this.result }), (this.plugins = this.processor.plugins.map((e) => ('object' == typeof e && e.prepare ? { ...e, ...e.prepare(this.result) } : e)));
       }
       async() {
        return this.error ? Promise.reject(this.error) : this.processed ? Promise.resolve(this.result) : (this.processing || (this.processing = this.runAsync()), this.processing);
       }
       catch(e) {
        return this.async().catch(e);
       }
       finally(e) {
        return this.async().then(e, e);
       }
       getAsyncError() {
        throw new Error('Use process(css).then(cb) to work with async plugins');
       }
       handleError(e, t) {
        let r = this.result.lastPlugin;
        try {
         t && t.addToError(e), (this.error = e), 'CssSyntaxError' !== e.name || e.plugin ? r.postcssVersion : ((e.plugin = r.postcssPlugin), e.setMessage());
        } catch (n) {
         console && console.error && console.error(n);
        }
        return e;
       }
       prepareVisitors() {
        this.listeners = {};
        let e = (e, t, r) => {
         this.listeners[t] || (this.listeners[t] = []), this.listeners[t].push([e, r]);
        };
        for (let t of this.plugins)
         if ('object' == typeof t)
          for (let r in t) {
           if (!h[r] && /^[A-Z]/.test(r)) throw new Error(`Unknown event ${r} in ${t.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`);
           if (!d[r])
            if ('object' == typeof t[r]) for (let n in t[r]) e(t, '*' === n ? r : r + '-' + n.toLowerCase(), t[r][n]);
            else 'function' == typeof t[r] && e(t, r, t[r]);
          }
        this.hasListener = Object.keys(this.listeners).length > 0;
       }
       async runAsync() {
        this.plugin = 0;
        for (let t = 0; t < this.plugins.length; t++) {
         let r = this.plugins[t],
          n = this.runOnRoot(r);
         if (m(n))
          try {
           await n;
          } catch (e) {
           throw this.handleError(e);
          }
        }
        if ((this.prepareVisitors(), this.hasListener)) {
         let t = this.result.root;
         for (; !t[l]; ) {
          t[l] = !0;
          let r = [x(t)];
          for (; r.length > 0; ) {
           let t = this.visitTick(r);
           if (m(t))
            try {
             await t;
            } catch (e) {
             let t = r[r.length - 1].node;
             throw this.handleError(e, t);
            }
          }
         }
         if (this.listeners.OnceExit)
          for (let [r, n] of this.listeners.OnceExit) {
           this.result.lastPlugin = r;
           try {
            if ('document' === t.type) {
             let e = t.nodes.map((e) => n(e, this.helpers));
             await Promise.all(e);
            } else await n(t, this.helpers);
           } catch (e) {
            throw this.handleError(e);
           }
          }
        }
        return (this.processed = !0), this.stringify();
       }
       runOnRoot(e) {
        this.result.lastPlugin = e;
        try {
         if ('object' == typeof e && e.Once) {
          if ('document' === this.result.root.type) {
           let t = this.result.root.nodes.map((t) => e.Once(t, this.helpers));
           return m(t[0]) ? Promise.all(t) : t;
          }
          return e.Once(this.result.root, this.helpers);
         }
         if ('function' == typeof e) return e(this.result.root, this.result);
        } catch (t) {
         throw this.handleError(t);
        }
       }
       stringify() {
        if (this.error) throw this.error;
        if (this.stringified) return this.result;
        (this.stringified = !0), this.sync();
        let e = this.result.opts,
         t = u;
        e.syntax && (t = e.syntax.stringify), e.stringifier && (t = e.stringifier), t.stringify && (t = t.stringify);
        let r = new s(t, this.result.root, this.result.opts).generate();
        return (this.result.css = r[0]), (this.result.map = r[1]), this.result;
       }
       sync() {
        if (this.error) throw this.error;
        if (this.processed) return this.result;
        if (((this.processed = !0), this.processing)) throw this.getAsyncError();
        for (let e of this.plugins) {
         if (m(this.runOnRoot(e))) throw this.getAsyncError();
        }
        if ((this.prepareVisitors(), this.hasListener)) {
         let e = this.result.root;
         for (; !e[l]; ) (e[l] = !0), this.walkSync(e);
         if (this.listeners.OnceExit)
          if ('document' === e.type) for (let t of e.nodes) this.visitSync(this.listeners.OnceExit, t);
          else this.visitSync(this.listeners.OnceExit, e);
        }
        return this.result;
       }
       then(e, t) {
        return this.async().then(e, t);
       }
       toString() {
        return this.css;
       }
       visitSync(e, t) {
        for (let [n, s] of e) {
         let e;
         this.result.lastPlugin = n;
         try {
          e = s(t, this.helpers);
         } catch (r) {
          throw this.handleError(r, t.proxyOf);
         }
         if ('root' !== t.type && 'document' !== t.type && !t.parent) return !0;
         if (m(e)) throw this.getAsyncError();
        }
       }
       visitTick(e) {
        let t = e[e.length - 1],
         { node: r, visitors: n } = t;
        if ('root' !== r.type && 'document' !== r.type && !r.parent) return void e.pop();
        if (n.length > 0 && t.visitorIndex < n.length) {
         let [e, s] = n[t.visitorIndex];
         (t.visitorIndex += 1), t.visitorIndex === n.length && ((t.visitors = []), (t.visitorIndex = 0)), (this.result.lastPlugin = e);
         try {
          return s(r.toProxy(), this.helpers);
         } catch (i) {
          throw this.handleError(i, r);
         }
        }
        if (0 !== t.iterator) {
         let n,
          s = t.iterator;
         for (; (n = r.nodes[r.indexes[s]]); ) if (((r.indexes[s] += 1), !n[l])) return (n[l] = !0), void e.push(x(n));
         (t.iterator = 0), delete r.indexes[s];
        }
        let s = t.events;
        for (; t.eventIndex < s.length; ) {
         let e = s[t.eventIndex];
         if (((t.eventIndex += 1), e === f)) return void (r.nodes && r.nodes.length && ((r[l] = !0), (t.iterator = r.getIterator())));
         if (this.listeners[e]) return void (t.visitors = this.listeners[e]);
        }
        e.pop();
       }
       walkSync(e) {
        e[l] = !0;
        let t = D(e);
        for (let r of t)
         if (r === f)
          e.nodes &&
           e.each((e) => {
            e[l] || this.walkSync(e);
           });
         else {
          let t = this.listeners[r];
          if (t && this.visitSync(t, e.toProxy())) return;
         }
       }
       warnings() {
        return this.sync().warnings();
       }
       get content() {
        return this.stringify().content;
       }
       get css() {
        return this.stringify().css;
       }
       get map() {
        return this.stringify().map;
       }
       get messages() {
        return this.sync().messages;
       }
       get opts() {
        return this.result.opts;
       }
       get processor() {
        return this.result.processor;
       }
       get root() {
        return this.sync().root;
       }
       get [Symbol.toStringTag]() {
        return 'LazyResult';
       }
      };
     (C.registerPostcss = (e) => {
      E = e;
     }),
      (t.exports = C),
      (C.default = C),
      o.registerLazyResult(C),
      n.registerLazyResult(C);
    }),
    K = l((e, t) => {
     var r = H(),
      n = N(),
      s = V(),
      i = y(),
      a =
       (W(),
       class {
        constructor(e, t, n) {
         (t = t.toString()), (this.stringified = !1), (this._processor = e), (this._css = t), (this._opts = n), (this._map = void 0);
         let a,
          o = i;
         (this.result = new s(this._processor, a, this._opts)), (this.result.css = t);
         let u = this;
         Object.defineProperty(this.result, 'root', { get: () => u.root });
         let l = new r(o, a, this._opts, t);
         if (l.isMap()) {
          let [e, t] = l.generate();
          e && (this.result.css = e), t && (this.result.map = t);
         } else l.clearAnnotation(), (this.result.css = l.css);
        }
        async() {
         return this.error ? Promise.reject(this.error) : Promise.resolve(this.result);
        }
        catch(e) {
         return this.async().catch(e);
        }
        finally(e) {
         return this.async().then(e, e);
        }
        sync() {
         if (this.error) throw this.error;
         return this.result;
        }
        then(e, t) {
         return this.async().then(e, t);
        }
        toString() {
         return this._css;
        }
        warnings() {
         return [];
        }
        get content() {
         return this.result.css;
        }
        get css() {
         return this.result.css;
        }
        get map() {
         return this.result.map;
        }
        get messages() {
         return [];
        }
        get opts() {
         return this.result.opts;
        }
        get processor() {
         return this.result.processor;
        }
        get root() {
         if (this._root) return this._root;
         let e,
          t = n;
         try {
          e = t(this._css, this._opts);
         } catch (r) {
          this.error = r;
         }
         if (this.error) throw this.error;
         return (this._root = e), e;
        }
        get [Symbol.toStringTag]() {
         return 'NoWorkResult';
        }
       });
     (t.exports = a), (a.default = a);
    }),
    G = l((e, t) => {
     var r = U(),
      n = J(),
      s = K(),
      i = A(),
      a = class {
       constructor(e = []) {
        (this.version = '8.5.1'), (this.plugins = this.normalize(e));
       }
       normalize(e) {
        let t = [];
        for (let r of e)
         if ((!0 === r.postcss ? (r = r()) : r.postcss && (r = r.postcss), 'object' == typeof r && Array.isArray(r.plugins))) t = t.concat(r.plugins);
         else if ('object' == typeof r && r.postcssPlugin) t.push(r);
         else if ('function' == typeof r) t.push(r);
         else if ('object' != typeof r || (!r.parse && !r.stringify)) throw new Error(r + ' is not a PostCSS plugin');
        return t;
       }
       process(e, t = {}) {
        return this.plugins.length || t.parser || t.stringifier || t.syntax ? new n(this, e, t) : new s(this, e, t);
       }
       use(e) {
        return (this.plugins = this.plugins.concat(this.normalize([e]))), this;
       }
      };
     (t.exports = a), (a.default = a), i.registerProcessor(a), r.registerProcessor(a);
    }),
    X = l((e, t) => {
     var r = w(),
      n = x(),
      s = v(),
      i = f(),
      a = b(),
      o = U(),
      u = $(),
      l = S(),
      p = J(),
      c = F(),
      h = D(),
      d = N(),
      m = G(),
      g = V(),
      E = A(),
      C = k(),
      T = y(),
      P = z();
     function I(...e) {
      return 1 === e.length && Array.isArray(e[0]) && (e = e[0]), new m(e);
     }
     (I.plugin = function (e, t) {
      let r,
       n = !1;
      function s(...r) {
       console && console.warn && !n && ((n = !0), console.warn(e + ': postcss.plugin was deprecated. Migration guide:\nhttps://evilmartians.com/chronicles/postcss-8-plugin-migration'));
       let s = t(...r);
       return (s.postcssPlugin = e), (s.postcssVersion = new m().version), s;
      }
      return (
       Object.defineProperty(s, 'postcss', { get: () => (r || (r = s()), r) }),
       (s.process = function (e, t, r) {
        return I([s(r)]).process(e, t);
       }),
       s
      );
     }),
      (I.stringify = T),
      (I.parse = d),
      (I.fromJSON = u),
      (I.list = c),
      (I.comment = (e) => new n(e)),
      (I.atRule = (e) => new r(e)),
      (I.decl = (e) => new a(e)),
      (I.rule = (e) => new C(e)),
      (I.root = (e) => new E(e)),
      (I.document = (e) => new o(e)),
      (I.CssSyntaxError = i),
      (I.Declaration = a),
      (I.Container = s),
      (I.Processor = m),
      (I.Document = o),
      (I.Comment = n),
      (I.Warning = P),
      (I.AtRule = r),
      (I.Result = g),
      (I.Input = l),
      (I.Rule = C),
      (I.Root = E),
      (I.Node = h),
      p.registerPostcss(I),
      (t.exports = I),
      (I.default = I);
    }),
    Y = l((e, t) => {
     var { Container: r } = X();
     t.exports = class extends r {
      constructor(e) {
       super(e), (this.type = 'decl'), (this.isNested = !0), this.nodes || (this.nodes = []);
      }
     };
    }),
    Q = l((e, t) => {
     var r = /[\t\n\f\r "#'()/;[\\\]{}]/g,
      n = /[,\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g,
      s = /.[\r\n"'(/\\]/,
      i = /[\da-f]/i,
      a = /[\n\f\r]/g;
     t.exports = function (e, t = {}) {
      let o,
       u,
       l,
       p,
       c,
       h,
       d,
       f,
       m,
       y,
       g = e.css.valueOf(),
       D = t.ignoreErrors,
       x = g.length,
       b = 0,
       v = [],
       E = [];
      function C(t) {
       throw e.error('Unclosed ' + t, b);
      }
      function T() {
       let e = 1,
        t = !1,
        r = !1;
       for (; e > 0; ) (u += 1), g.length <= u && C('interpolation'), (o = g.charCodeAt(u)), (f = g.charCodeAt(u + 1)), t ? (r || o !== t ? (92 === o ? (r = !r) : r && (r = !1)) : ((t = !1), (r = !1))) : 39 === o || 34 === o ? (t = o) : 125 === o ? (e -= 1) : 35 === o && 123 === f && (e += 1);
      }
      return {
       back: function (e) {
        E.push(e);
       },
       endOfFile: function () {
        return 0 === E.length && b >= x;
       },
       nextToken: function (e) {
        if (E.length) return E.pop();
        if (b >= x) return;
        let t = !!e && e.ignoreUnclosed;
        switch (((o = g.charCodeAt(b)), o)) {
         case 10:
         case 32:
         case 9:
         case 13:
         case 12:
          u = b;
          do {
           (u += 1), (o = g.charCodeAt(u));
          } while (32 === o || 10 === o || 9 === o || 13 === o || 12 === o);
          (m = ['space', g.slice(b, u)]), (b = u - 1);
          break;
         case 91:
         case 93:
         case 123:
         case 125:
         case 58:
         case 59:
         case 41: {
          let e = String.fromCharCode(o);
          m = [e, e, b];
          break;
         }
         case 44:
          m = ['word', ',', b, b + 1];
          break;
         case 40:
          if (((d = v.length ? v.pop()[1] : ''), (f = g.charCodeAt(b + 1)), 'url' === d && 39 !== f && 34 !== f)) {
           for (y = 1, h = !1, u = b + 1; u <= g.length - 1; ) {
            if (((f = g.charCodeAt(u)), 92 === f)) h = !h;
            else if (40 === f) y += 1;
            else if (41 === f && ((y -= 1), 0 === y)) break;
            u += 1;
           }
           (p = g.slice(b, u + 1)), (m = ['brackets', p, b, u]), (b = u);
          } else (u = g.indexOf(')', b + 1)), (p = g.slice(b, u + 1)), -1 === u || s.test(p) ? (m = ['(', '(', b]) : ((m = ['brackets', p, b, u]), (b = u));
          break;
         case 39:
         case 34:
          for (l = o, u = b, h = !1; u < x && (u++, u === x && C('string'), (o = g.charCodeAt(u)), (f = g.charCodeAt(u + 1)), h || o !== l); ) 92 === o ? (h = !h) : h ? (h = !1) : 35 === o && 123 === f && T();
          (m = ['string', g.slice(b, u + 1), b, u]), (b = u);
          break;
         case 64:
          (r.lastIndex = b + 1), r.test(g), (u = 0 === r.lastIndex ? g.length - 1 : r.lastIndex - 2), (m = ['at-word', g.slice(b, u + 1), b, u]), (b = u);
          break;
         case 92:
          for (u = b, c = !0; 92 === g.charCodeAt(u + 1); ) (u += 1), (c = !c);
          if (((o = g.charCodeAt(u + 1)), c && 47 !== o && 32 !== o && 10 !== o && 9 !== o && 13 !== o && 12 !== o && ((u += 1), i.test(g.charAt(u))))) {
           for (; i.test(g.charAt(u + 1)); ) u += 1;
           32 === g.charCodeAt(u + 1) && (u += 1);
          }
          (m = ['word', g.slice(b, u + 1), b, u]), (b = u);
          break;
         default:
          (f = g.charCodeAt(b + 1)), 35 === o && 123 === f ? ((u = b), T(), (p = g.slice(b, u + 1)), (m = ['word', p, b, u]), (b = u)) : 47 === o && 42 === f ? ((u = g.indexOf('*/', b + 2) + 1), 0 === u && (D || t ? (u = g.length) : C('comment')), (m = ['comment', g.slice(b, u + 1), b, u]), (b = u)) : 47 === o && 47 === f ? ((a.lastIndex = b + 1), a.test(g), (u = 0 === a.lastIndex ? g.length - 1 : a.lastIndex - 2), (p = g.slice(b, u + 1)), (m = ['comment', p, b, u, 'inline']), (b = u)) : ((n.lastIndex = b + 1), n.test(g), (u = 0 === n.lastIndex ? g.length - 1 : n.lastIndex - 2), (m = ['word', g.slice(b, u + 1), b, u]), v.push(m), (b = u));
        }
        return b++, m;
       },
       position: function () {
        return b;
       },
      };
     };
    }),
    Z = l((e, t) => {
     var { Comment: r } = X(),
      n = I(),
      s = Y(),
      i = Q();
     t.exports = class extends n {
      atrule(e) {
       let t = e[1],
        r = e;
       for (; !this.tokenizer.endOfFile(); ) {
        let e = this.tokenizer.nextToken();
        if ('word' !== e[0] || e[2] !== r[3] + 1) {
         this.tokenizer.back(e);
         break;
        }
        (t += e[1]), (r = e);
       }
       super.atrule(['at-word', t, e[2], r[3]]);
      }
      comment(e) {
       if ('inline' === e[4]) {
        let t = new r();
        this.init(t, e[2]), (t.raws.inline = !0);
        let n = this.input.fromOffset(e[3]);
        t.source.end = { column: n.col, line: n.line, offset: e[3] + 1 };
        let s = e[1].slice(2);
        if (/^\s*$/.test(s)) (t.text = ''), (t.raws.left = s), (t.raws.right = '');
        else {
         let e = s.match(/^(\s*)([^]*\S)(\s*)$/),
          r = e[2].replace(/(\*\/|\/\*)/g, '*//*');
         (t.text = r), (t.raws.left = e[1]), (t.raws.right = e[3]), (t.raws.text = e[2]);
        }
       } else super.comment(e);
      }
      createTokenizer() {
       this.tokenizer = i(this.input);
      }
      raw(e, t, r, n) {
       if ((super.raw(e, t, r, n), e.raws[t])) {
        let n = e.raws[t].raw;
        (e.raws[t].raw = r.reduce((e, t) => {
         if ('comment' === t[0] && 'inline' === t[4]) {
          return e + '/*' + t[1].slice(2).replace(/(\*\/|\/\*)/g, '*//*') + '*/';
         }
         return e + t[1];
        }, '')),
         n !== e.raws[t].raw && (e.raws[t].scss = n);
       }
      }
      rule(e) {
       let t = !1,
        r = 0,
        n = '';
       for (let s of e)
        if (t) 'comment' !== s[0] && '{' !== s[0] && (n += s[1]);
        else {
         if ('space' === s[0] && s[1].includes('\n')) break;
         '(' === s[0] ? (r += 1) : ')' === s[0] ? (r -= 1) : 0 === r && ':' === s[0] && (t = !0);
        }
       if (!t || '' === n.trim() || /^[#:A-Za-z-]/.test(n)) super.rule(e);
       else {
        e.pop();
        let t,
         r,
         n = new s();
        this.init(n, e[0][2]);
        for (let s = e.length - 1; s >= 0; s--)
         if ('space' !== e[s][0]) {
          t = e[s];
          break;
         }
        if (t[3]) {
         let e = this.input.fromOffset(t[3]);
         n.source.end = { column: e.col, line: e.line, offset: t[3] + 1 };
        } else {
         let e = this.input.fromOffset(t[2]);
         n.source.end = { column: e.col, line: e.line, offset: t[2] + 1 };
        }
        for (; 'word' !== e[0][0]; ) n.raws.before += e.shift()[1];
        if (e[0][2]) {
         let t = this.input.fromOffset(e[0][2]);
         n.source.start = { column: t.col, line: t.line, offset: e[0][2] };
        }
        for (n.prop = ''; e.length; ) {
         let t = e[0][0];
         if (':' === t || 'space' === t || 'comment' === t) break;
         n.prop += e.shift()[1];
        }
        for (n.raws.between = ''; e.length; ) {
         if (((r = e.shift()), ':' === r[0])) {
          n.raws.between += r[1];
          break;
         }
         n.raws.between += r[1];
        }
        ('_' === n.prop[0] || '*' === n.prop[0]) && ((n.raws.before += n.prop[0]), (n.prop = n.prop.slice(1))), (n.raws.between += this.spacesAndCommentsFromStart(e)), this.precheckMissedSemicolon(e);
        for (let s = e.length - 1; s > 0; s--) {
         if (((r = e[s]), '!important' === r[1])) {
          n.important = !0;
          let t = this.stringFrom(e, s);
          (t = this.spacesFromEnd(e) + t), ' !important' !== t && (n.raws.important = t);
          break;
         }
         if ('important' === r[1]) {
          let t = e.slice(0),
           r = '';
          for (let e = s; e > 0; e--) {
           let n = t[e][0];
           if (0 === r.trim().indexOf('!') && 'space' !== n) break;
           r = t.pop()[1] + r;
          }
          0 === r.trim().indexOf('!') && ((n.important = !0), (n.raws.important = r), (e = t));
         }
         if ('space' !== r[0] && 'comment' !== r[0]) break;
        }
        this.raw(n, 'value', e), n.value.includes(':') && this.checkMissedSemicolon(e), (this.current = n);
       }
      }
     };
    }),
    ee = l((e, t) => {
     var { Input: r } = X(),
      n = Z();
     t.exports = function (e, t) {
      let s = new r(e, t),
       i = new n(s);
      return i.parse(), i.root;
     };
    }),
    te = l((e) => {
     Object.defineProperty(e, '__esModule', { value: !0 }),
      (e.default = function (e) {
       (this.after = e.after), (this.before = e.before), (this.type = e.type), (this.value = e.value), (this.sourceIndex = e.sourceIndex);
      });
    }),
    re = l((e) => {
     Object.defineProperty(e, '__esModule', { value: !0 });
     var t,
      r = te(),
      n = (t = r) && t.__esModule ? t : { default: t };
     function s(e) {
      var t = this;
      this.constructor(e),
       (this.nodes = e.nodes),
       void 0 === this.after && (this.after = this.nodes.length > 0 ? this.nodes[this.nodes.length - 1].after : ''),
       void 0 === this.before && (this.before = this.nodes.length > 0 ? this.nodes[0].before : ''),
       void 0 === this.sourceIndex && (this.sourceIndex = this.before.length),
       this.nodes.forEach(function (e) {
        e.parent = t;
       });
     }
     (s.prototype = Object.create(n.default.prototype)),
      (s.constructor = n.default),
      (s.prototype.walk = function (e, t) {
       for (var r = 'string' == typeof e || e instanceof RegExp, n = r ? t : e, s = 'string' == typeof e ? new RegExp(e) : e, i = 0; i < this.nodes.length; i++) {
        var a = this.nodes[i];
        if (((!r || s.test(a.type)) && n && !1 === n(a, i, this.nodes)) || (a.nodes && !1 === a.walk(e, t))) return !1;
       }
       return !0;
      }),
      (s.prototype.each = function () {
       for (var e = arguments.length <= 0 || void 0 === arguments[0] ? function () {} : arguments[0], t = 0; t < this.nodes.length; t++) {
        if (!1 === e(this.nodes[t], t, this.nodes)) return !1;
       }
       return !0;
      }),
      (e.default = s);
    }),
    ne = l((e) => {
     Object.defineProperty(e, '__esModule', { value: !0 }),
      (e.parseMediaFeature = s),
      (e.parseMediaQuery = i),
      (e.parseMediaList = function (e) {
       var n = [],
        s = 0,
        a = 0,
        o = /^(\s*)url\s*\(/.exec(e);
       if (null !== o) {
        for (var u = o[0].length, l = 1; l > 0; ) {
         var p = e[u];
         '(' === p && l++, ')' === p && l--, u++;
        }
        n.unshift(new t.default({ type: 'url', value: e.substring(0, u).trim(), sourceIndex: o[1].length, before: o[1], after: /^(\s*)/.exec(e.substring(u))[1] })), (s = u);
       }
       for (var c = s; c < e.length; c++) {
        var h = e[c];
        if (('(' === h && a++, ')' === h && a--, 0 === a && ',' === h)) {
         var d = e.substring(s, c),
          f = /^(\s*)/.exec(d)[1];
         n.push(new r.default({ type: 'media-query', value: d.trim(), sourceIndex: s + f.length, nodes: i(d, s), before: f, after: /(\s*)$/.exec(d)[1] })), (s = c + 1);
        }
       }
       var m = e.substring(s),
        y = /^(\s*)/.exec(m)[1];
       return n.push(new r.default({ type: 'media-query', value: m.trim(), sourceIndex: s + y.length, nodes: i(m, s), before: y, after: /(\s*)$/.exec(m)[1] })), n;
      });
     var t = n(te()),
      r = n(re());
     function n(e) {
      return e && e.__esModule ? e : { default: e };
     }
     function s(e) {
      var t = [{ mode: 'normal', character: null }],
       r = [],
       n = 0,
       s = '',
       i = null,
       a = null,
       o = arguments.length <= 1 || void 0 === arguments[1] ? 0 : arguments[1],
       u = e;
      '(' === e[0] && ')' === e[e.length - 1] && ((u = e.substring(1, e.length - 1)), o++);
      for (var l = 0; l < u.length; l++) {
       var p = u[l];
       if ((("'" === p || '"' === p) && (!0 === t[n].isCalculationEnabled ? (t.push({ mode: 'string', isCalculationEnabled: !1, character: p }), n++) : 'string' === t[n].mode && t[n].character === p && '\\' !== u[l - 1] && (t.pop(), n--)), '{' === p ? (t.push({ mode: 'interpolation', isCalculationEnabled: !0 }), n++) : '}' === p && (t.pop(), n--), 'normal' === t[n].mode && ':' === p)) {
        var c = u.substring(l + 1);
        ((a = { type: 'value', before: /^(\s*)/.exec(c)[1], after: /(\s*)$/.exec(c)[1], value: c.trim() }).sourceIndex = a.before.length + l + 1 + o), (i = { type: 'colon', sourceIndex: l + o, after: a.before, value: ':' });
        break;
       }
       s += p;
      }
      return ((s = { type: 'media-feature', before: /^(\s*)/.exec(s)[1], after: /(\s*)$/.exec(s)[1], value: s.trim() }).sourceIndex = s.before.length + o), r.push(s), null !== i && ((i.before = s.after), r.push(i)), null !== a && r.push(a), r;
     }
     function i(e) {
      var n = arguments.length <= 1 || void 0 === arguments[1] ? 0 : arguments[1],
       i = [],
       a = 0,
       o = !1,
       u = void 0;
      u = { before: '', after: '', value: '' };
      for (var l = 0; l < e.length; l++) {
       var p = e[l];
       o ? ((u.value += p), ('{' === p || '(' === p) && a++, (')' === p || '}' === p) && a--) : -1 !== p.search(/\s/) ? (u.before += p) : ('(' === p && ((u.type = 'media-feature-expression'), a++), (u.value = p), (u.sourceIndex = n + l), (o = !0)), o && 0 === a && (')' === p || l === e.length - 1 || -1 !== e[l + 1].search(/\s/)) && (-1 !== ['not', 'only', 'and'].indexOf(u.value) && (u.type = 'keyword'), 'media-feature-expression' === u.type && (u.nodes = s(u.value, u.sourceIndex)), i.push(Array.isArray(u.nodes) ? new r.default(u) : new t.default(u)), (u = { before: '', after: '', value: '' }), (o = !1));
      }
      for (var c = 0; c < i.length; c++)
       if (((u = i[c]), c > 0 && (i[c - 1].after = u.before), void 0 === u.type)) {
        if (c > 0) {
         if ('media-feature-expression' === i[c - 1].type) {
          u.type = 'keyword';
          continue;
         }
         if ('not' === i[c - 1].value || 'only' === i[c - 1].value) {
          u.type = 'media-type';
          continue;
         }
         if ('and' === i[c - 1].value) {
          u.type = 'media-feature-expression';
          continue;
         }
         'media-type' === i[c - 1].type && (i[c + 1] ? (u.type = 'media-feature-expression' === i[c + 1].type ? 'keyword' : 'media-feature-expression') : (u.type = 'media-feature-expression'));
        }
        if (0 === c) {
         if (!i[c + 1]) {
          u.type = 'media-type';
          continue;
         }
         if (i[c + 1] && ('media-feature-expression' === i[c + 1].type || 'keyword' === i[c + 1].type)) {
          u.type = 'media-type';
          continue;
         }
         if (i[c + 2]) {
          if ('media-feature-expression' === i[c + 2].type) {
           (u.type = 'media-type'), (i[c + 1].type = 'keyword');
           continue;
          }
          if ('keyword' === i[c + 2].type) {
           (u.type = 'keyword'), (i[c + 1].type = 'media-type');
           continue;
          }
         }
         if (i[c + 3] && 'media-feature-expression' === i[c + 3].type) {
          (u.type = 'keyword'), (i[c + 1].type = 'media-type'), (i[c + 2].type = 'keyword');
          continue;
         }
        }
       }
      return i;
     }
    }),
    se = l((e) => {
     Object.defineProperty(e, '__esModule', { value: !0 }),
      (e.default = function (e) {
       return new n.default({ nodes: (0, s.parseMediaList)(e), type: 'media-query-list', value: e.trim() });
      });
     var t,
      r = re(),
      n = (t = r) && t.__esModule ? t : { default: t },
      s = ne();
    }),
    ie = l((e, t) => {
     t.exports = function (e, t) {
      return (t = 'number' == typeof t ? t : 1 / 0)
       ? (function e(r, n) {
          return r.reduce(function (r, s) {
           return Array.isArray(s) && n < t ? r.concat(e(s, n + 1)) : r.concat(s);
          }, []);
         })(e, 1)
       : Array.isArray(e)
         ? e.map(function (e) {
            return e;
           })
         : e;
     };
    }),
    ae = l((e, t) => {
     t.exports = function (e, t) {
      for (var r = -1, n = []; -1 !== (r = e.indexOf(t, r + 1)); ) n.push(r);
      return n;
     };
    }),
    oe = l((e, t) => {
     t.exports = function (e, t, r) {
      return 0 === e.length
       ? e
       : t
         ? (r || e.sort(t),
           (function (e, t) {
            for (var r = 1, n = e.length, s = e[0], i = e[0], a = 1; a < n; ++a)
             if (((i = s), t((s = e[a]), i))) {
              if (a === r) {
               r++;
               continue;
              }
              e[r++] = s;
             }
            return (e.length = r), e;
           })(e, t))
         : (r || e.sort(),
           (function (e) {
            for (var t = 1, r = e.length, n = e[0], s = e[0], i = 1; i < r; ++i, s = n)
             if (((s = n), (n = e[i]) !== s)) {
              if (i === t) {
               t++;
               continue;
              }
              e[t++] = n;
             }
            return (e.length = t), e;
           })(e));
     };
    }),
    ue = l((e, t) => {
     e.__esModule = !0;
     var r =
      'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
       ? function (e) {
          return typeof e;
         }
       : function (e) {
          return e && 'function' == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e;
         };
     var n = function e(t, n) {
       if ('object' !== (typeof t > 'u' ? 'undefined' : r(t))) return t;
       var s = new t.constructor();
       for (var i in t)
        if (t.hasOwnProperty(i)) {
         var a = t[i],
          o = typeof a > 'u' ? 'undefined' : r(a);
         'parent' === i && 'object' === o
          ? n && (s[i] = n)
          : (s[i] =
             a instanceof Array
              ? a.map(function (t) {
                 return e(t, s);
                })
              : e(a, s));
        }
       return s;
      },
      s = (function () {
       function e() {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        for (var r in ((function (e, t) {
         if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
        })(this, e),
        t))
         this[r] = t[r];
        var n = t.spaces,
         s = (n = void 0 === n ? {} : n).before,
         i = void 0 === s ? '' : s,
         a = n.after,
         o = void 0 === a ? '' : a;
        this.spaces = { before: i, after: o };
       }
       return (
        (e.prototype.remove = function () {
         return this.parent && this.parent.removeChild(this), (this.parent = void 0), this;
        }),
        (e.prototype.replaceWith = function () {
         if (this.parent) {
          for (var e in arguments) this.parent.insertBefore(this, arguments[e]);
          this.remove();
         }
         return this;
        }),
        (e.prototype.next = function () {
         return this.parent.at(this.parent.index(this) + 1);
        }),
        (e.prototype.prev = function () {
         return this.parent.at(this.parent.index(this) - 1);
        }),
        (e.prototype.clone = function () {
         var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
          t = n(this);
         for (var r in e) t[r] = e[r];
         return t;
        }),
        (e.prototype.toString = function () {
         return [this.spaces.before, String(this.value), this.spaces.after].join('');
        }),
        e
       );
      })();
     (e.default = s), (t.exports = e.default);
    }),
    le = l((e) => {
     e.__esModule = !0;
     (e.TAG = 'tag'), (e.STRING = 'string'), (e.SELECTOR = 'selector'), (e.ROOT = 'root'), (e.PSEUDO = 'pseudo'), (e.NESTING = 'nesting'), (e.ID = 'id'), (e.COMMENT = 'comment'), (e.COMBINATOR = 'combinator'), (e.CLASS = 'class'), (e.ATTRIBUTE = 'attribute'), (e.UNIVERSAL = 'universal');
    }),
    pe = l((e, t) => {
     e.__esModule = !0;
     var r,
      n = (function () {
       function e(e, t) {
        for (var r = 0; r < t.length; r++) {
         var n = t[r];
         (n.enumerable = n.enumerable || !1), (n.configurable = !0), 'value' in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
        }
       }
       return function (t, r, n) {
        return r && e(t.prototype, r), n && e(t, n), t;
       };
      })(),
      s = ue(),
      i = (r = s) && r.__esModule ? r : { default: r },
      a = (function (e) {
       if (e && e.__esModule) return e;
       var t = {};
       if (null != e) for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
       return (t.default = e), t;
      })(le());
     var o = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, t);
       var n = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
       })(this, e.call(this, r));
       return n.nodes || (n.nodes = []), n;
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       (t.prototype.append = function (e) {
        return (e.parent = this), this.nodes.push(e), this;
       }),
       (t.prototype.prepend = function (e) {
        return (e.parent = this), this.nodes.unshift(e), this;
       }),
       (t.prototype.at = function (e) {
        return this.nodes[e];
       }),
       (t.prototype.index = function (e) {
        return 'number' == typeof e ? e : this.nodes.indexOf(e);
       }),
       (t.prototype.removeChild = function (e) {
        (e = this.index(e)), (this.at(e).parent = void 0), this.nodes.splice(e, 1);
        var t = void 0;
        for (var r in this.indexes) (t = this.indexes[r]) >= e && (this.indexes[r] = t - 1);
        return this;
       }),
       (t.prototype.removeAll = function () {
        var e = this.nodes,
         t = Array.isArray(e),
         r = 0;
        for (e = t ? e : e[Symbol.iterator](); ; ) {
         var n;
         if (t) {
          if (r >= e.length) break;
          n = e[r++];
         } else {
          if ((r = e.next()).done) break;
          n = r.value;
         }
         n.parent = void 0;
        }
        return (this.nodes = []), this;
       }),
       (t.prototype.empty = function () {
        return this.removeAll();
       }),
       (t.prototype.insertAfter = function (e, t) {
        var r = this.index(e);
        this.nodes.splice(r + 1, 0, t);
        var n = void 0;
        for (var s in this.indexes) r <= (n = this.indexes[s]) && (this.indexes[s] = n + this.nodes.length);
        return this;
       }),
       (t.prototype.insertBefore = function (e, t) {
        var r = this.index(e);
        this.nodes.splice(r, 0, t);
        var n = void 0;
        for (var s in this.indexes) r <= (n = this.indexes[s]) && (this.indexes[s] = n + this.nodes.length);
        return this;
       }),
       (t.prototype.each = function (e) {
        this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach++;
        var t = this.lastEach;
        if (((this.indexes[t] = 0), this.length)) {
         for (var r = void 0, n = void 0; this.indexes[t] < this.length && ((r = this.indexes[t]), !1 !== (n = e(this.at(r), r))); ) this.indexes[t] += 1;
         if ((delete this.indexes[t], !1 === n)) return !1;
        }
       }),
       (t.prototype.walk = function (e) {
        return this.each(function (t, r) {
         var n = e(t, r);
         if ((!1 !== n && t.length && (n = t.walk(e)), !1 === n)) return !1;
        });
       }),
       (t.prototype.walkAttributes = function (e) {
        var t = this;
        return this.walk(function (r) {
         if (r.type === a.ATTRIBUTE) return e.call(t, r);
        });
       }),
       (t.prototype.walkClasses = function (e) {
        var t = this;
        return this.walk(function (r) {
         if (r.type === a.CLASS) return e.call(t, r);
        });
       }),
       (t.prototype.walkCombinators = function (e) {
        var t = this;
        return this.walk(function (r) {
         if (r.type === a.COMBINATOR) return e.call(t, r);
        });
       }),
       (t.prototype.walkComments = function (e) {
        var t = this;
        return this.walk(function (r) {
         if (r.type === a.COMMENT) return e.call(t, r);
        });
       }),
       (t.prototype.walkIds = function (e) {
        var t = this;
        return this.walk(function (r) {
         if (r.type === a.ID) return e.call(t, r);
        });
       }),
       (t.prototype.walkNesting = function (e) {
        var t = this;
        return this.walk(function (r) {
         if (r.type === a.NESTING) return e.call(t, r);
        });
       }),
       (t.prototype.walkPseudos = function (e) {
        var t = this;
        return this.walk(function (r) {
         if (r.type === a.PSEUDO) return e.call(t, r);
        });
       }),
       (t.prototype.walkTags = function (e) {
        var t = this;
        return this.walk(function (r) {
         if (r.type === a.TAG) return e.call(t, r);
        });
       }),
       (t.prototype.walkUniversals = function (e) {
        var t = this;
        return this.walk(function (r) {
         if (r.type === a.UNIVERSAL) return e.call(t, r);
        });
       }),
       (t.prototype.split = function (e) {
        var t = this,
         r = [];
        return this.reduce(function (n, s, i) {
         var a = e.call(t, s);
         return r.push(s), a ? (n.push(r), (r = [])) : i === t.length - 1 && n.push(r), n;
        }, []);
       }),
       (t.prototype.map = function (e) {
        return this.nodes.map(e);
       }),
       (t.prototype.reduce = function (e, t) {
        return this.nodes.reduce(e, t);
       }),
       (t.prototype.every = function (e) {
        return this.nodes.every(e);
       }),
       (t.prototype.some = function (e) {
        return this.nodes.some(e);
       }),
       (t.prototype.filter = function (e) {
        return this.nodes.filter(e);
       }),
       (t.prototype.sort = function (e) {
        return this.nodes.sort(e);
       }),
       (t.prototype.toString = function () {
        return this.map(String).join('');
       }),
       n(t, [
        {
         key: 'first',
         get: function () {
          return this.at(0);
         },
        },
        {
         key: 'last',
         get: function () {
          return this.at(this.length - 1);
         },
        },
        {
         key: 'length',
         get: function () {
          return this.nodes.length;
         },
        },
       ]),
       t
      );
     })(i.default);
     (e.default = o), (t.exports = e.default);
    }),
    ce = l((e, t) => {
     e.__esModule = !0;
     var r,
      n = pe(),
      s = (r = n) && r.__esModule ? r : { default: r },
      i = le();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, t);
       var n = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
       })(this, e.call(this, r));
       return (n.type = i.ROOT), n;
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       (t.prototype.toString = function () {
        var e = this.reduce(function (e, t) {
         var r = String(t);
         return r ? e + r + ',' : '';
        }, '').slice(0, -1);
        return this.trailingComma ? e + ',' : e;
       }),
       t
      );
     })(s.default);
     (e.default = a), (t.exports = e.default);
    }),
    he = l((e, t) => {
     e.__esModule = !0;
     var r,
      n = pe(),
      s = (r = n) && r.__esModule ? r : { default: r },
      i = le();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, t);
       var n = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
       })(this, e.call(this, r));
       return (n.type = i.SELECTOR), n;
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       t
      );
     })(s.default);
     (e.default = a), (t.exports = e.default);
    }),
    de = l((e, t) => {
     e.__esModule = !0;
     var r,
      n = (function () {
       function e(e, t) {
        for (var r = 0; r < t.length; r++) {
         var n = t[r];
         (n.enumerable = n.enumerable || !1), (n.configurable = !0), 'value' in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
        }
       }
       return function (t, r, n) {
        return r && e(t.prototype, r), n && e(t, n), t;
       };
      })(),
      s = ue();
     var i = (function (e) {
      function t() {
       return (
        (function (e, t) {
         if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
        })(this, t),
        (function (e, t) {
         if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
         return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
        })(this, e.apply(this, arguments))
       );
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       (t.prototype.toString = function () {
        return [this.spaces.before, this.ns, String(this.value), this.spaces.after].join('');
       }),
       n(t, [
        {
         key: 'ns',
         get: function () {
          var e = this.namespace;
          return e ? ('string' == typeof e ? e : '') + '|' : '';
         },
        },
       ]),
       t
      );
     })(((r = s) && r.__esModule ? r : { default: r }).default);
     (e.default = i), (t.exports = e.default);
    }),
    fe = l((e, t) => {
     e.__esModule = !0;
     var r,
      n = de(),
      s = (r = n) && r.__esModule ? r : { default: r },
      i = le();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, t);
       var n = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
       })(this, e.call(this, r));
       return (n.type = i.CLASS), n;
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       (t.prototype.toString = function () {
        return [this.spaces.before, this.ns, '.' + this.value, this.spaces.after].join('');
       }),
       t
      );
     })(s.default);
     (e.default = a), (t.exports = e.default);
    }),
    me = l((e, t) => {
     e.__esModule = !0;
     var r,
      n = ue(),
      s = (r = n) && r.__esModule ? r : { default: r },
      i = le();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, t);
       var n = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
       })(this, e.call(this, r));
       return (n.type = i.COMMENT), n;
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       t
      );
     })(s.default);
     (e.default = a), (t.exports = e.default);
    }),
    ye = l((e, t) => {
     e.__esModule = !0;
     var r,
      n = de(),
      s = (r = n) && r.__esModule ? r : { default: r },
      i = le();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, t);
       var n = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
       })(this, e.call(this, r));
       return (n.type = i.ID), n;
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       (t.prototype.toString = function () {
        return [this.spaces.before, this.ns, '#' + this.value, this.spaces.after].join('');
       }),
       t
      );
     })(s.default);
     (e.default = a), (t.exports = e.default);
    }),
    ge = l((e, t) => {
     e.__esModule = !0;
     var r,
      n = de(),
      s = (r = n) && r.__esModule ? r : { default: r },
      i = le();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, t);
       var n = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
       })(this, e.call(this, r));
       return (n.type = i.TAG), n;
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       t
      );
     })(s.default);
     (e.default = a), (t.exports = e.default);
    }),
    De = l((e, t) => {
     e.__esModule = !0;
     var r,
      n = ue(),
      s = (r = n) && r.__esModule ? r : { default: r },
      i = le();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, t);
       var n = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
       })(this, e.call(this, r));
       return (n.type = i.STRING), n;
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       t
      );
     })(s.default);
     (e.default = a), (t.exports = e.default);
    }),
    xe = l((e, t) => {
     e.__esModule = !0;
     var r,
      n = pe(),
      s = (r = n) && r.__esModule ? r : { default: r },
      i = le();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, t);
       var n = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
       })(this, e.call(this, r));
       return (n.type = i.PSEUDO), n;
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       (t.prototype.toString = function () {
        var e = this.length ? '(' + this.map(String).join(',') + ')' : '';
        return [this.spaces.before, String(this.value), e, this.spaces.after].join('');
       }),
       t
      );
     })(s.default);
     (e.default = a), (t.exports = e.default);
    }),
    be = l((e, t) => {
     e.__esModule = !0;
     var r,
      n = de(),
      s = (r = n) && r.__esModule ? r : { default: r },
      i = le();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, t);
       var n = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
       })(this, e.call(this, r));
       return (n.type = i.ATTRIBUTE), (n.raws = {}), n;
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       (t.prototype.toString = function () {
        var e = [this.spaces.before, '[', this.ns, this.attribute];
        return this.operator && e.push(this.operator), this.value && e.push(this.value), this.raws.insensitive ? e.push(this.raws.insensitive) : this.insensitive && e.push(' i'), e.push(']'), e.concat(this.spaces.after).join('');
       }),
       t
      );
     })(s.default);
     (e.default = a), (t.exports = e.default);
    }),
    ve = l((e, t) => {
     e.__esModule = !0;
     var r,
      n = de(),
      s = (r = n) && r.__esModule ? r : { default: r },
      i = le();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, t);
       var n = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
       })(this, e.call(this, r));
       return (n.type = i.UNIVERSAL), (n.value = '*'), n;
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       t
      );
     })(s.default);
     (e.default = a), (t.exports = e.default);
    }),
    Ee = l((e, t) => {
     e.__esModule = !0;
     var r,
      n = ue(),
      s = (r = n) && r.__esModule ? r : { default: r },
      i = le();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, t);
       var n = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
       })(this, e.call(this, r));
       return (n.type = i.COMBINATOR), n;
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       t
      );
     })(s.default);
     (e.default = a), (t.exports = e.default);
    }),
    Ce = l((e, t) => {
     e.__esModule = !0;
     var r,
      n = ue(),
      s = (r = n) && r.__esModule ? r : { default: r },
      i = le();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, t);
       var n = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
       })(this, e.call(this, r));
       return (n.type = i.NESTING), (n.value = '&'), n;
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       t
      );
     })(s.default);
     (e.default = a), (t.exports = e.default);
    }),
    Te = l((e, t) => {
     (e.__esModule = !0),
      (e.default = function (e) {
       return e.sort(function (e, t) {
        return e - t;
       });
      }),
      (t.exports = e.default);
    }),
    Se = l((e, t) => {
     (e.__esModule = !0),
      (e.default = function (e) {
       for (
        var t = [],
         A = e.css.valueOf(),
         F = void 0,
         k = void 0,
         P = void 0,
         I = void 0,
         N = void 0,
         B = void 0,
         _ = void 0,
         L = void 0,
         O = void 0,
         M = void 0,
         j = void 0,
         R = A.length,
         q = -1,
         U = 1,
         $ = 0,
         H = function (t, r) {
          if (!e.safe) throw e.error('Unclosed ' + t, U, $ - q, $);
          k = (A += r).length - 1;
         };
        $ < R;

       ) {
        switch (((F = A.charCodeAt($)) === a && ((q = $), (U += 1)), F)) {
         case a:
         case o:
         case l:
         case p:
         case u:
          k = $;
          do {
           (k += 1), (F = A.charCodeAt(k)) === a && ((q = k), (U += 1));
          } while (F === o || F === a || F === l || F === p || F === u);
          t.push(['space', A.slice($, k), U, $ - q, $]), ($ = k - 1);
          break;
         case c:
         case h:
         case d:
         case f:
          k = $;
          do {
           (k += 1), (F = A.charCodeAt(k));
          } while (F === c || F === h || F === d || F === f);
          t.push(['combinator', A.slice($, k), U, $ - q, $]), ($ = k - 1);
          break;
         case v:
          t.push(['*', '*', U, $ - q, $]);
          break;
         case C:
          t.push(['&', '&', U, $ - q, $]);
          break;
         case m:
          t.push([',', ',', U, $ - q, $]);
          break;
         case D:
          t.push(['[', '[', U, $ - q, $]);
          break;
         case x:
          t.push([']', ']', U, $ - q, $]);
          break;
         case E:
          t.push([':', ':', U, $ - q, $]);
          break;
         case b:
          t.push([';', ';', U, $ - q, $]);
          break;
         case y:
          t.push(['(', '(', U, $ - q, $]);
          break;
         case g:
          t.push([')', ')', U, $ - q, $]);
          break;
         case r:
         case n:
          (P = F === r ? "'" : '"'), (k = $);
          do {
           for (M = !1, -1 === (k = A.indexOf(P, k + 1)) && H('quote', P), j = k; A.charCodeAt(j - 1) === s; ) (j -= 1), (M = !M);
          } while (M);
          t.push(['string', A.slice($, k + 1), U, $ - q, U, k - q, $]), ($ = k);
          break;
         case T:
          (S.lastIndex = $ + 1), S.test(A), (k = 0 === S.lastIndex ? A.length - 1 : S.lastIndex - 2), t.push(['at-word', A.slice($, k + 1), U, $ - q, U, k - q, $]), ($ = k);
          break;
         case s:
          for (k = $, _ = !0; A.charCodeAt(k + 1) === s; ) (k += 1), (_ = !_);
          (F = A.charCodeAt(k + 1)), _ && F !== i && F !== o && F !== a && F !== l && F !== p && F !== u && (k += 1), t.push(['word', A.slice($, k + 1), U, $ - q, U, k - q, $]), ($ = k);
          break;
         default:
          F === i && A.charCodeAt($ + 1) === v ? (0 === (k = A.indexOf('*/', $ + 2) + 1) && H('comment', '*/'), (N = (I = (B = A.slice($, k + 1)).split('\n')).length - 1) > 0 ? ((L = U + N), (O = k - I[N].length)) : ((L = U), (O = q)), t.push(['comment', B, U, $ - q, L, k - O, $]), (q = O), (U = L), ($ = k)) : ((w.lastIndex = $ + 1), w.test(A), (k = 0 === w.lastIndex ? A.length - 1 : w.lastIndex - 2), t.push(['word', A.slice($, k + 1), U, $ - q, U, k - q, $]), ($ = k));
        }
        $++;
       }
       return t;
      });
     var r = 39,
      n = 34,
      s = 92,
      i = 47,
      a = 10,
      o = 32,
      u = 12,
      l = 9,
      p = 13,
      c = 43,
      h = 62,
      d = 126,
      f = 124,
      m = 44,
      y = 40,
      g = 41,
      D = 91,
      x = 93,
      b = 59,
      v = 42,
      E = 58,
      C = 38,
      T = 64,
      S = /[ \n\t\r\{\(\)'"\\;/]/g,
      w = /[ \n\t\r\(\)\*:;@!&'"\+\|~>,\[\]\\]|\/(?=\*)/g;
     t.exports = e.default;
    }),
    we = l((e, t) => {
     e.__esModule = !0;
     var r = (function () {
       function e(e, t) {
        for (var r = 0; r < t.length; r++) {
         var n = t[r];
         (n.enumerable = n.enumerable || !1), (n.configurable = !0), 'value' in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
        }
       }
       return function (t, r, n) {
        return r && e(t.prototype, r), n && e(t, n), t;
       };
      })(),
      n = v(ie()),
      s = v(ae()),
      i = v(oe()),
      a = v(ce()),
      o = v(he()),
      u = v(fe()),
      l = v(me()),
      p = v(ye()),
      c = v(ge()),
      h = v(De()),
      d = v(xe()),
      f = v(be()),
      m = v(ve()),
      y = v(Ee()),
      g = v(Ce()),
      D = v(Te()),
      x = v(Se()),
      b = (function (e) {
       if (e && e.__esModule) return e;
       var t = {};
       if (null != e) for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
       return (t.default = e), t;
      })(le());
     function v(e) {
      return e && e.__esModule ? e : { default: e };
     }
     var E = (function () {
      function e(t) {
       (function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, e),
        (this.input = t),
        (this.lossy = !1 === t.options.lossless),
        (this.position = 0),
        (this.root = new a.default());
       var r = new o.default();
       return this.root.append(r), (this.current = r), this.lossy ? (this.tokens = (0, x.default)({ safe: t.safe, css: t.css.trim() })) : (this.tokens = (0, x.default)(t)), this.loop();
      }
      return (
       (e.prototype.attribute = function () {
        var e = '',
         t = void 0,
         r = this.currToken;
        for (this.position++; this.position < this.tokens.length && ']' !== this.currToken[0]; ) (e += this.tokens[this.position][1]), this.position++;
        this.position === this.tokens.length && !~e.indexOf(']') && this.error('Expected a closing square bracket.');
        var n = e.split(/((?:[*~^$|]?=))([^]*)/),
         s = n[0].split(/(\|)/g),
         i = { operator: n[1], value: n[2], source: { start: { line: r[2], column: r[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: r[4] };
        if ((s.length > 1 ? ('' === s[0] && (s[0] = !0), (i.attribute = this.parseValue(s[2])), (i.namespace = this.parseNamespace(s[0]))) : (i.attribute = this.parseValue(n[0])), (t = new f.default(i)), n[2])) {
         var a = n[2].split(/(\s+i\s*?)$/),
          o = a[0].trim();
         (t.value = this.lossy ? o : a[0]), a[1] && ((t.insensitive = !0), this.lossy || (t.raws.insensitive = a[1])), (t.quoted = "'" === o[0] || '"' === o[0]), (t.raws.unquoted = t.quoted ? o.slice(1, -1) : o);
        }
        this.newNode(t), this.position++;
       }),
       (e.prototype.combinator = function () {
        if ('|' === this.currToken[1]) return this.namespace();
        for (var e = new y.default({ value: '', source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] }); this.position < this.tokens.length && this.currToken && ('space' === this.currToken[0] || 'combinator' === this.currToken[0]); ) this.nextToken && 'combinator' === this.nextToken[0] ? ((e.spaces.before = this.parseSpace(this.currToken[1])), (e.source.start.line = this.nextToken[2]), (e.source.start.column = this.nextToken[3]), (e.source.end.column = this.nextToken[3]), (e.source.end.line = this.nextToken[2]), (e.sourceIndex = this.nextToken[4])) : this.prevToken && 'combinator' === this.prevToken[0] ? (e.spaces.after = this.parseSpace(this.currToken[1])) : 'combinator' === this.currToken[0] ? (e.value = this.currToken[1]) : 'space' === this.currToken[0] && (e.value = this.parseSpace(this.currToken[1], ' ')), this.position++;
        return this.newNode(e);
       }),
       (e.prototype.comma = function () {
        if (this.position === this.tokens.length - 1) return (this.root.trailingComma = !0), void this.position++;
        var e = new o.default();
        this.current.parent.append(e), (this.current = e), this.position++;
       }),
       (e.prototype.comment = function () {
        var e = new l.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] });
        this.newNode(e), this.position++;
       }),
       (e.prototype.error = function (e) {
        throw new this.input.error(e);
       }),
       (e.prototype.missingBackslash = function () {
        return this.error('Expected a backslash preceding the semicolon.');
       }),
       (e.prototype.missingParenthesis = function () {
        return this.error('Expected opening parenthesis.');
       }),
       (e.prototype.missingSquareBracket = function () {
        return this.error('Expected opening square bracket.');
       }),
       (e.prototype.namespace = function () {
        var e = (this.prevToken && this.prevToken[1]) || !0;
        return 'word' === this.nextToken[0] ? (this.position++, this.word(e)) : '*' === this.nextToken[0] ? (this.position++, this.universal(e)) : void 0;
       }),
       (e.prototype.nesting = function () {
        this.newNode(new g.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] })), this.position++;
       }),
       (e.prototype.parentheses = function () {
        var e = this.current.last;
        if (e && e.type === b.PSEUDO) {
         var t = new o.default(),
          r = this.current;
         e.append(t), (this.current = t);
         var n = 1;
         for (this.position++; this.position < this.tokens.length && n; ) '(' === this.currToken[0] && n++, ')' === this.currToken[0] && n--, n ? this.parse() : ((t.parent.source.end.line = this.currToken[2]), (t.parent.source.end.column = this.currToken[3]), this.position++);
         n && this.error('Expected closing parenthesis.'), (this.current = r);
        } else {
         var s = 1;
         for (this.position++, e.value += '('; this.position < this.tokens.length && s; ) '(' === this.currToken[0] && s++, ')' === this.currToken[0] && s--, (e.value += this.parseParenthesisToken(this.currToken)), this.position++;
         s && this.error('Expected closing parenthesis.');
        }
       }),
       (e.prototype.pseudo = function () {
        for (var e = this, t = '', r = this.currToken; this.currToken && ':' === this.currToken[0]; ) (t += this.currToken[1]), this.position++;
        if (!this.currToken) return this.error('Expected pseudo-class or pseudo-element');
        if ('word' === this.currToken[0]) {
         var n = void 0;
         this.splitWord(!1, function (s, i) {
          (t += s), (n = new d.default({ value: t, source: { start: { line: r[2], column: r[3] }, end: { line: e.currToken[4], column: e.currToken[5] } }, sourceIndex: r[4] })), e.newNode(n), i > 1 && e.nextToken && '(' === e.nextToken[0] && e.error('Misplaced parenthesis.');
         });
        } else this.error('Unexpected "' + this.currToken[0] + '" found.');
       }),
       (e.prototype.space = function () {
        var e = this.currToken;
        0 === this.position || ',' === this.prevToken[0] || '(' === this.prevToken[0] ? ((this.spaces = this.parseSpace(e[1])), this.position++) : this.position === this.tokens.length - 1 || ',' === this.nextToken[0] || ')' === this.nextToken[0] ? ((this.current.last.spaces.after = this.parseSpace(e[1])), this.position++) : this.combinator();
       }),
       (e.prototype.string = function () {
        var e = this.currToken;
        this.newNode(new h.default({ value: this.currToken[1], source: { start: { line: e[2], column: e[3] }, end: { line: e[4], column: e[5] } }, sourceIndex: e[6] })), this.position++;
       }),
       (e.prototype.universal = function (e) {
        var t = this.nextToken;
        if (t && '|' === t[1]) return this.position++, this.namespace();
        this.newNode(new m.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] }), e), this.position++;
       }),
       (e.prototype.splitWord = function (e, t) {
        for (var r = this, a = this.nextToken, o = this.currToken[1]; a && 'word' === a[0]; ) {
         this.position++;
         var l = this.currToken[1];
         if (((o += l), l.lastIndexOf('\\') === l.length - 1)) {
          var h = this.nextToken;
          h && 'space' === h[0] && ((o += this.parseSpace(h[1], ' ')), this.position++);
         }
         a = this.nextToken;
        }
        var d = (0, s.default)(o, '.'),
         f = (0, s.default)(o, '#'),
         m = (0, s.default)(o, '#{');
        m.length &&
         (f = f.filter(function (e) {
          return !~m.indexOf(e);
         }));
        var y = (0, D.default)((0, i.default)((0, n.default)([[0], d, f])));
        y.forEach(function (n, s) {
         var i = y[s + 1] || o.length,
          a = o.slice(n, i);
         if (0 === s && t) return t.call(r, a, y.length);
         var l = void 0;
         (l = ~d.indexOf(n) ? new u.default({ value: a.slice(1), source: { start: { line: r.currToken[2], column: r.currToken[3] + n }, end: { line: r.currToken[4], column: r.currToken[3] + (i - 1) } }, sourceIndex: r.currToken[6] + y[s] }) : ~f.indexOf(n) ? new p.default({ value: a.slice(1), source: { start: { line: r.currToken[2], column: r.currToken[3] + n }, end: { line: r.currToken[4], column: r.currToken[3] + (i - 1) } }, sourceIndex: r.currToken[6] + y[s] }) : new c.default({ value: a, source: { start: { line: r.currToken[2], column: r.currToken[3] + n }, end: { line: r.currToken[4], column: r.currToken[3] + (i - 1) } }, sourceIndex: r.currToken[6] + y[s] })), r.newNode(l, e);
        }),
         this.position++;
       }),
       (e.prototype.word = function (e) {
        var t = this.nextToken;
        return t && '|' === t[1] ? (this.position++, this.namespace()) : this.splitWord(e);
       }),
       (e.prototype.loop = function () {
        for (; this.position < this.tokens.length; ) this.parse(!0);
        return this.root;
       }),
       (e.prototype.parse = function (e) {
        switch (this.currToken[0]) {
         case 'space':
          this.space();
          break;
         case 'comment':
          this.comment();
          break;
         case '(':
          this.parentheses();
          break;
         case ')':
          e && this.missingParenthesis();
          break;
         case '[':
          this.attribute();
          break;
         case ']':
          this.missingSquareBracket();
          break;
         case 'at-word':
         case 'word':
          this.word();
          break;
         case ':':
          this.pseudo();
          break;
         case ';':
          this.missingBackslash();
          break;
         case ',':
          this.comma();
          break;
         case '*':
          this.universal();
          break;
         case '&':
          this.nesting();
          break;
         case 'combinator':
          this.combinator();
          break;
         case 'string':
          this.string();
        }
       }),
       (e.prototype.parseNamespace = function (e) {
        if (this.lossy && 'string' == typeof e) {
         var t = e.trim();
         return !t.length || t;
        }
        return e;
       }),
       (e.prototype.parseSpace = function (e, t) {
        return this.lossy ? t || '' : e;
       }),
       (e.prototype.parseValue = function (e) {
        return this.lossy && e && 'string' == typeof e ? e.trim() : e;
       }),
       (e.prototype.parseParenthesisToken = function (e) {
        return this.lossy ? ('space' === e[0] ? this.parseSpace(e[1], ' ') : this.parseValue(e[1])) : e[1];
       }),
       (e.prototype.newNode = function (e, t) {
        return t && (e.namespace = this.parseNamespace(t)), this.spaces && ((e.spaces.before = this.spaces), (this.spaces = '')), this.current.append(e);
       }),
       r(e, [
        {
         key: 'currToken',
         get: function () {
          return this.tokens[this.position];
         },
        },
        {
         key: 'nextToken',
         get: function () {
          return this.tokens[this.position + 1];
         },
        },
        {
         key: 'prevToken',
         get: function () {
          return this.tokens[this.position - 1];
         },
        },
       ]),
       e
      );
     })();
     (e.default = E), (t.exports = e.default);
    }),
    Ae = l((e, t) => {
     e.__esModule = !0;
     var r,
      n = (function () {
       function e(e, t) {
        for (var r = 0; r < t.length; r++) {
         var n = t[r];
         (n.enumerable = n.enumerable || !1), (n.configurable = !0), 'value' in n && (n.writable = !0), Object.defineProperty(e, n.key, n);
        }
       }
       return function (t, r, n) {
        return r && e(t.prototype, r), n && e(t, n), t;
       };
      })(),
      s = we(),
      i = (r = s) && r.__esModule ? r : { default: r };
     var a = (function () {
      function e(t) {
       return (
        (function (e, t) {
         if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
        })(this, e),
        (this.func = t || function () {}),
        this
       );
      }
      return (
       (e.prototype.process = function (e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
         r = new i.default({
          css: e,
          error: function (e) {
           throw new Error(e);
          },
          options: t,
         });
        return (this.res = r), this.func(r), this;
       }),
       n(e, [
        {
         key: 'result',
         get: function () {
          return String(this.res);
         },
        },
       ]),
       e
      );
     })();
     (e.default = a), (t.exports = e.default);
    }),
    Fe = l((e, t) => {
     var r = function (e, t) {
      let n = new e.constructor();
      for (let s in e) {
       if (!e.hasOwnProperty(s)) continue;
       let i = e[s],
        a = typeof i;
       'parent' === s && 'object' === a ? t && (n[s] = t) : 'source' === s ? (n[s] = i) : i instanceof Array ? (n[s] = i.map((e) => r(e, n))) : 'before' !== s && 'after' !== s && 'between' !== s && 'semicolon' !== s && ('object' === a && null !== i && (i = r(i)), (n[s] = i));
      }
      return n;
     };
     t.exports = class {
      constructor(e) {
       (e = e || {}), (this.raws = { before: '', after: '' });
       for (let t in e) this[t] = e[t];
      }
      remove() {
       return this.parent && this.parent.removeChild(this), (this.parent = void 0), this;
      }
      toString() {
       return [this.raws.before, String(this.value), this.raws.after].join('');
      }
      clone(e) {
       e = e || {};
       let t = r(this);
       for (let r in e) t[r] = e[r];
       return t;
      }
      cloneBefore(e) {
       e = e || {};
       let t = this.clone(e);
       return this.parent.insertBefore(this, t), t;
      }
      cloneAfter(e) {
       e = e || {};
       let t = this.clone(e);
       return this.parent.insertAfter(this, t), t;
      }
      replaceWith() {
       let e = Array.prototype.slice.call(arguments);
       if (this.parent) {
        for (let t of e) this.parent.insertBefore(this, t);
        this.remove();
       }
       return this;
      }
      moveTo(e) {
       return this.cleanRaws(this.root() === e.root()), this.remove(), e.append(this), this;
      }
      moveBefore(e) {
       return this.cleanRaws(this.root() === e.root()), this.remove(), e.parent.insertBefore(e, this), this;
      }
      moveAfter(e) {
       return this.cleanRaws(this.root() === e.root()), this.remove(), e.parent.insertAfter(e, this), this;
      }
      next() {
       let e = this.parent.index(this);
       return this.parent.nodes[e + 1];
      }
      prev() {
       let e = this.parent.index(this);
       return this.parent.nodes[e - 1];
      }
      toJSON() {
       let e = {};
       for (let t in this) {
        if (!this.hasOwnProperty(t) || 'parent' === t) continue;
        let r = this[t];
        r instanceof Array ? (e[t] = r.map((e) => ('object' == typeof e && e.toJSON ? e.toJSON() : e))) : 'object' == typeof r && r.toJSON ? (e[t] = r.toJSON()) : (e[t] = r);
       }
       return e;
      }
      root() {
       let e = this;
       for (; e.parent; ) e = e.parent;
       return e;
      }
      cleanRaws(e) {
       delete this.raws.before, delete this.raws.after, e || delete this.raws.between;
      }
      positionInside(e) {
       let t = this.toString(),
        r = this.source.start.column,
        n = this.source.start.line;
       for (let s = 0; s < e; s++) '\n' === t[s] ? ((r = 1), (n += 1)) : (r += 1);
       return { line: n, column: r };
      }
      positionBy(e) {
       let t = this.source.start;
       if (Object(e).index) t = this.positionInside(e.index);
       else if (Object(e).word) {
        let r = this.toString().indexOf(e.word);
        -1 !== r && (t = this.positionInside(r));
       }
       return t;
      }
     };
    }),
    ke = l((e, t) => {
     var r = Fe(),
      n = class extends r {
       constructor(e) {
        super(e), this.nodes || (this.nodes = []);
       }
       push(e) {
        return (e.parent = this), this.nodes.push(e), this;
       }
       each(e) {
        this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), (this.lastEach += 1);
        let t,
         r,
         n = this.lastEach;
        if (((this.indexes[n] = 0), this.nodes)) {
         for (; this.indexes[n] < this.nodes.length && ((t = this.indexes[n]), (r = e(this.nodes[t], t)), !1 !== r); ) this.indexes[n] += 1;
         return delete this.indexes[n], r;
        }
       }
       walk(e) {
        return this.each((t, r) => {
         let n = e(t, r);
         return !1 !== n && t.walk && (n = t.walk(e)), n;
        });
       }
       walkType(e, t) {
        if (!e || !t) throw new Error('Parameters {type} and {callback} are required.');
        let r = 'function' == typeof e;
        return this.walk((n, s) => {
         if ((r && n instanceof e) || (!r && n.type === e)) return t.call(this, n, s);
        });
       }
       append(e) {
        return (e.parent = this), this.nodes.push(e), this;
       }
       prepend(e) {
        return (e.parent = this), this.nodes.unshift(e), this;
       }
       cleanRaws(e) {
        if ((super.cleanRaws(e), this.nodes)) for (let t of this.nodes) t.cleanRaws(e);
       }
       insertAfter(e, t) {
        let r,
         n = this.index(e);
        this.nodes.splice(n + 1, 0, t);
        for (let s in this.indexes) (r = this.indexes[s]), n <= r && (this.indexes[s] = r + this.nodes.length);
        return this;
       }
       insertBefore(e, t) {
        let r,
         n = this.index(e);
        this.nodes.splice(n, 0, t);
        for (let s in this.indexes) (r = this.indexes[s]), n <= r && (this.indexes[s] = r + this.nodes.length);
        return this;
       }
       removeChild(e) {
        let t;
        (e = this.index(e)), (this.nodes[e].parent = void 0), this.nodes.splice(e, 1);
        for (let r in this.indexes) (t = this.indexes[r]), t >= e && (this.indexes[r] = t - 1);
        return this;
       }
       removeAll() {
        for (let e of this.nodes) e.parent = void 0;
        return (this.nodes = []), this;
       }
       every(e) {
        return this.nodes.every(e);
       }
       some(e) {
        return this.nodes.some(e);
       }
       index(e) {
        return 'number' == typeof e ? e : this.nodes.indexOf(e);
       }
       get first() {
        if (this.nodes) return this.nodes[0];
       }
       get last() {
        if (this.nodes) return this.nodes[this.nodes.length - 1];
       }
       toString() {
        let e = this.nodes.map(String).join('');
        return this.value && (e = this.value + e), this.raws.before && (e = this.raws.before + e), this.raws.after && (e += this.raws.after), e;
       }
      };
     (n.registerWalker = (e) => {
      let t = 'walk' + e.name;
      t.lastIndexOf('s') !== t.length - 1 && (t += 's'),
       !n.prototype[t] &&
        (n.prototype[t] = function (t) {
         return this.walkType(e, t);
        });
     }),
      (t.exports = n);
    }),
    Pe = l((e, t) => {
     var r = ke();
     t.exports = class extends r {
      constructor(e) {
       super(e), (this.type = 'root');
      }
     };
    }),
    Ie = l((e, t) => {
     var r = ke();
     t.exports = class extends r {
      constructor(e) {
       super(e), (this.type = 'value'), (this.unbalanced = 0);
      }
     };
    }),
    Ne = l((e, t) => {
     var r = ke(),
      n = class extends r {
       constructor(e) {
        super(e), (this.type = 'atword');
       }
       toString() {
        this.quoted && this.raws.quote;
        return [this.raws.before, '@', String.prototype.toString.call(this.value), this.raws.after].join('');
       }
      };
     r.registerWalker(n), (t.exports = n);
    }),
    Be = l((e, t) => {
     var r = ke(),
      n = Fe(),
      s = class extends n {
       constructor(e) {
        super(e), (this.type = 'colon');
       }
      };
     r.registerWalker(s), (t.exports = s);
    }),
    _e = l((e, t) => {
     var r = ke(),
      n = Fe(),
      s = class extends n {
       constructor(e) {
        super(e), (this.type = 'comma');
       }
      };
     r.registerWalker(s), (t.exports = s);
    }),
    Le = l((e, t) => {
     var r = ke(),
      n = Fe(),
      s = class extends n {
       constructor(e) {
        super(e), (this.type = 'comment'), (this.inline = Object(e).inline || !1);
       }
       toString() {
        return [this.raws.before, this.inline ? '//' : '/*', String(this.value), this.inline ? '' : '*/', this.raws.after].join('');
       }
      };
     r.registerWalker(s), (t.exports = s);
    }),
    Oe = l((e, t) => {
     var r = ke(),
      n = class extends r {
       constructor(e) {
        super(e), (this.type = 'func'), (this.unbalanced = -1);
       }
      };
     r.registerWalker(n), (t.exports = n);
    }),
    Me = l((e, t) => {
     var r = ke(),
      n = Fe(),
      s = class extends n {
       constructor(e) {
        super(e), (this.type = 'number'), (this.unit = Object(e).unit || '');
       }
       toString() {
        return [this.raws.before, String(this.value), this.unit, this.raws.after].join('');
       }
      };
     r.registerWalker(s), (t.exports = s);
    }),
    je = l((e, t) => {
     var r = ke(),
      n = Fe(),
      s = class extends n {
       constructor(e) {
        super(e), (this.type = 'operator');
       }
      };
     r.registerWalker(s), (t.exports = s);
    }),
    Re = l((e, t) => {
     var r = ke(),
      n = Fe(),
      s = class extends n {
       constructor(e) {
        super(e), (this.type = 'paren'), (this.parenType = '');
       }
      };
     r.registerWalker(s), (t.exports = s);
    }),
    qe = l((e, t) => {
     var r = ke(),
      n = Fe(),
      s = class extends n {
       constructor(e) {
        super(e), (this.type = 'string');
       }
       toString() {
        let e = this.quoted ? this.raws.quote : '';
        return [this.raws.before, e, this.value + '', e, this.raws.after].join('');
       }
      };
     r.registerWalker(s), (t.exports = s);
    }),
    Ue = l((e, t) => {
     var r = ke(),
      n = Fe(),
      s = class extends n {
       constructor(e) {
        super(e), (this.type = 'word');
       }
      };
     r.registerWalker(s), (t.exports = s);
    }),
    $e = l((e, t) => {
     var r = ke(),
      n = Fe(),
      s = class extends n {
       constructor(e) {
        super(e), (this.type = 'unicode-range');
       }
      };
     r.registerWalker(s), (t.exports = s);
    }),
    He = l((e, t) => {
     var r = class extends Error {
      constructor(e) {
       super(e), (this.name = this.constructor.name), (this.message = e || 'An error ocurred while tokzenizing.'), 'function' == typeof Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : (this.stack = new Error(e).stack);
      }
     };
     t.exports = r;
    }),
    ze = l((e, t) => {
     var r = /[ \n\t\r\{\(\)'"\\;,/]/g,
      n = /[ \n\t\r\(\)\{\}\*:;@!&'"\+\|~>,\[\]\\]|\/(?=\*)/g,
      s = /[ \n\t\r\(\)\{\}\*:;@!&'"\-\+\|~>,\[\]\\]|\//g,
      i = /^[a-z0-9]/i,
      a = /^[a-f0-9?\-]/i,
      o = He();
     t.exports = function (e, t) {
      t = t || {};
      let u,
       l,
       p,
       c,
       h,
       d,
       f,
       m,
       y,
       g,
       D,
       x = [],
       b = e.valueOf(),
       v = b.length,
       E = -1,
       C = 1,
       T = 0,
       S = 0,
       w = null;
      function A(e) {
       throw new o(`Unclosed ${e} at line: ${C}, column: ${T - E}, token: ${T}`);
      }
      for (; T < v; ) {
       switch (((u = b.charCodeAt(T)), 10 === u && ((E = T), (C += 1)), u)) {
        case 10:
        case 32:
        case 9:
        case 13:
        case 12:
         l = T;
         do {
          (l += 1), (u = b.charCodeAt(l)), 10 === u && ((E = l), (C += 1));
         } while (32 === u || 10 === u || 9 === u || 13 === u || 12 === u);
         x.push(['space', b.slice(T, l), C, T - E, C, l - E, T]), (T = l - 1);
         break;
        case 58:
         (l = T + 1), x.push(['colon', b.slice(T, l), C, T - E, C, l - E, T]), (T = l - 1);
         break;
        case 44:
         (l = T + 1), x.push(['comma', b.slice(T, l), C, T - E, C, l - E, T]), (T = l - 1);
         break;
        case 123:
         x.push(['{', '{', C, T - E, C, l - E, T]);
         break;
        case 125:
         x.push(['}', '}', C, T - E, C, l - E, T]);
         break;
        case 40:
         S++, (w = !w && 1 === S && x.length > 0 && 'word' === x[x.length - 1][0] && 'url' === x[x.length - 1][1]), x.push(['(', '(', C, T - E, C, l - E, T]);
         break;
        case 41:
         S--, (w = w && S > 0), x.push([')', ')', C, T - E, C, l - E, T]);
         break;
        case 39:
        case 34:
         (p = 39 === u ? "'" : '"'), (l = T);
         do {
          for (y = !1, l = b.indexOf(p, l + 1), -1 === l && A('quote'), g = l; 92 === b.charCodeAt(g - 1); ) (g -= 1), (y = !y);
         } while (y);
         x.push(['string', b.slice(T, l + 1), C, T - E, C, l - E, T]), (T = l);
         break;
        case 64:
         (r.lastIndex = T + 1), r.test(b), (l = 0 === r.lastIndex ? b.length - 1 : r.lastIndex - 2), x.push(['atword', b.slice(T, l + 1), C, T - E, C, l - E, T]), (T = l);
         break;
        case 92:
         (l = T), (u = b.charCodeAt(l + 1)), x.push(['word', b.slice(T, l + 1), C, T - E, C, l - E, T]), (T = l);
         break;
        case 43:
        case 45:
        case 42:
         (l = T + 1), (D = b.slice(T + 1, l + 1));
         b.slice(T - 1, T);
         if (45 === u && 45 === D.charCodeAt(0)) {
          l++, x.push(['word', b.slice(T, l), C, T - E, C, l - E, T]), (T = l - 1);
          break;
         }
         x.push(['operator', b.slice(T, l), C, T - E, C, l - E, T]), (T = l - 1);
         break;
        default:
         if (47 === u && (42 === b.charCodeAt(T + 1) || (t.loose && !w && 47 === b.charCodeAt(T + 1)))) {
          if (42 === b.charCodeAt(T + 1)) (l = b.indexOf('*/', T + 2) + 1), 0 === l && A('comment');
          else {
           let e = b.indexOf('\n', T + 2);
           l = -1 !== e ? e - 1 : v;
          }
          (d = b.slice(T, l + 1)), (c = d.split('\n')), (h = c.length - 1), h > 0 ? ((f = C + h), (m = l - c[h].length)) : ((f = C), (m = E)), x.push(['comment', d, C, T - E, f, l - m, T]), (E = m), (C = f), (T = l);
         } else if (35 !== u || i.test(b.slice(T + 1, T + 2)))
          if ((117 !== u && 85 !== u) || 43 !== b.charCodeAt(T + 1))
           if (47 === u) (l = T + 1), x.push(['operator', b.slice(T, l), C, T - E, C, l - E, T]), (T = l - 1);
           else {
            let e = n;
            if ((u >= 48 && u <= 57 && (e = s), (e.lastIndex = T + 1), e.test(b), (l = 0 === e.lastIndex ? b.length - 1 : e.lastIndex - 2), e === s || 46 === u)) {
             let e = b.charCodeAt(l),
              t = b.charCodeAt(l + 1),
              r = b.charCodeAt(l + 2);
             (101 === e || 69 === e) && (45 === t || 43 === t) && r >= 48 && r <= 57 && ((s.lastIndex = l + 2), s.test(b), (l = 0 === s.lastIndex ? b.length - 1 : s.lastIndex - 2));
            }
            x.push(['word', b.slice(T, l + 1), C, T - E, C, l - E, T]), (T = l);
           }
          else {
           l = T + 2;
           do {
            (l += 1), (u = b.charCodeAt(l));
           } while (l < v && a.test(b.slice(l, l + 1)));
           x.push(['unicoderange', b.slice(T, l), C, T - E, C, l - E, T]), (T = l - 1);
          }
         else (l = T + 1), x.push(['#', b.slice(T, l), C, T - E, C, l - E, T]), (T = l - 1);
       }
       T++;
      }
      return x;
     };
    }),
    Ve = l((e, t) => {
     var r = class extends Error {
      constructor(e) {
       super(e), (this.name = this.constructor.name), (this.message = e || 'An error ocurred while parsing.'), 'function' == typeof Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : (this.stack = new Error(e).stack);
      }
     };
     t.exports = r;
    }),
    We = l((e, t) => {
     var r = Pe(),
      n = Ie(),
      s = Ne(),
      i = Be(),
      a = _e(),
      o = Le(),
      u = Oe(),
      l = Me(),
      p = je(),
      c = Re(),
      h = qe(),
      d = Ue(),
      f = $e(),
      m = ze(),
      y = ie(),
      g = ae(),
      D = oe(),
      x = Ve();
     t.exports = class {
      constructor(e, t) {
       (this.cache = []), (this.input = e), (this.options = Object.assign({}, { loose: !1 }, t)), (this.position = 0), (this.unbalanced = 0), (this.root = new r());
       let s = new n();
       this.root.append(s), (this.current = s), (this.tokens = m(e, this.options));
      }
      parse() {
       return this.loop();
      }
      colon() {
       let e = this.currToken;
       this.newNode(new i({ value: e[1], source: { start: { line: e[2], column: e[3] }, end: { line: e[4], column: e[5] } }, sourceIndex: e[6] })), this.position++;
      }
      comma() {
       let e = this.currToken;
       this.newNode(new a({ value: e[1], source: { start: { line: e[2], column: e[3] }, end: { line: e[4], column: e[5] } }, sourceIndex: e[6] })), this.position++;
      }
      comment() {
       let e,
        t = !1,
        r = this.currToken[1].replace(/\/\*|\*\//g, '');
       this.options.loose && r.startsWith('//') && ((r = r.substring(2)), (t = !0)), (e = new o({ value: r, inline: t, source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] })), this.newNode(e), this.position++;
      }
      error(e, t) {
       throw new x(e + ` at line: ${t[2]}, column ${t[3]}`);
      }
      loop() {
       for (; this.position < this.tokens.length; ) this.parseTokens();
       return !this.current.last && this.spaces ? (this.current.raws.before += this.spaces) : this.spaces && (this.current.last.raws.after += this.spaces), (this.spaces = ''), this.root;
      }
      operator() {
       let e,
        t = this.currToken[1];
       if ('+' === t || '-' === t)
        if ((this.options.loose || (this.position > 0 && ('func' === this.current.type && 'calc' === this.current.value ? (('space' !== this.prevToken[0] && '(' !== this.prevToken[0]) || ('space' !== this.nextToken[0] && 'word' !== this.nextToken[0]) || ('word' === this.nextToken[0] && 'operator' !== this.current.last.type && '(' !== this.current.last.value)) && this.error('Syntax Error', this.currToken) : ('space' === this.nextToken[0] || 'operator' === this.nextToken[0] || 'operator' === this.prevToken[0]) && this.error('Syntax Error', this.currToken))), this.options.loose)) {
         if ((!this.current.nodes.length || (this.current.last && 'operator' === this.current.last.type)) && 'word' === this.nextToken[0]) return this.word();
        } else if ('word' === this.nextToken[0]) return this.word();
       return (e = new p({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] })), this.position++, this.newNode(e);
      }
      parseTokens() {
       switch (this.currToken[0]) {
        case 'space':
         this.space();
         break;
        case 'colon':
         this.colon();
         break;
        case 'comma':
         this.comma();
         break;
        case 'comment':
         this.comment();
         break;
        case '(':
         this.parenOpen();
         break;
        case ')':
         this.parenClose();
         break;
        case 'atword':
        case 'word':
        default:
         this.word();
         break;
        case 'operator':
         this.operator();
         break;
        case 'string':
         this.string();
         break;
        case 'unicoderange':
         this.unicodeRange();
       }
      }
      parenOpen() {
       let e,
        t = 1,
        r = this.position + 1,
        n = this.currToken;
       for (; r < this.tokens.length && t; ) {
        let e = this.tokens[r];
        '(' === e[0] && t++, ')' === e[0] && t--, r++;
       }
       if ((t && this.error('Expected closing parenthesis', n), (e = this.current.last), e && 'func' === e.type && e.unbalanced < 0 && ((e.unbalanced = 0), (this.current = e)), this.current.unbalanced++, this.newNode(new c({ value: n[1], source: { start: { line: n[2], column: n[3] }, end: { line: n[4], column: n[5] } }, sourceIndex: n[6] })), this.position++, 'func' === this.current.type && this.current.unbalanced && 'url' === this.current.value && 'string' !== this.currToken[0] && ')' !== this.currToken[0] && !this.options.loose)) {
        let e = this.nextToken,
         t = this.currToken[1],
         r = { line: this.currToken[2], column: this.currToken[3] };
        for (; e && ')' !== e[0] && this.current.unbalanced; ) this.position++, (t += this.currToken[1]), (e = this.nextToken);
        this.position !== this.tokens.length - 1 && (this.position++, this.newNode(new d({ value: t, source: { start: r, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] })));
       }
      }
      parenClose() {
       let e = this.currToken;
       this.newNode(new c({ value: e[1], source: { start: { line: e[2], column: e[3] }, end: { line: e[4], column: e[5] } }, sourceIndex: e[6] })), this.position++, (!(this.position >= this.tokens.length - 1) || this.current.unbalanced) && (this.current.unbalanced--, this.current.unbalanced < 0 && this.error('Expected opening parenthesis', e), !this.current.unbalanced && this.cache.length && (this.current = this.cache.pop()));
      }
      space() {
       let e = this.currToken;
       this.position === this.tokens.length - 1 || ',' === this.nextToken[0] || ')' === this.nextToken[0] ? ((this.current.last.raws.after += e[1]), this.position++) : ((this.spaces = e[1]), this.position++);
      }
      unicodeRange() {
       let e = this.currToken;
       this.newNode(new f({ value: e[1], source: { start: { line: e[2], column: e[3] }, end: { line: e[4], column: e[5] } }, sourceIndex: e[6] })), this.position++;
      }
      splitWord() {
       let e,
        t,
        r = this.nextToken,
        n = this.currToken[1],
        i = /^[\+\-]?((\d+(\.\d*)?)|(\.\d+))([eE][\+\-]?\d+)?/;
       if (!/^(?!\#([a-z0-9]+))[\#\{\}]/gi.test(n))
        for (; r && 'word' === r[0]; ) {
         this.position++;
         let e = this.currToken[1];
         (n += e), (r = this.nextToken);
        }
       var a;
       (e = g(n, '@')),
        (a = D(y([[0], e]))),
        (t = a.sort((e, t) => e - t)),
        t.forEach((a, o) => {
         let p,
          c = t[o + 1] || n.length,
          h = n.slice(a, c);
         if (~e.indexOf(a)) p = new s({ value: h.slice(1), source: { start: { line: this.currToken[2], column: this.currToken[3] + a }, end: { line: this.currToken[4], column: this.currToken[3] + (c - 1) } }, sourceIndex: this.currToken[6] + t[o] });
         else if (i.test(this.currToken[1])) {
          let e = h.replace(i, '');
          p = new l({ value: h.replace(e, ''), source: { start: { line: this.currToken[2], column: this.currToken[3] + a }, end: { line: this.currToken[4], column: this.currToken[3] + (c - 1) } }, sourceIndex: this.currToken[6] + t[o], unit: e });
         } else (p = new (r && '(' === r[0] ? u : d)({ value: h, source: { start: { line: this.currToken[2], column: this.currToken[3] + a }, end: { line: this.currToken[4], column: this.currToken[3] + (c - 1) } }, sourceIndex: this.currToken[6] + t[o] })), 'word' === p.type ? ((p.isHex = /^#(.+)/.test(h)), (p.isColor = /^#([0-9a-f]{3}|[0-9a-f]{4}|[0-9a-f]{6}|[0-9a-f]{8})$/i.test(h))) : this.cache.push(this.current);
         this.newNode(p);
        }),
        this.position++;
      }
      string() {
       let e,
        t = this.currToken,
        r = this.currToken[1],
        n = /^(\"|\')/,
        s = n.test(r),
        i = '';
       s && ((i = r.match(n)[0]), (r = r.slice(1, r.length - 1))), (e = new h({ value: r, source: { start: { line: t[2], column: t[3] }, end: { line: t[4], column: t[5] } }, sourceIndex: t[6], quoted: s })), (e.raws.quote = i), this.newNode(e), this.position++;
      }
      word() {
       return this.splitWord();
      }
      newNode(e) {
       return this.spaces && ((e.raws.before += this.spaces), (this.spaces = '')), this.current.append(e);
      }
      get currToken() {
       return this.tokens[this.position];
      }
      get nextToken() {
       return this.tokens[this.position + 1];
      }
      get prevToken() {
       return this.tokens[this.position - 1];
      }
     };
    }),
    Je = {};
   p(Je, { languages: () => In, options: () => Nn, parsers: () => Bn, printers: () => ms });
   var Ke = (e, t, r, n) => {
     if (!e || null != t) return t.replaceAll ? t.replaceAll(r, n) : r.global ? t.replace(r, n) : t.split(r).join(n);
    },
    Ge = 'string',
    Xe = 'array',
    Ye = 'cursor',
    Qe = 'indent',
    Ze = 'align',
    et = 'trim',
    tt = 'group',
    rt = 'fill',
    nt = 'if-break',
    st = 'indent-if-break',
    it = 'line-suffix',
    at = 'line-suffix-boundary',
    ot = 'line',
    ut = 'label',
    lt = 'break-parent',
    pt = new Set([Ye, Qe, Ze, et, tt, rt, nt, st, it, at, ot, ut, lt]),
    ct = (e, t, r) => {
     if (!e || null != t) return Array.isArray(t) || 'string' == typeof t ? t[r < 0 ? t.length + r : r] : t.at(r);
    };
   var ht = function (e) {
    if ('string' == typeof e) return Ge;
    if (Array.isArray(e)) return Xe;
    if (!e) return;
    let { type: t } = e;
    return pt.has(t) ? t : void 0;
   };
   function dt(e) {
    let t = null === e ? 'null' : typeof e;
    if ('string' !== t && 'object' !== t) return `Unexpected doc '${t}', \nExpected it to be 'string' or 'object'.`;
    if (ht(e)) throw new Error('doc is valid.');
    let r = Object.prototype.toString.call(e);
    if ('[object Object]' !== r) return `Unexpected doc '${r}'.`;
    let n = ((e) => new Intl.ListFormat('en-US', { type: 'disjunction' }).format(e))([...pt].map((e) => `'${e}'`));
    return `Unexpected doc.type '${e.type}'.\nExpected it to be ${n}.`;
   }
   var ft = class extends Error {
    name = 'InvalidDocError';
    constructor(e) {
     super(dt(e)), (this.doc = e);
    }
   };
   function mt(e, t) {
    if ('string' == typeof e) return t(e);
    let r = new Map();
    return n(e);
    function n(e) {
     if (r.has(e)) return r.get(e);
     let s = (function (e) {
      switch (ht(e)) {
       case Xe:
        return t(e.map(n));
       case rt:
        return t({ ...e, parts: e.parts.map(n) });
       case nt:
        return t({ ...e, breakContents: n(e.breakContents), flatContents: n(e.flatContents) });
       case tt: {
        let { expandedStates: r, contents: s } = e;
        return r ? ((r = r.map(n)), (s = r[0])) : (s = n(s)), t({ ...e, contents: s, expandedStates: r });
       }
       case Ze:
       case Qe:
       case st:
       case ut:
       case it:
        return t({ ...e, contents: n(e.contents) });
       case Ge:
       case Ye:
       case et:
       case at:
       case ot:
       case lt:
        return t(e);
       default:
        throw new ft(e);
      }
     })(e);
     return r.set(e, s), s;
    }
   }
   function yt(e) {
    return e.type !== ot || e.hard ? (e.type === nt ? e.flatContents : e) : e.soft ? '' : ' ';
   }
   var gt = () => {},
    Dt = gt,
    xt = gt,
    bt = gt;
   function vt(e) {
    return Dt(e), { type: Qe, contents: e };
   }
   function Et(e, t) {
    return Dt(t), { type: Ze, contents: t, n: e };
   }
   function Ct(e, t = {}) {
    return Dt(e), xt(t.expandedStates, !0), { type: tt, id: t.id, contents: e, break: !!t.shouldBreak, expandedStates: t.expandedStates };
   }
   function Tt(e) {
    return Et(-1, e);
   }
   function St(e) {
    return bt(e), { type: rt, parts: e };
   }
   function wt(e, t = '', r = {}) {
    return Dt(e), '' !== t && Dt(t), { type: nt, breakContents: e, flatContents: t, groupId: r.groupId };
   }
   function At(e) {
    return Dt(e), { type: it, contents: e };
   }
   var Ft = { type: lt },
    kt = { type: ot },
    Pt = { type: ot, soft: !0 },
    It = [{ type: ot, hard: !0 }, Ft];
   function Nt(e, t) {
    Dt(e), xt(t);
    let r = [];
    for (let n = 0; n < t.length; n++) 0 !== n && r.push(e), r.push(t[n]);
    return r;
   }
   var Bt = function (e) {
     return Array.isArray(e) && e.length > 0;
    },
    _t = new Proxy(() => {}, { get: () => _t }),
    Lt = _t,
    Ot = "'";
   var Mt = function (e, t) {
    let r = !0 === t || t === Ot ? Ot : '"',
     n = r === Ot ? '"' : Ot,
     s = 0,
     i = 0;
    for (let a of e) a === r ? s++ : a === n && i++;
    return s > i ? n : r;
   };
   var jt = function (e, t, r) {
    let n = '"' === t ? "'" : '"',
     s = Ke(!1, e, /\\(.)|(["'])/gsu, (e, s, i) => (s === n ? s : i === t ? '\\' + i : i || (r && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/u.test(s) ? s : '\\' + s)));
    return t + s + t;
   };
   var Rt = function (e, t) {
     Lt(/^(?<quote>["']).*\k<quote>$/su.test(e));
     let r = e.slice(1, -1),
      n = 'json' === t.parser || 'jsonc' === t.parser || ('json5' === t.parser && 'preserve' === t.quoteProps && !t.singleQuote) ? '"' : t.__isInHtmlAttribute ? "'" : Mt(r, t.singleQuote);
     return e.charAt(0) === n ? e : jt(r, n, !1);
    },
    qt = class extends Error {
     name = 'UnexpectedNodeError';
     constructor(e, t, r = 'type') {
      super(`Unexpected ${t} node ${r}: ${JSON.stringify(e[r])}.`), (this.node = e);
     }
    };
   var Ut = function (e) {
     return 'front-matter' === (null == e ? void 0 : e.type);
    },
    $t = new Set(['raw', 'raws', 'sourceIndex', 'source', 'before', 'after', 'trailingComma', 'spaces']);
   function Ht(e, t, r) {
    if ((Ut(e) && 'yaml' === e.language && delete t.value, 'css-comment' === e.type && 'css-root' === r.type && r.nodes.length > 0 && (((r.nodes[0] === e || (Ut(r.nodes[0]) && r.nodes[1] === e)) && (delete t.text, /^\*\s*@(?:format|prettier)\s*$/u.test(e.text))) || ('css-root' === r.type && ct(!1, r.nodes, -1) === e)))) return null;
    if (
     ('value-root' === e.type && delete t.text,
     ('media-query' === e.type || 'media-query-list' === e.type || 'media-feature-expression' === e.type) && delete t.value,
     'css-rule' === e.type && delete t.params,
     ('media-feature' === e.type || 'media-keyword' === e.type || 'media-type' === e.type || 'media-unknown' === e.type || 'media-url' === e.type || 'media-value' === e.type || 'selector-attribute' === e.type || 'selector-string' === e.type || 'selector-class' === e.type || 'selector-combinator' === e.type || 'value-string' === e.type) &&
      e.value &&
      (t.value = (function (e) {
       return Ke(!1, Ke(!1, e, "'", '"'), /\\([^\da-f])/giu, '$1');
      })(e.value)),
     'selector-combinator' === e.type && (t.value = Ke(!1, t.value, /\s+/gu, ' ')),
     'media-feature' === e.type && (t.value = Ke(!1, t.value, ' ', '')),
     (('value-word' === e.type && ((e.isColor && e.isHex) || ['initial', 'inherit', 'unset', 'revert'].includes(e.value.toLowerCase()))) || 'media-feature' === e.type || 'selector-root-invalid' === e.type || 'selector-pseudo' === e.type) && (t.value = t.value.toLowerCase()),
     'css-decl' === e.type && (t.prop = e.prop.toLowerCase()),
     ('css-atrule' === e.type || 'css-import' === e.type) && (t.name = e.name.toLowerCase()),
     'value-number' === e.type && (t.unit = e.unit.toLowerCase()),
     'value-unknown' === e.type && (t.value = Ke(!1, t.value, /;$/gu, '')),
     'selector-attribute' === e.type && ((t.attribute = e.attribute.trim()), e.namespace && 'string' == typeof e.namespace && (t.namespace = e.namespace.trim() || !0), e.value && ((t.value = Ke(!1, t.value.trim(), /^["']|["']$/gu, '')), delete t.quoted)),
     ('media-value' === e.type || 'media-type' === e.type || 'value-number' === e.type || 'selector-root-invalid' === e.type || 'selector-class' === e.type || 'selector-combinator' === e.type || 'selector-tag' === e.type) &&
      e.value &&
      (t.value = Ke(!1, t.value, /([\d+.e-]+)([a-z]*)/giu, (e, t, r) => {
       let n = Number(t);
       return Number.isNaN(n) ? e : n + r.toLowerCase();
      })),
     'selector-tag' === e.type)
    ) {
     let e = t.value.toLowerCase();
     ['from', 'to'].includes(e) && (t.value = e);
    }
    if (('css-atrule' === e.type && 'supports' === e.name.toLowerCase() && delete t.value, 'selector-unknown' === e.type && delete t.value, 'value-comma_group' === e.type)) {
     let r = e.groups.findIndex((e) => 'value-number' === e.type && '...' === e.unit);
     -1 !== r && ((t.groups[r].unit = ''), t.groups.splice(r + 1, 0, { type: 'value-word', value: '...', isColor: !1, isHex: !1 }));
    }
    return 'value-comma_group' === e.type && e.groups.some((e) => ('value-atword' === e.type && e.value.endsWith('[')) || ('value-word' === e.type && e.value.startsWith(']'))) ? { type: 'value-atword', value: e.groups.map((e) => e.value).join(''), group: { open: null, close: null, groups: [], type: 'value-paren_group' } } : void 0;
   }
   Ht.ignoredProperties = $t;
   var zt = Ht;
   var Vt = async function (e, t) {
    if ('yaml' === e.language) {
     let r = e.value.trim(),
      n = r ? await t(r, { parser: 'yaml' }) : '';
     return (function (e) {
      return Et({ type: 'root' }, e);
     })([e.startDelimiter, e.explicitLanguage, It, n, n ? It : '', e.endDelimiter]);
    }
   };
   function Wt(e) {
    let { node: t } = e;
    if ('front-matter' === t.type)
     return async (e) => {
      let r = await Vt(t, e);
      return r ? [r, It] : void 0;
     };
   }
   Wt.getVisitorKeys = (e) => ('css-root' === e.type ? ['frontMatter'] : []);
   var Jt = Wt,
    Kt = null;
   function Gt(e) {
    if (null !== Kt && (Kt.property, 1)) {
     let e = Kt;
     return (Kt = Gt.prototype = null), e;
    }
    return (Kt = Gt.prototype = e ?? Object.create(null)), new Gt();
   }
   for (let gs = 0; gs <= 10; gs++) Gt();
   var Xt = (function (e, t = 'type') {
    return (
     (function (e) {
      Gt(e);
     })(e),
     function (r) {
      let n = r[t],
       s = e[n];
      if (!Array.isArray(s)) throw Object.assign(new Error(`Missing visitor keys for '${n}'.`), { node: r });
      return s;
     }
    );
   })({ 'front-matter': [], 'css-root': ['frontMatter', 'nodes'], 'css-comment': [], 'css-rule': ['selector', 'nodes'], 'css-decl': ['value', 'selector', 'nodes'], 'css-atrule': ['selector', 'params', 'value', 'nodes'], 'media-query-list': ['nodes'], 'media-query': ['nodes'], 'media-type': [], 'media-feature-expression': ['nodes'], 'media-feature': [], 'media-colon': [], 'media-value': [], 'media-keyword': [], 'media-url': [], 'media-unknown': [], 'selector-root': ['nodes'], 'selector-selector': ['nodes'], 'selector-comment': [], 'selector-string': [], 'selector-tag': [], 'selector-id': [], 'selector-class': [], 'selector-attribute': [], 'selector-combinator': ['nodes'], 'selector-universal': [], 'selector-pseudo': ['nodes'], 'selector-nesting': [], 'selector-unknown': [], 'value-value': ['group'], 'value-root': ['group'], 'value-comment': [], 'value-comma_group': ['groups'], 'value-paren_group': ['open', 'groups', 'close'], 'value-func': ['group'], 'value-paren': [], 'value-number': [], 'value-operator': [], 'value-word': [], 'value-colon': [], 'value-comma': [], 'value-string': [], 'value-atword': [], 'value-unicode-range': [], 'value-unknown': [] });
   var Yt = function (e, t) {
    let r = 0;
    for (let n = 0; n < e.line - 1; ++n) r = t.indexOf('\n', r) + 1;
    return r + e.column;
   };
   function Qt(e) {
    return (t, r, n) => {
     let s = !(null == n || !n.backwards);
     if (!1 === r) return !1;
     let { length: i } = t,
      a = r;
     for (; a >= 0 && a < i; ) {
      let r = t.charAt(a);
      if (e instanceof RegExp) {
       if (!e.test(r)) return a;
      } else if (!e.includes(r)) return a;
      s ? a-- : a++;
     }
     return (-1 === a || a === i) && a;
    };
   }
   Qt(/\s/u);
   var Zt = Qt(' \t'),
    er = Qt(',; \t'),
    tr = Qt(/[^\n\r]/u);
   function rr(e, t) {
    var r, n, s;
    if ('number' == typeof (null == (n = null == (r = e.source) ? void 0 : r.start) ? void 0 : n.offset)) return e.source.start.offset;
    if ('number' == typeof e.sourceIndex) return e.sourceIndex;
    if (null != (s = e.source) && s.start) return Yt(e.source.start, t);
    throw Object.assign(new Error('Can not locate node.'), { node: e });
   }
   function nr(e, t) {
    var r, n;
    if ('css-comment' === e.type && e.inline) return tr(t, e.source.startOffset);
    if ('number' == typeof (null == (n = null == (r = e.source) ? void 0 : r.end) ? void 0 : n.offset)) return e.source.end.offset;
    if (e.source) {
     if (e.source.end) return Yt(e.source.end, t);
     if (Bt(e.nodes)) return nr(ct(!1, e.nodes, -1), t);
    }
    return null;
   }
   function sr(e, t) {
    e.source && ((e.source.startOffset = rr(e, t)), (e.source.endOffset = nr(e, t)));
    for (let r in e) {
     let n = e[r];
     'source' === r || !n || 'object' != typeof n || ('value-root' === n.type || 'value-unknown' === n.type ? ir(n, ar(e), n.text || n.value) : sr(n, t));
    }
   }
   function ir(e, t, r) {
    e.source && ((e.source.startOffset = rr(e, r) + t), (e.source.endOffset = nr(e, r) + t));
    for (let n in e) {
     let s = e[n];
     'source' === n || !s || 'object' != typeof s || ir(s, t, r);
    }
   }
   function ar(e) {
    var t;
    let r = e.source.startOffset;
    return 'string' == typeof e.prop && (r += e.prop.length), 'css-atrule' === e.type && 'string' == typeof e.name && (r += 1 + e.name.length + e.raws.afterName.match(/^\s*:?\s*/u)[0].length), 'css-atrule' !== e.type && 'string' == typeof (null == (t = e.raws) ? void 0 : t.between) && (r += e.raws.between.length), r;
   }
   function or(e) {
    var t;
    return null == (t = e.source) ? void 0 : t.startOffset;
   }
   function ur(e) {
    var t;
    return null == (t = e.source) ? void 0 : t.endOffset;
   }
   var lr = /\*\/$/,
    pr = /^\/\*\*?/,
    cr = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/,
    hr = /(^|\s+)\/\/([^\n\r]*)/g,
    dr = /^(\r?\n)+/,
    fr = /(?:^|\r?\n) *(@[^\n\r]*?) *\r?\n *(?![^\n\r@]*\/\/[^]*)([^\s@][^\n\r@]+?) *\r?\n/g,
    mr = /(?:^|\r?\n) *@(\S+) *([^\n\r]*)/g,
    yr = /(\r?\n|^) *\* ?/g,
    gr = [];
   function Dr(e, t) {
    return [...gr, ...(Array.isArray(t) ? t : [t])].map((t) => `@${e} ${t}`.trim());
   }
   var xr = function (e) {
    if (!e.startsWith('#!')) return '';
    let t = e.indexOf('\n');
    return -1 === t ? e : e.slice(0, t);
   };
   function br(e) {
    let t = xr(e);
    t && (e = e.slice(t.length + 1));
    let r = (function (e) {
      let t = e.match(cr);
      return t ? t[0].trimStart() : '';
     })(e),
     { pragmas: n, comments: s } = (function (e) {
      e = Ke(!1, e.replace(pr, '').replace(lr, ''), yr, '$1');
      let t = '';
      for (; t !== e; ) (t = e), (e = Ke(!1, e, fr, '\n$1 $2\n'));
      e = e.replace(dr, '').trimEnd();
      let r,
       n = Object.create(null),
       s = Ke(!1, e, mr, '').replace(dr, '').trimEnd();
      for (; (r = mr.exec(e)); ) {
       let e = Ke(!1, r[2], hr, '');
       if ('string' == typeof n[r[1]] || Array.isArray(n[r[1]])) {
        let t = n[r[1]];
        n[r[1]] = [...gr, ...(Array.isArray(t) ? t : [t]), e];
       } else n[r[1]] = e;
      }
      return { comments: s, pragmas: n };
     })(r);
    return { shebang: t, text: e, pragmas: n, comments: s };
   }
   function vr(e) {
    let { shebang: t, text: r, pragmas: n, comments: s } = br(e),
     i = (function (e) {
      let t = e.match(cr),
       r = null == t ? void 0 : t[0];
      return null == r ? e : e.slice(r.length);
     })(r),
     a = (function ({ comments: e = '', pragmas: t = {} }) {
      let r = '\n',
       n = ' *',
       s = Object.keys(t),
       i = s
        .flatMap((e) => Dr(e, t[e]))
        .map((e) => `${n} ${e}${r}`)
        .join('');
      if (!e) {
       if (0 === s.length) return '';
       if (1 === s.length && !Array.isArray(t[s[0]])) {
        let e = t[s[0]];
        return `/** ${Dr(s[0], e)[0]} */`;
       }
      }
      let a =
       e
        .split(r)
        .map((e) => `${n} ${e}`)
        .join(r) + r;
      return '/**\n' + (e ? a : '') + (e && s.length > 0 ? n + r : '') + i + ' */';
     })({ pragmas: { format: '', ...n }, comments: s.trimStart() });
    return (t ? `${t}\n` : '') + a + (i.startsWith('\n') ? '\n' : '\n\n') + i;
   }
   var Er = 3;
   var Cr = function (e) {
    let t = (function (e) {
     let t = e.slice(0, Er);
     if ('---' !== t && '+++' !== t) return;
     let r = e.indexOf('\n', Er);
     if (-1 === r) return;
     let n = e.slice(Er, r).trim(),
      s = e.indexOf(`\n${t}`, r),
      i = n;
     if ((i || (i = '+++' === t ? 'toml' : 'yaml'), -1 === s && '---' === t && 'yaml' === i && (s = e.indexOf('\n...', r)), -1 === s)) return;
     let a = s + 1 + Er,
      o = e.charAt(a + 1);
     if (!/\s?/u.test(o)) return;
     let u = e.slice(0, a);
     return { type: 'front-matter', language: i, explicitLanguage: n, value: e.slice(r + 1, s), startDelimiter: t, endDelimiter: u.slice(-Er), raw: u };
    })(e);
    if (!t) return { content: e };
    let { raw: r } = t;
    return { frontMatter: t, content: Ke(!1, r, /[^\n]/gu, ' ') + e.slice(r.length) };
   };
   var Tr = new Set(['red', 'green', 'blue', 'alpha', 'a', 'rgb', 'hue', 'h', 'saturation', 's', 'lightness', 'l', 'whiteness', 'w', 'blackness', 'b', 'tint', 'shade', 'blend', 'blenda', 'contrast', 'hsl', 'hsla', 'hwb', 'hwba']);
   var Sr = new Set(['initial', 'inherit', 'unset', 'revert']);
   function wr(e, t) {
    var r;
    let n = e.findAncestor((e) => 'css-atrule' === e.type);
    return (null == (r = null == n ? void 0 : n.name) ? void 0 : r.toLowerCase().endsWith('keyframes')) && ['from', 'to'].includes(t.toLowerCase());
   }
   function Ar(e) {
    return e.includes('$') || e.includes('@') || e.includes('#') || e.startsWith('%') || e.startsWith('--') || e.startsWith(':--') || (e.includes('(') && e.includes(')')) ? e : e.toLowerCase();
   }
   function Fr(e, t) {
    var r;
    let n = e.findAncestor((e) => 'value-func' === e.type);
    return (null == (r = null == n ? void 0 : n.value) ? void 0 : r.toLowerCase()) === t;
   }
   function kr(e) {
    var t;
    let r = e.findAncestor((e) => 'css-rule' === e.type),
     n = null == (t = null == r ? void 0 : r.raws) ? void 0 : t.selector;
    return n && (n.startsWith(':import') || n.startsWith(':export'));
   }
   function Pr(e, t) {
    let r = Array.isArray(t) ? t : [t],
     n = e.findAncestor((e) => 'css-atrule' === e.type);
    return n && r.includes(n.name.toLowerCase());
   }
   function Ir(e) {
    let { selector: t } = e;
    return !!t && (('string' == typeof t && /^@.+:.*$/u.test(t)) || (t.value && /^@.+:.*$/u.test(t.value)));
   }
   function Nr(e) {
    return 'value-word' === e.type && ['from', 'through', 'end'].includes(e.value);
   }
   function Br(e) {
    return 'value-word' === e.type && ['and', 'or', 'not'].includes(e.value);
   }
   function _r(e) {
    return 'value-word' === e.type && 'in' === e.value;
   }
   function Lr(e) {
    return 'value-operator' === e.type && '*' === e.value;
   }
   function Or(e) {
    return 'value-operator' === e.type && '/' === e.value;
   }
   function Mr(e) {
    return 'value-operator' === e.type && '+' === e.value;
   }
   function jr(e) {
    return 'value-operator' === e.type && '-' === e.value;
   }
   function Rr(e) {
    return (
     Lr(e) ||
     Or(e) ||
     Mr(e) ||
     jr(e) ||
     (function (e) {
      return 'value-operator' === e.type && '%' === e.value;
     })(e)
    );
   }
   function qr(e) {
    return 'value-word' === e.type && ['==', '!='].includes(e.value);
   }
   function Ur(e) {
    return 'value-word' === e.type && ['<', '>', '<=', '>='].includes(e.value);
   }
   function $r(e, t) {
    return 'scss' === t.parser && 'css-atrule' === e.type && ['if', 'else', 'for', 'each', 'while'].includes(e.name);
   }
   function Hr(e) {
    var t;
    return (null == (t = e.raws) ? void 0 : t.params) && /^\(\s*\)$/u.test(e.raws.params);
   }
   function zr(e) {
    return e.name.startsWith('prettier-placeholder');
   }
   function Vr(e) {
    return e.prop.startsWith('@prettier-placeholder');
   }
   function Wr(e, t) {
    return '$$' === e.value && 'value-func' === e.type && 'value-word' === (null == t ? void 0 : t.type) && !t.raws.before;
   }
   function Jr(e) {
    var t, r, n;
    return 'value-paren_group' === (null == (n = null == (r = null == (t = e.value) ? void 0 : t.group) ? void 0 : r.group) ? void 0 : n.type) && null !== e.value.group.group.open && null !== e.value.group.group.close;
   }
   function Kr(e) {
    var t;
    return '' === (null == (t = e.raws) ? void 0 : t.before);
   }
   function Gr(e) {
    var t, r;
    return 'value-comma_group' === e.type && 'value-colon' === (null == (r = null == (t = e.groups) ? void 0 : t[1]) ? void 0 : r.type);
   }
   function Xr(e) {
    var t;
    return 'value-paren_group' === e.type && (null == (t = e.groups) ? void 0 : t[0]) && Gr(e.groups[0]);
   }
   function Yr(e, t) {
    var r;
    if ('scss' !== t.parser) return !1;
    let { node: n } = e;
    if (0 === n.groups.length) return !1;
    let s = e.grandparent;
    if (!(Xr(n) || (s && Xr(s)))) return !1;
    let i = e.findAncestor((e) => 'css-decl' === e.type);
    return !!((null != (r = null == i ? void 0 : i.prop) && r.startsWith('$')) || Xr(s) || 'value-func' === s.type);
   }
   function Qr(e) {
    return 'value-comment' === e.type && e.inline;
   }
   function Zr(e) {
    return 'value-word' === e.type && '#' === e.value;
   }
   function en(e) {
    return 'value-word' === e.type && '{' === e.value;
   }
   function tn(e) {
    return 'value-word' === e.type && '}' === e.value;
   }
   function rn(e) {
    return ['value-word', 'value-atword'].includes(e.type);
   }
   function nn(e) {
    return 'value-colon' === (null == e ? void 0 : e.type);
   }
   function sn(e) {
    return e.value && ['not', 'and', 'or'].includes(e.value.toLowerCase());
   }
   function an(e) {
    return 'value-func' === e.type && Tr.has(e.value.toLowerCase());
   }
   function on(e) {
    return /\/\//u.test(e.split(/[\n\r]/u).pop());
   }
   function un(e) {
    return 'value-atword' === (null == e ? void 0 : e.type) && e.value.startsWith('prettier-placeholder-');
   }
   function ln(e) {
    var t, r;
    return 'value-paren_group' === e.type && '(' === (null == (t = e.open) ? void 0 : t.value) && ')' === (null == (r = e.close) ? void 0 : r.value);
   }
   var pn = function (e, t, r) {
    var n;
    let { node: s } = e,
     i = e.parent,
     a = e.grandparent,
     o = (function (e) {
      var t, r;
      return null == (r = null == (t = e.findAncestor((e) => 'css-decl' === e.type)) ? void 0 : t.prop) ? void 0 : r.toLowerCase();
     })(e),
     u = o && 'value-value' === i.type && ('grid' === o || o.startsWith('grid-template')),
     l = e.findAncestor((e) => 'css-atrule' === e.type),
     p = l && $r(l, t),
     c = s.groups.some((e) => Qr(e)),
     h = e.map(r, 'groups'),
     d = [''],
     f = Fr(e, 'url'),
     m = !1,
     y = !1;
    for (let g = 0; g < s.groups.length; ++g) {
     let r = s.groups[g - 1],
      o = s.groups[g],
      c = s.groups[g + 1],
      D = s.groups[g + 2];
     if (Qr(o) && !c) {
      d.push([d.pop(), At([' ', h[g]])]);
      continue;
     }
     if ((d.push([d.pop(), h[g]]), f)) {
      ((c && Mr(c)) || Mr(o)) && d.push([d.pop(), ' ']);
      continue;
     }
     if ((nn(c) && 'value-word' === o.type && d.length > 2 && s.groups.slice(0, g).every((e) => 'value-comment' === e.type) && !Qr(r) && (d[d.length - 2] = Tt(ct(!1, d, -2))), (Pr(e, 'forward') && 'value-word' === o.type && o.value && void 0 !== r && 'value-word' === r.type && 'as' === r.value && 'value-operator' === c.type && '*' === c.value) || !c || ('value-word' === o.type && o.value.endsWith('-') && un(c)))) continue;
     if ('value-string' === o.type && o.quoted) {
      let e = o.value.lastIndexOf('#{'),
       t = o.value.lastIndexOf('}');
      -1 !== e && -1 !== t ? (m = e > t) : -1 !== e ? (m = !0) : -1 !== t && (m = !1);
     }
     if (m || nn(o) || nn(c) || ('value-atword' === o.type && ('' === o.value || o.value.endsWith('['))) || ('value-word' === c.type && c.value.startsWith(']')) || '~' === o.value || ('value-string' !== o.type && o.value && o.value.includes('\\') && c && 'value-comment' !== c.type) || (null != r && r.value && r.value.indexOf('\\') === r.value.length - 1 && 'value-operator' === o.type && '/' === o.value) || '\\' === o.value || Wr(o, c) || Zr(o) || en(o) || tn(c) || (en(c) && Kr(c)) || (tn(o) && Kr(c)) || ('--' === o.value && Zr(c))) continue;
     let x = Rr(o),
      b = Rr(c);
     if ((((x && Zr(c)) || (b && tn(o))) && Kr(c)) || (!r && Or(o)) || (Fr(e, 'calc') && (Mr(o) || Mr(c) || jr(o) || jr(c)) && Kr(c))) continue;
     let v = (Mr(o) || jr(o)) && 0 === g && ('value-number' === c.type || c.isHex) && a && an(a) && !Kr(c),
      E = 'value-func' === (null == D ? void 0 : D.type) || (D && rn(D)) || 'value-func' === o.type || rn(o),
      C = 'value-func' === c.type || rn(c) || 'value-func' === (null == r ? void 0 : r.type) || (r && rn(r));
     if ('scss' === t.parser && x && '-' === o.value && 'value-func' === c.type && ur(o) !== or(c)) d.push([d.pop(), ' ']);
     else if ((Lr(c) || Lr(o) || Fr(e, 'calc') || v || !((Or(c) && !E) || (Or(o) && !C) || (Mr(c) && !E) || (Mr(o) && !C) || jr(c) || jr(o)) || !(Kr(c) || (x && (!r || (r && Rr(r)))))) && (('scss' !== t.parser && 'less' !== t.parser) || !x || '-' !== o.value || !ln(c) || ur(o) !== or(c.open) || '(' !== c.open.value)) {
      if (Qr(o)) {
       if ('value-paren_group' === i.type) {
        d.push(Tt(It), '');
        continue;
       }
       d.push(It, '');
       continue;
      }
      if (p && (qr(c) || Ur(c) || Br(c) || _r(o) || Nr(o))) {
       d.push([d.pop(), ' ']);
       continue;
      }
      if (l && 'namespace' === l.name.toLowerCase()) {
       d.push([d.pop(), ' ']);
       continue;
      }
      if (u) {
       o.source && c.source && o.source.start.line !== c.source.start.line ? (d.push(It, ''), (y = !0)) : d.push([d.pop(), ' ']);
       continue;
      }
      if (b) {
       d.push([d.pop(), ' ']);
       continue;
      }
      if (!('...' === (null == c ? void 0 : c.value) || (un(o) && un(c) && ur(o) === or(c)))) {
       if (un(o) && ln(c) && ur(o) === or(c.open)) {
        d.push(Pt, '');
        continue;
       }
       if ('with' === o.value && ln(c)) {
        d = [[St(d), ' ']];
        continue;
       }
       (null != (n = o.value) && n.endsWith('#') && '{' === c.value && ln(c.group)) || (Qr(c) && !D) || d.push(kt, '');
      }
     }
    }
    return (
     c && d.push([d.pop(), Ft]),
     y && d.unshift('', It),
     p
      ? Ct(vt(d))
      : (function (e) {
           var t;
           let { node: r } = e;
           return 'url' === r.groups[0].value && 2 === r.groups.length && 'import' === (null == (t = e.findAncestor((e) => 'css-atrule' === e.type)) ? void 0 : t.name);
          })(e)
        ? Ct(St(d))
        : Ct(vt(St(d)))
    );
   };
   var cn = function (e) {
     return 1 === e.length
      ? e
      : e
         .toLowerCase()
         .replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(?=\d)/u, '$1$2')
         .replace(/^([+-]?[\d.]+)e[+-]?0+$/u, '$1')
         .replace(/^([+-])?\./u, '$10.')
         .replace(/(\.\d+?)0+(?=e|$)/u, '$1')
         .replace(/\.(?=e|$)/u, '');
    },
    hn = new Map([
     ['em', 'em'],
     ['rem', 'rem'],
     ['ex', 'ex'],
     ['rex', 'rex'],
     ['cap', 'cap'],
     ['rcap', 'rcap'],
     ['ch', 'ch'],
     ['rch', 'rch'],
     ['ic', 'ic'],
     ['ric', 'ric'],
     ['lh', 'lh'],
     ['rlh', 'rlh'],
     ['vw', 'vw'],
     ['svw', 'svw'],
     ['lvw', 'lvw'],
     ['dvw', 'dvw'],
     ['vh', 'vh'],
     ['svh', 'svh'],
     ['lvh', 'lvh'],
     ['dvh', 'dvh'],
     ['vi', 'vi'],
     ['svi', 'svi'],
     ['lvi', 'lvi'],
     ['dvi', 'dvi'],
     ['vb', 'vb'],
     ['svb', 'svb'],
     ['lvb', 'lvb'],
     ['dvb', 'dvb'],
     ['vmin', 'vmin'],
     ['svmin', 'svmin'],
     ['lvmin', 'lvmin'],
     ['dvmin', 'dvmin'],
     ['vmax', 'vmax'],
     ['svmax', 'svmax'],
     ['lvmax', 'lvmax'],
     ['dvmax', 'dvmax'],
     ['cm', 'cm'],
     ['mm', 'mm'],
     ['q', 'Q'],
     ['in', 'in'],
     ['pt', 'pt'],
     ['pc', 'pc'],
     ['px', 'px'],
     ['deg', 'deg'],
     ['grad', 'grad'],
     ['rad', 'rad'],
     ['turn', 'turn'],
     ['s', 's'],
     ['ms', 'ms'],
     ['hz', 'Hz'],
     ['khz', 'kHz'],
     ['dpi', 'dpi'],
     ['dpcm', 'dpcm'],
     ['dppx', 'dppx'],
     ['x', 'x'],
     ['cqw', 'cqw'],
     ['cqh', 'cqh'],
     ['cqi', 'cqi'],
     ['cqb', 'cqb'],
     ['cqmin', 'cqmin'],
     ['cqmax', 'cqmax'],
     ['fr', 'fr'],
    ]);
   function dn(e) {
    let t = e.toLowerCase();
    return hn.has(t) ? hn.get(t) : e;
   }
   var fn = /(["'])(?:(?!\1)[^\\]|\\.)*\1/gsu,
    mn = new RegExp(fn.source + `|(${/[$@]?[_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/giu.source})?(${/(?:\d*\.\d+|\d+\.?)(?:e[+-]?\d+)?/giu.source})(${/[a-z]+/giu.source})?`, 'giu');
   function yn(e, t) {
    return Ke(!1, e, fn, (e) => Rt(e, t));
   }
   function gn(e, t) {
    let r = t.singleQuote ? "'" : '"';
    return e.includes('"') || e.includes("'") ? e : r + e + r;
   }
   function Dn(e) {
    return Ke(!1, e, mn, (e, t, r, n, s) => (!r && n ? xn(n) + Ar(s || '') : e));
   }
   function xn(e) {
    return cn(e).replace(/\.0(?=$|e)/u, '');
   }
   var bn = function (e, t, r) {
    let n = !(null == r || !r.backwards);
    if (!1 === t) return !1;
    let s = e.charAt(t);
    if (n) {
     if ('\r' === e.charAt(t - 1) && '\n' === s) return t - 2;
     if ('\n' === s || '\r' === s || '\u2028' === s || '\u2029' === s) return t - 1;
    } else {
     if ('\r' === s && '\n' === e.charAt(t + 1)) return t + 2;
     if ('\n' === s || '\r' === s || '\u2028' === s || '\u2029' === s) return t + 1;
    }
    return t;
   };
   var vn = function (e, t, r = {}) {
    let n = Zt(e, r.backwards ? t - 1 : t, r);
    return n !== bn(e, n, r);
   };
   var En = function (e, t) {
    if (!1 === t) return !1;
    if ('/' === e.charAt(t) && '*' === e.charAt(t + 1)) for (let r = t + 2; r < e.length; ++r) if ('*' === e.charAt(r) && '/' === e.charAt(r + 1)) return r + 2;
    return t;
   };
   var Cn = function (e, t) {
    return !1 !== t && ('/' === e.charAt(t) && '/' === e.charAt(t + 1) ? tr(e, t) : t);
   };
   var Tn = function (e, t) {
    let r = null,
     n = t;
    for (; n !== r; ) (r = n), (n = er(e, n)), (n = En(e, n)), (n = Zt(e, n));
    return (n = Cn(e, n)), (n = bn(e, n)), !1 !== n && vn(e, n);
   };
   function Sn(e, t) {
    return (function (e) {
     return 'value-func' === e.type && 'var' === e.value.toLowerCase();
    })(e.grandparent) &&
     (function ({ node: e, parent: t }, r) {
      return !(!e.source || !r.originalText.slice(or(e), or(t.close)).trimEnd().endsWith(','));
     })(e, t)
     ? ','
     : 'value-comment' === e.node.type ||
         ('value-comma_group' === e.node.type && e.node.groups.every((e) => 'value-comment' === e.type)) ||
         !(function (e) {
          return 'es5' === e.trailingComma || 'all' === e.trailingComma;
         })(t) ||
         !e.callParent(() => Yr(e, t))
       ? ''
       : wt(',');
   }
   function wn(e, t, r) {
    let { node: n, parent: s } = e,
     i = e.map(({ node: e }) => ('string' == typeof e ? e : r()), 'groups');
    if (
     s &&
     (function (e) {
      return 'value-func' === e.type && 'url' === e.value.toLowerCase();
     })(s) &&
     (1 === n.groups.length || (n.groups.length > 0 && 'value-comma_group' === n.groups[0].type && n.groups[0].groups.length > 0 && 'value-word' === n.groups[0].groups[0].type && n.groups[0].groups[0].value.startsWith('data:')))
    )
     return [n.open ? r('open') : '', Nt(',', i), n.close ? r('close') : ''];
    if (!n.open) {
     let t = An(e);
     xt(i);
     let r = (function (e, t) {
       let r = [];
       for (let n = 0; n < e.length; n += t) r.push(e.slice(n, n + t));
       return r;
      })(Nt(',', i), 2),
      n = Nt(t ? It : kt, r);
     return vt(t ? [It, n] : Ct([Fn(e) ? Pt : '', St(n)]));
    }
    let a = e.map(({ node: r, isLast: n, index: s }) => {
      var a;
      let o = i[s];
      Gr(r) && 'value-comma_group' === r.type && r.groups && 'value-paren_group' !== r.groups[0].type && 'value-paren_group' === (null == (a = r.groups[2]) ? void 0 : a.type) && ht(o) === tt && ht(o.contents) === Qe && ht(o.contents.contents) === rt && (o = Ct(Tt(o)));
      let u = [o, n ? Sn(e, t) : ','];
      if (!n && 'value-comma_group' === r.type && Bt(r.groups)) {
       let e = ct(!1, r.groups, -1);
       !e.source && e.close && (e = e.close), e.source && Tn(t.originalText, ur(e)) && u.push(It);
      }
      return u;
     }, 'groups'),
     o = (function (e, t) {
      if (!Gr(t)) return !1;
      let { groups: r } = t,
       n = r.indexOf(e);
      return -1 !== n && nn(r[n + 1]);
     })(n, s),
     u = (function (e, t) {
      var r, n;
      if ('(' !== (null == (r = e.open) ? void 0 : r.value) || ')' !== (null == (n = e.close) ? void 0 : n.value) || e.groups.some((e) => 'value-comma_group' !== e.type)) return !1;
      if ('value-comma_group' === t.type) {
       let r = t.groups.indexOf(e) - 1,
        n = t.groups[r];
       if ('value-word' === (null == n ? void 0 : n.type) && 'with' === n.value) return !0;
      }
      return !1;
     })(n, s),
     l = Yr(e, t),
     p = u || (l && !o),
     c = u || o,
     h = Ct([n.open ? r('open') : '', vt([Pt, Nt(kt, a)]), Pt, n.close ? r('close') : ''], { shouldBreak: p });
    return c ? Tt(h) : h;
   }
   function An(e) {
    return e.match(
     (e) => 'value-paren_group' === e.type && !e.open && e.groups.some((e) => 'value-comma_group' === e.type),
     (e, t) => 'group' === t && 'value-value' === e.type,
     (e, t) => 'group' === t && 'value-root' === e.type,
     (e, t) => 'value' === t && (('css-decl' === e.type && !e.prop.startsWith('--')) || ('css-atrule' === e.type && e.variable)),
    );
   }
   function Fn(e) {
    return e.match(
     (e) => 'value-paren_group' === e.type && !e.open,
     (e, t) => 'group' === t && 'value-value' === e.type,
     (e, t) => 'group' === t && 'value-root' === e.type,
     (e, t) => 'value' === t && 'css-decl' === e.type,
    );
   }
   var kn = function (e, t, r) {
    let n = [];
    return (
     e.each(() => {
      let { node: s, previous: i } = e;
      if (('css-comment' === (null == i ? void 0 : i.type) && 'prettier-ignore' === i.text.trim() ? n.push(t.originalText.slice(or(s), ur(s))) : n.push(r()), e.isLast)) return;
      let { next: a } = e;
      ('css-comment' === a.type && !vn(t.originalText, or(a), { backwards: !0 }) && !Ut(s)) || ('css-atrule' === a.type && 'else' === a.name && 'css-comment' !== s.type) ? n.push(' ') : (n.push(t.__isHTMLStyleAttribute ? kt : It), Tn(t.originalText, ur(s)) && !Ut(s) && n.push(It));
     }, 'nodes'),
     n
    );
   };
   var Pn = {
     print: function (e, t, r) {
      var n, s, i, a, o, u;
      let { node: l } = e;
      switch (l.type) {
       case 'front-matter':
        return [l.raw, It];
       case 'css-root': {
        let n = kn(e, t, r),
         s = l.raws.after.trim();
        return s.startsWith(';') && (s = s.slice(1).trim()), [l.frontMatter ? [r('frontMatter'), It] : '', n, s ? ` ${s}` : '', l.nodes.length > 0 ? It : ''];
       }
       case 'css-comment': {
        let e = l.inline || l.raws.inline,
         r = t.originalText.slice(or(l), ur(l));
        return e ? r.trimEnd() : r;
       }
       case 'css-rule':
        return [r('selector'), l.important ? ' !important' : '', l.nodes ? ['selector-unknown' === (null == (n = l.selector) ? void 0 : n.type) && on(l.selector.value) ? kt : l.selector ? ' ' : '', '{', l.nodes.length > 0 ? vt([It, kn(e, t, r)]) : '', It, '}', Ir(l) ? ';' : ''] : ';'];
       case 'css-decl': {
        let n = e.parent,
         { between: a } = l.raws,
         o = a.trim(),
         u = ':' === o,
         p = 'string' == typeof l.value && /^ *$/u.test(l.value),
         c = 'string' == typeof l.value ? l.value : r('value');
        return (
         (c = (function (e) {
          var t, r;
          return 'value-root' === (null == (t = e.value) ? void 0 : t.type) && 'value-value' === (null == (r = e.value.group) ? void 0 : r.type) && 'composes' === e.prop.toLowerCase();
         })(l)
          ? (function (e) {
             return mt(e, yt);
            })(c)
          : c),
         !u && on(o) && !(null != (i = null == (s = l.value) ? void 0 : s.group) && i.group && e.call(() => An(e), 'value', 'group', 'group')) && (c = vt([It, Tt(c)])),
         [Ke(!1, l.raws.before, /[\s;]/gu, ''), ('css-atrule' === n.type && n.variable) || kr(e) ? l.prop : Ar(l.prop), o.startsWith('//') ? ' ' : '', o, l.extend || p ? '' : ' ', 'less' === t.parser && l.extend && l.selector ? ['extend(', r('selector'), ')'] : '', c, l.raws.important ? l.raws.important.replace(/\s*!\s*important/iu, ' !important') : l.important ? ' !important' : '', l.raws.scssDefault ? l.raws.scssDefault.replace(/\s*!default/iu, ' !default') : l.scssDefault ? ' !default' : '', l.raws.scssGlobal ? l.raws.scssGlobal.replace(/\s*!global/iu, ' !global') : l.scssGlobal ? ' !global' : '', l.nodes ? [' {', vt([Pt, kn(e, t, r)]), Pt, '}'] : Vr(l) && !n.raws.semicolon && ';' !== t.originalText[ur(l) - 1] ? '' : t.__isHTMLStyleAttribute && e.isLast ? wt(';') : ';']
        );
       }
       case 'css-atrule': {
        let n = e.parent,
         s = zr(l) && !n.raws.semicolon && ';' !== t.originalText[ur(l) - 1];
        if ('less' === t.parser) {
         if (l.mixin) return [r('selector'), l.important ? ' !important' : '', s ? '' : ';'];
         if (l.function) return [l.name, 'string' == typeof l.params ? l.params : r('params'), s ? '' : ';'];
         if (l.variable) return ['@', l.name, ': ', l.value ? r('value') : '', l.raws.between.trim() ? l.raws.between.trim() + ' ' : '', l.nodes ? ['{', vt([l.nodes.length > 0 ? Pt : '', kn(e, t, r)]), Pt, '}'] : '', s ? '' : ';'];
        }
        let i = 'import' === l.name && 'value-unknown' === (null == (a = l.params) ? void 0 : a.type) && l.params.value.endsWith(';');
        return ['@', Hr(l) || l.name.endsWith(':') || zr(l) ? l.name : Ar(l.name), l.params ? [Hr(l) ? '' : zr(l) ? ('' === l.raws.afterName ? '' : l.name.endsWith(':') ? ' ' : /^\s*\n\s*\n/u.test(l.raws.afterName) ? [It, It] : /^\s*\n/u.test(l.raws.afterName) ? It : ' ') : ' ', 'string' == typeof l.params ? l.params : r('params')] : '', l.selector ? vt([' ', r('selector')]) : '', l.value ? Ct([' ', r('value'), $r(l, t) ? (Jr(l) ? ' ' : kt) : '']) : 'else' === l.name ? ' ' : '', l.nodes ? [$r(l, t) ? '' : (l.selector && !l.selector.nodes && 'string' == typeof l.selector.value && on(l.selector.value)) || (!l.selector && 'string' == typeof l.params && on(l.params)) ? kt : ' ', '{', vt([l.nodes.length > 0 ? Pt : '', kn(e, t, r)]), Pt, '}'] : s || i ? '' : ';'];
       }
       case 'media-query-list': {
        let t = [];
        return (
         e.each(({ node: e }) => {
          ('media-query' === e.type && '' === e.value) || t.push(r());
         }, 'nodes'),
         Ct(vt(Nt(kt, t)))
        );
       }
       case 'media-query':
        return [Nt(' ', e.map(r, 'nodes')), e.isLast ? '' : ','];
       case 'media-type':
       case 'media-value':
        return Dn(yn(l.value, t));
       case 'media-feature-expression':
        return l.nodes ? ['(', ...e.map(r, 'nodes'), ')'] : l.value;
       case 'media-feature':
        return Ar(yn(Ke(!1, l.value, / +/gu, ' '), t));
       case 'media-colon':
        return [l.value, ' '];
       case 'media-keyword':
       case 'selector-string':
        return yn(l.value, t);
       case 'media-url':
        return yn(Ke(!1, Ke(!1, l.value, /^url\(\s+/giu, 'url('), /\s+\)$/gu, ')'), t);
       case 'media-unknown':
       case 'selector-comment':
       case 'selector-nesting':
       case 'value-paren':
       case 'value-operator':
       case 'value-unicode-range':
       case 'value-unknown':
        return l.value;
       case 'selector-root':
        return Ct([Pr(e, 'custom-selector') ? [e.findAncestor((e) => 'css-atrule' === e.type).customSelector, kt] : '', Nt([',', Pr(e, ['extend', 'custom-selector', 'nest']) ? kt : It], e.map(r, 'nodes'))]);
       case 'selector-selector':
        return Ct((l.nodes.length > 1 ? vt : (e) => e)(e.map(r, 'nodes')));
       case 'selector-tag':
        return [l.namespace ? [!0 === l.namespace ? '' : l.namespace.trim(), '|'] : '', 'selector-nesting' === (null == (o = e.previous) ? void 0 : o.type) ? l.value : Dn(wr(e, l.value) ? l.value.toLowerCase() : l.value)];
       case 'selector-id':
        return ['#', l.value];
       case 'selector-class':
        return ['.', Dn(yn(l.value, t))];
       case 'selector-attribute':
        return ['[', l.namespace ? [!0 === l.namespace ? '' : l.namespace.trim(), '|'] : '', l.attribute.trim(), l.operator ?? '', l.value ? gn(yn(l.value.trim(), t), t) : '', l.insensitive ? ' i' : '', ']'];
       case 'selector-combinator':
        if ('+' === l.value || '>' === l.value || '~' === l.value || '>>>' === l.value) {
         let t = e.parent;
         return ['selector-selector' === t.type && t.nodes[0] === l ? '' : kt, l.value, e.isLast ? '' : ' '];
        }
        return [l.value.trim().startsWith('(') ? kt : '', Dn(yn(l.value.trim(), t)) || kt];
       case 'selector-universal':
        return [l.namespace ? [!0 === l.namespace ? '' : l.namespace.trim(), '|'] : '', l.value];
       case 'selector-pseudo':
        return [Ar(l.value), Bt(l.nodes) ? Ct(['(', vt([Pt, Nt([',', kt], e.map(r, 'nodes'))]), Pt, ')']) : ''];
       case 'selector-unknown': {
        let r = e.findAncestor((e) => 'css-rule' === e.type);
        if (null != r && r.isSCSSNesterProperty) return Dn(yn(Ar(l.value), t));
        let n = e.parent;
        if (null != (u = n.raws) && u.selector) {
         let e = or(n),
          r = e + n.raws.selector.length;
         return t.originalText.slice(e, r).trim();
        }
        let s = e.grandparent;
        if ('value-paren_group' === n.type && 'value-func' === (null == s ? void 0 : s.type) && 'selector' === s.value) {
         let e = ur(n.open) + 1,
          r = or(n.close),
          s = t.originalText.slice(e, r).trim();
         return on(s) ? [Ft, s] : s;
        }
        return l.value;
       }
       case 'value-value':
       case 'value-root':
        return r('group');
       case 'value-comment':
        return t.originalText.slice(or(l), ur(l));
       case 'value-comma_group':
        return pn(e, t, r);
       case 'value-paren_group':
        return wn(e, t, r);
       case 'value-func':
        return [l.value, Pr(e, 'supports') && sn(l) ? ' ' : '', r('group')];
       case 'value-number':
        return [xn(l.value), dn(l.unit)];
       case 'value-word':
        return (l.isColor && l.isHex) ||
         (function (e) {
          return Sr.has(e.toLowerCase());
         })(l.value)
         ? l.value.toLowerCase()
         : l.value;
       case 'value-colon': {
        let { previous: t } = e;
        return Ct([l.value, ('string' == typeof (null == t ? void 0 : t.value) && t.value.endsWith('\\')) || Fr(e, 'url') ? '' : kt]);
       }
       case 'value-string':
        return Rt(l.raws.quote + l.value + l.raws.quote, t);
       case 'value-atword':
        return ['@', l.value];
       default:
        throw new qt(l, 'PostCSS');
      }
     },
     embed: Jt,
     insertPragma: function (e) {
      let { frontMatter: t, content: r } = Cr(e);
      return (t ? t.raw + '\n\n' : '') + vr(r);
     },
     massageAstNode: zt,
     getVisitorKeys: Xt,
    },
    In = [
     { linguistLanguageId: 50, name: 'CSS', type: 'markup', tmScope: 'source.css', aceMode: 'css', codemirrorMode: 'css', codemirrorMimeType: 'text/css', color: '#563d7c', extensions: ['.css', '.wxss'], parsers: ['css'], vscodeLanguageIds: ['css'] },
     { linguistLanguageId: 262764437, name: 'PostCSS', type: 'markup', color: '#dc3a0c', tmScope: 'source.postcss', group: 'CSS', extensions: ['.pcss', '.postcss'], aceMode: 'text', parsers: ['css'], vscodeLanguageIds: ['postcss'] },
     { linguistLanguageId: 198, name: 'Less', type: 'markup', color: '#1d365d', aliases: ['less-css'], extensions: ['.less'], tmScope: 'source.css.less', aceMode: 'less', codemirrorMode: 'css', codemirrorMimeType: 'text/css', parsers: ['less'], vscodeLanguageIds: ['less'] },
     { linguistLanguageId: 329, name: 'SCSS', type: 'markup', color: '#c6538c', tmScope: 'source.css.scss', aceMode: 'scss', codemirrorMode: 'css', codemirrorMimeType: 'text/x-scss', extensions: ['.scss'], parsers: ['scss'], vscodeLanguageIds: ['scss'] },
    ],
    Nn = { singleQuote: { category: 'Common', type: 'boolean', default: !1, description: 'Use single quotes instead of double quotes.' } },
    Bn = {};
   p(Bn, { css: () => hs, less: () => ds, scss: () => fs });
   var _n = c(N(), 1),
    Ln = c(q(), 1),
    On = c(ee(), 1);
   var Mn = function (e, t) {
    let r = new SyntaxError(e + ' (' + t.loc.start.line + ':' + t.loc.start.column + ')');
    return Object.assign(r, t);
   };
   function jn(e, t, r) {
    if (e && 'object' == typeof e) {
     delete e.parent;
     for (let n in e) jn(e[n], t, r), 'type' === n && 'string' == typeof e[n] && !e[n].startsWith(t) && (!r || !r.test(e[n])) && (e[n] = t + e[n]);
    }
    return e;
   }
   function Rn(e) {
    if (e && 'object' == typeof e) {
     delete e.parent;
     for (let t in e) Rn(e[t]);
     !Array.isArray(e) && e.value && !e.type && (e.type = 'unknown');
    }
    return e;
   }
   var qn = c(se(), 1).default.default;
   var Un = function (e) {
     let t;
     try {
      t = qn(e);
     } catch {
      return { type: 'selector-unknown', value: e };
     }
     return jn(Rn(t), 'media-');
    },
    $n = c(Ae(), 1);
   var Hn = function (e) {
     if (/\/\/|\/\*/u.test(e)) return { type: 'selector-unknown', value: e.trim() };
     let t;
     try {
      new $n.default((e) => {
       t = e;
      }).process(e);
     } catch {
      return { type: 'selector-unknown', value: e };
     }
     return jn(t, 'selector-');
    },
    zn = c(We(), 1),
    Vn = (e) => {
     for (; e.parent; ) e = e.parent;
     return e;
    };
   var Wn = function (e) {
    return Vn(e)
     .text.slice(e.group.open.sourceIndex + 1, e.group.close.sourceIndex)
     .trim();
   };
   var Jn = function (e) {
    if (Bt(e)) for (let t = e.length - 1; t > 0; t--) if ('word' === e[t].type && '{' === e[t].value && 'word' === e[t - 1].type && e[t - 1].value.endsWith('#')) return !0;
    return !1;
   };
   var Kn = function (e) {
    return e.some((e) => 'string' === e.type || ('func' === e.type && !e.value.endsWith('\\')));
   };
   var Gn = function (e, t) {
     return !('scss' !== t.parser || 'word' !== (null == e ? void 0 : e.type) || !e.value.startsWith('$'));
    },
    Xn = (e) => 'paren' === e.type && ')' === e.value;
   function Yn(e, t) {
    var r;
    let { nodes: n } = e,
     s = { open: null, close: null, groups: [], type: 'paren_group' },
     i = [s],
     a = s,
     o = { groups: [], type: 'comma_group' },
     u = [o];
    for (let l = 0; l < n.length; ++l) {
     let a = n[l];
     if (('scss' === t.parser && 'number' === a.type && '..' === a.unit && a.value.endsWith('.') && ((a.value = a.value.slice(0, -1)), (a.unit = '...')), 'func' === a.type && 'selector' === a.value && (a.group.groups = [Hn(Vn(e).text.slice(a.group.open.sourceIndex + 1, a.group.close.sourceIndex))]), 'func' === a.type && 'url' === a.value)) {
      let e = (null == (r = a.group) ? void 0 : r.groups) ?? [],
       n = [];
      for (let t = 0; t < e.length; t++) {
       let r = e[t];
       'comma_group' === r.type ? (n = [...n, ...r.groups]) : n.push(r);
      }
      (Jn(n) || (!Kn(n) && !Gn(n[0], t))) && (a.group.groups = [Wn(a)]);
     }
     if ('paren' === a.type && '(' === a.value) (s = { open: a, close: null, groups: [], type: 'paren_group' }), i.push(s), (o = { groups: [], type: 'comma_group' }), u.push(o);
     else if (Xn(a)) {
      if ((o.groups.length > 0 && s.groups.push(o), (s.close = a), 1 === u.length)) throw new Error('Unbalanced parenthesis');
      u.pop(), (o = ct(!1, u, -1)), o.groups.push(s), i.pop(), (s = ct(!1, i, -1));
     } else if ('comma' === a.type) {
      if (l === n.length - 3 && 'comment' === n[l + 1].type && Xn(n[l + 2])) continue;
      s.groups.push(o), (o = { groups: [], type: 'comma_group' }), (u[u.length - 1] = o);
     } else o.groups.push(a);
    }
    return o.groups.length > 0 && s.groups.push(o), a;
   }
   function Qn(e) {
    return ('paren_group' === e.type && !e.open && !e.close && 1 === e.groups.length) || ('comma_group' === e.type && 1 === e.groups.length) ? Qn(e.groups[0]) : 'paren_group' === e.type || 'comma_group' === e.type ? { ...e, groups: e.groups.map(Qn) } : e;
   }
   function Zn(e, t) {
    if (e && 'object' == typeof e) for (let r in e) 'parent' !== r && (Zn(e[r], t), 'nodes' === r && ((e.group = Qn(Yn(e, t))), delete e[r]));
    return e;
   }
   var es = function (e, t) {
     if ('less' === t.parser && e.startsWith('~`')) return { type: 'value-unknown', value: e };
     let r = null;
     try {
      r = new zn.default(e, { loose: !0 }).parse();
     } catch {
      return { type: 'value-unknown', value: e };
     }
     return (r.text = e), jn(Zn(r, t), 'value-', /^selector-/u);
    },
    ts = new Set(['import', 'use', 'forward']);
   var rs = function (e) {
    return ts.has(e);
   };
   var ns = function (e, t) {
     return (
      !('scss' !== t.parser || !e.selector) &&
      e.selector
       .replace(/\/\*.*?\*\//u, '')
       .replace(/\/\/.*\n/u, '')
       .trim()
       .endsWith(':')
     );
    },
    ss = /(\s*)(!default).*$/u,
    is = /(\s*)(!global).*$/u;
   function as(e, t) {
    var r, n;
    if (e && 'object' == typeof e) {
     delete e.parent;
     for (let r in e) as(e[r], t);
     if (!e.type) return e;
     if ((e.raws ?? (e.raws = {}), 'css-decl' === e.type && 'string' == typeof e.prop && e.prop.startsWith('--') && 'string' == typeof e.value && e.value.startsWith('{'))) {
      let n;
      if (e.value.trimEnd().endsWith('}')) {
       let s,
        i,
        a = t.originalText.slice(0, e.source.start.offset),
        o = 'a'.repeat(e.prop.length) + t.originalText.slice(e.source.start.offset + e.prop.length, e.source.end.offset),
        u = Ke(!1, a, /[^\n]/gu, ' ') + o;
       s = 'scss' === t.parser ? ps : 'less' === t.parser ? ls : us;
       try {
        i = s(u, { ...t });
       } catch {}
       1 === (null == (r = null == i ? void 0 : i.nodes) ? void 0 : r.length) && 'css-rule' === i.nodes[0].type && (n = i.nodes[0].nodes);
      }
      return (e.value = n ? { type: 'css-rule', nodes: n } : { type: 'value-unknown', value: e.raws.value.raw }), e;
     }
     let s = '';
     'string' == typeof e.selector && ((s = e.raws.selector ? (e.raws.selector.scss ?? e.raws.selector.raw) : e.selector), e.raws.between && e.raws.between.trim().length > 0 && (s += e.raws.between), (e.raws.selector = s));
     let i = '';
     'string' == typeof e.value && ((i = e.raws.value ? (e.raws.value.scss ?? e.raws.value.raw) : e.value), (e.raws.value = i.trim()));
     let a = '';
     if (('string' == typeof e.params && ((a = e.raws.params ? (e.raws.params.scss ?? e.raws.params.raw) : e.params), e.raws.afterName && e.raws.afterName.trim().length > 0 && (a = e.raws.afterName + a), e.raws.between && e.raws.between.trim().length > 0 && (a += e.raws.between), (a = a.trim()), (e.raws.params = a)), s.trim().length > 0)) return s.startsWith('@') && s.endsWith(':') ? e : e.mixin ? ((e.selector = es(s, t)), e) : (ns(e, t) && (e.isSCSSNesterProperty = !0), (e.selector = Hn(s)), e);
     if (i.trim().length > 0) {
      let r = i.match(ss);
      r && ((i = i.slice(0, r.index)), (e.scssDefault = !0), '!default' !== r[0].trim() && (e.raws.scssDefault = r[0]));
      let n = i.match(is);
      if ((n && ((i = i.slice(0, n.index)), (e.scssGlobal = !0), '!global' !== n[0].trim() && (e.raws.scssGlobal = n[0])), i.startsWith('progid:'))) return { type: 'value-unknown', value: i };
      e.value = es(i, t);
     }
     if (('less' === t.parser && 'css-decl' === e.type && i.startsWith('extend(') && (e.extend || (e.extend = ':' === e.raws.between), e.extend && !e.selector && (delete e.value, (e.selector = Hn(i.slice(7, -1))))), 'css-atrule' === e.type)) {
      if ('less' === t.parser) {
       if (e.mixin) {
        let t = e.raws.identifier + e.name + e.raws.afterName + e.raws.params;
        return (e.selector = Hn(t)), delete e.params, e;
       }
       if (e.function) return e;
      }
      if ('css' === t.parser && 'custom-selector' === e.name) {
       let t = e.params.match(/:--\S+\s+/u)[0].trim();
       return (e.customSelector = t), (e.selector = Hn(e.params.slice(t.length).trim())), delete e.params, e;
      }
      if ('less' === t.parser) {
       if (e.name.includes(':') && !e.params) {
        e.variable = !0;
        let r = e.name.split(':');
        (e.name = r[0]), (e.value = es(r.slice(1).join(':'), t));
       }
       if (!['page', 'nest', 'keyframes'].includes(e.name) && ':' === (null == (n = e.params) ? void 0 : n[0])) {
        e.variable = !0;
        let r = e.params.slice(1);
        r && (e.value = es(r, t)), (e.raws.afterName += ':');
       }
       if (e.variable) return delete e.params, e.value || delete e.value, e;
      }
     }
     if ('css-atrule' === e.type && a.length > 0) {
      let { name: r } = e,
       n = e.name.toLowerCase();
      return 'warn' === r || 'error' === r ? ((e.params = { type: 'media-unknown', value: a }), e) : 'extend' === r || 'nest' === r ? ((e.selector = Hn(a)), delete e.params, e) : 'at-root' === r ? (/^\(\s*(?:without|with)\s*:.+\)$/su.test(a) ? (e.params = es(a, t)) : ((e.selector = Hn(a)), delete e.params), e) : rs(n) ? ((e.import = !0), delete e.filename, (e.params = es(a, t)), e) : ['namespace', 'supports', 'if', 'else', 'for', 'each', 'while', 'debug', 'mixin', 'include', 'function', 'return', 'define-mixin', 'add-mixin'].includes(r) ? ((a = a.replace(/(\$\S+?)(\s+)?\.{3}/u, '$1...$2')), (a = a.replace(/^(?!if)(\S+)(\s+)\(/u, '$1($2')), (e.value = es(a, t)), delete e.params, e) : ['media', 'custom-media'].includes(n) ? (a.includes('#{') ? { type: 'media-unknown', value: a } : ((e.params = Un(a)), e)) : ((e.params = a), e);
     }
    }
    return e;
   }
   function os(e, t, r) {
    let n,
     s = Cr(t),
     { frontMatter: i } = s;
    t = s.content;
    try {
     n = e(t, { map: !1 });
    } catch (a) {
     let { name: e, reason: t, line: r, column: n } = a;
     throw 'number' != typeof r ? a : Mn(`${e}: ${t}`, { loc: { start: { line: r, column: n } }, cause: a });
    }
    return (r.originalText = t), (n = as(jn(n, 'css-'), r)), sr(n, t), i && ((i.source = { startOffset: 0, endOffset: i.raw.length }), (n.frontMatter = i)), n;
   }
   function us(e, t = {}) {
    return os(_n.default.default, e, t);
   }
   function ls(e, t = {}) {
    return os(
     (e) =>
      Ln.default.parse(
       (function (e) {
        let t,
         r = 'initial',
         n = 'initial',
         s = !1,
         i = [];
        for (let a = 0; a < e.length; a++) {
         let o = e[a];
         switch (r) {
          case 'initial':
           if ("'" === o) {
            r = 'single-quotes';
            continue;
           }
           if ('"' === o) {
            r = 'double-quotes';
            continue;
           }
           if (('u' === o || 'U' === o) && 'url(' === e.slice(a, a + 4).toLowerCase()) {
            (r = 'url'), (a += 3);
            continue;
           }
           if ('*' === o && '/' === e[a - 1]) {
            r = 'comment-block';
            continue;
           }
           if ('/' === o && '/' === e[a - 1]) {
            (r = 'comment-inline'), (t = a - 1);
            continue;
           }
           continue;
          case 'single-quotes':
           if (("'" === o && '\\' !== e[a - 1] && ((r = n), (n = 'initial')), '\n' === o || '\r' === o)) return e;
           continue;
          case 'double-quotes':
           if (('"' === o && '\\' !== e[a - 1] && ((r = n), (n = 'initial')), '\n' === o || '\r' === o)) return e;
           continue;
          case 'url':
           if ((')' === o && (r = 'initial'), '\n' === o || '\r' === o)) return e;
           if ("'" === o) {
            (r = 'single-quotes'), (n = 'url');
            continue;
           }
           if ('"' === o) {
            (r = 'double-quotes'), (n = 'url');
            continue;
           }
           continue;
          case 'comment-block':
           '/' === o && '*' === e[a - 1] && (r = 'initial');
           continue;
          case 'comment-inline':
           ('"' === o || "'" === o || '*' === o) && (s = !0), ('\n' === o || '\r' === o) && (s && i.push([t, a]), (r = 'initial'), (s = !1));
           continue;
         }
        }
        for (let [a, o] of i) e = e.slice(0, a) + Ke(!1, e.slice(a, o), /["'*]/gu, ' ') + e.slice(o);
        return e;
       })(e),
      ),
     e,
     t,
    );
   }
   function ps(e, t = {}) {
    return os(On.default, e, t);
   }
   var cs = {
     astFormat: 'postcss',
     hasPragma: function (e) {
      return (function (e) {
       let { pragmas: t } = br(e);
       return Object.prototype.hasOwnProperty.call(t, 'prettier') || Object.prototype.hasOwnProperty.call(t, 'format');
      })(Cr(e).content);
     },
     locStart: or,
     locEnd: ur,
    },
    hs = { ...cs, parse: us },
    ds = { ...cs, parse: ls },
    fs = { ...cs, parse: ps },
    ms = { postcss: Pn },
    ys = Je;
  },
  75119: (e, t, r) => {
   r.d(t, { ZP: () => _n });
   var n = Object.create,
    s = Object.defineProperty,
    i = Object.getOwnPropertyDescriptor,
    a = Object.getOwnPropertyNames,
    o = Object.getPrototypeOf,
    u = Object.prototype.hasOwnProperty,
    l = (e) => {
     throw TypeError(e);
    },
    p = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports),
    c = (e, t) => {
     for (var r in t) s(e, r, { get: t[r], enumerable: !0 });
    },
    h = (e, t, r) => (
     (r = null != e ? n(o(e)) : {}),
     ((e, t, r, n) => {
      if ((t && 'object' == typeof t) || 'function' == typeof t) for (let o of a(t)) !u.call(e, o) && o !== r && s(e, o, { get: () => t[o], enumerable: !(n = i(t, o)) || n.enumerable });
      return e;
     })(!t && e && e.__esModule ? r : s(r, 'default', { value: e, enumerable: !0 }), e)
    ),
    d = (e, t, r) => (
     ((e, t, r) => {
      t.has(e) || l('Cannot ' + r);
     })(e, t, 'access private method'),
     r
    ),
    f = p((e, t) => {
     var r = new Proxy(String, { get: () => r });
     t.exports = r;
    }),
    m = p((e) => {
     Object.defineProperty(e, '__esModule', { value: !0 });
     var t = /\r\n|[\n\r\u2028\u2029]/;
     e.codeFrameColumns = function (e, r, n = {}) {
      let s = new Proxy({}, { get: () => (e) => e }),
       i = e.split(t),
       {
        start: a,
        end: o,
        markerLines: u,
       } = (function (e, t, r) {
        let n = Object.assign({ column: 0, line: -1 }, e.start),
         s = Object.assign({}, n, e.end),
         { linesAbove: i = 2, linesBelow: a = 3 } = r || {},
         o = n.line,
         u = n.column,
         l = s.line,
         p = s.column,
         c = Math.max(o - (i + 1), 0),
         h = Math.min(t.length, l + a);
        -1 === o && (c = 0), -1 === l && (h = t.length);
        let d = l - o,
         f = {};
        if (d)
         for (let m = 0; m <= d; m++) {
          let e = m + o;
          if (u)
           if (0 === m) {
            let r = t[e - 1].length;
            f[e] = [u, r - u + 1];
           } else if (m === d) f[e] = [0, p];
           else {
            let r = t[e - m].length;
            f[e] = [0, r];
           }
          else f[e] = !0;
         }
        else f[o] = u === p ? !u || [u, 0] : [u, p - u];
        return { start: c, end: h, markerLines: f };
       })(r, i, n),
       l = r.start && 'number' == typeof r.start.column,
       p = String(o).length,
       c = e
        .split(t, o)
        .slice(a, o)
        .map((e, t) => {
         let r = a + 1 + t,
          i = ` ${` ${r}`.slice(-p)} |`,
          o = u[r],
          l = !u[r + 1];
         if (o) {
          let t = '';
          if (Array.isArray(o)) {
           let r = e.slice(0, Math.max(o[0] - 1, 0)).replace(/[^\t]/g, ' '),
            a = o[1] || 1;
           (t = ['\n ', s.gutter(i.replace(/\d/g, ' ')), ' ', r, s.marker('^').repeat(a)].join('')), l && n.message && (t += ' ' + s.message(n.message));
          }
          return [s.marker('>'), s.gutter(i), e.length > 0 ? ` ${e}` : '', t].join('');
         }
         return ` ${s.gutter(i)}${e.length > 0 ? ` ${e}` : ''}`;
        })
        .join('\n');
      return n.message && !l && (c = `${' '.repeat(p + 1)}${n.message}\n${c}`), c;
     };
    }),
    y = {};
   c(y, { __debug: () => Bn, check: () => In, doc: () => on, format: () => Pn, formatWithCursor: () => kn, getSupportInfo: () => Nn, util: () => hn, version: () => cn });
   var g = (e, t, r, n) => {
    if (!e || null != t) return t.replaceAll ? t.replaceAll(r, n) : r.global ? t.replace(r, n) : t.split(r).join(n);
   };
   function D() {}
   function x(e, t, r, n, s) {
    for (var i, a = []; t; ) a.push(t), (i = t.previousComponent), delete t.previousComponent, (t = i);
    a.reverse();
    for (var o = 0, u = a.length, l = 0, p = 0; o < u; o++) {
     var c = a[o];
     if (c.removed) (c.value = e.join(n.slice(p, p + c.count))), (p += c.count);
     else {
      if (!c.added && s) {
       var h = r.slice(l, l + c.count);
       (h = h.map(function (e, t) {
        var r = n[p + t];
        return r.length > e.length ? r : e;
       })),
        (c.value = e.join(h));
      } else c.value = e.join(r.slice(l, l + c.count));
      (l += c.count), c.added || (p += c.count);
     }
    }
    return a;
   }
   D.prototype = {
    diff: function (e, t) {
     var r,
      n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
      s = n.callback;
     'function' == typeof n && ((s = n), (n = {}));
     var i = this;
     function a(e) {
      return (
       (e = i.postProcess(e, n)),
       s
        ? (setTimeout(function () {
           s(e);
          }, 0),
          !0)
        : e
      );
     }
     (e = this.castInput(e, n)), (t = this.castInput(t, n)), (e = this.removeEmpty(this.tokenize(e, n)));
     var o = (t = this.removeEmpty(this.tokenize(t, n))).length,
      u = e.length,
      l = 1,
      p = o + u;
     null != n.maxEditLength && (p = Math.min(p, n.maxEditLength));
     var c = null !== (r = n.timeout) && void 0 !== r ? r : 1 / 0,
      h = Date.now() + c,
      d = [{ oldPos: -1, lastComponent: void 0 }],
      f = this.extractCommon(d[0], t, e, 0, n);
     if (d[0].oldPos + 1 >= u && f + 1 >= o) return a(x(i, d[0].lastComponent, t, e, i.useLongestToken));
     var m = -1 / 0,
      y = 1 / 0;
     function g() {
      for (var r = Math.max(m, -l); r <= Math.min(y, l); r += 2) {
       var s = void 0,
        p = d[r - 1],
        c = d[r + 1];
       p && (d[r - 1] = void 0);
       var h = !1;
       if (c) {
        var g = c.oldPos - r;
        h = c && 0 <= g && g < o;
       }
       var D = p && p.oldPos + 1 < u;
       if (h || D) {
        if (((s = !D || (h && p.oldPos < c.oldPos) ? i.addToPath(c, !0, !1, 0, n) : i.addToPath(p, !1, !0, 1, n)), (f = i.extractCommon(s, t, e, r, n)), s.oldPos + 1 >= u && f + 1 >= o)) return a(x(i, s.lastComponent, t, e, i.useLongestToken));
        (d[r] = s), s.oldPos + 1 >= u && (y = Math.min(y, r - 1)), f + 1 >= o && (m = Math.max(m, r + 1));
       } else d[r] = void 0;
      }
      l++;
     }
     if (s)
      !(function e() {
       setTimeout(function () {
        if (l > p || Date.now() > h) return s();
        g() || e();
       }, 0);
      })();
     else
      for (; l <= p && Date.now() <= h; ) {
       var D = g();
       if (D) return D;
      }
    },
    addToPath: function (e, t, r, n, s) {
     var i = e.lastComponent;
     return i && !s.oneChangePerToken && i.added === t && i.removed === r ? { oldPos: e.oldPos + n, lastComponent: { count: i.count + 1, added: t, removed: r, previousComponent: i.previousComponent } } : { oldPos: e.oldPos + n, lastComponent: { count: 1, added: t, removed: r, previousComponent: i } };
    },
    extractCommon: function (e, t, r, n, s) {
     for (var i = t.length, a = r.length, o = e.oldPos, u = o - n, l = 0; u + 1 < i && o + 1 < a && this.equals(r[o + 1], t[u + 1], s); ) u++, o++, l++, s.oneChangePerToken && (e.lastComponent = { count: 1, previousComponent: e.lastComponent, added: !1, removed: !1 });
     return l && !s.oneChangePerToken && (e.lastComponent = { count: l, previousComponent: e.lastComponent, added: !1, removed: !1 }), (e.oldPos = o), u;
    },
    equals: function (e, t, r) {
     return r.comparator ? r.comparator(e, t) : e === t || (r.ignoreCase && e.toLowerCase() === t.toLowerCase());
    },
    removeEmpty: function (e) {
     for (var t = [], r = 0; r < e.length; r++) e[r] && t.push(e[r]);
     return t;
    },
    castInput: function (e) {
     return e;
    },
    tokenize: function (e) {
     return Array.from(e);
    },
    join: function (e) {
     return e.join('');
    },
    postProcess: function (e) {
     return e;
    },
   };
   new D();
   function b(e, t) {
    var r;
    for (r = 0; r < e.length && r < t.length; r++) if (e[r] != t[r]) return e.slice(0, r);
    return e.slice(0, r);
   }
   function v(e, t) {
    var r;
    if (!e || !t || e[e.length - 1] != t[t.length - 1]) return '';
    for (r = 0; r < e.length && r < t.length; r++) if (e[e.length - (r + 1)] != t[t.length - (r + 1)]) return e.slice(-r);
    return e.slice(-r);
   }
   function E(e, t, r) {
    if (e.slice(0, t.length) != t) throw Error('string '.concat(JSON.stringify(e), " doesn't start with prefix ").concat(JSON.stringify(t), '; this is a bug'));
    return r + e.slice(t.length);
   }
   function C(e, t, r) {
    if (!t) return e + r;
    if (e.slice(-t.length) != t) throw Error('string '.concat(JSON.stringify(e), " doesn't end with suffix ").concat(JSON.stringify(t), '; this is a bug'));
    return e.slice(0, -t.length) + r;
   }
   function T(e, t) {
    return E(e, t, '');
   }
   function S(e, t) {
    return C(e, t, '');
   }
   function w(e, t) {
    return t.slice(
     0,
     (function (e, t) {
      var r = 0;
      e.length > t.length && (r = e.length - t.length);
      var n = t.length;
      e.length < t.length && (n = e.length);
      var s = Array(n),
       i = 0;
      s[0] = 0;
      for (var a = 1; a < n; a++) {
       for (t[a] == t[i] ? (s[a] = s[i]) : (s[a] = i); i > 0 && t[a] != t[i]; ) i = s[i];
       t[a] == t[i] && i++;
      }
      i = 0;
      for (var o = r; o < e.length; o++) {
       for (; i > 0 && e[o] != t[i]; ) i = s[i];
       e[o] == t[i] && i++;
      }
      return i;
     })(e, t),
    );
   }
   var A = 'a-zA-Z0-9_\\u{C0}-\\u{FF}\\u{D8}-\\u{F6}\\u{F8}-\\u{2C6}\\u{2C8}-\\u{2D7}\\u{2DE}-\\u{2FF}\\u{1E00}-\\u{1EFF}',
    F = new RegExp('['.concat(A, ']+|\\s+|[^').concat(A, ']'), 'ug'),
    k = new D();
   function P(e, t, r, n) {
    if (t && r) {
     var s = t.value.match(/^\s*/)[0],
      i = t.value.match(/\s*$/)[0],
      a = r.value.match(/^\s*/)[0],
      o = r.value.match(/\s*$/)[0];
     if (e) {
      var u = b(s, a);
      (e.value = C(e.value, a, u)), (t.value = T(t.value, u)), (r.value = T(r.value, u));
     }
     if (n) {
      var l = v(i, o);
      (n.value = E(n.value, o, l)), (t.value = S(t.value, l)), (r.value = S(r.value, l));
     }
    } else if (r) e && (r.value = r.value.replace(/^\s*/, '')), n && (n.value = n.value.replace(/^\s*/, ''));
    else if (e && n) {
     var p = n.value.match(/^\s*/)[0],
      c = t.value.match(/^\s*/)[0],
      h = t.value.match(/\s*$/)[0],
      d = b(p, c);
     t.value = T(t.value, d);
     var f = v(T(p, d), h);
     (t.value = S(t.value, f)), (n.value = E(n.value, p, f)), (e.value = C(e.value, p, p.slice(0, p.length - f.length)));
    } else if (n) {
     var m = n.value.match(/^\s*/)[0],
      y = w(t.value.match(/\s*$/)[0], m);
     t.value = S(t.value, y);
    } else if (e) {
     var g = w(e.value.match(/\s*$/)[0], t.value.match(/^\s*/)[0]);
     t.value = T(t.value, g);
    }
   }
   (k.equals = function (e, t, r) {
    return r.ignoreCase && ((e = e.toLowerCase()), (t = t.toLowerCase())), e.trim() === t.trim();
   }),
    (k.tokenize = function (e) {
     var t,
      r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
     if (r.intlSegmenter) {
      if ('word' != r.intlSegmenter.resolvedOptions().granularity) throw new Error('The segmenter passed must have a granularity of "word"');
      t = Array.from(r.intlSegmenter.segment(e), function (e) {
       return e.segment;
      });
     } else t = e.match(F) || [];
     var n = [],
      s = null;
     return (
      t.forEach(function (e) {
       /\s/.test(e) ? (null == s ? n.push(e) : n.push(n.pop() + e)) : /\s/.test(s) ? (n[n.length - 1] == s ? n.push(n.pop() + e) : n.push(s + e)) : n.push(e), (s = e);
      }),
      n
     );
    }),
    (k.join = function (e) {
     return e
      .map(function (e, t) {
       return 0 == t ? e : e.replace(/^\s+/, '');
      })
      .join('');
    }),
    (k.postProcess = function (e, t) {
     if (!e || t.oneChangePerToken) return e;
     var r = null,
      n = null,
      s = null;
     return (
      e.forEach(function (e) {
       e.added ? (n = e) : e.removed ? (s = e) : ((n || s) && P(r, s, n, e), (r = e), (n = null), (s = null));
      }),
      (n || s) && P(r, s, n, null),
      e
     );
    }),
    (new D().tokenize = function (e) {
     var t = new RegExp('(\\r?\\n)|['.concat(A, ']+|[^\\S\\n\\r]+|[^').concat(A, ']'), 'ug');
     return e.match(t) || [];
    });
   var I = new D();
   function N(e) {
    return (N =
     'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
      ? function (e) {
         return typeof e;
        }
      : function (e) {
         return e && 'function' == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e;
        })(e);
   }
   (I.tokenize = function (e, t) {
    t.stripTrailingCr && (e = e.replace(/\r\n/g, '\n'));
    var r = [],
     n = e.split(/(\n|\r\n)/);
    n[n.length - 1] || n.pop();
    for (var s = 0; s < n.length; s++) {
     var i = n[s];
     s % 2 && !t.newlineIsToken ? (r[r.length - 1] += i) : r.push(i);
    }
    return r;
   }),
    (I.equals = function (e, t, r) {
     return r.ignoreWhitespace ? ((!r.newlineIsToken || !e.includes('\n')) && (e = e.trim()), (!r.newlineIsToken || !t.includes('\n')) && (t = t.trim())) : r.ignoreNewlineAtEof && !r.newlineIsToken && (e.endsWith('\n') && (e = e.slice(0, -1)), t.endsWith('\n') && (t = t.slice(0, -1))), D.prototype.equals.call(this, e, t, r);
    }),
    (new D().tokenize = function (e) {
     return e.split(/(\S.+?[.!?])(?=\s+|$)/);
    }),
    (new D().tokenize = function (e) {
     return e.split(/([{}:;,]|\s+)/);
    });
   var B = new D();
   function _(e, t, r, n, s) {
    var i, a;
    for (t = t || [], r = r || [], n && (e = n(s, e)), i = 0; i < t.length; i += 1) if (t[i] === e) return r[i];
    if ('[object Array]' === Object.prototype.toString.call(e)) {
     for (t.push(e), a = new Array(e.length), r.push(a), i = 0; i < e.length; i += 1) a[i] = _(e[i], t, r, n, s);
     return t.pop(), r.pop(), a;
    }
    if ((e && e.toJSON && (e = e.toJSON()), 'object' === N(e) && null !== e)) {
     t.push(e), (a = {}), r.push(a);
     var o,
      u = [];
     for (o in e) Object.prototype.hasOwnProperty.call(e, o) && u.push(o);
     for (u.sort(), i = 0; i < u.length; i += 1) a[(o = u[i])] = _(e[o], t, r, n, o);
     t.pop(), r.pop();
    } else a = e;
    return a;
   }
   (B.useLongestToken = !0),
    (B.tokenize = I.tokenize),
    (B.castInput = function (e, t) {
     var r = t.undefinedReplacement,
      n = t.stringifyReplacer,
      s =
       void 0 === n
        ? function (e, t) {
           return typeof t > 'u' ? r : t;
          }
        : n;
     return 'string' == typeof e ? e : JSON.stringify(_(e, null, null, s), s, '  ');
    }),
    (B.equals = function (e, t, r) {
     return D.prototype.equals.call(B, e.replace(/,([\r\n])/g, '$1'), t.replace(/,([\r\n])/g, '$1'), r);
    });
   var L = new D();
   function O(e) {
    switch (e) {
     case 'cr':
      return '\r';
     case 'crlf':
      return '\r\n';
     default:
      return '\n';
    }
   }
   function M(e, t) {
    let r;
    switch (t) {
     case '\n':
      r = /\n/gu;
      break;
     case '\r':
      r = /\r/gu;
      break;
     case '\r\n':
      r = /\r\n/gu;
      break;
     default:
      throw new Error(`Unexpected "eol" ${JSON.stringify(t)}.`);
    }
    let n = e.match(r);
    return n ? n.length : 0;
   }
   (L.tokenize = function (e) {
    return e.slice();
   }),
    (L.join = L.removeEmpty =
     function (e) {
      return e;
     });
   var j = 'string',
    R = 'array',
    q = 'cursor',
    U = 'indent',
    $ = 'align',
    H = 'trim',
    z = 'group',
    V = 'fill',
    W = 'if-break',
    J = 'indent-if-break',
    K = 'line-suffix',
    G = 'line-suffix-boundary',
    X = 'line',
    Y = 'label',
    Q = 'break-parent',
    Z = new Set([q, U, $, H, z, V, W, J, K, G, X, Y, Q]),
    ee = (e, t, r) => {
     if (!e || null != t) return Array.isArray(t) || 'string' == typeof t ? t[r < 0 ? t.length + r : r] : t.at(r);
    };
   var te = function (e) {
    if ('string' == typeof e) return j;
    if (Array.isArray(e)) return R;
    if (!e) return;
    let { type: t } = e;
    return Z.has(t) ? t : void 0;
   };
   function re(e) {
    let t = null === e ? 'null' : typeof e;
    if ('string' !== t && 'object' !== t) return `Unexpected doc '${t}', \nExpected it to be 'string' or 'object'.`;
    if (te(e)) throw new Error('doc is valid.');
    let r = Object.prototype.toString.call(e);
    if ('[object Object]' !== r) return `Unexpected doc '${r}'.`;
    let n = ((e) => new Intl.ListFormat('en-US', { type: 'disjunction' }).format(e))([...Z].map((e) => `'${e}'`));
    return `Unexpected doc.type '${e.type}'.\nExpected it to be ${n}.`;
   }
   var ne = class extends Error {
     name = 'InvalidDocError';
     constructor(e) {
      super(re(e)), (this.doc = e);
     }
    },
    se = {};
   var ie = function (e, t, r, n) {
    let s = [e];
    for (; s.length > 0; ) {
     let e = s.pop();
     if (e === se) {
      r(s.pop());
      continue;
     }
     r && s.push(e, se);
     let i = te(e);
     if (!i) throw new ne(e);
     if (!1 !== (null == t ? void 0 : t(e)))
      switch (i) {
       case R:
       case V: {
        let t = i === R ? e : e.parts;
        for (let e = t.length - 1; e >= 0; --e) s.push(t[e]);
        break;
       }
       case W:
        s.push(e.flatContents, e.breakContents);
        break;
       case z:
        if (n && e.expandedStates) for (let t = e.expandedStates.length - 1; t >= 0; --t) s.push(e.expandedStates[t]);
        else s.push(e.contents);
        break;
       case $:
       case U:
       case J:
       case Y:
       case K:
        s.push(e.contents);
        break;
       case j:
       case q:
       case H:
       case G:
       case X:
       case Q:
        break;
       default:
        throw new ne(e);
      }
    }
   };
   function ae(e, t) {
    if ('string' == typeof e) return t(e);
    let r = new Map();
    return n(e);
    function n(e) {
     if (r.has(e)) return r.get(e);
     let s = (function (e) {
      switch (te(e)) {
       case R:
        return t(e.map(n));
       case V:
        return t({ ...e, parts: e.parts.map(n) });
       case W:
        return t({ ...e, breakContents: n(e.breakContents), flatContents: n(e.flatContents) });
       case z: {
        let { expandedStates: r, contents: s } = e;
        return r ? ((r = r.map(n)), (s = r[0])) : (s = n(s)), t({ ...e, contents: s, expandedStates: r });
       }
       case $:
       case U:
       case J:
       case Y:
       case K:
        return t({ ...e, contents: n(e.contents) });
       case j:
       case q:
       case H:
       case G:
       case X:
       case Q:
        return t(e);
       default:
        throw new ne(e);
      }
     })(e);
     return r.set(e, s), s;
    }
   }
   function oe(e, t, r) {
    let n = r,
     s = !1;
    return (
     ie(e, function (e) {
      if (s) return !1;
      let r = t(e);
      void 0 !== r && ((s = !0), (n = r));
     }),
     n
    );
   }
   function ue(e) {
    if ((e.type === z && e.break) || (e.type === X && e.hard) || e.type === Q) return !0;
   }
   function le(e) {
    if (e.length > 0) {
     let t = ee(!1, e, -1);
     !t.expandedStates && !t.break && (t.break = 'propagated');
    }
    return null;
   }
   function pe(e) {
    return e.type !== X || e.hard ? (e.type === W ? e.flatContents : e) : e.soft ? '' : ' ';
   }
   function ce(e) {
    for (e = [...e]; e.length >= 2 && ee(!1, e, -2).type === X && ee(!1, e, -1).type === Q; ) e.length -= 2;
    if (e.length > 0) {
     let t = he(ee(!1, e, -1));
     e[e.length - 1] = t;
    }
    return e;
   }
   function he(e) {
    switch (te(e)) {
     case U:
     case J:
     case z:
     case K:
     case Y: {
      let t = he(e.contents);
      return { ...e, contents: t };
     }
     case W:
      return { ...e, breakContents: he(e.breakContents), flatContents: he(e.flatContents) };
     case V:
      return { ...e, parts: ce(e.parts) };
     case R:
      return ce(e);
     case j:
      return e.replace(/[\n\r]*$/u, '');
     case $:
     case q:
     case H:
     case G:
     case X:
     case Q:
      break;
     default:
      throw new ne(e);
    }
    return e;
   }
   function de(e) {
    return he(
     (function (e) {
      return ae(e, (e) =>
       (function (e) {
        switch (te(e)) {
         case V:
          if (e.parts.every((e) => '' === e)) return '';
          break;
         case z:
          if (!(e.contents || e.id || e.break || e.expandedStates)) return '';
          if (e.contents.type === z && e.contents.id === e.id && e.contents.break === e.break && e.contents.expandedStates === e.expandedStates) return e.contents;
          break;
         case $:
         case U:
         case J:
         case K:
          if (!e.contents) return '';
          break;
         case W:
          if (!e.flatContents && !e.breakContents) return '';
          break;
         case R: {
          let t = [];
          for (let r of e) {
           if (!r) continue;
           let [e, ...n] = Array.isArray(r) ? r : [r];
           'string' == typeof e && 'string' == typeof ee(!1, t, -1) ? (t[t.length - 1] += e) : t.push(e), t.push(...n);
          }
          return 0 === t.length ? '' : 1 === t.length ? t[0] : t;
         }
         case j:
         case q:
         case H:
         case G:
         case X:
         case Y:
         case Q:
          break;
         default:
          throw new ne(e);
        }
        return e;
       })(e),
      );
     })(e),
    );
   }
   function fe(e) {
    if (e.type === X) return !0;
   }
   function me(e, t) {
    return e.type === Y ? { ...e, contents: t(e.contents) } : t(e);
   }
   var ye = () => {},
    ge = ye,
    De = ye,
    xe = ye;
   function be(e) {
    return ge(e), { type: U, contents: e };
   }
   function ve(e, t) {
    return ge(t), { type: $, contents: t, n: e };
   }
   function Ee(e, t = {}) {
    return ge(e), De(t.expandedStates, !0), { type: z, id: t.id, contents: e, break: !!t.shouldBreak, expandedStates: t.expandedStates };
   }
   function Ce(e) {
    return ge(e), { type: K, contents: e };
   }
   var Te = { type: G },
    Se = { type: Q },
    we = { type: H },
    Ae = { type: X, hard: !0 },
    Fe = { type: X, hard: !0, literal: !0 },
    ke = { type: X },
    Pe = { type: X, soft: !0 },
    Ie = [Ae, Se],
    Ne = [Fe, Se],
    Be = { type: q };
   function _e(e, t) {
    ge(e), De(t);
    let r = [];
    for (let n = 0; n < t.length; n++) 0 !== n && r.push(e), r.push(t[n]);
    return r;
   }
   function Le(e, t, r) {
    ge(e);
    let n = e;
    if (t > 0) {
     for (let e = 0; e < Math.floor(t / r); ++e) n = be(n);
     (n = ve(t % r, n)), (n = ve(Number.NEGATIVE_INFINITY, n));
    }
    return n;
   }
   function Oe(e) {
    var t;
    if (!e) return '';
    if (Array.isArray(e)) {
     let t = [];
     for (let r of e)
      if (Array.isArray(r)) t.push(...Oe(r));
      else {
       let e = Oe(r);
       '' !== e && t.push(e);
      }
     return t;
    }
    return e.type === W ? { ...e, breakContents: Oe(e.breakContents), flatContents: Oe(e.flatContents) } : e.type === z ? { ...e, contents: Oe(e.contents), expandedStates: null == (t = e.expandedStates) ? void 0 : t.map(Oe) } : e.type === V ? { type: 'fill', parts: e.parts.map(Oe) } : e.contents ? { ...e, contents: Oe(e.contents) } : e;
   }
   var Me = (e) =>
     !(
      (function (e) {
       return 12288 === e || (e >= 65281 && e <= 65376) || (e >= 65504 && e <= 65510);
      })(e) ||
      (function (e) {
       return (e >= 4352 && e <= 4447) || 8986 === e || 8987 === e || 9001 === e || 9002 === e || (e >= 9193 && e <= 9196) || 9200 === e || 9203 === e || 9725 === e || 9726 === e || 9748 === e || 9749 === e || (e >= 9776 && e <= 9783) || (e >= 9800 && e <= 9811) || 9855 === e || (e >= 9866 && e <= 9871) || 9875 === e || 9889 === e || 9898 === e || 9899 === e || 9917 === e || 9918 === e || 9924 === e || 9925 === e || 9934 === e || 9940 === e || 9962 === e || 9970 === e || 9971 === e || 9973 === e || 9978 === e || 9981 === e || 9989 === e || 9994 === e || 9995 === e || 10024 === e || 10060 === e || 10062 === e || (e >= 10067 && e <= 10069) || 10071 === e || (e >= 10133 && e <= 10135) || 10160 === e || 10175 === e || 11035 === e || 11036 === e || 11088 === e || 11093 === e || (e >= 11904 && e <= 11929) || (e >= 11931 && e <= 12019) || (e >= 12032 && e <= 12245) || (e >= 12272 && e <= 12287) || (e >= 12289 && e <= 12350) || (e >= 12353 && e <= 12438) || (e >= 12441 && e <= 12543) || (e >= 12549 && e <= 12591) || (e >= 12593 && e <= 12686) || (e >= 12688 && e <= 12773) || (e >= 12783 && e <= 12830) || (e >= 12832 && e <= 12871) || (e >= 12880 && e <= 42124) || (e >= 42128 && e <= 42182) || (e >= 43360 && e <= 43388) || (e >= 44032 && e <= 55203) || (e >= 63744 && e <= 64255) || (e >= 65040 && e <= 65049) || (e >= 65072 && e <= 65106) || (e >= 65108 && e <= 65126) || (e >= 65128 && e <= 65131) || (e >= 94176 && e <= 94180) || 94192 === e || 94193 === e || (e >= 94208 && e <= 100343) || (e >= 100352 && e <= 101589) || (e >= 101631 && e <= 101640) || (e >= 110576 && e <= 110579) || (e >= 110581 && e <= 110587) || 110589 === e || 110590 === e || (e >= 110592 && e <= 110882) || 110898 === e || (e >= 110928 && e <= 110930) || 110933 === e || (e >= 110948 && e <= 110951) || (e >= 110960 && e <= 111355) || (e >= 119552 && e <= 119638) || (e >= 119648 && e <= 119670) || 126980 === e || 127183 === e || 127374 === e || (e >= 127377 && e <= 127386) || (e >= 127488 && e <= 127490) || (e >= 127504 && e <= 127547) || (e >= 127552 && e <= 127560) || 127568 === e || 127569 === e || (e >= 127584 && e <= 127589) || (e >= 127744 && e <= 127776) || (e >= 127789 && e <= 127797) || (e >= 127799 && e <= 127868) || (e >= 127870 && e <= 127891) || (e >= 127904 && e <= 127946) || (e >= 127951 && e <= 127955) || (e >= 127968 && e <= 127984) || 127988 === e || (e >= 127992 && e <= 128062) || 128064 === e || (e >= 128066 && e <= 128252) || (e >= 128255 && e <= 128317) || (e >= 128331 && e <= 128334) || (e >= 128336 && e <= 128359) || 128378 === e || 128405 === e || 128406 === e || 128420 === e || (e >= 128507 && e <= 128591) || (e >= 128640 && e <= 128709) || 128716 === e || (e >= 128720 && e <= 128722) || (e >= 128725 && e <= 128727) || (e >= 128732 && e <= 128735) || 128747 === e || 128748 === e || (e >= 128756 && e <= 128764) || (e >= 128992 && e <= 129003) || 129008 === e || (e >= 129292 && e <= 129338) || (e >= 129340 && e <= 129349) || (e >= 129351 && e <= 129535) || (e >= 129648 && e <= 129660) || (e >= 129664 && e <= 129673) || (e >= 129679 && e <= 129734) || (e >= 129742 && e <= 129756) || (e >= 129759 && e <= 129769) || (e >= 129776 && e <= 129784) || (e >= 131072 && e <= 196605) || (e >= 196608 && e <= 262141);
      })(e)
     ),
    je = /[^\x20-\x7F]/u;
   var Re = function (e) {
     if (!e) return 0;
     if (!je.test(e)) return e.length;
     e = e.replace(/[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE89\uDE8F-\uDEC2\uDEC6\uDECE-\uDEDC\uDEDF-\uDEE9]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g, '  ');
     let t = 0;
     for (let r of e) {
      let e = r.codePointAt(0);
      e <= 31 || (e >= 127 && e <= 159) || (e >= 768 && e <= 879) || (t += Me(e) ? 1 : 2);
     }
     return t;
    },
    qe = Symbol('MODE_BREAK'),
    Ue = Symbol('MODE_FLAT'),
    $e = Symbol('cursor'),
    He = Symbol('DOC_FILL_PRINTED_LENGTH');
   function ze(e, t) {
    return We(e, { type: 'indent' }, t);
   }
   function Ve(e, t, r) {
    return t === Number.NEGATIVE_INFINITY ? e.root || { value: '', length: 0, queue: [] } : t < 0 ? We(e, { type: 'dedent' }, r) : t ? ('root' === t.type ? { ...e, root: e } : We(e, { type: 'string' == typeof t ? 'stringAlign' : 'numberAlign', n: t }, r)) : e;
   }
   function We(e, t, r) {
    let n = 'dedent' === t.type ? e.queue.slice(0, -1) : [...e.queue, t],
     s = '',
     i = 0,
     a = 0,
     o = 0;
    for (let d of n)
     switch (d.type) {
      case 'indent':
       p(), r.useTabs ? u(1) : l(r.tabWidth);
       break;
      case 'stringAlign':
       p(), (s += d.n), (i += d.n.length);
       break;
      case 'numberAlign':
       (a += 1), (o += d.n);
       break;
      default:
       throw new Error(`Unexpected type '${d.type}'`);
     }
    return c(), { ...e, value: s, length: i, queue: n };
    function u(e) {
     (s += '\t'.repeat(e)), (i += r.tabWidth * e);
    }
    function l(e) {
     (s += ' '.repeat(e)), (i += e);
    }
    function p() {
     r.useTabs ? (a > 0 && u(a), h()) : c();
    }
    function c() {
     o > 0 && l(o), h();
    }
    function h() {
     (a = 0), (o = 0);
    }
   }
   function Je(e) {
    let t = 0,
     r = 0,
     n = e.length;
    e: for (; n--; ) {
     let s = e[n];
     if (s !== $e)
      for (let r = s.length - 1; r >= 0; r--) {
       let i = s[r];
       if (' ' !== i && '\t' !== i) {
        e[n] = s.slice(0, r + 1);
        break e;
       }
       t++;
      }
     else r++;
    }
    if (t > 0 || r > 0) for (e.length = n + 1; r-- > 0; ) e.push($e);
    return t;
   }
   function Ke(e, t, r, n, s, i) {
    if (r === Number.POSITIVE_INFINITY) return !0;
    let a = t.length,
     o = [e],
     u = [];
    for (; r >= 0; ) {
     if (0 === o.length) {
      if (0 === a) return !0;
      o.push(t[--a]);
      continue;
     }
     let { mode: e, doc: l } = o.pop(),
      p = te(l);
     switch (p) {
      case j:
       u.push(l), (r -= Re(l));
       break;
      case R:
      case V: {
       let t = p === R ? l : l.parts,
        r = l[He] ?? 0;
       for (let n = t.length - 1; n >= r; n--) o.push({ mode: e, doc: t[n] });
       break;
      }
      case U:
      case $:
      case J:
      case Y:
       o.push({ mode: e, doc: l.contents });
       break;
      case H:
       r += Je(u);
       break;
      case z: {
       if (i && l.break) return !1;
       let t = l.break ? qe : e,
        r = l.expandedStates && t === qe ? ee(!1, l.expandedStates, -1) : l.contents;
       o.push({ mode: t, doc: r });
       break;
      }
      case W: {
       let t = (l.groupId ? s[l.groupId] || Ue : e) === qe ? l.breakContents : l.flatContents;
       t && o.push({ mode: e, doc: t });
       break;
      }
      case X:
       if (e === qe || l.hard) return !0;
       l.soft || (u.push(' '), r--);
       break;
      case K:
       n = !0;
       break;
      case G:
       if (n) return !1;
     }
    }
    return !1;
   }
   function Ge(e, t) {
    let r = {},
     n = t.printWidth,
     s = O(t.endOfLine),
     i = 0,
     a = [{ ind: { value: '', length: 0, queue: [] }, mode: qe, doc: e }],
     o = [],
     u = !1,
     l = [],
     p = 0;
    for (
     (function (e) {
      let t = new Set(),
       r = [];
      ie(
       e,
       function (e) {
        if ((e.type === Q && le(r), e.type === z)) {
         if ((r.push(e), t.has(e))) return !1;
         t.add(e);
        }
       },
       function (e) {
        e.type === z && r.pop().break && le(r);
       },
       !0,
      );
     })(e);
     a.length > 0;

    ) {
     let { ind: e, mode: c, doc: h } = a.pop();
     switch (te(h)) {
      case j: {
       let e = '\n' !== s ? g(!1, h, '\n', s) : h;
       o.push(e), a.length > 0 && (i += Re(e));
       break;
      }
      case R:
       for (let t = h.length - 1; t >= 0; t--) a.push({ ind: e, mode: c, doc: h[t] });
       break;
      case q:
       if (p >= 2) throw new Error("There are too many 'cursor' in doc.");
       o.push($e), p++;
       break;
      case U:
       a.push({ ind: ze(e, t), mode: c, doc: h.contents });
       break;
      case $:
       a.push({ ind: Ve(e, h.n, t), mode: c, doc: h.contents });
       break;
      case H:
       i -= Je(o);
       break;
      case z:
       switch (c) {
        case Ue:
         if (!u) {
          a.push({ ind: e, mode: h.break ? qe : Ue, doc: h.contents });
          break;
         }
        case qe: {
         u = !1;
         let t = { ind: e, mode: Ue, doc: h.contents },
          s = n - i,
          o = l.length > 0;
         if (!h.break && Ke(t, a, s, o, r)) a.push(t);
         else if (h.expandedStates) {
          let t = ee(!1, h.expandedStates, -1);
          if (h.break) {
           a.push({ ind: e, mode: qe, doc: t });
           break;
          }
          for (let n = 1; n < h.expandedStates.length + 1; n++) {
           if (n >= h.expandedStates.length) {
            a.push({ ind: e, mode: qe, doc: t });
            break;
           }
           {
            let t = h.expandedStates[n],
             i = { ind: e, mode: Ue, doc: t };
            if (Ke(i, a, s, o, r)) {
             a.push(i);
             break;
            }
           }
          }
         } else a.push({ ind: e, mode: qe, doc: h.contents });
         break;
        }
       }
       h.id && (r[h.id] = ee(!1, a, -1).mode);
       break;
      case V: {
       let t = n - i,
        s = h[He] ?? 0,
        { parts: o } = h,
        u = o.length - s;
       if (0 === u) break;
       let p = o[s + 0],
        d = o[s + 1],
        f = { ind: e, mode: Ue, doc: p },
        m = { ind: e, mode: qe, doc: p },
        y = Ke(f, [], t, l.length > 0, r, !0);
       if (1 === u) {
        y ? a.push(f) : a.push(m);
        break;
       }
       let g = { ind: e, mode: Ue, doc: d },
        D = { ind: e, mode: qe, doc: d };
       if (2 === u) {
        y ? a.push(g, f) : a.push(D, m);
        break;
       }
       let x = o[s + 2],
        b = { ind: e, mode: c, doc: { ...h, [He]: s + 2 } };
       Ke({ ind: e, mode: Ue, doc: [p, d, x] }, [], t, l.length > 0, r, !0) ? a.push(b, g, f) : y ? a.push(b, D, f) : a.push(b, D, m);
       break;
      }
      case W:
      case J: {
       let t = h.groupId ? r[h.groupId] : c;
       if (t === qe) {
        let t = h.type === W ? h.breakContents : h.negate ? h.contents : be(h.contents);
        t && a.push({ ind: e, mode: c, doc: t });
       }
       if (t === Ue) {
        let t = h.type === W ? h.flatContents : h.negate ? be(h.contents) : h.contents;
        t && a.push({ ind: e, mode: c, doc: t });
       }
       break;
      }
      case K:
       l.push({ ind: e, mode: c, doc: h.contents });
       break;
      case G:
       l.length > 0 && a.push({ ind: e, mode: c, doc: Ae });
       break;
      case X:
       switch (c) {
        case Ue:
         if (!h.hard) {
          h.soft || (o.push(' '), (i += 1));
          break;
         }
         u = !0;
        case qe:
         if (l.length > 0) {
          a.push({ ind: e, mode: c, doc: h }, ...l.reverse()), (l.length = 0);
          break;
         }
         h.literal ? (e.root ? (o.push(s, e.root.value), (i = e.root.length)) : (o.push(s), (i = 0))) : ((i -= Je(o)), o.push(s + e.value), (i = e.length));
       }
       break;
      case Y:
       a.push({ ind: e, mode: c, doc: h.contents });
       break;
      case Q:
       break;
      default:
       throw new ne(h);
     }
     0 === a.length && l.length > 0 && (a.push(...l.reverse()), (l.length = 0));
    }
    let c = o.indexOf($e);
    if (-1 !== c) {
     let e = o.indexOf($e, c + 1);
     if (-1 === e) return { formatted: o.filter((e) => e !== $e).join('') };
     let t = o.slice(0, c).join(''),
      r = o.slice(c + 1, e).join('');
     return { formatted: t + r + o.slice(e + 1).join(''), cursorNodeStart: t.length, cursorNodeText: r };
    }
    return { formatted: o.join('') };
   }
   var Xe,
    Ye,
    Qe,
    Ze = function (e, t, r = 0) {
     let n = 0;
     for (let s = r; s < e.length; ++s) '\t' === e[s] ? (n = n + t - (n % t)) : n++;
     return n;
    };
   (Xe = new WeakSet()),
    (Ye = function (e) {
     let { stack: t } = this;
     for (let r = t.length - 1; r >= 0; r -= 2) if (!Array.isArray(t[r]) && --e < 0) return r;
     return -1;
    }),
    (Qe = function* () {
     let { stack: e } = this;
     for (let t = e.length - 3; t >= 0; t -= 2) {
      let r = e[t];
      Array.isArray(r) || (yield r);
     }
    });
   var et = class {
     constructor(e) {
      ((e, t, r) => {
       t.has(e) ? l('Cannot add the same private member more than once') : t instanceof WeakSet ? t.add(e) : t.set(e, r);
      })(this, Xe),
       (this.stack = [e]);
     }
     get key() {
      let { stack: e, siblings: t } = this;
      return ee(!1, e, null === t ? -2 : -4) ?? null;
     }
     get index() {
      return null === this.siblings ? null : ee(!1, this.stack, -2);
     }
     get node() {
      return ee(!1, this.stack, -1);
     }
     get parent() {
      return this.getNode(1);
     }
     get grandparent() {
      return this.getNode(2);
     }
     get isInArray() {
      return null !== this.siblings;
     }
     get siblings() {
      let { stack: e } = this,
       t = ee(!1, e, -3);
      return Array.isArray(t) ? t : null;
     }
     get next() {
      let { siblings: e } = this;
      return null === e ? null : e[this.index + 1];
     }
     get previous() {
      let { siblings: e } = this;
      return null === e ? null : e[this.index - 1];
     }
     get isFirst() {
      return 0 === this.index;
     }
     get isLast() {
      let { siblings: e, index: t } = this;
      return null !== e && t === e.length - 1;
     }
     get isRoot() {
      return 1 === this.stack.length;
     }
     get root() {
      return this.stack[0];
     }
     get ancestors() {
      return [...d(this, Xe, Qe).call(this)];
     }
     getName() {
      let { stack: e } = this,
       { length: t } = e;
      return t > 1 ? ee(!1, e, -2) : null;
     }
     getValue() {
      return ee(!1, this.stack, -1);
     }
     getNode(e = 0) {
      let t = d(this, Xe, Ye).call(this, e);
      return -1 === t ? null : this.stack[t];
     }
     getParentNode(e = 0) {
      return this.getNode(e + 1);
     }
     call(e, ...t) {
      let { stack: r } = this,
       { length: n } = r,
       s = ee(!1, r, -1);
      for (let i of t) (s = s[i]), r.push(i, s);
      try {
       return e(this);
      } finally {
       r.length = n;
      }
     }
     callParent(e, t = 0) {
      let r = d(this, Xe, Ye).call(this, t + 1),
       n = this.stack.splice(r + 1);
      try {
       return e(this);
      } finally {
       this.stack.push(...n);
      }
     }
     each(e, ...t) {
      let { stack: r } = this,
       { length: n } = r,
       s = ee(!1, r, -1);
      for (let i of t) (s = s[i]), r.push(i, s);
      try {
       for (let t = 0; t < s.length; ++t) r.push(t, s[t]), e(this, t, s), (r.length -= 2);
      } finally {
       r.length = n;
      }
     }
     map(e, ...t) {
      let r = [];
      return (
       this.each(
        (t, n, s) => {
         r[n] = e(t, n, s);
        },
        ...t,
       ),
       r
      );
     }
     match(...e) {
      let t = this.stack.length - 1,
       r = null,
       n = this.stack[t--];
      for (let s of e) {
       if (void 0 === n) return !1;
       let e = null;
       if (('number' == typeof r && ((e = r), (r = this.stack[t--]), (n = this.stack[t--])), s && !s(n, r, e))) return !1;
       (r = this.stack[t--]), (n = this.stack[t--]);
      }
      return !0;
     }
     findAncestor(e) {
      for (let t of d(this, Xe, Qe).call(this)) if (e(t)) return t;
     }
     hasAncestor(e) {
      for (let t of d(this, Xe, Qe).call(this)) if (e(t)) return !0;
      return !1;
     }
    },
    tt = new Proxy(() => {}, { get: () => tt }),
    rt = tt;
   var nt = function (e) {
    return null !== e && 'object' == typeof e;
   };
   function* st(e, t) {
    let { getVisitorKeys: r, filter: n = () => !0 } = t,
     s = (e) => nt(e) && n(e);
    for (let i of r(e)) {
     let t = e[i];
     if (Array.isArray(t)) for (let e of t) s(e) && (yield e);
     else s(t) && (yield t);
    }
   }
   function it(e) {
    return (t, r, n) => {
     let s = !(null == n || !n.backwards);
     if (!1 === r) return !1;
     let { length: i } = t,
      a = r;
     for (; a >= 0 && a < i; ) {
      let r = t.charAt(a);
      if (e instanceof RegExp) {
       if (!e.test(r)) return a;
      } else if (!e.includes(r)) return a;
      s ? a-- : a++;
     }
     return (-1 === a || a === i) && a;
    };
   }
   var at = it(/\s/u),
    ot = it(' \t'),
    ut = it(',; \t'),
    lt = it(/[^\n\r]/u);
   var pt = function (e, t, r) {
    let n = !(null == r || !r.backwards);
    if (!1 === t) return !1;
    let s = e.charAt(t);
    if (n) {
     if ('\r' === e.charAt(t - 1) && '\n' === s) return t - 2;
     if ('\n' === s || '\r' === s || '\u2028' === s || '\u2029' === s) return t - 1;
    } else {
     if ('\r' === s && '\n' === e.charAt(t + 1)) return t + 2;
     if ('\n' === s || '\r' === s || '\u2028' === s || '\u2029' === s) return t + 1;
    }
    return t;
   };
   var ct = function (e, t, r = {}) {
    let n = ot(e, r.backwards ? t - 1 : t, r);
    return n !== pt(e, n, r);
   };
   var ht = function (e) {
     return Array.isArray(e) && e.length > 0;
    },
    dt = new Set(['tokens', 'comments', 'parent', 'enclosingNode', 'precedingNode', 'followingNode']),
    ft = (e) => Object.keys(e).filter((e) => !dt.has(e));
   var mt = function (e) {
    return e ? (t) => e(t, dt) : ft;
   };
   function yt(e, t) {
    (e.comments ?? (e.comments = [])).push(t),
     (t.printed = !1),
     (t.nodeDescription = (function (e) {
      let t = e.type || e.kind || '(unknown type)',
       r = String(e.name || (e.id && ('object' == typeof e.id ? e.id.name : e.id)) || (e.key && ('object' == typeof e.key ? e.key.name : e.key)) || (e.value && ('object' == typeof e.value ? '' : String(e.value))) || e.operator || '');
      return r.length > 20 && (r = r.slice(0, 19) + '\u2026'), t + (r ? ' ' + r : '');
     })(e));
   }
   function gt(e, t) {
    (t.leading = !0), (t.trailing = !1), yt(e, t);
   }
   function Dt(e, t, r) {
    (t.leading = !1), (t.trailing = !1), r && (t.marker = r), yt(e, t);
   }
   function xt(e, t) {
    (t.leading = !1), (t.trailing = !0), yt(e, t);
   }
   var bt = new WeakMap();
   function vt(e, t) {
    if (bt.has(e)) return bt.get(e);
    let {
     printer: { getCommentChildNodes: r, canAttachComment: n, getVisitorKeys: s },
     locStart: i,
     locEnd: a,
    } = t;
    if (!n) return [];
    let o = ((null == r ? void 0 : r(e, t)) ?? [...st(e, { getVisitorKeys: mt(s) })]).flatMap((e) => (n(e) ? [e] : vt(e, t)));
    return o.sort((e, t) => i(e) - i(t) || a(e) - a(t)), bt.set(e, o), o;
   }
   function Et(e, t, r, n) {
    let s,
     i,
     { locStart: a, locEnd: o } = r,
     u = a(t),
     l = o(t),
     p = vt(e, r),
     c = 0,
     h = p.length;
    for (; c < h; ) {
     let e = (c + h) >> 1,
      n = p[e],
      d = a(n),
      f = o(n);
     if (d <= u && l <= f) return Et(n, t, r, n);
     if (f <= u) (s = n), (c = e + 1);
     else {
      if (!(l <= d)) throw new Error('Comment location overlaps with node location');
      (i = n), (h = e);
     }
    }
    if ('TemplateLiteral' === (null == n ? void 0 : n.type)) {
     let { quasis: e } = n,
      a = Ft(e, t, r);
     s && Ft(e, s, r) !== a && (s = null), i && Ft(e, i, r) !== a && (i = null);
    }
    return { enclosingNode: n, precedingNode: s, followingNode: i };
   }
   var Ct = () => !1;
   var Tt = (e) => !/[\S\n\u2028\u2029]/u.test(e);
   function St(e, t, r, n) {
    let { comment: s, precedingNode: i } = r[n],
     { locStart: a, locEnd: o } = t,
     u = a(s);
    if (i)
     for (let l = n - 1; l >= 0; l--) {
      let { comment: t, precedingNode: n } = r[l];
      if (n !== i || !Tt(e.slice(o(t), u))) break;
      u = a(t);
     }
    return ct(e, u, { backwards: !0 });
   }
   function wt(e, t, r, n) {
    let { comment: s, followingNode: i } = r[n],
     { locStart: a, locEnd: o } = t,
     u = o(s);
    if (i)
     for (let l = n + 1; l < r.length; l++) {
      let { comment: t, followingNode: n } = r[l];
      if (n !== i || !Tt(e.slice(u, a(t)))) break;
      u = o(t);
     }
    return ct(e, u);
   }
   function At(e, t) {
    var r, n;
    let s = e.length;
    if (0 === s) return;
    let i,
     { precedingNode: a, followingNode: o } = e[0],
     u = t.locStart(o);
    for (i = s; i > 0; --i) {
     let { comment: s, precedingNode: l, followingNode: p } = e[i - 1];
     rt.strictEqual(l, a), rt.strictEqual(p, o);
     let c = t.originalText.slice(t.locEnd(s), u);
     if (!((null == (n = (r = t.printer).isGap) ? void 0 : n.call(r, c, t)) ?? /^[\s(]*$/u.test(c))) break;
     u = t.locStart(s);
    }
    for (let [l, { comment: p }] of e.entries()) l < i ? xt(a, p) : gt(o, p);
    for (let l of [a, o]) l.comments && l.comments.length > 1 && l.comments.sort((e, r) => t.locStart(e) - t.locStart(r));
    e.length = 0;
   }
   function Ft(e, t, r) {
    let n = r.locStart(t) - 1;
    for (let s = 1; s < e.length; ++s) if (n < r.locStart(e[s])) return s - 1;
    return 0;
   }
   var kt = function (e, t) {
    let r = t - 1;
    return (r = ot(e, r, { backwards: !0 })), (r = pt(e, r, { backwards: !0 })), (r = ot(e, r, { backwards: !0 })), r !== pt(e, r, { backwards: !0 });
   };
   function Pt(e, t) {
    return (e.node.printed = !0), t.printer.printComment(e, t);
   }
   function It(e, t) {
    let r = e.node;
    if (!r) return {};
    let n = t[Symbol.for('printedComments')];
    if (0 === (r.comments || []).filter((e) => !n.has(e)).length) return { leading: '', trailing: '' };
    let s,
     i = [],
     a = [];
    return (
     e.each(() => {
      let r = e.node;
      if (null != n && n.has(r)) return;
      let { leading: o, trailing: u } = r;
      o
       ? i.push(
          (function (e, t) {
           var r;
           let n = e.node,
            s = [Pt(e, t)],
            { printer: i, originalText: a, locStart: o, locEnd: u } = t;
           if (null == (r = i.isBlockComment) ? void 0 : r.call(i, n)) {
            let e = ct(a, u(n)) ? (ct(a, o(n), { backwards: !0 }) ? Ie : ke) : ' ';
            s.push(e);
           } else s.push(Ie);
           let l = pt(a, ot(a, u(n)));
           return !1 !== l && ct(a, l) && s.push(Ie), s;
          })(e, t),
         )
       : u &&
         ((s = (function (e, t, r) {
          var n;
          let s = e.node,
           i = Pt(e, t),
           { printer: a, originalText: o, locStart: u } = t,
           l = null == (n = a.isBlockComment) ? void 0 : n.call(a, s);
          if ((null != r && r.hasLineSuffix && (null == r || !r.isBlock)) || ct(o, u(s), { backwards: !0 })) {
           let e = kt(o, u(s));
           return { doc: Ce([Ie, e ? Ie : '', i]), isBlock: l, hasLineSuffix: !0 };
          }
          return !l || (null != r && r.hasLineSuffix) ? { doc: [Ce([' ', i]), Se], isBlock: l, hasLineSuffix: !0 } : { doc: [' ', i], isBlock: l, hasLineSuffix: !1 };
         })(e, t, s)),
         a.push(s.doc));
     }, 'comments'),
     { leading: i, trailing: a }
    );
   }
   var Nt = function (e) {
     return () => {};
    },
    Bt = class extends Error {
     name = 'ConfigError';
    },
    _t = class extends Error {
     name = 'UndefinedParserError';
    },
    Lt = {
     cursorOffset: { category: 'Special', type: 'int', default: -1, range: { start: -1, end: 1 / 0, step: 1 }, description: 'Print (to stderr) where a cursor at the given position would move to after formatting.', cliCategory: 'Editor' },
     endOfLine: {
      category: 'Global',
      type: 'choice',
      default: 'lf',
      description: 'Which end of line characters to apply.',
      choices: [
       { value: 'lf', description: 'Line Feed only (\\n), common on Linux and macOS as well as inside git repos' },
       { value: 'crlf', description: 'Carriage Return + Line Feed characters (\\r\\n), common on Windows' },
       { value: 'cr', description: 'Carriage Return character only (\\r), used very rarely' },
       { value: 'auto', description: "Maintain existing\n(mixed values within one file are normalised by looking at what's used after the first line)" },
      ],
     },
     filepath: { category: 'Special', type: 'path', description: 'Specify the input filepath. This will be used to do parser inference.', cliName: 'stdin-filepath', cliCategory: 'Other', cliDescription: 'Path to the file to pretend that stdin comes from.' },
     insertPragma: { category: 'Special', type: 'boolean', default: !1, description: "Insert @format pragma into file's first docblock comment.", cliCategory: 'Other' },
     parser: {
      category: 'Global',
      type: 'choice',
      default: void 0,
      description: 'Which parser to use.',
      exception: (e) => 'string' == typeof e || 'function' == typeof e,
      choices: [
       { value: 'flow', description: 'Flow' },
       { value: 'babel', description: 'JavaScript' },
       { value: 'babel-flow', description: 'Flow' },
       { value: 'babel-ts', description: 'TypeScript' },
       { value: 'typescript', description: 'TypeScript' },
       { value: 'acorn', description: 'JavaScript' },
       { value: 'espree', description: 'JavaScript' },
       { value: 'meriyah', description: 'JavaScript' },
       { value: 'css', description: 'CSS' },
       { value: 'less', description: 'Less' },
       { value: 'scss', description: 'SCSS' },
       { value: 'json', description: 'JSON' },
       { value: 'json5', description: 'JSON5' },
       { value: 'jsonc', description: 'JSON with Comments' },
       { value: 'json-stringify', description: 'JSON.stringify' },
       { value: 'graphql', description: 'GraphQL' },
       { value: 'markdown', description: 'Markdown' },
       { value: 'mdx', description: 'MDX' },
       { value: 'vue', description: 'Vue' },
       { value: 'yaml', description: 'YAML' },
       { value: 'glimmer', description: 'Ember / Handlebars' },
       { value: 'html', description: 'HTML' },
       { value: 'angular', description: 'Angular' },
       { value: 'lwc', description: 'Lightning Web Components' },
      ],
     },
     plugins: { type: 'path', array: !0, default: [{ value: [] }], category: 'Global', description: 'Add a plugin. Multiple plugins can be passed as separate `--plugin`s.', exception: (e) => 'string' == typeof e || 'object' == typeof e, cliName: 'plugin', cliCategory: 'Config' },
     printWidth: { category: 'Global', type: 'int', default: 80, description: 'The line length where Prettier will try wrap.', range: { start: 0, end: 1 / 0, step: 1 } },
     rangeEnd: { category: 'Special', type: 'int', default: 1 / 0, range: { start: 0, end: 1 / 0, step: 1 }, description: 'Format code ending at a given character offset (exclusive).\nThe range will extend forwards to the end of the selected statement.', cliCategory: 'Editor' },
     rangeStart: { category: 'Special', type: 'int', default: 0, range: { start: 0, end: 1 / 0, step: 1 }, description: 'Format code starting at a given character offset.\nThe range will extend backwards to the start of the first line containing the selected statement.', cliCategory: 'Editor' },
     requirePragma: { category: 'Special', type: 'boolean', default: !1, description: "Require either '@prettier' or '@format' to be present in the file's first docblock comment\nin order for it to be formatted.", cliCategory: 'Other' },
     tabWidth: { type: 'int', category: 'Global', default: 2, description: 'Number of spaces per indentation level.', range: { start: 0, end: 1 / 0, step: 1 } },
     useTabs: { category: 'Global', type: 'boolean', default: !1, description: 'Indent with tabs instead of spaces.' },
     embeddedLanguageFormatting: {
      category: 'Global',
      type: 'choice',
      default: 'auto',
      description: 'Control how Prettier formats quoted code embedded in the file.',
      choices: [
       { value: 'auto', description: 'Format embedded code if Prettier can automatically identify it.' },
       { value: 'off', description: 'Never automatically format embedded code.' },
      ],
     },
    };
   function Ot({ plugins: e = [], showDeprecated: t = !1 } = {}) {
    let r = e.flatMap((e) => e.languages ?? []),
     n = [];
    for (let s of (function (e) {
     let t = [];
     for (let [r, n] of Object.entries(e)) {
      let e = { name: r, ...n };
      Array.isArray(e.default) && (e.default = ee(!1, e.default, -1).value), t.push(e);
     }
     return t;
    })(Object.assign({}, ...e.map(({ options: e }) => e), Lt)))
     (!t && s.deprecated) ||
      (Array.isArray(s.choices) && (t || (s.choices = s.choices.filter((e) => !e.deprecated)), 'parser' === s.name && (s.choices = [...s.choices, ...Mt(s.choices, r, e)])),
      (s.pluginDefaults = Object.fromEntries(
       e
        .filter((e) => {
         var t;
         return void 0 !== (null == (t = e.defaultOptions) ? void 0 : t[s.name]);
        })
        .map((e) => [e.name, e.defaultOptions[s.name]]),
      )),
      n.push(s));
    return { languages: r, options: n };
   }
   function* Mt(e, t, r) {
    let n = new Set(e.map((e) => e.value));
    for (let s of t)
     if (s.parsers)
      for (let e of s.parsers)
       if (!n.has(e)) {
        n.add(e);
        let t = r.find((t) => t.parsers && Object.prototype.hasOwnProperty.call(t.parsers, e)),
         i = s.name;
        null != t && t.name && (i += ` (plugin: ${t.name})`), yield { value: e, description: i };
       }
   }
   var jt = (e) => String(e).split(/[/\\]/u).pop();
   function Rt(e, t) {
    if (!t) return;
    let r = jt(t).toLowerCase();
    return e.find(({ filenames: e }) => (null == e ? void 0 : e.some((e) => e.toLowerCase() === r))) ?? e.find(({ extensions: e }) => (null == e ? void 0 : e.some((e) => r.endsWith(e))));
   }
   var qt = function (e, t) {
     let r = e.plugins.flatMap((e) => e.languages ?? []),
      n =
       (function (e, t) {
        if (t) return e.find(({ name: e }) => e.toLowerCase() === t) ?? e.find(({ aliases: e }) => (null == e ? void 0 : e.includes(t))) ?? e.find(({ extensions: e }) => (null == e ? void 0 : e.includes(`.${t}`)));
       })(r, t.language) ??
       Rt(r, t.physicalFile) ??
       Rt(r, t.file) ??
       void t.physicalFile;
     return null == n ? void 0 : n.parsers[0];
    },
    Ut = {
     key: (e) => (/^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(e) ? e : JSON.stringify(e)),
     value(e) {
      if (null === e || 'object' != typeof e) return JSON.stringify(e);
      if (Array.isArray(e)) return `[${e.map((e) => Ut.value(e)).join(', ')}]`;
      let t = Object.keys(e);
      return 0 === t.length ? '{}' : `{ ${t.map((t) => `${Ut.key(t)}: ${Ut.value(e[t])}`).join(', ')} }`;
     },
     pair: ({ key: e, value: t }) => Ut.value({ [e]: t }),
    },
    $t = h(f(), 1),
    Ht = h(f(), 1),
    zt = Symbol.for('vnopts.VALUE_NOT_EXIST'),
    Vt = Symbol.for('vnopts.VALUE_UNCHANGED'),
    Wt = ' '.repeat(2);
   function Jt(e, t, r, n) {
    return [`Invalid ${Ht.default.red(n.key(e))} value.`, `Expected ${Ht.default.blue(r)},`, `but received ${t === zt ? Ht.default.gray('nothing') : Ht.default.red(n.value(t))}.`].join(' ');
   }
   function Kt({ text: e, list: t }, r) {
    let n = [];
    return e && n.push(`- ${Ht.default.blue(e)}`), t && n.push([`- ${Ht.default.blue(t.title)}:`].concat(t.values.map((e) => Kt(e, r - Wt.length).replace(/^|\n/g, `$&${Wt}`))).join('\n')), Gt(n, r);
   }
   function Gt(e, t) {
    if (1 === e.length) return e[0];
    let [r, n] = e,
     [s, i] = e.map((e) => e.split('\n', 1)[0].length);
    return s > t && s > i ? n : r;
   }
   var Xt = h(f(), 1),
    Yt = [],
    Qt = [];
   var Zt = (e, t, { descriptor: r, logger: n, schemas: s }) => {
     let i = [`Ignored unknown option ${Xt.default.yellow(r.pair({ key: e, value: t }))}.`],
      a = Object.keys(s)
       .sort()
       .find(
        (t) =>
         (function (e, t) {
          if (e === t) return 0;
          let r = e;
          e.length > t.length && ((e = t), (t = r));
          let n = e.length,
           s = t.length;
          for (; n > 0 && e.charCodeAt(~-n) === t.charCodeAt(~-s); ) n--, s--;
          let i = 0;
          for (; i < n && e.charCodeAt(i) === t.charCodeAt(i); ) i++;
          if (((n -= i), (s -= i), 0 === n)) return s;
          let a,
           o,
           u,
           l,
           p = 0,
           c = 0;
          for (; p < n; ) (Qt[p] = e.charCodeAt(i + p)), (Yt[p] = ++p);
          for (; c < s; ) for (a = t.charCodeAt(i + c), u = c++, o = c, p = 0; p < n; p++) (l = a === Qt[p] ? u : u + 1), (u = Yt[p]), (o = Yt[p] = u > o ? (l > o ? o + 1 : l) : l > u ? u + 1 : l);
          return o;
         })(e, t) < 3,
       );
     a && i.push(`Did you mean ${Xt.default.blue(r.key(a))}?`), n.warn(i.join(' '));
    },
    er = ['default', 'expected', 'validate', 'deprecated', 'forward', 'redirect', 'overlap', 'preprocess', 'postprocess'];
   var tr = class {
    static create(e) {
     return (function (e, t) {
      let r = new e(t),
       n = Object.create(r);
      for (let s of er) s in t && (n[s] = rr(t[s], r, tr.prototype[s].length));
      return n;
     })(this, e);
    }
    constructor(e) {
     this.name = e.name;
    }
    default(e) {}
    expected(e) {
     return 'nothing';
    }
    validate(e, t) {
     return !1;
    }
    deprecated(e, t) {
     return !1;
    }
    forward(e, t) {}
    redirect(e, t) {}
    overlap(e, t, r) {
     return e;
    }
    preprocess(e, t) {
     return e;
    }
    postprocess(e, t) {
     return Vt;
    }
   };
   function rr(e, t, r) {
    return 'function' == typeof e ? (...n) => e(...n.slice(0, r - 1), t, ...n.slice(r - 1)) : () => e;
   }
   var nr = class extends tr {
     constructor(e) {
      super(e), (this._sourceName = e.sourceName);
     }
     expected(e) {
      return e.schemas[this._sourceName].expected(e);
     }
     validate(e, t) {
      return t.schemas[this._sourceName].validate(e, t);
     }
     redirect(e, t) {
      return this._sourceName;
     }
    },
    sr = class extends tr {
     expected() {
      return 'anything';
     }
     validate() {
      return !0;
     }
    },
    ir = class extends tr {
     constructor({ valueSchema: e, name: t = e.name, ...r }) {
      super({ ...r, name: t }), (this._valueSchema = e);
     }
     expected(e) {
      let { text: t, list: r } = e.normalizeExpectedResult(this._valueSchema.expected(e));
      return { text: t && `an array of ${t}`, list: r && { title: 'an array of the following values', values: [{ list: r }] } };
     }
     validate(e, t) {
      if (!Array.isArray(e)) return !1;
      let r = [];
      for (let n of e) {
       let e = t.normalizeValidateResult(this._valueSchema.validate(n, t), n);
       !0 !== e && r.push(e.value);
      }
      return 0 === r.length || { value: r };
     }
     deprecated(e, t) {
      let r = [];
      for (let n of e) {
       let e = t.normalizeDeprecatedResult(this._valueSchema.deprecated(n, t), n);
       !1 !== e && r.push(...e.map(({ value: e }) => ({ value: [e] })));
      }
      return r;
     }
     forward(e, t) {
      let r = [];
      for (let n of e) {
       let e = t.normalizeForwardResult(this._valueSchema.forward(n, t), n);
       r.push(...e.map(ar));
      }
      return r;
     }
     redirect(e, t) {
      let r = [],
       n = [];
      for (let s of e) {
       let e = t.normalizeRedirectResult(this._valueSchema.redirect(s, t), s);
       'remain' in e && r.push(e.remain), n.push(...e.redirect.map(ar));
      }
      return 0 === r.length ? { redirect: n } : { redirect: n, remain: r };
     }
     overlap(e, t) {
      return e.concat(t);
     }
    };
   function ar({ from: e, to: t }) {
    return { from: [e], to: t };
   }
   var or = class extends tr {
    expected() {
     return 'true or false';
    }
    validate(e) {
     return 'boolean' == typeof e;
    }
   };
   function ur(e, t) {
    let r = Object.create(null);
    for (let n of e) {
     let e = n[t];
     if (r[e]) throw new Error(`Duplicate ${t} ${JSON.stringify(e)}`);
     r[e] = n;
    }
    return r;
   }
   function lr(e, t) {
    if (e === t) return 0;
    let r = typeof e,
     n = typeof t,
     s = ['undefined', 'object', 'boolean', 'number', 'string'];
    return r !== n ? s.indexOf(r) - s.indexOf(n) : 'string' !== r ? Number(e) - Number(t) : e.localeCompare(t);
   }
   function pr(e) {
    return void 0 === e ? {} : e;
   }
   function cr(e) {
    if ('string' == typeof e) return { text: e };
    let { text: t, list: r } = e;
    return (
     (function (e, t) {
      if (!e) throw new Error(t);
     })(void 0 !== (t || r), 'Unexpected `expected` result, there should be at least one field.'),
     r ? { text: t, list: { title: r.title, values: r.values.map(cr) } } : { text: t }
    );
   }
   function hr(e, t) {
    return !0 === e || (!1 === e ? { value: t } : e);
   }
   function dr(e, t, r = !1) {
    return !1 !== e && (!0 === e ? !!r || [{ value: t }] : 'value' in e ? [e] : 0 !== e.length && e);
   }
   function fr(e, t) {
    return 'string' == typeof e || 'key' in e ? { from: t, to: e } : 'from' in e ? { from: e.from, to: e.to } : { from: t, to: e.to };
   }
   function mr(e, t) {
    return void 0 === e ? [] : Array.isArray(e) ? e.map((e) => fr(e, t)) : [fr(e, t)];
   }
   function yr(e, t) {
    let r = mr('object' == typeof e && 'redirect' in e ? e.redirect : e, t);
    return 0 === r.length ? { remain: t, redirect: r } : 'object' == typeof e && 'remain' in e ? { remain: e.remain, redirect: r } : { redirect: r };
   }
   var gr,
    Dr = class extends tr {
     constructor(e) {
      super(e),
       (this._choices = (function (e, t) {
        let r = new Map();
        for (let n of e) {
         let e = n[t];
         if (r.has(e)) throw new Error(`Duplicate ${t} ${JSON.stringify(e)}`);
         r.set(e, n);
        }
        return r;
       })(
        e.choices.map((e) => (e && 'object' == typeof e ? e : { value: e })),
        'value',
       ));
     }
     expected({ descriptor: e }) {
      let t = Array.from(this._choices.keys())
        .map((e) => this._choices.get(e))
        .filter(({ hidden: e }) => !e)
        .map((e) => e.value)
        .sort(lr)
        .map(e.value),
       r = t.slice(0, -2),
       n = t.slice(-2);
      return { text: r.concat(n.join(' or ')).join(', '), list: { title: 'one of the following values', values: t } };
     }
     validate(e) {
      return this._choices.has(e);
     }
     deprecated(e) {
      let t = this._choices.get(e);
      return !(!t || !t.deprecated) && { value: e };
     }
     forward(e) {
      let t = this._choices.get(e);
      return t ? t.forward : void 0;
     }
     redirect(e) {
      let t = this._choices.get(e);
      return t ? t.redirect : void 0;
     }
    },
    xr = class extends tr {
     expected() {
      return 'a number';
     }
     validate(e, t) {
      return 'number' == typeof e;
     }
    },
    br = class extends xr {
     expected() {
      return 'an integer';
     }
     validate(e, t) {
      return !0 === t.normalizeValidateResult(super.validate(e, t), e) && (r = e) === Math.floor(r);
      var r;
     }
    },
    vr = class extends tr {
     expected() {
      return 'a string';
     }
     validate(e) {
      return 'string' == typeof e;
     }
    },
    Er = Ut,
    Cr = Zt,
    Tr = (e, t, r) => {
     let { text: n, list: s } = r.normalizeExpectedResult(r.schemas[e].expected(r)),
      i = [];
     return n && i.push(Jt(e, t, n, r.descriptor)), s && i.push([Jt(e, t, s.title, r.descriptor)].concat(s.values.map((e) => Kt(e, r.loggerPrintWidth))).join('\n')), Gt(i, r.loggerPrintWidth);
    },
    Sr = (e, t, { descriptor: r }) => {
     let n = [`${$t.default.yellow('string' == typeof e ? r.key(e) : r.pair(e))} is deprecated`];
     return t && n.push(`we now treat it as ${$t.default.blue('string' == typeof t ? r.key(t) : r.pair(t))}`), n.join('; ') + '.';
    },
    wr = class {
     constructor(e, t) {
      let { logger: r = console, loggerPrintWidth: n = 80, descriptor: s = Er, unknown: i = Cr, invalid: a = Tr, deprecated: o = Sr, missing: u = () => !1, required: l = () => !1, preprocess: p = (e) => e, postprocess: c = () => Vt } = t || {};
      var h;
      (this._utils = { descriptor: s, logger: r || { warn: () => {} }, loggerPrintWidth: n, schemas: ur(e, 'name'), normalizeDefaultResult: pr, normalizeExpectedResult: cr, normalizeDeprecatedResult: dr, normalizeForwardResult: mr, normalizeRedirectResult: yr, normalizeValidateResult: hr }),
       (this._unknownHandler = i),
       (this._invalidHandler =
        ((h = a),
        (...e) => {
         let t = h(...e);
         return 'string' == typeof t ? new Error(t) : t;
        })),
       (this._deprecatedHandler = o),
       (this._identifyMissing = (e, t) => !(e in t) || u(e, t)),
       (this._identifyRequired = l),
       (this._preprocess = p),
       (this._postprocess = c),
       this.cleanHistory();
     }
     cleanHistory() {
      this._hasDeprecationWarned = (function () {
       let e = Object.create(null);
       return (t) => {
        let r = JSON.stringify(t);
        return !!e[r] || ((e[r] = !0), !1);
       };
      })();
     }
     normalize(e) {
      let t = {},
       r = [this._preprocess(e, this._utils)],
       n = () => {
        for (; 0 !== r.length; ) {
         let e = r.shift(),
          n = this._applyNormalization(e, t);
         r.push(...n);
        }
       };
      n();
      for (let s of Object.keys(this._utils.schemas)) {
       let e = this._utils.schemas[s];
       if (!(s in t)) {
        let t = pr(e.default(this._utils));
        'value' in t && r.push({ [s]: t.value });
       }
      }
      n();
      for (let s of Object.keys(this._utils.schemas)) {
       if (!(s in t)) continue;
       let e = this._utils.schemas[s],
        r = t[s],
        n = e.postprocess(r, this._utils);
       n !== Vt && (this._applyValidation(n, s, e), (t[s] = n));
      }
      return this._applyPostprocess(t), this._applyRequiredCheck(t), t;
     }
     _applyNormalization(e, t) {
      let r = [],
       { knownKeys: n, unknownKeys: s } = this._partitionOptionKeys(e);
      for (let i of n) {
       let n = this._utils.schemas[i],
        s = n.preprocess(e[i], this._utils);
       this._applyValidation(s, i, n);
       let a = ({ from: e, to: t }) => {
         r.push('string' == typeof t ? { [t]: e } : { [t.key]: t.value });
        },
        o = ({ value: e, redirectTo: t }) => {
         let r = dr(n.deprecated(e, this._utils), s, !0);
         if (!1 !== r)
          if (!0 === r) this._hasDeprecationWarned(i) || this._utils.logger.warn(this._deprecatedHandler(i, t, this._utils));
          else
           for (let { value: n } of r) {
            let e = { key: i, value: n };
            if (!this._hasDeprecationWarned(e)) {
             let r = 'string' == typeof t ? { key: t, value: n } : t;
             this._utils.logger.warn(this._deprecatedHandler(e, r, this._utils));
            }
           }
        };
       mr(n.forward(s, this._utils), s).forEach(a);
       let u = yr(n.redirect(s, this._utils), s);
       if ((u.redirect.forEach(a), 'remain' in u)) {
        let e = u.remain;
        (t[i] = i in t ? n.overlap(t[i], e, this._utils) : e), o({ value: e });
       }
       for (let { from: e, to: t } of u.redirect) o({ value: e, redirectTo: t });
      }
      for (let i of s) {
       let n = e[i];
       this._applyUnknownHandler(i, n, t, (e, t) => {
        r.push({ [e]: t });
       });
      }
      return r;
     }
     _applyRequiredCheck(e) {
      for (let t of Object.keys(this._utils.schemas)) if (this._identifyMissing(t, e) && this._identifyRequired(t)) throw this._invalidHandler(t, zt, this._utils);
     }
     _partitionOptionKeys(e) {
      let [t, r] = (function (e, t) {
       let r = [],
        n = [];
       for (let s of e) t(s) ? r.push(s) : n.push(s);
       return [r, n];
      })(
       Object.keys(e).filter((t) => !this._identifyMissing(t, e)),
       (e) => e in this._utils.schemas,
      );
      return { knownKeys: t, unknownKeys: r };
     }
     _applyValidation(e, t, r) {
      let n = hr(r.validate(e, this._utils), e);
      if (!0 !== n) throw this._invalidHandler(t, n.value, this._utils);
     }
     _applyUnknownHandler(e, t, r, n) {
      let s = this._unknownHandler(e, t, this._utils);
      if (s)
       for (let i of Object.keys(s)) {
        if (this._identifyMissing(i, s)) continue;
        let e = s[i];
        i in this._utils.schemas ? n(i, e) : (r[i] = e);
       }
     }
     _applyPostprocess(e) {
      let t = this._postprocess(e, this._utils);
      if (t !== Vt) {
       if (t.delete) for (let r of t.delete) delete e[r];
       if (t.override) {
        let { knownKeys: r, unknownKeys: n } = this._partitionOptionKeys(t.override);
        for (let s of r) {
         let r = t.override[s];
         this._applyValidation(r, s, this._utils.schemas[s]), (e[s] = r);
        }
        for (let s of n) {
         let r = t.override[s];
         this._applyUnknownHandler(s, r, e, (t, r) => {
          let n = this._utils.schemas[t];
          this._applyValidation(r, t, n), (e[t] = r);
         });
        }
       }
      }
     }
    };
   function Ar(e, { isCLI: t, optionInfos: r, FlagSchema: n }) {
    let s,
     { name: i } = e,
     a = { name: i },
     o = {};
    switch (e.type) {
     case 'int':
      (s = br), t && (a.preprocess = Number);
      break;
     case 'string':
     case 'path':
      s = vr;
      break;
     case 'choice':
      (s = Dr), (a.choices = e.choices.map((t) => (null != t && t.redirect ? { ...t, redirect: { to: { key: e.name, value: t.redirect } } } : t)));
      break;
     case 'boolean':
      s = or;
      break;
     case 'flag':
      (s = n), (a.flags = r.flatMap((e) => [e.alias, e.description && e.name, e.oppositeDescription && `no-${e.name}`].filter(Boolean)));
      break;
     default:
      throw new Error(`Unexpected type ${e.type}`);
    }
    if ((e.exception ? (a.validate = (t, r, n) => e.exception(t) || r.validate(t, n)) : (a.validate = (e, t, r) => void 0 === e || t.validate(e, r)), e.redirect && (o.redirect = (t) => (t ? { to: 'string' == typeof e.redirect ? e.redirect : { key: e.redirect.option, value: e.redirect.value } } : void 0)), e.deprecated && (o.deprecated = !0), t && !e.array)) {
     let e = a.preprocess || ((e) => e);
     a.preprocess = (t, r, n) => r.preprocess(e(Array.isArray(t) ? ee(!1, t, -1) : t), n);
    }
    return e.array ? ir.create({ ...(t ? { preprocess: (e) => (Array.isArray(e) ? e : [e]) } : {}), ...o, valueSchema: s.create(a) }) : s.create({ ...a, ...o });
   }
   var Fr = function (e, t, { logger: r = !1, isCLI: n = !1, passThrough: s = !1, FlagSchema: i, descriptor: a } = {}) {
     if (n) {
      if (!i) throw new Error("'FlagSchema' option is required.");
      if (!a) throw new Error("'descriptor' option is required.");
     } else a = Ut;
     let o = s
       ? Array.isArray(s)
         ? (e, t) => (s.includes(e) ? { [e]: t } : void 0)
         : (e, t) => ({ [e]: t })
       : (e, t, r) => {
          let { _: n, ...s } = r.schemas;
          return Zt(e, t, { ...r, schemas: s });
         },
      u = (function (e, { isCLI: t, FlagSchema: r }) {
       let n = [];
       t && n.push(sr.create({ name: '_' }));
       for (let s of e) n.push(Ar(s, { isCLI: t, optionInfos: e, FlagSchema: r })), s.alias && t && n.push(nr.create({ name: s.alias, sourceName: s.name }));
       return n;
      })(t, { isCLI: n, FlagSchema: i }),
      l = new wr(u, { logger: r, unknown: o, descriptor: a }),
      p = !1 !== r;
     p && gr && (l._hasDeprecationWarned = gr);
     let c = l.normalize(e);
     return p && (gr = l._hasDeprecationWarned), c;
    },
    kr = (e, t, r) => {
     if (!e || null != t) {
      if (t.findLast) return t.findLast(r);
      for (let e = t.length - 1; e >= 0; e--) {
       let n = t[e];
       if (r(n, e, t)) return n;
      }
     }
    };
   function Pr(e, t) {
    if (!t) throw new Error('parserName is required.');
    let r = kr(!1, e, (e) => e.parsers && Object.prototype.hasOwnProperty.call(e.parsers, t));
    if (r) return r;
    let n = `Couldn't resolve parser "${t}".`;
    throw ((n += ' Plugins must be explicitly added to the standalone bundle.'), new Bt(n));
   }
   function Ir({ plugins: e, parser: t }) {
    return Nr(Pr(e, t), t);
   }
   function Nr(e, t) {
    let r = e.parsers[t];
    return 'function' == typeof r ? r() : r;
   }
   var Br = { astFormat: 'estree', printer: {}, originalText: void 0, locStart: null, locEnd: null };
   var _r = async function (e, t = {}) {
     var r;
     let n = { ...e };
     if (!n.parser) {
      if (!n.filepath) throw new _t("No parser and no file path given, couldn't infer a parser.");
      if (((n.parser = qt(n, { physicalFile: n.filepath })), !n.parser)) throw new _t(`No parser could be inferred for file "${n.filepath}".`);
     }
     let s = Ot({ plugins: e.plugins, showDeprecated: !0 }).options,
      i = { ...Br, ...Object.fromEntries(s.filter((e) => void 0 !== e.default).map((e) => [e.name, e.default])) },
      a = Pr(n.plugins, n.parser),
      o = await Nr(a, n.parser);
     (n.astFormat = o.astFormat), (n.locEnd = o.locEnd), (n.locStart = o.locStart);
     let u =
       null != (r = a.printers) && r[o.astFormat]
        ? a
        : (function (e, t) {
           if (!t) throw new Error('astFormat is required.');
           let r = kr(!1, e, (e) => e.printers && Object.prototype.hasOwnProperty.call(e.printers, t));
           if (r) return r;
           let n = `Couldn't find plugin for AST format "${t}".`;
           throw ((n += ' Plugins must be explicitly added to the standalone bundle.'), new Bt(n));
          })(n.plugins, o.astFormat),
      l = await (function (e, t) {
       let r = e.printers[t];
       return 'function' == typeof r ? r() : r;
      })(u, o.astFormat);
     n.printer = l;
     let p = { ...i, ...(u.defaultOptions ? Object.fromEntries(Object.entries(u.defaultOptions).filter(([, e]) => void 0 !== e)) : {}) };
     for (let [c, h] of Object.entries(p)) (null === n[c] || void 0 === n[c]) && (n[c] = h);
     return 'json' === n.parser && (n.trailingComma = 'none'), Fr(n, s, { passThrough: Object.keys(Br), ...t });
    },
    Lr = h(m(), 1);
   var Or = async function (e, t) {
    let r,
     n = await Ir(t),
     s = n.preprocess ? n.preprocess(e, t) : e;
    t.originalText = s;
    try {
     r = await n.parse(s, t, t);
    } catch (i) {
     !(function (e, t) {
      let { loc: r } = e;
      if (r) {
       let n = (0, Lr.codeFrameColumns)(t, r, { highlightCode: !0 });
       throw ((e.message += '\n' + n), (e.codeFrame = n), e);
      }
      throw e;
     })(i, e);
    }
    return { text: s, ast: r };
   };
   async function Mr(e, t, r, n, s) {
    let {
     embeddedLanguageFormatting: i,
     printer: { embed: a, hasPrettierIgnore: o = () => !1, getVisitorKeys: u },
    } = r;
    if (!a || 'auto' !== i) return;
    if (a.length > 2) throw new Error('printer.embed has too many parameters. The API changed in Prettier v3. Please update your plugin. See https://prettier.io/docs/en/plugins.html#optional-embed');
    let l = mt(a.getVisitorKeys ?? u),
     p = [];
    !(function t() {
     let { node: n } = e;
     if (null === n || 'object' != typeof n || o(e)) return;
     for (let r of l(n)) Array.isArray(n[r]) ? e.each(t, r) : e.call(t, r);
     let i = a(e, r);
     if (i) {
      if ('function' == typeof i) return void p.push({ print: i, node: n, pathStack: [...e.stack] });
      s.set(n, i);
     }
    })();
    let c = e.stack;
    for (let { print: f, node: m, pathStack: y } of p)
     try {
      e.stack = y;
      let n = await f(h, t, e, r);
      n && s.set(m, n);
     } catch (d) {
      if (globalThis.PRETTIER_DEBUG) throw d;
     }
    function h(e, t) {
     return (async function (e, t, r, n) {
      let s = await _r({ ...r, ...t, parentParser: r.parser, originalText: e }, { passThrough: !0 }),
       { ast: i } = await Or(e, s),
       a = await n(i, s);
      return de(a);
     })(e, t, r, n);
    }
    e.stack = c;
   }
   var jr = function (e, t) {
    let { originalText: r, [Symbol.for('comments')]: n, locStart: s, locEnd: i, [Symbol.for('printedComments')]: a } = t,
     { node: o } = e,
     u = s(o),
     l = i(o);
    for (let p of n) s(p) >= u && i(p) <= l && a.add(p);
    return r.slice(u, l);
   };
   async function Rr(e, t) {
    ({ ast: e } = await Ur(e, t));
    let r = new Map(),
     n = new et(e),
     s = Nt(t),
     i = new Map();
    await Mr(n, o, t, Rr, i);
    let a = await qr(n, t, o, void 0, i);
    return (
     (function (e) {
      let { [Symbol.for('comments')]: t, [Symbol.for('printedComments')]: r } = e;
      for (let n of t) {
       if (!n.printed && !r.has(n)) throw new Error('Comment "' + n.value.trim() + '" was not printed. Please report this error!');
       delete n.printed;
      }
     })(t),
     t.nodeAfterCursor && !t.nodeBeforeCursor ? [Be, a] : t.nodeBeforeCursor && !t.nodeAfterCursor ? [a, Be] : a
    );
    function o(e, t) {
     return void 0 === e || e === n ? u(t) : Array.isArray(e) ? n.call(() => u(t), ...e) : n.call(() => u(t), e);
    }
    function u(e) {
     s(n);
     let a = n.node;
     if (null == a) return '';
     let u = a && 'object' == typeof a && void 0 === e;
     if (u && r.has(a)) return r.get(a);
     let l = qr(n, t, o, e, i);
     return u && r.set(a, l), l;
    }
   }
   function qr(e, t, r, n, s) {
    var i;
    let a,
     { node: o } = e,
     { printer: u } = t;
    switch (((a = null != (i = u.hasPrettierIgnore) && i.call(u, e) ? jr(e, t) : s.has(o) ? s.get(o) : u.print(e, t, r, n)), o)) {
     case t.cursorNode:
      a = me(a, (e) => [Be, e, Be]);
      break;
     case t.nodeBeforeCursor:
      a = me(a, (e) => [e, Be]);
      break;
     case t.nodeAfterCursor:
      a = me(a, (e) => [Be, e]);
    }
    return (
     u.printComment &&
      (!u.willPrintOwnComments || !u.willPrintOwnComments(e, t)) &&
      (a = (function (e, t, r) {
       let { leading: n, trailing: s } = It(e, r);
       return n || s ? me(t, (e) => [n, e, s]) : t;
      })(e, a, t)),
     a
    );
   }
   async function Ur(e, t) {
    let r = e.comments ?? [];
    (t[Symbol.for('comments')] = r),
     (t[Symbol.for('tokens')] = e.tokens ?? []),
     (t[Symbol.for('printedComments')] = new Set()),
     (function (e, t) {
      let { comments: r } = e;
      if ((delete e.comments, !ht(r) || !t.printer.canAttachComment)) return;
      let n = [],
       {
        locStart: s,
        locEnd: i,
        printer: { experimentalFeatures: { avoidAstMutation: a = !1 } = {}, handleComments: o = {} },
        originalText: u,
       } = t,
       { ownLine: l = Ct, endOfLine: p = Ct, remaining: c = Ct } = o,
       h = r.map((n, s) => ({ ...Et(e, n, t), comment: n, text: u, options: t, ast: e, isLastComment: r.length - 1 === s }));
      for (let [d, f] of h.entries()) {
       let e,
        { comment: t, precedingNode: r, enclosingNode: o, followingNode: u, text: m, options: y, ast: g, isLastComment: D } = f;
       if ('json' === y.parser || 'json5' === y.parser || 'jsonc' === y.parser || '__js_expression' === y.parser || '__ts_expression' === y.parser || '__vue_expression' === y.parser || '__vue_ts_expression' === y.parser) {
        if (s(t) - s(g) <= 0) {
         gt(g, t);
         continue;
        }
        if (i(t) - i(g) >= 0) {
         xt(g, t);
         continue;
        }
       }
       if ((a ? (e = [f]) : ((t.enclosingNode = o), (t.precedingNode = r), (t.followingNode = u), (e = [t, m, y, g, D])), St(m, y, h, d))) (t.placement = 'ownLine'), l(...e) || (u ? gt(u, t) : r ? xt(r, t) : Dt(o || g, t));
       else if (wt(m, y, h, d)) (t.placement = 'endOfLine'), p(...e) || (r ? xt(r, t) : u ? gt(u, t) : Dt(o || g, t));
       else if (((t.placement = 'remaining'), !c(...e)))
        if (r && u) {
         let e = n.length;
         e > 0 && n[e - 1].followingNode !== u && At(n, y), n.push(f);
        } else r ? xt(r, t) : u ? gt(u, t) : Dt(o || g, t);
      }
      if ((At(n, t), !a)) for (let d of r) delete d.precedingNode, delete d.enclosingNode, delete d.followingNode;
     })(e, t);
    let {
     printer: { preprocess: n },
    } = t;
    return { ast: (e = n ? await n(e, t) : e), comments: r };
   }
   var $r = function (e, t) {
    let { cursorOffset: r, locStart: n, locEnd: s } = t,
     i = mt(t.printer.getVisitorKeys),
     a = (e) => n(e) <= r && s(e) >= r,
     o = e,
     u = [e];
    for (let d of (function* (e, t) {
     let r = [e];
     for (let n = 0; n < r.length; n++) {
      let e = r[n];
      for (let n of st(e, t)) yield n, r.push(n);
     }
    })(e, { getVisitorKeys: i, filter: a }))
     u.push(d), (o = d);
    if (
     (function (e, t) {
      return st(e, t).next().done;
     })(o, { getVisitorKeys: i })
    )
     return { cursorNode: o };
    let l,
     p,
     c = -1,
     h = Number.POSITIVE_INFINITY;
    for (; u.length > 0 && (void 0 === l || void 0 === p); ) {
     o = u.pop();
     let e = void 0 !== l,
      t = void 0 !== p;
     for (let a of st(o, { getVisitorKeys: i })) {
      if (!e) {
       let e = s(a);
       e <= r && e > c && ((l = a), (c = e));
      }
      if (!t) {
       let e = n(a);
       e >= r && e < h && ((p = a), (h = e));
      }
     }
    }
    return { nodeBeforeCursor: l, nodeAfterCursor: p };
   };
   var Hr = function (e, t) {
     let {
      printer: { massageAstNode: r, getVisitorKeys: n },
     } = t;
     if (!r) return e;
     let s = mt(n),
      i = r.ignoredProperties ?? new Set();
     return (function e(t, n) {
      if (null === t || 'object' != typeof t) return t;
      if (Array.isArray(t)) return t.map((t) => e(t, n)).filter(Boolean);
      let a = {},
       o = new Set(s(t));
      for (let r in t) !Object.prototype.hasOwnProperty.call(t, r) || i.has(r) || (o.has(r) ? (a[r] = e(t[r], t)) : (a[r] = t[r]));
      let u = r(t, a, n);
      if (null !== u) return u ?? a;
     })(e);
    },
    zr = (e, t, r) => {
     if (!e || null != t) {
      if (t.findLastIndex) return t.findLastIndex(r);
      for (let e = t.length - 1; e >= 0; e--) {
       if (r(t[e], e, t)) return e;
      }
      return -1;
     }
    },
    Vr = ({ parser: e }) => 'json' === e || 'json5' === e || 'jsonc' === e || 'json-stringify' === e;
   function Wr(e) {
    let t = zr(!1, e, (e) => 'Program' !== e.type && 'File' !== e.type);
    return -1 === t ? e : e.slice(0, t + 1);
   }
   function Jr(e, t, r, n, s = [], i) {
    let { locStart: a, locEnd: o } = r,
     u = a(e),
     l = o(e);
    if (!(t > l || t < u || ('rangeEnd' === i && t === u) || ('rangeStart' === i && t === l))) {
     for (let a of vt(e, r)) {
      let o = Jr(a, t, r, n, [e, ...s], i);
      if (o) return o;
     }
     if (!n || n(e, s[0])) return { node: e, parentNodes: s };
    }
   }
   var Kr = new Set(['JsonRoot', 'ObjectExpression', 'ArrayExpression', 'StringLiteral', 'NumericLiteral', 'BooleanLiteral', 'NullLiteral', 'UnaryExpression', 'TemplateLiteral']),
    Gr = new Set(['OperationDefinition', 'FragmentDefinition', 'VariableDefinition', 'TypeExtensionDefinition', 'ObjectTypeDefinition', 'FieldDefinition', 'DirectiveDefinition', 'EnumTypeDefinition', 'EnumValueDefinition', 'InputValueDefinition', 'InputObjectTypeDefinition', 'SchemaDefinition', 'OperationTypeDefinition', 'InterfaceTypeDefinition', 'UnionTypeDefinition', 'ScalarTypeDefinition']);
   function Xr(e, t, r) {
    if (!t) return !1;
    switch (e.parser) {
     case 'flow':
     case 'babel':
     case 'babel-flow':
     case 'babel-ts':
     case 'typescript':
     case 'acorn':
     case 'espree':
     case 'meriyah':
     case '__babel_estree':
      return (function (e, t) {
       return 'DeclareExportDeclaration' !== t && 'TypeParameterDeclaration' !== e && ('Directive' === e || 'TypeAlias' === e || 'TSExportAssignment' === e || e.startsWith('Declare') || e.startsWith('TSDeclare') || e.endsWith('Statement') || e.endsWith('Declaration'));
      })(t.type, null == r ? void 0 : r.type);
     case 'json':
     case 'json5':
     case 'jsonc':
     case 'json-stringify':
      return Kr.has(t.type);
     case 'graphql':
      return Gr.has(t.kind);
     case 'vue':
      return 'root' !== t.tag;
    }
    return !1;
   }
   function Yr(e, t, r) {
    let { rangeStart: n, rangeEnd: s, locStart: i, locEnd: a } = t;
    rt.ok(s > n);
    let o = e.slice(n, s).search(/\S/u),
     u = -1 === o;
    if (!u) for (n += o; s > n && !/\S/u.test(e[s - 1]); --s);
    let l,
     p,
     c = Jr(r, n, t, (e, r) => Xr(t, e, r), [], 'rangeStart'),
     h = u ? c : Jr(r, s, t, (e) => Xr(t, e), [], 'rangeEnd');
    if (!c || !h) return { rangeStart: 0, rangeEnd: 0 };
    if (Vr(t)) {
     let e = (function (e, t) {
      let r = [e.node, ...e.parentNodes],
       n = new Set([t.node, ...t.parentNodes]);
      return r.find((e) => Kr.has(e.type) && n.has(e));
     })(c, h);
     (l = e), (p = e);
    } else
     ({ startNode: l, endNode: p } = (function (e, t, { locStart: r, locEnd: n }) {
      let s = e.node,
       i = t.node;
      if (s === i) return { startNode: s, endNode: i };
      let a = r(e.node);
      for (let u of Wr(t.parentNodes)) {
       if (!(r(u) >= a)) break;
       i = u;
      }
      let o = n(t.node);
      for (let u of Wr(e.parentNodes)) {
       if (!(n(u) <= o)) break;
       if (((s = u), s === i)) break;
      }
      return { startNode: s, endNode: i };
     })(c, h, t));
    return { rangeStart: Math.min(i(l), i(p)), rangeEnd: Math.max(a(l), a(p)) };
   }
   var Qr = '\ufeff',
    Zr = Symbol('cursor');
   async function en(e, t, r = 0) {
    if (!e || 0 === e.trim().length) return { formatted: '', cursorOffset: -1, comments: [] };
    let { ast: n, text: s } = await Or(e, t);
    t.cursorOffset >= 0 && (t = { ...t, ...$r(n, t) });
    let i = await Rr(n, t);
    r > 0 && (i = Le([Ie, i], r, t.tabWidth));
    let a = Ge(i, t);
    if (r > 0) {
     let e = a.formatted.trim();
     void 0 !== a.cursorNodeStart && ((a.cursorNodeStart -= a.formatted.indexOf(e)), a.cursorNodeStart < 0 && ((a.cursorNodeStart = 0), (a.cursorNodeText = a.cursorNodeText.trimStart())), a.cursorNodeStart + a.cursorNodeText.length > e.length && (a.cursorNodeText = a.cursorNodeText.trimEnd())), (a.formatted = e + O(t.endOfLine));
    }
    let o = t[Symbol.for('comments')];
    if (t.cursorOffset >= 0) {
     let e, r, n, i;
     if ((t.cursorNode || t.nodeBeforeCursor || t.nodeAfterCursor) && a.cursorNodeText)
      if (((n = a.cursorNodeStart), (i = a.cursorNodeText), t.cursorNode)) (e = t.locStart(t.cursorNode)), (r = s.slice(e, t.locEnd(t.cursorNode)));
      else {
       if (!t.nodeBeforeCursor && !t.nodeAfterCursor) throw new Error('Cursor location must contain at least one of cursorNode, nodeBeforeCursor, nodeAfterCursor');
       e = t.nodeBeforeCursor ? t.locEnd(t.nodeBeforeCursor) : 0;
       let n = t.nodeAfterCursor ? t.locStart(t.nodeAfterCursor) : s.length;
       r = s.slice(e, n);
      }
     else (e = 0), (r = s), (n = 0), (i = a.formatted);
     let u = t.cursorOffset - e;
     if (r === i) return { formatted: a.formatted, cursorOffset: n + u, comments: o };
     let l = r.split('');
     l.splice(u, 0, Zr);
     let p = (function (e, t, r) {
       return L.diff(e, t, r);
      })(l, i.split('')),
      c = n;
     for (let t of p)
      if (t.removed) {
       if (t.value.includes(Zr)) break;
      } else c += t.count;
     return { formatted: a.formatted, cursorOffset: c, comments: o };
    }
    return { formatted: a.formatted, cursorOffset: -1, comments: o };
   }
   function tn(e, t, r) {
    return 'number' != typeof t || Number.isNaN(t) || t < 0 || t > e.length ? r : t;
   }
   function rn(e, t) {
    let { cursorOffset: r, rangeStart: n, rangeEnd: s } = t;
    return (r = tn(e, r, -1)), (n = tn(e, n, 0)), (s = tn(e, s, e.length)), { ...t, cursorOffset: r, rangeStart: n, rangeEnd: s };
   }
   function nn(e, t) {
    let { cursorOffset: r, rangeStart: n, rangeEnd: s, endOfLine: i } = rn(e, t),
     a = e.charAt(0) === Qr;
    if (
     (a && ((e = e.slice(1)), r--, n--, s--),
     'auto' === i &&
      (i = (function (e) {
       let t = e.indexOf('\r');
       return -1 !== t ? ('\n' === e.charAt(t + 1) ? 'crlf' : 'cr') : 'lf';
      })(e)),
     e.includes('\r'))
    ) {
     let t = (t) => M(e.slice(0, Math.max(t, 0)), '\r\n');
     (r -= t(r)),
      (n -= t(n)),
      (s -= t(s)),
      (e = (function (e) {
       return g(!1, e, /\r\n?/gu, '\n');
      })(e));
    }
    return { hasBOM: a, text: e, options: rn(e, { ...t, cursorOffset: r, rangeStart: n, rangeEnd: s, endOfLine: i }) };
   }
   async function sn(e, t) {
    let r = await Ir(t);
    return !r.hasPragma || r.hasPragma(e);
   }
   async function an(e, t) {
    let r,
     { hasBOM: n, text: s, options: i } = nn(e, await _r(t));
    return (i.rangeStart >= i.rangeEnd && '' !== s) || (i.requirePragma && !(await sn(s, i)))
     ? { formatted: e, cursorOffset: t.cursorOffset, comments: [] }
     : (i.rangeStart > 0 || i.rangeEnd < s.length
        ? (r = await (async function (e, t) {
           let { ast: r, text: n } = await Or(e, t),
            { rangeStart: s, rangeEnd: i } = Yr(n, t, r),
            a = n.slice(s, i),
            o = Math.min(s, n.lastIndexOf('\n', s) + 1),
            u = n.slice(o, s).match(/^\s*/u)[0],
            l = Ze(u, t.tabWidth),
            p = await en(a, { ...t, rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: t.cursorOffset > s && t.cursorOffset <= i ? t.cursorOffset - s : -1, endOfLine: 'lf' }, l),
            c = p.formatted.trimEnd(),
            { cursorOffset: h } = t;
           h > i ? (h += c.length - a.length) : p.cursorOffset >= 0 && (h = p.cursorOffset + s);
           let d = n.slice(0, s) + c + n.slice(i);
           if ('lf' !== t.endOfLine) {
            let e = O(t.endOfLine);
            h >= 0 && '\r\n' === e && (h += M(d.slice(0, h), '\n')), (d = g(!1, d, '\n', e));
           }
           return { formatted: d, cursorOffset: h, comments: p.comments };
          })(s, i))
        : (!i.requirePragma && i.insertPragma && i.printer.insertPragma && !(await sn(s, i)) && (s = i.printer.insertPragma(s)), (r = await en(s, i))),
       n && ((r.formatted = Qr + r.formatted), r.cursorOffset >= 0 && r.cursorOffset++),
       r);
   }
   var on = {};
   c(on, { builders: () => un, printer: () => ln, utils: () => pn });
   var un = {
     join: _e,
     line: ke,
     softline: Pe,
     hardline: Ie,
     literalline: Ne,
     group: Ee,
     conditionalGroup: function (e, t) {
      return Ee(e[0], { ...t, expandedStates: e });
     },
     fill: function (e) {
      return xe(e), { type: V, parts: e };
     },
     lineSuffix: Ce,
     lineSuffixBoundary: Te,
     cursor: Be,
     breakParent: Se,
     ifBreak: function (e, t = '', r = {}) {
      return ge(e), '' !== t && ge(t), { type: W, breakContents: e, flatContents: t, groupId: r.groupId };
     },
     trim: we,
     indent: be,
     indentIfBreak: function (e, t) {
      return ge(e), { type: J, contents: e, groupId: t.groupId, negate: t.negate };
     },
     align: ve,
     addAlignmentToDoc: Le,
     markAsRoot: function (e) {
      return ve({ type: 'root' }, e);
     },
     dedentToRoot: function (e) {
      return ve(Number.NEGATIVE_INFINITY, e);
     },
     dedent: function (e) {
      return ve(-1, e);
     },
     hardlineWithoutBreakParent: Ae,
     literallineWithoutBreakParent: Fe,
     label: function (e, t) {
      return ge(t), e ? { type: Y, label: e, contents: t } : t;
     },
     concat: (e) => e,
    },
    ln = { printDocToString: Ge },
    pn = {
     willBreak: function (e) {
      return oe(e, ue, !1);
     },
     traverseDoc: ie,
     findInDoc: oe,
     mapDoc: ae,
     removeLines: function (e) {
      return ae(e, pe);
     },
     stripTrailingHardline: de,
     replaceEndOfLine: function (e, t = Ne) {
      return ae(e, (e) => ('string' == typeof e ? _e(t, e.split('\n')) : e));
     },
     canBreak: function (e) {
      return oe(e, fe, !1);
     },
    },
    cn = '3.5.1',
    hn = {};
   c(hn, { addDanglingComment: () => Dt, addLeadingComment: () => gt, addTrailingComment: () => xt, getAlignmentSize: () => Ze, getIndentSize: () => gn, getMaxContinuousCount: () => Dn, getNextNonSpaceNonCommentCharacter: () => xn, getNextNonSpaceNonCommentCharacterIndex: () => Sn, getPreferredQuote: () => vn, getStringWidth: () => Re, hasNewline: () => ct, hasNewlineInRange: () => En, hasSpaces: () => Cn, isNextLineEmpty: () => An, isNextLineEmptyAfterIndex: () => yn, isPreviousLineEmpty: () => wn, makeString: () => Tn, skip: () => it, skipEverythingButNewLine: () => lt, skipInlineComment: () => dn, skipNewline: () => pt, skipSpaces: () => ot, skipToLineEnd: () => ut, skipTrailingComment: () => fn, skipWhitespace: () => at });
   var dn = function (e, t) {
    if (!1 === t) return !1;
    if ('/' === e.charAt(t) && '*' === e.charAt(t + 1)) for (let r = t + 2; r < e.length; ++r) if ('*' === e.charAt(r) && '/' === e.charAt(r + 1)) return r + 2;
    return t;
   };
   var fn = function (e, t) {
    return !1 !== t && ('/' === e.charAt(t) && '/' === e.charAt(t + 1) ? lt(e, t) : t);
   };
   var mn = function (e, t) {
    let r = null,
     n = t;
    for (; n !== r; ) (r = n), (n = ot(e, n)), (n = dn(e, n)), (n = fn(e, n)), (n = pt(e, n));
    return n;
   };
   var yn = function (e, t) {
    let r = null,
     n = t;
    for (; n !== r; ) (r = n), (n = ut(e, n)), (n = dn(e, n)), (n = ot(e, n));
    return (n = fn(e, n)), (n = pt(e, n)), !1 !== n && ct(e, n);
   };
   var gn = function (e, t) {
    let r = e.lastIndexOf('\n');
    return -1 === r ? 0 : Ze(e.slice(r + 1).match(/^[\t ]*/u)[0], t);
   };
   var Dn = function (e, t) {
    let r = e.match(
     new RegExp(
      `(${(function (e) {
       if ('string' != typeof e) throw new TypeError('Expected a string');
       return e.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&').replace(/-/g, '\\x2d');
      })(t)})+`,
      'gu',
     ),
    );
    return null === r ? 0 : r.reduce((e, r) => Math.max(e, r.length / t.length), 0);
   };
   var xn = function (e, t) {
     let r = mn(e, t);
     return !1 === r ? '' : e.charAt(r);
    },
    bn = "'";
   var vn = function (e, t) {
    let r = !0 === t || t === bn ? bn : '"',
     n = r === bn ? '"' : bn,
     s = 0,
     i = 0;
    for (let a of e) a === r ? s++ : a === n && i++;
    return s > i ? n : r;
   };
   var En = function (e, t, r) {
    for (let n = t; n < r; ++n) if ('\n' === e.charAt(n)) return !0;
    return !1;
   };
   var Cn = function (e, t, r = {}) {
    return ot(e, r.backwards ? t - 1 : t, r) !== t;
   };
   var Tn = function (e, t, r) {
    let n = '"' === t ? "'" : '"',
     s = g(!1, e, /\\(.)|(["'])/gsu, (e, s, i) => (s === n ? s : i === t ? '\\' + i : i || (r && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/u.test(s) ? s : '\\' + s)));
    return t + s + t;
   };
   function Sn(e, t) {
    return 2 === arguments.length || 'number' == typeof t
     ? mn(e, t)
     : (function (e, t, r) {
        return mn(e, r(t));
       })(...arguments);
   }
   function wn(e, t) {
    return 2 === arguments.length || 'number' == typeof t
     ? kt(e, t)
     : (function (e, t, r) {
        return kt(e, r(t));
       })(...arguments);
   }
   function An(e, t) {
    return 2 === arguments.length || 'number' == typeof t
     ? yn(e, t)
     : (function (e, t, r) {
        return yn(e, r(t));
       })(...arguments);
   }
   function Fn(e, t = 1) {
    return async (...r) => {
     let n = r[t] ?? {},
      s = n.plugins ?? [];
     return (r[t] = { ...n, plugins: Array.isArray(s) ? s : Object.values(s) }), e(...r);
    };
   }
   var kn = Fn(an);
   async function Pn(e, t) {
    let { formatted: r } = await kn(e, { ...t, cursorOffset: -1 });
    return r;
   }
   async function In(e, t) {
    return (await Pn(e, t)) === e;
   }
   var Nn = Fn(Ot, 0),
    Bn = {
     parse: Fn(async function (e, t, r) {
      let { text: n, options: s } = nn(e, await _r(t)),
       i = await Or(n, s);
      return r && (r.preprocessForPrint && (i.ast = await Ur(i.ast, s)), r.massage && (i.ast = Hr(i.ast, s))), i;
     }),
     formatAST: Fn(async function (e, t) {
      return (t = await _r(t)), Ge(await Rr(e, t), t);
     }),
     formatDoc: Fn(async function (e, t) {
      let r = (function (e) {
        let t = Object.create(null),
         r = new Set();
        return (function e(t, r, s) {
         var i, a;
         if ('string' == typeof t) return JSON.stringify(t);
         if (Array.isArray(t)) {
          let r = t.map(e).filter(Boolean);
          return 1 === r.length ? r[0] : `[${r.join(', ')}]`;
         }
         if (t.type === X) {
          let e = (null == (i = null == s ? void 0 : s[r + 1]) ? void 0 : i.type) === Q;
          return t.literal ? (e ? 'literalline' : 'literallineWithoutBreakParent') : t.hard ? (e ? 'hardline' : 'hardlineWithoutBreakParent') : t.soft ? 'softline' : 'line';
         }
         if (t.type === Q) return (null == (a = null == s ? void 0 : s[r - 1]) ? void 0 : a.type) === X && s[r - 1].hard ? void 0 : 'breakParent';
         if (t.type === H) return 'trim';
         if (t.type === U) return 'indent(' + e(t.contents) + ')';
         if (t.type === $) return t.n === Number.NEGATIVE_INFINITY ? 'dedentToRoot(' + e(t.contents) + ')' : t.n < 0 ? 'dedent(' + e(t.contents) + ')' : 'root' === t.n.type ? 'markAsRoot(' + e(t.contents) + ')' : 'align(' + JSON.stringify(t.n) + ', ' + e(t.contents) + ')';
         if (t.type === W) return 'ifBreak(' + e(t.breakContents) + (t.flatContents ? ', ' + e(t.flatContents) : '') + (t.groupId ? (t.flatContents ? '' : ', ""') + `, { groupId: ${n(t.groupId)} }` : '') + ')';
         if (t.type === J) {
          let r = [];
          t.negate && r.push('negate: true'), t.groupId && r.push(`groupId: ${n(t.groupId)}`);
          let s = r.length > 0 ? `, { ${r.join(', ')} }` : '';
          return `indentIfBreak(${e(t.contents)}${s})`;
         }
         if (t.type === z) {
          let r = [];
          t.break && 'propagated' !== t.break && r.push('shouldBreak: true'), t.id && r.push(`id: ${n(t.id)}`);
          let s = r.length > 0 ? `, { ${r.join(', ')} }` : '';
          return t.expandedStates ? `conditionalGroup([${t.expandedStates.map((t) => e(t)).join(',')}]${s})` : `group(${e(t.contents)}${s})`;
         }
         if (t.type === V) return `fill([${t.parts.map((t) => e(t)).join(', ')}])`;
         if (t.type === K) return 'lineSuffix(' + e(t.contents) + ')';
         if (t.type === G) return 'lineSuffixBoundary';
         if (t.type === Y) return `label(${JSON.stringify(t.label)}, ${e(t.contents)})`;
         throw new Error('Unknown doc type ' + t.type);
        })(Oe(e));
        function n(e) {
         if ('symbol' != typeof e) return JSON.stringify(String(e));
         if (e in t) return t[e];
         let n = e.description || 'symbol';
         for (let s = 0; ; s++) {
          let i = n + (s > 0 ? ` #${s}` : '');
          if (!r.has(i)) return r.add(i), (t[e] = `Symbol.for(${JSON.stringify(i)})`);
         }
        }
       })(e),
       { formatted: n } = await an(r, { ...t, parser: '__js_expression' });
      return n;
     }),
     printToDoc: Fn(async function (e, t) {
      t = await _r(t);
      let { ast: r } = await Or(e, t);
      return Rr(r, t);
     }),
     printDocToString: Fn(async function (e, t) {
      return Ge(e, await _r(t));
     }),
    },
    _n = y;
  },
 },
]);
