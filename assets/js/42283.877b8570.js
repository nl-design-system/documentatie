'use strict';
(self.webpackChunk_nl_design_system_website = self.webpackChunk_nl_design_system_website || []).push([
 [42283],
 {
  64642: (e, t, r) => {
   r.d(t, { Z: () => Ce });
   var s,
    n,
    i = Object.create,
    a = Object.defineProperty,
    o = Object.getOwnPropertyDescriptor,
    u = Object.getOwnPropertyNames,
    l = Object.getPrototypeOf,
    p = Object.prototype.hasOwnProperty,
    c = (e, t, r) => (
     (r = null != e ? i(l(e)) : {}),
     ((e, t, r, s) => {
      if ((t && 'object' == typeof t) || 'function' == typeof t) for (let n of u(t)) !p.call(e, n) && n !== r && a(e, n, { get: () => t[n], enumerable: !(s = o(t, n)) || s.enumerable });
      return e;
     })(!t && e && e.__esModule ? r : a(r, 'default', { value: e, enumerable: !0 }), e)
    ),
    h =
     ((s = (e) => {
      function t(e, t) {
       if (null == e) return {};
       var r = {};
       for (var s in e)
        if ({}.hasOwnProperty.call(e, s)) {
         if (t.includes(s)) continue;
         r[s] = e[s];
        }
       return r;
      }
      Object.defineProperty(e, '__esModule', { value: !0 });
      var r = class {
        constructor(e, t, r) {
         (this.line = void 0), (this.column = void 0), (this.index = void 0), (this.line = e), (this.column = t), (this.index = r);
        }
       },
       s = class {
        constructor(e, t) {
         (this.start = void 0), (this.end = void 0), (this.filename = void 0), (this.identifierName = void 0), (this.start = e), (this.end = t);
        }
       };
      function n(e, t) {
       let { line: s, column: n, index: i } = e;
       return new r(s, n + t, i + t);
      }
      var i = 'BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED',
       a = { ImportMetaOutsideModule: { message: 'import.meta may appear only with \'sourceType: "module"\'', code: i }, ImportOutsideModule: { message: "'import' and 'export' may appear only with 'sourceType: \"module\"'", code: i } },
       o = { ArrayPattern: 'array destructuring pattern', AssignmentExpression: 'assignment expression', AssignmentPattern: 'assignment expression', ArrowFunctionExpression: 'arrow function expression', ConditionalExpression: 'conditional expression', CatchClause: 'catch clause', ForOfStatement: 'for-of statement', ForInStatement: 'for-in statement', ForStatement: 'for-loop', FormalParameters: 'function parameter list', Identifier: 'identifier', ImportSpecifier: 'import specifier', ImportDefaultSpecifier: 'import default specifier', ImportNamespaceSpecifier: 'import namespace specifier', ObjectPattern: 'object destructuring pattern', ParenthesizedExpression: 'parenthesized expression', RestElement: 'rest element', UpdateExpression: { true: 'prefix operation', false: 'postfix operation' }, VariableDeclarator: 'variable declaration', YieldExpression: 'yield expression' },
       u = (e) => ('UpdateExpression' === e.type ? o.UpdateExpression[`${e.prefix}`] : o[e.type]),
       l = { AccessorIsGenerator: ({ kind: e }) => `A ${e}ter cannot be a generator.`, ArgumentsInClass: "'arguments' is only allowed in functions and class methods.", AsyncFunctionInSingleStatementContext: 'Async functions can only be declared at the top level or inside a block.', AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.", AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.", AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.", AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncFunction: "'await' is only allowed within async functions.", BadGetterArity: "A 'get' accessor must not have any formal parameters.", BadSetterArity: "A 'set' accessor must have exactly one formal parameter.", BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.", ConstructorClassField: "Classes may not have a field named 'constructor'.", ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.", ConstructorIsAccessor: 'Class constructor may not be an accessor.', ConstructorIsAsync: "Constructor can't be an async function.", ConstructorIsGenerator: "Constructor can't be a generator.", DeclarationMissingInitializer: ({ kind: e }) => `Missing initializer in ${e} declaration.`, DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.", DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.", DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.", DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?", DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.", DecoratorSemicolon: 'Decorators must not be followed by a semicolon.', DecoratorStaticBlock: "Decorators can't be used with a static block.", DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.', DeletePrivateField: 'Deleting a private field is not allowed.', DestructureNamedImport: 'ES2015 named imports do not destructure. Use another statement for destructuring after the import.', DuplicateConstructor: 'Duplicate constructor in the same class.', DuplicateDefaultExport: 'Only one default export allowed per module.', DuplicateExport: ({ exportName: e }) => `\`${e}\` has already been exported. Exported identifiers must be unique.`, DuplicateProto: 'Redefinition of __proto__ property.', DuplicateRegExpFlags: 'Duplicate regular expression flag.', DynamicImportPhaseRequiresImportExpressions: ({ phase: e }) => `'import.${e}(...)' can only be parsed when using the 'createImportExpressions' option.`, ElementAfterRest: 'Rest element must be last element.', EscapedCharNotAnIdentifier: 'Invalid Unicode escape.', ExportBindingIsString: ({ localName: e, exportName: t }) => `A string literal cannot be used as an exported binding without \`from\`.\n- Did you mean \`export { '${e}' as '${t}' } from 'some-module'\`?`, ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.", ForInOfLoopInitializer: ({ type: e }) => `'${'ForInStatement' === e ? 'for-in' : 'for-of'}' loop variable declaration may not have an initializer.`, ForInUsing: "For-in loop may not start with 'using' declaration.", ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.", ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.", GeneratorInSingleStatementContext: 'Generators can only be declared at the top level or inside a block.', IllegalBreakContinue: ({ type: e }) => `Unsyntactic ${'BreakStatement' === e ? 'break' : 'continue'}.`, IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.", IllegalReturn: "'return' outside of function.", ImportAttributesUseAssert: 'The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedImportAssert` parser plugin to suppress this error.', ImportBindingIsString: ({ importName: e }) => `A string literal cannot be used as an imported binding.\n- Did you mean \`import { "${e}" as foo }\`?`, ImportCallArity: '`import()` requires exactly one or two arguments.', ImportCallNotNewExpression: 'Cannot use new with import(...).', ImportCallSpreadArgument: '`...` is not allowed in `import()`.', ImportJSONBindingNotDefault: 'A JSON module can only be imported with `default`.', ImportReflectionHasAssertion: '`import module x` cannot have assertions.', ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.', IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.", InvalidBigIntLiteral: 'Invalid BigIntLiteral.', InvalidCodePoint: 'Code point out of bounds.', InvalidCoverInitializedName: 'Invalid shorthand property initializer.', InvalidDecimal: 'Invalid decimal.', InvalidDigit: ({ radix: e }) => `Expected number in radix ${e}.`, InvalidEscapeSequence: 'Bad character escape sequence.', InvalidEscapeSequenceTemplate: 'Invalid escape sequence in template.', InvalidEscapedReservedWord: ({ reservedWord: e }) => `Escape sequence in keyword ${e}.`, InvalidIdentifier: ({ identifierName: e }) => `Invalid identifier ${e}.`, InvalidLhs: ({ ancestor: e }) => `Invalid left-hand side in ${u(e)}.`, InvalidLhsBinding: ({ ancestor: e }) => `Binding invalid left-hand side in ${u(e)}.`, InvalidLhsOptionalChaining: ({ ancestor: e }) => `Invalid optional chaining in the left-hand side of ${u(e)}.`, InvalidNumber: 'Invalid number.', InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.", InvalidOrUnexpectedToken: ({ unexpected: e }) => `Unexpected character '${e}'.`, InvalidParenthesizedAssignment: 'Invalid parenthesized assignment pattern.', InvalidPrivateFieldResolution: ({ identifierName: e }) => `Private name #${e} is not defined.`, InvalidPropertyBindingPattern: 'Binding member expression.', InvalidRecordProperty: 'Only properties and spread elements are allowed in record definitions.', InvalidRestAssignmentPattern: "Invalid rest operator's argument.", LabelRedeclaration: ({ labelName: e }) => `Label '${e}' is already declared.`, LetInLexicalBinding: "'let' is disallowed as a lexically bound name.", LineTerminatorBeforeArrow: "No line break is allowed before '=>'.", MalformedRegExpFlags: 'Invalid regular expression flag.', MissingClassName: 'A class name is required.', MissingEqInAssignment: "Only '=' operator can be used for specifying default value.", MissingSemicolon: 'Missing semicolon.', MissingPlugin: ({ missingPlugin: e }) => `This experimental syntax requires enabling the parser plugin: ${e.map((e) => JSON.stringify(e)).join(', ')}.`, MissingOneOfPlugins: ({ missingPlugin: e }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${e.map((e) => JSON.stringify(e)).join(', ')}.`, MissingUnicodeEscape: 'Expecting Unicode escape sequence \\uXXXX.', MixingCoalesceWithLogical: 'Nullish coalescing operator(??) requires parens when mixing with logical operators.', ModuleAttributeDifferentFromType: 'The only accepted module attribute is `type`.', ModuleAttributeInvalidValue: 'Only string literals are allowed as module attribute values.', ModuleAttributesWithDuplicateKeys: ({ key: e }) => `Duplicate key "${e}" is not allowed in module attributes.`, ModuleExportNameHasLoneSurrogate: ({ surrogateCharCode: e }) => `An export name cannot include a lone surrogate, found '\\u${e.toString(16)}'.`, ModuleExportUndefined: ({ localName: e }) => `Export '${e}' is not defined.`, MultipleDefaultsInSwitch: 'Multiple default clauses.', NewlineAfterThrow: 'Illegal newline after throw.', NoCatchOrFinally: 'Missing catch or finally clause.', NumberIdentifier: 'Identifier directly after number.', NumericSeparatorInEscapeSequence: 'Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.', ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.", OptionalChainingNoNew: 'Constructors in/after an Optional Chain are not allowed.', OptionalChainingNoTemplate: 'Tagged Template Literals are not allowed in optionalChain.', OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.", ParamDupe: 'Argument name clash.', PatternHasAccessor: "Object pattern can't contain getter or setter.", PatternHasMethod: "Object pattern can't contain methods.", PrivateInExpectedIn: ({ identifierName: e }) => `Private names are only allowed in property accesses (\`obj.#${e}\`) or in \`in\` expressions (\`#${e} in obj\`).`, PrivateNameRedeclaration: ({ identifierName: e }) => `Duplicate private name #${e}.`, RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", RecordNoProto: "'__proto__' is not allowed in Record expressions.", RestTrailingComma: 'Unexpected trailing comma after rest element.', SloppyFunction: 'In non-strict mode code, functions can only be declared at top level or inside a block.', SloppyFunctionAnnexB: 'In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.', SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.', StaticPrototype: 'Classes may not have static property named prototype.', SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?", SuperPrivateField: "Private fields can't be accessed on super.", TrailingDecorator: 'Decorators must be attached to a class element.', TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", UnexpectedArgumentPlaceholder: 'Unexpected argument placeholder.', UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.', UnexpectedDigitAfterHash: 'Unexpected digit after hash token.', UnexpectedImportExport: "'import' and 'export' may only appear at the top level.", UnexpectedKeyword: ({ keyword: e }) => `Unexpected keyword '${e}'.`, UnexpectedLeadingDecorator: 'Leading decorators must be attached to a class declaration.', UnexpectedLexicalDeclaration: 'Lexical declaration cannot appear in a single-statement context.', UnexpectedNewTarget: '`new.target` can only be used in functions or class properties.', UnexpectedNumericSeparator: 'A numeric separator is only allowed between two digits.', UnexpectedPrivateField: 'Unexpected private name.', UnexpectedReservedWord: ({ reservedWord: e }) => `Unexpected reserved word '${e}'.`, UnexpectedSuper: "'super' is only allowed in object methods and classes.", UnexpectedToken: ({ expected: e, unexpected: t }) => `Unexpected token${t ? ` '${t}'.` : ''}${e ? `, expected "${e}"` : ''}`, UnexpectedTokenUnaryExponentiation: 'Illegal expression. Wrap left hand side or entire exponentiation in parentheses.', UnexpectedUsingDeclaration: 'Using declaration cannot appear in the top level when source type is `script`.', UnsupportedBind: 'Binding should be performed on object property.', UnsupportedDecoratorExport: 'A decorated export must export a class declaration.', UnsupportedDefaultExport: 'Only expressions, functions or classes are allowed as the `default` export.', UnsupportedImport: '`import` can only be used in `import()` or `import.meta`.', UnsupportedMetaProperty: ({ target: e, onlyValidPropertyName: t }) => `The only valid meta property for ${e} is ${e}.${t}.`, UnsupportedParameterDecorator: 'Decorators cannot be used to decorate parameters.', UnsupportedPropertyDecorator: 'Decorators cannot be used to decorate object literal properties.', UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).", UnterminatedComment: 'Unterminated comment.', UnterminatedRegExp: 'Unterminated regular expression.', UnterminatedString: 'Unterminated string constant.', UnterminatedTemplate: 'Unterminated template.', UsingDeclarationExport: 'Using declaration cannot be exported.', UsingDeclarationHasBindingPattern: 'Using declaration cannot have destructuring patterns.', VarRedeclaration: ({ identifierName: e }) => `Identifier '${e}' has already been declared.`, YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.", YieldInParameter: 'Yield expression is not allowed in formal parameters.', ZeroDigitNumericSeparator: 'Numeric separator can not be used after leading 0.' },
       p = new Set(['ArrowFunctionExpression', 'AssignmentExpression', 'ConditionalExpression', 'YieldExpression']),
       c = Object.assign({ PipeBodyIsTighter: 'Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.', PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.', PipeTopicUnbound: 'Topic reference is unbound; it must be inside a pipe body.', PipeTopicUnconfiguredToken: ({ token: e }) => `Invalid topic token ${e}. In order to use ${e} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${e}" }.`, PipeTopicUnused: 'Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.', PipeUnparenthesizedBody: ({ type: e }) => `Hack-style pipe body cannot be an unparenthesized ${u({ type: e })}; please wrap it in parentheses.` }, { PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.', PipelineBodySequenceExpression: 'Pipeline body may not be a comma-separated sequence expression.', PipelineHeadSequenceExpression: 'Pipeline head should not be a comma-separated sequence expression.', PipelineTopicUnused: 'Pipeline is in topic style but does not use topic reference.', PrimaryTopicNotAllowed: 'Topic reference was used in a lexical context without topic binding.', PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.' }),
       h = ['message'];
      function d(e, t, r) {
       Object.defineProperty(e, t, { enumerable: !1, configurable: !0, value: r });
      }
      function f({ toMessage: e, code: t, reasonCode: s, syntaxPlugin: n }) {
       let i = 'MissingPlugin' === s || 'MissingOneOfPlugins' === s;
       {
        let e = { AccessorCannotDeclareThisParameter: 'AccesorCannotDeclareThisParameter', AccessorCannotHaveTypeParameters: 'AccesorCannotHaveTypeParameters', ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: 'ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference', SetAccessorCannotHaveOptionalParameter: 'SetAccesorCannotHaveOptionalParameter', SetAccessorCannotHaveRestParameter: 'SetAccesorCannotHaveRestParameter', SetAccessorCannotHaveReturnType: 'SetAccesorCannotHaveReturnType' };
        e[s] && (s = e[s]);
       }
       return function a(o, u) {
        let l = new SyntaxError();
        return (
         (l.code = t),
         (l.reasonCode = s),
         (l.loc = o),
         (l.pos = o.index),
         (l.syntaxPlugin = n),
         i && (l.missingPlugin = u.missingPlugin),
         d(l, 'clone', function (e = {}) {
          var t;
          let { line: s, column: n, index: i } = null != (t = e.loc) ? t : o;
          return a(new r(s, n, i), Object.assign({}, u, e.details));
         }),
         d(l, 'details', u),
         Object.defineProperty(l, 'message', {
          configurable: !0,
          get() {
           let t = `${e(u)} (${o.line}:${o.column})`;
           return (this.message = t), t;
          },
          set(e) {
           Object.defineProperty(this, 'message', { value: e, writable: !0 });
          },
         }),
         l
        );
       };
      }
      function m(e, r) {
       if (Array.isArray(e)) return (t) => m(t, e[0]);
       let s = {};
       for (let n of Object.keys(e)) {
        let i = e[n],
         a = 'string' == typeof i ? { message: () => i } : 'function' == typeof i ? { message: i } : i,
         { message: o } = a,
         u = t(a, h),
         l = 'string' == typeof o ? () => o : o;
        s[n] = f(Object.assign({ code: 'BABEL_PARSER_SYNTAX_ERROR', reasonCode: n, toMessage: l }, r ? { syntaxPlugin: r } : {}, u));
       }
       return s;
      }
      var y = Object.assign({}, m(a), m(l), m({ StrictDelete: 'Deleting local variable in strict mode.', StrictEvalArguments: ({ referenceName: e }) => `Assigning to '${e}' in strict mode.`, StrictEvalArgumentsBinding: ({ bindingName: e }) => `Binding '${e}' in strict mode.`, StrictFunction: 'In strict mode code, functions can only be declared at top level or inside a block.', StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.", StrictOctalLiteral: 'Legacy octal literals are not allowed in strict mode.', StrictWith: "'with' in strict mode." }), m`pipelineOperator`(c)),
       { defineProperty: D } = Object,
       g = (e, t) => {
        e && D(e, t, { enumerable: !1, value: e[t] });
       };
      function x(e) {
       return g(e.loc.start, 'index'), g(e.loc.end, 'index'), e;
      }
      var E = class {
        constructor(e, t) {
         (this.token = void 0), (this.preserveSpace = void 0), (this.token = e), (this.preserveSpace = !!t);
        }
       },
       b = { brace: new E('{'), j_oTag: new E('<tag'), j_cTag: new E('</tag'), j_expr: new E('<tag>...</tag>', !0) };
      b.template = new E('`', !0);
      var T = !0,
       A = !0,
       C = !0,
       v = !0,
       F = !0,
       w = class {
        constructor(e, t = {}) {
         (this.label = void 0), (this.keyword = void 0), (this.beforeExpr = void 0), (this.startsExpr = void 0), (this.rightAssociative = void 0), (this.isLoop = void 0), (this.isAssign = void 0), (this.prefix = void 0), (this.postfix = void 0), (this.binop = void 0), (this.label = e), (this.keyword = t.keyword), (this.beforeExpr = !!t.beforeExpr), (this.startsExpr = !!t.startsExpr), (this.rightAssociative = !!t.rightAssociative), (this.isLoop = !!t.isLoop), (this.isAssign = !!t.isAssign), (this.prefix = !!t.prefix), (this.postfix = !!t.postfix), (this.binop = null != t.binop ? t.binop : null), (this.updateContext = null);
        }
       },
       S = new Map();
      function P(e, t = {}) {
       t.keyword = e;
       let r = _(e, t);
       return S.set(e, r), r;
      }
      function k(e, t) {
       return _(e, { beforeExpr: T, binop: t });
      }
      var I = -1,
       N = [],
       B = [],
       O = [],
       L = [],
       M = [],
       j = [];
      function _(e, t = {}) {
       var r, s, n, i;
       return ++I, B.push(e), O.push(null != (r = t.binop) ? r : -1), L.push(null != (s = t.beforeExpr) && s), M.push(null != (n = t.startsExpr) && n), j.push(null != (i = t.prefix) && i), N.push(new w(e, t)), I;
      }
      function R(e, t = {}) {
       var r, s, n, i;
       return ++I, S.set(e, I), B.push(e), O.push(null != (r = t.binop) ? r : -1), L.push(null != (s = t.beforeExpr) && s), M.push(null != (n = t.startsExpr) && n), j.push(null != (i = t.prefix) && i), N.push(new w('name', t)), I;
      }
      var U = { bracketL: _('[', { beforeExpr: T, startsExpr: A }), bracketHashL: _('#[', { beforeExpr: T, startsExpr: A }), bracketBarL: _('[|', { beforeExpr: T, startsExpr: A }), bracketR: _(']'), bracketBarR: _('|]'), braceL: _('{', { beforeExpr: T, startsExpr: A }), braceBarL: _('{|', { beforeExpr: T, startsExpr: A }), braceHashL: _('#{', { beforeExpr: T, startsExpr: A }), braceR: _('}'), braceBarR: _('|}'), parenL: _('(', { beforeExpr: T, startsExpr: A }), parenR: _(')'), comma: _(',', { beforeExpr: T }), semi: _(';', { beforeExpr: T }), colon: _(':', { beforeExpr: T }), doubleColon: _('::', { beforeExpr: T }), dot: _('.'), question: _('?', { beforeExpr: T }), questionDot: _('?.'), arrow: _('=>', { beforeExpr: T }), template: _('template'), ellipsis: _('...', { beforeExpr: T }), backQuote: _('`', { startsExpr: A }), dollarBraceL: _('${', { beforeExpr: T, startsExpr: A }), templateTail: _('...`', { startsExpr: A }), templateNonTail: _('...${', { beforeExpr: T, startsExpr: A }), at: _('@'), hash: _('#', { startsExpr: A }), interpreterDirective: _('#!...'), eq: _('=', { beforeExpr: T, isAssign: v }), assign: _('_=', { beforeExpr: T, isAssign: v }), slashAssign: _('_=', { beforeExpr: T, isAssign: v }), xorAssign: _('_=', { beforeExpr: T, isAssign: v }), moduloAssign: _('_=', { beforeExpr: T, isAssign: v }), incDec: _('++/--', { prefix: F, postfix: !0, startsExpr: A }), bang: _('!', { beforeExpr: T, prefix: F, startsExpr: A }), tilde: _('~', { beforeExpr: T, prefix: F, startsExpr: A }), doubleCaret: _('^^', { startsExpr: A }), doubleAt: _('@@', { startsExpr: A }), pipeline: k('|>', 0), nullishCoalescing: k('??', 1), logicalOR: k('||', 1), logicalAND: k('&&', 2), bitwiseOR: k('|', 3), bitwiseXOR: k('^', 4), bitwiseAND: k('&', 5), equality: k('==/!=/===/!==', 6), lt: k('</>/<=/>=', 7), gt: k('</>/<=/>=', 7), relational: k('</>/<=/>=', 7), bitShift: k('<</>>/>>>', 8), bitShiftL: k('<</>>/>>>', 8), bitShiftR: k('<</>>/>>>', 8), plusMin: _('+/-', { beforeExpr: T, binop: 9, prefix: F, startsExpr: A }), modulo: _('%', { binop: 10, startsExpr: A }), star: _('*', { binop: 10 }), slash: k('/', 10), exponent: _('**', { beforeExpr: T, binop: 11, rightAssociative: !0 }), _in: P('in', { beforeExpr: T, binop: 7 }), _instanceof: P('instanceof', { beforeExpr: T, binop: 7 }), _break: P('break'), _case: P('case', { beforeExpr: T }), _catch: P('catch'), _continue: P('continue'), _debugger: P('debugger'), _default: P('default', { beforeExpr: T }), _else: P('else', { beforeExpr: T }), _finally: P('finally'), _function: P('function', { startsExpr: A }), _if: P('if'), _return: P('return', { beforeExpr: T }), _switch: P('switch'), _throw: P('throw', { beforeExpr: T, prefix: F, startsExpr: A }), _try: P('try'), _var: P('var'), _const: P('const'), _with: P('with'), _new: P('new', { beforeExpr: T, startsExpr: A }), _this: P('this', { startsExpr: A }), _super: P('super', { startsExpr: A }), _class: P('class', { startsExpr: A }), _extends: P('extends', { beforeExpr: T }), _export: P('export'), _import: P('import', { startsExpr: A }), _null: P('null', { startsExpr: A }), _true: P('true', { startsExpr: A }), _false: P('false', { startsExpr: A }), _typeof: P('typeof', { beforeExpr: T, prefix: F, startsExpr: A }), _void: P('void', { beforeExpr: T, prefix: F, startsExpr: A }), _delete: P('delete', { beforeExpr: T, prefix: F, startsExpr: A }), _do: P('do', { isLoop: C, beforeExpr: T }), _for: P('for', { isLoop: C }), _while: P('while', { isLoop: C }), _as: R('as', { startsExpr: A }), _assert: R('assert', { startsExpr: A }), _async: R('async', { startsExpr: A }), _await: R('await', { startsExpr: A }), _defer: R('defer', { startsExpr: A }), _from: R('from', { startsExpr: A }), _get: R('get', { startsExpr: A }), _let: R('let', { startsExpr: A }), _meta: R('meta', { startsExpr: A }), _of: R('of', { startsExpr: A }), _sent: R('sent', { startsExpr: A }), _set: R('set', { startsExpr: A }), _source: R('source', { startsExpr: A }), _static: R('static', { startsExpr: A }), _using: R('using', { startsExpr: A }), _yield: R('yield', { startsExpr: A }), _asserts: R('asserts', { startsExpr: A }), _checks: R('checks', { startsExpr: A }), _exports: R('exports', { startsExpr: A }), _global: R('global', { startsExpr: A }), _implements: R('implements', { startsExpr: A }), _intrinsic: R('intrinsic', { startsExpr: A }), _infer: R('infer', { startsExpr: A }), _is: R('is', { startsExpr: A }), _mixins: R('mixins', { startsExpr: A }), _proto: R('proto', { startsExpr: A }), _require: R('require', { startsExpr: A }), _satisfies: R('satisfies', { startsExpr: A }), _keyof: R('keyof', { startsExpr: A }), _readonly: R('readonly', { startsExpr: A }), _unique: R('unique', { startsExpr: A }), _abstract: R('abstract', { startsExpr: A }), _declare: R('declare', { startsExpr: A }), _enum: R('enum', { startsExpr: A }), _module: R('module', { startsExpr: A }), _namespace: R('namespace', { startsExpr: A }), _interface: R('interface', { startsExpr: A }), _type: R('type', { startsExpr: A }), _opaque: R('opaque', { startsExpr: A }), name: _('name', { startsExpr: A }), placeholder: _('%%', { startsExpr: !0 }), string: _('string', { startsExpr: A }), num: _('num', { startsExpr: A }), bigint: _('bigint', { startsExpr: A }), decimal: _('decimal', { startsExpr: A }), regexp: _('regexp', { startsExpr: A }), privateName: _('#name', { startsExpr: A }), eof: _('eof'), jsxName: _('jsxName'), jsxText: _('jsxText', { beforeExpr: !0 }), jsxTagStart: _('jsxTagStart', { startsExpr: !0 }), jsxTagEnd: _('jsxTagEnd') };
      function $(e) {
       return e >= 93 && e <= 133;
      }
      function q(e) {
       return e >= 58 && e <= 133;
      }
      function J(e) {
       return e >= 58 && e <= 137;
      }
      function W(e) {
       return M[e];
      }
      function z(e) {
       return e >= 129 && e <= 131;
      }
      function V(e) {
       return e >= 58 && e <= 92;
      }
      function H(e) {
       return B[e];
      }
      function K(e) {
       return O[e];
      }
      function X(e) {
       return e >= 24 && e <= 25;
      }
      function G(e) {
       return N[e];
      }
      (N[8].updateContext = (e) => {
       e.pop();
      }),
       (N[5].updateContext =
        N[7].updateContext =
        N[23].updateContext =
         (e) => {
          e.push(b.brace);
         }),
       (N[22].updateContext = (e) => {
        e[e.length - 1] === b.template ? e.pop() : e.push(b.template);
       }),
       (N[143].updateContext = (e) => {
        e.push(b.j_expr, b.j_oTag);
       });
      var Y = '\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u0870-\u0887\u0889-\u088e\u08a0-\u08c9\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c5d\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cdd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u1711\u171f-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4c\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c8a\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7cd\ua7d0\ua7d1\ua7d3\ua7d5-\ua7dc\ua7f2-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc',
       Q = '\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u0897-\u089f\u08ca-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3c\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0cf3\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ece\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u180f-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf-\u1ace\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1dff\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\u30fb\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f\uff65',
       Z = new RegExp('[' + Y + ']'),
       ee = new RegExp('[' + Y + Q + ']');
      Y = Q = null;
      var te = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191],
       re = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
      function se(e, t) {
       let r = 65536;
       for (let s = 0, n = t.length; s < n; s += 2) {
        if (((r += t[s]), r > e)) return !1;
        if (((r += t[s + 1]), r >= e)) return !0;
       }
       return !1;
      }
      function ne(e) {
       return e < 65 ? 36 === e : e <= 90 || (e < 97 ? 95 === e : e <= 122 || (e <= 65535 ? e >= 170 && Z.test(String.fromCharCode(e)) : se(e, te)));
      }
      function ie(e) {
       return e < 48 ? 36 === e : e < 58 || (!(e < 65) && (e <= 90 || (e < 97 ? 95 === e : e <= 122 || (e <= 65535 ? e >= 170 && ee.test(String.fromCharCode(e)) : se(e, te) || se(e, re)))));
      }
      var ae = ['implements', 'interface', 'let', 'package', 'private', 'protected', 'public', 'static', 'yield'],
       oe = ['eval', 'arguments'],
       ue = new Set(['break', 'case', 'catch', 'continue', 'debugger', 'default', 'do', 'else', 'finally', 'for', 'function', 'if', 'return', 'switch', 'throw', 'try', 'var', 'const', 'while', 'with', 'new', 'this', 'super', 'class', 'extends', 'export', 'import', 'null', 'true', 'false', 'in', 'instanceof', 'typeof', 'void', 'delete']),
       le = new Set(ae),
       pe = new Set(oe);
      function ce(e, t) {
       return (t && 'await' === e) || 'enum' === e;
      }
      function he(e, t) {
       return ce(e, t) || le.has(e);
      }
      function de(e) {
       return pe.has(e);
      }
      function fe(e, t) {
       return he(e, t) || de(e);
      }
      var me = new Set(['break', 'case', 'catch', 'continue', 'debugger', 'default', 'do', 'else', 'finally', 'for', 'function', 'if', 'return', 'switch', 'throw', 'try', 'var', 'const', 'while', 'with', 'new', 'this', 'super', 'class', 'extends', 'export', 'import', 'null', 'true', 'false', 'in', 'instanceof', 'typeof', 'void', 'delete', 'implements', 'interface', 'let', 'package', 'private', 'protected', 'public', 'static', 'yield', 'eval', 'arguments', 'enum', 'await']),
       ye = class {
        constructor(e) {
         (this.flags = 0), (this.names = new Map()), (this.firstLexicalName = ''), (this.flags = e);
        }
       },
       De = class {
        constructor(e, t) {
         (this.parser = void 0), (this.scopeStack = []), (this.inModule = void 0), (this.undefinedExports = new Map()), (this.parser = e), (this.inModule = t);
        }
        get inTopLevel() {
         return (1 & this.currentScope().flags) > 0;
        }
        get inFunction() {
         return (2 & this.currentVarScopeFlags()) > 0;
        }
        get allowSuper() {
         return (16 & this.currentThisScopeFlags()) > 0;
        }
        get allowDirectSuper() {
         return (32 & this.currentThisScopeFlags()) > 0;
        }
        get inClass() {
         return (64 & this.currentThisScopeFlags()) > 0;
        }
        get inClassAndNotInNonArrowFunction() {
         let e = this.currentThisScopeFlags();
         return (64 & e) > 0 && 0 == (2 & e);
        }
        get inStaticBlock() {
         for (let e = this.scopeStack.length - 1; ; e--) {
          let { flags: t } = this.scopeStack[e];
          if (128 & t) return !0;
          if (451 & t) return !1;
         }
        }
        get inNonArrowFunction() {
         return (2 & this.currentThisScopeFlags()) > 0;
        }
        get treatFunctionsAsVar() {
         return this.treatFunctionsAsVarInScope(this.currentScope());
        }
        createScope(e) {
         return new ye(e);
        }
        enter(e) {
         this.scopeStack.push(this.createScope(e));
        }
        exit() {
         return this.scopeStack.pop().flags;
        }
        treatFunctionsAsVarInScope(e) {
         return !!(130 & e.flags || (!this.parser.inModule && 1 & e.flags));
        }
        declareName(e, t, r) {
         let s = this.currentScope();
         if (8 & t || 16 & t) {
          this.checkRedeclarationInScope(s, e, t, r);
          let n = s.names.get(e) || 0;
          16 & t ? (n |= 4) : (s.firstLexicalName || (s.firstLexicalName = e), (n |= 2)), s.names.set(e, n), 8 & t && this.maybeExportDefined(s, e);
         } else if (4 & t) for (let n = this.scopeStack.length - 1; n >= 0 && ((s = this.scopeStack[n]), this.checkRedeclarationInScope(s, e, t, r), s.names.set(e, 1 | (s.names.get(e) || 0)), this.maybeExportDefined(s, e), !(387 & s.flags)); --n);
         this.parser.inModule && 1 & s.flags && this.undefinedExports.delete(e);
        }
        maybeExportDefined(e, t) {
         this.parser.inModule && 1 & e.flags && this.undefinedExports.delete(t);
        }
        checkRedeclarationInScope(e, t, r, s) {
         this.isRedeclaredInScope(e, t, r) && this.parser.raise(y.VarRedeclaration, s, { identifierName: t });
        }
        isRedeclaredInScope(e, t, r) {
         if (!(1 & r)) return !1;
         if (8 & r) return e.names.has(t);
         let s = e.names.get(t);
         return 16 & r ? (2 & s) > 0 || (!this.treatFunctionsAsVarInScope(e) && (1 & s) > 0) : ((2 & s) > 0 && !(8 & e.flags && e.firstLexicalName === t)) || (!this.treatFunctionsAsVarInScope(e) && (4 & s) > 0);
        }
        checkLocalExport(e) {
         let { name: t } = e;
         this.scopeStack[0].names.has(t) || this.undefinedExports.set(t, e.loc.start);
        }
        currentScope() {
         return this.scopeStack[this.scopeStack.length - 1];
        }
        currentVarScopeFlags() {
         for (let e = this.scopeStack.length - 1; ; e--) {
          let { flags: t } = this.scopeStack[e];
          if (387 & t) return t;
         }
        }
        currentThisScopeFlags() {
         for (let e = this.scopeStack.length - 1; ; e--) {
          let { flags: t } = this.scopeStack[e];
          if (451 & t && !(4 & t)) return t;
         }
        }
       },
       ge = class extends ye {
        constructor(...e) {
         super(...e), (this.declareFunctions = new Set());
        }
       },
       xe = class extends De {
        createScope(e) {
         return new ge(e);
        }
        declareName(e, t, r) {
         let s = this.currentScope();
         if (2048 & t) return this.checkRedeclarationInScope(s, e, t, r), this.maybeExportDefined(s, e), void s.declareFunctions.add(e);
         super.declareName(e, t, r);
        }
        isRedeclaredInScope(e, t, r) {
         if (super.isRedeclaredInScope(e, t, r)) return !0;
         if (2048 & r && !e.declareFunctions.has(t)) {
          let r = e.names.get(t);
          return (4 & r) > 0 || (2 & r) > 0;
         }
         return !1;
        }
        checkLocalExport(e) {
         this.scopeStack[0].declareFunctions.has(e.name) || super.checkLocalExport(e);
        }
       },
       Ee = class {
        constructor() {
         (this.sawUnambiguousESM = !1), (this.ambiguousScriptDifferentAst = !1);
        }
        sourceToOffsetPos(e) {
         return e + this.startIndex;
        }
        offsetToSourcePos(e) {
         return e - this.startIndex;
        }
        hasPlugin(e) {
         if ('string' == typeof e) return this.plugins.has(e);
         {
          let [t, r] = e;
          if (!this.hasPlugin(t)) return !1;
          let s = this.plugins.get(t);
          for (let e of Object.keys(r)) if ((null == s ? void 0 : s[e]) !== r[e]) return !1;
          return !0;
         }
        }
        getPluginOption(e, t) {
         var r;
         return null == (r = this.plugins.get(e)) ? void 0 : r[t];
        }
       };
      function be(e, t) {
       void 0 === e.trailingComments ? (e.trailingComments = t) : e.trailingComments.unshift(...t);
      }
      function Te(e, t) {
       void 0 === e.innerComments ? (e.innerComments = t) : e.innerComments.unshift(...t);
      }
      function Ae(e, t, r) {
       let s = null,
        n = t.length;
       for (; null === s && n > 0; ) s = t[--n];
       null === s || s.start > r.start ? Te(e, r.comments) : be(s, r.comments);
      }
      var Ce = class extends Ee {
        addComment(e) {
         this.filename && (e.loc.filename = this.filename);
         let { commentsLen: t } = this.state;
         this.comments.length !== t && (this.comments.length = t), this.comments.push(e), this.state.commentsLen++;
        }
        processComment(e) {
         let { commentStack: t } = this.state,
          r = t.length;
         if (0 === r) return;
         let s = r - 1,
          n = t[s];
         n.start === e.end && ((n.leadingNode = e), s--);
         let { start: i } = e;
         for (; s >= 0; s--) {
          let r = t[s],
           n = r.end;
          if (!(n > i)) {
           n === i && (r.trailingNode = e);
           break;
          }
          (r.containingNode = e), this.finalizeComment(r), t.splice(s, 1);
         }
        }
        finalizeComment(e) {
         let { comments: t } = e;
         if (null !== e.leadingNode || null !== e.trailingNode)
          null !== e.leadingNode && be(e.leadingNode, t),
           null !== e.trailingNode &&
            (function (e, t) {
             void 0 === e.leadingComments ? (e.leadingComments = t) : e.leadingComments.unshift(...t);
            })(e.trailingNode, t);
         else {
          let { containingNode: r, start: s } = e;
          if (44 === this.input.charCodeAt(this.offsetToSourcePos(s) - 1))
           switch (r.type) {
            case 'ObjectExpression':
            case 'ObjectPattern':
            case 'RecordExpression':
             Ae(r, r.properties, e);
             break;
            case 'CallExpression':
            case 'OptionalCallExpression':
             Ae(r, r.arguments, e);
             break;
            case 'FunctionDeclaration':
            case 'FunctionExpression':
            case 'ArrowFunctionExpression':
            case 'ObjectMethod':
            case 'ClassMethod':
            case 'ClassPrivateMethod':
             Ae(r, r.params, e);
             break;
            case 'ArrayExpression':
            case 'ArrayPattern':
            case 'TupleExpression':
             Ae(r, r.elements, e);
             break;
            case 'ExportNamedDeclaration':
            case 'ImportDeclaration':
             Ae(r, r.specifiers, e);
             break;
            case 'TSEnumDeclaration':
            case 'TSEnumBody':
             Ae(r, r.members, e);
             break;
            default:
             Te(r, t);
           }
          else Te(r, t);
         }
        }
        finalizeRemainingComments() {
         let { commentStack: e } = this.state;
         for (let t = e.length - 1; t >= 0; t--) this.finalizeComment(e[t]);
         this.state.commentStack = [];
        }
        resetPreviousNodeTrailingComments(e) {
         let { commentStack: t } = this.state,
          { length: r } = t;
         if (0 === r) return;
         let s = t[r - 1];
         s.leadingNode === e && (s.leadingNode = null);
        }
        resetPreviousIdentifierLeadingComments(e) {
         let { commentStack: t } = this.state,
          { length: r } = t;
         0 !== r && (t[r - 1].trailingNode === e ? (t[r - 1].trailingNode = null) : r >= 2 && t[r - 2].trailingNode === e && (t[r - 2].trailingNode = null));
        }
        takeSurroundingComments(e, t, r) {
         let { commentStack: s } = this.state,
          n = s.length;
         if (0 === n) return;
         let i = n - 1;
         for (; i >= 0; i--) {
          let n = s[i],
           a = n.end;
          if (n.start === r) n.leadingNode = e;
          else if (a === t) n.trailingNode = e;
          else if (a < t) break;
         }
        }
       },
       ve = new RegExp(/\r\n|[\r\n\u2028\u2029]/.source, 'g');
      function Fe(e) {
       switch (e) {
        case 10:
        case 13:
        case 8232:
        case 8233:
         return !0;
        default:
         return !1;
       }
      }
      function we(e, t, r) {
       for (let s = t; s < r; s++) if (Fe(e.charCodeAt(s))) return !0;
       return !1;
      }
      var Se = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g,
       Pe = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g;
      function ke(e) {
       switch (e) {
        case 9:
        case 11:
        case 12:
        case 32:
        case 160:
        case 5760:
        case 8192:
        case 8193:
        case 8194:
        case 8195:
        case 8196:
        case 8197:
        case 8198:
        case 8199:
        case 8200:
        case 8201:
        case 8202:
        case 8239:
        case 8287:
        case 12288:
        case 65279:
         return !0;
        default:
         return !1;
       }
      }
      var Ie = class e {
        constructor() {
         (this.flags = 1024), (this.startIndex = void 0), (this.curLine = void 0), (this.lineStart = void 0), (this.startLoc = void 0), (this.endLoc = void 0), (this.errors = []), (this.potentialArrowAt = -1), (this.noArrowAt = []), (this.noArrowParamsConversionAt = []), (this.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null }), (this.labels = []), (this.commentsLen = 0), (this.commentStack = []), (this.pos = 0), (this.type = 140), (this.value = null), (this.start = 0), (this.end = 0), (this.lastTokEndLoc = null), (this.lastTokStartLoc = null), (this.context = [b.brace]), (this.firstInvalidTemplateEscapePos = null), (this.strictErrors = new Map()), (this.tokensLength = 0);
        }
        get strict() {
         return (1 & this.flags) > 0;
        }
        set strict(e) {
         e ? (this.flags |= 1) : (this.flags &= -2);
        }
        init({ strictMode: e, sourceType: t, startIndex: s, startLine: n, startColumn: i }) {
         (this.strict = !1 !== e && (!0 === e || 'module' === t)), (this.startIndex = s), (this.curLine = n), (this.lineStart = -i), (this.startLoc = this.endLoc = new r(n, i, s));
        }
        get maybeInArrowParameters() {
         return (2 & this.flags) > 0;
        }
        set maybeInArrowParameters(e) {
         e ? (this.flags |= 2) : (this.flags &= -3);
        }
        get inType() {
         return (4 & this.flags) > 0;
        }
        set inType(e) {
         e ? (this.flags |= 4) : (this.flags &= -5);
        }
        get noAnonFunctionType() {
         return (8 & this.flags) > 0;
        }
        set noAnonFunctionType(e) {
         e ? (this.flags |= 8) : (this.flags &= -9);
        }
        get hasFlowComment() {
         return (16 & this.flags) > 0;
        }
        set hasFlowComment(e) {
         e ? (this.flags |= 16) : (this.flags &= -17);
        }
        get isAmbientContext() {
         return (32 & this.flags) > 0;
        }
        set isAmbientContext(e) {
         e ? (this.flags |= 32) : (this.flags &= -33);
        }
        get inAbstractClass() {
         return (64 & this.flags) > 0;
        }
        set inAbstractClass(e) {
         e ? (this.flags |= 64) : (this.flags &= -65);
        }
        get inDisallowConditionalTypesContext() {
         return (128 & this.flags) > 0;
        }
        set inDisallowConditionalTypesContext(e) {
         e ? (this.flags |= 128) : (this.flags &= -129);
        }
        get soloAwait() {
         return (256 & this.flags) > 0;
        }
        set soloAwait(e) {
         e ? (this.flags |= 256) : (this.flags &= -257);
        }
        get inFSharpPipelineDirectBody() {
         return (512 & this.flags) > 0;
        }
        set inFSharpPipelineDirectBody(e) {
         e ? (this.flags |= 512) : (this.flags &= -513);
        }
        get canStartJSXElement() {
         return (1024 & this.flags) > 0;
        }
        set canStartJSXElement(e) {
         e ? (this.flags |= 1024) : (this.flags &= -1025);
        }
        get containsEsc() {
         return (2048 & this.flags) > 0;
        }
        set containsEsc(e) {
         e ? (this.flags |= 2048) : (this.flags &= -2049);
        }
        get hasTopLevelAwait() {
         return (4096 & this.flags) > 0;
        }
        set hasTopLevelAwait(e) {
         e ? (this.flags |= 4096) : (this.flags &= -4097);
        }
        curPosition() {
         return new r(this.curLine, this.pos - this.lineStart, this.pos + this.startIndex);
        }
        clone() {
         let t = new e();
         return (t.flags = this.flags), (t.startIndex = this.startIndex), (t.curLine = this.curLine), (t.lineStart = this.lineStart), (t.startLoc = this.startLoc), (t.endLoc = this.endLoc), (t.errors = this.errors.slice()), (t.potentialArrowAt = this.potentialArrowAt), (t.noArrowAt = this.noArrowAt.slice()), (t.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice()), (t.topicContext = this.topicContext), (t.labels = this.labels.slice()), (t.commentsLen = this.commentsLen), (t.commentStack = this.commentStack.slice()), (t.pos = this.pos), (t.type = this.type), (t.value = this.value), (t.start = this.start), (t.end = this.end), (t.lastTokEndLoc = this.lastTokEndLoc), (t.lastTokStartLoc = this.lastTokStartLoc), (t.context = this.context.slice()), (t.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos), (t.strictErrors = this.strictErrors), (t.tokensLength = this.tokensLength), t;
        }
       },
       Ne = function (e) {
        return e >= 48 && e <= 57;
       },
       Be = { decBinOct: new Set([46, 66, 69, 79, 95, 98, 101, 111]), hex: new Set([46, 88, 95, 120]) },
       Oe = { bin: (e) => 48 === e || 49 === e, oct: (e) => e >= 48 && e <= 55, dec: (e) => e >= 48 && e <= 57, hex: (e) => (e >= 48 && e <= 57) || (e >= 65 && e <= 70) || (e >= 97 && e <= 102) };
      function Le(e, t, r, s, n, i) {
       let a = r,
        o = s,
        u = n,
        l = '',
        p = null,
        c = r,
        { length: h } = t;
       for (;;) {
        if (r >= h) {
         i.unterminated(a, o, u), (l += t.slice(c, r));
         break;
        }
        let d = t.charCodeAt(r);
        if (Me(e, d, t, r)) {
         l += t.slice(c, r);
         break;
        }
        if (92 === d) {
         l += t.slice(c, r);
         let a = je(t, r, s, n, 'template' === e, i);
         null !== a.ch || p ? (l += a.ch) : (p = { pos: r, lineStart: s, curLine: n }), ({ pos: r, lineStart: s, curLine: n } = a), (c = r);
        } else 8232 === d || 8233 === d ? (++n, (s = ++r)) : 10 === d || 13 === d ? ('template' === e ? ((l += t.slice(c, r) + '\n'), ++r, 13 === d && 10 === t.charCodeAt(r) && ++r, ++n, (c = s = r)) : i.unterminated(a, o, u)) : ++r;
       }
       return { pos: r, str: l, firstInvalidLoc: p, lineStart: s, curLine: n, containsInvalid: !!p };
      }
      function Me(e, t, r, s) {
       return 'template' === e ? 96 === t || (36 === t && 123 === r.charCodeAt(s + 1)) : t === ('double' === e ? 34 : 39);
      }
      function je(e, t, r, s, n, i) {
       let a = !n;
       t++;
       let o = (e) => ({ pos: t, ch: e, lineStart: r, curLine: s }),
        u = e.charCodeAt(t++);
       switch (u) {
        case 110:
         return o('\n');
        case 114:
         return o('\r');
        case 120: {
         let n;
         return ({ code: n, pos: t } = _e(e, t, r, s, 2, !1, a, i)), o(null === n ? null : String.fromCharCode(n));
        }
        case 117: {
         let n;
         return ({ code: n, pos: t } = Ue(e, t, r, s, a, i)), o(null === n ? null : String.fromCodePoint(n));
        }
        case 116:
         return o('\t');
        case 98:
         return o('\b');
        case 118:
         return o('\v');
        case 102:
         return o('\f');
        case 13:
         10 === e.charCodeAt(t) && ++t;
        case 10:
         (r = t), ++s;
        case 8232:
        case 8233:
         return o('');
        case 56:
        case 57:
         if (n) return o(null);
         i.strictNumericEscape(t - 1, r, s);
        default:
         if (u >= 48 && u <= 55) {
          let a = t - 1,
           u = /^[0-7]+/.exec(e.slice(a, t + 2))[0],
           l = parseInt(u, 8);
          l > 255 && ((u = u.slice(0, -1)), (l = parseInt(u, 8))), (t += u.length - 1);
          let p = e.charCodeAt(t);
          if ('0' !== u || 56 === p || 57 === p) {
           if (n) return o(null);
           i.strictNumericEscape(a, r, s);
          }
          return o(String.fromCharCode(l));
         }
         return o(String.fromCharCode(u));
       }
      }
      function _e(e, t, r, s, n, i, a, o) {
       let u,
        l = t;
       return ({ n: u, pos: t } = Re(e, t, r, s, 16, n, i, !1, o, !a)), null === u && (a ? o.invalidEscapeSequence(l, r, s) : (t = l - 1)), { code: u, pos: t };
      }
      function Re(e, t, r, s, n, i, a, o, u, l) {
       let p = t,
        c = 16 === n ? Be.hex : Be.decBinOct,
        h = 16 === n ? Oe.hex : 10 === n ? Oe.dec : 8 === n ? Oe.oct : Oe.bin,
        d = !1,
        f = 0;
       for (let m = 0, y = i ?? 1 / 0; m < y; ++m) {
        let i,
         p = e.charCodeAt(t);
        if (95 !== p || 'bail' === o) {
         if (((i = p >= 97 ? p - 97 + 10 : p >= 65 ? p - 65 + 10 : Ne(p) ? p - 48 : 1 / 0), i >= n)) {
          if (i <= 9 && l) return { n: null, pos: t };
          if (i <= 9 && u.invalidDigit(t, r, s, n)) i = 0;
          else {
           if (!a) break;
           (i = 0), (d = !0);
          }
         }
         ++t, (f = f * n + i);
        } else {
         let n = e.charCodeAt(t - 1),
          i = e.charCodeAt(t + 1);
         if (o) {
          if (Number.isNaN(i) || !h(i) || c.has(n) || c.has(i)) {
           if (l) return { n: null, pos: t };
           u.unexpectedNumericSeparator(t, r, s);
          }
         } else {
          if (l) return { n: null, pos: t };
          u.numericSeparatorInEscapeSequence(t, r, s);
         }
         ++t;
        }
       }
       return t === p || (null != i && t - p !== i) || d ? { n: null, pos: t } : { n: f, pos: t };
      }
      function Ue(e, t, r, s, n, i) {
       let a;
       if (123 === e.charCodeAt(t)) {
        if ((++t, ({ code: a, pos: t } = _e(e, t, r, s, e.indexOf('}', t) - t, !0, n, i)), ++t, null !== a && a > 1114111)) {
         if (!n) return { code: null, pos: t };
         i.invalidCodePoint(t, r, s);
        }
       } else ({ code: a, pos: t } = _e(e, t, r, s, 4, !1, n, i));
       return { code: a, pos: t };
      }
      function $e(e, t, s) {
       return new r(s, e - t, e);
      }
      var qe = new Set([103, 109, 115, 105, 121, 117, 100, 118]),
       Je = class {
        constructor(e) {
         let t = e.startIndex || 0;
         (this.type = e.type), (this.value = e.value), (this.start = t + e.start), (this.end = t + e.end), (this.loc = new s(e.startLoc, e.endLoc));
        }
       },
       We = class extends Ce {
        constructor(e, t) {
         super(),
          (this.isLookahead = void 0),
          (this.tokens = []),
          (this.errorHandlers_readInt = { invalidDigit: (e, t, r, s) => !!(1024 & this.optionFlags) && (this.raise(y.InvalidDigit, $e(e, t, r), { radix: s }), !0), numericSeparatorInEscapeSequence: this.errorBuilder(y.NumericSeparatorInEscapeSequence), unexpectedNumericSeparator: this.errorBuilder(y.UnexpectedNumericSeparator) }),
          (this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, { invalidEscapeSequence: this.errorBuilder(y.InvalidEscapeSequence), invalidCodePoint: this.errorBuilder(y.InvalidCodePoint) })),
          (this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
           strictNumericEscape: (e, t, r) => {
            this.recordStrictModeErrors(y.StrictNumericEscape, $e(e, t, r));
           },
           unterminated: (e, t, r) => {
            throw this.raise(y.UnterminatedString, $e(e - 1, t, r));
           },
          })),
          (this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
           strictNumericEscape: this.errorBuilder(y.StrictNumericEscape),
           unterminated: (e, t, r) => {
            throw this.raise(y.UnterminatedTemplate, $e(e, t, r));
           },
          })),
          (this.state = new Ie()),
          this.state.init(e),
          (this.input = t),
          (this.length = t.length),
          (this.comments = []),
          (this.isLookahead = !1);
        }
        pushToken(e) {
         (this.tokens.length = this.state.tokensLength), this.tokens.push(e), ++this.state.tokensLength;
        }
        next() {
         this.checkKeywordEscapes(), 128 & this.optionFlags && this.pushToken(new Je(this.state)), (this.state.lastTokEndLoc = this.state.endLoc), (this.state.lastTokStartLoc = this.state.startLoc), this.nextToken();
        }
        eat(e) {
         return !!this.match(e) && (this.next(), !0);
        }
        match(e) {
         return this.state.type === e;
        }
        createLookaheadState(e) {
         return { pos: e.pos, value: null, type: e.type, start: e.start, end: e.end, context: [this.curContext()], inType: e.inType, startLoc: e.startLoc, lastTokEndLoc: e.lastTokEndLoc, curLine: e.curLine, lineStart: e.lineStart, curPosition: e.curPosition };
        }
        lookahead() {
         let e = this.state;
         (this.state = this.createLookaheadState(e)), (this.isLookahead = !0), this.nextToken(), (this.isLookahead = !1);
         let t = this.state;
         return (this.state = e), t;
        }
        nextTokenStart() {
         return this.nextTokenStartSince(this.state.pos);
        }
        nextTokenStartSince(e) {
         return (Se.lastIndex = e), Se.test(this.input) ? Se.lastIndex : e;
        }
        lookaheadCharCode() {
         return this.input.charCodeAt(this.nextTokenStart());
        }
        nextTokenInLineStart() {
         return this.nextTokenInLineStartSince(this.state.pos);
        }
        nextTokenInLineStartSince(e) {
         return (Pe.lastIndex = e), Pe.test(this.input) ? Pe.lastIndex : e;
        }
        lookaheadInLineCharCode() {
         return this.input.charCodeAt(this.nextTokenInLineStart());
        }
        codePointAtPos(e) {
         let t = this.input.charCodeAt(e);
         if (55296 == (64512 & t) && ++e < this.input.length) {
          let r = this.input.charCodeAt(e);
          56320 == (64512 & r) && (t = 65536 + ((1023 & t) << 10) + (1023 & r));
         }
         return t;
        }
        setStrict(e) {
         (this.state.strict = e), e && (this.state.strictErrors.forEach(([e, t]) => this.raise(e, t)), this.state.strictErrors.clear());
        }
        curContext() {
         return this.state.context[this.state.context.length - 1];
        }
        nextToken() {
         this.skipSpace(), (this.state.start = this.state.pos), this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length ? this.finishToken(140) : this.getTokenFromCode(this.codePointAtPos(this.state.pos));
        }
        skipBlockComment(e) {
         let t;
         this.isLookahead || (t = this.state.curPosition());
         let r = this.state.pos,
          n = this.input.indexOf(e, r + 2);
         if (-1 === n) throw this.raise(y.UnterminatedComment, this.state.curPosition());
         for (this.state.pos = n + e.length, ve.lastIndex = r + 2; ve.test(this.input) && ve.lastIndex <= n; ) ++this.state.curLine, (this.state.lineStart = ve.lastIndex);
         if (this.isLookahead) return;
         let i = { type: 'CommentBlock', value: this.input.slice(r + 2, n), start: this.sourceToOffsetPos(r), end: this.sourceToOffsetPos(n + e.length), loc: new s(t, this.state.curPosition()) };
         return 128 & this.optionFlags && this.pushToken(i), i;
        }
        skipLineComment(e) {
         let t,
          r = this.state.pos;
         this.isLookahead || (t = this.state.curPosition());
         let n = this.input.charCodeAt((this.state.pos += e));
         if (this.state.pos < this.length) for (; !Fe(n) && ++this.state.pos < this.length; ) n = this.input.charCodeAt(this.state.pos);
         if (this.isLookahead) return;
         let i = this.state.pos,
          a = { type: 'CommentLine', value: this.input.slice(r + e, i), start: this.sourceToOffsetPos(r), end: this.sourceToOffsetPos(i), loc: new s(t, this.state.curPosition()) };
         return 128 & this.optionFlags && this.pushToken(a), a;
        }
        skipSpace() {
         let e = this.state.pos,
          t = 2048 & this.optionFlags ? [] : null;
         e: for (; this.state.pos < this.length; ) {
          let r = this.input.charCodeAt(this.state.pos);
          switch (r) {
           case 32:
           case 160:
           case 9:
            ++this.state.pos;
            break;
           case 13:
            10 === this.input.charCodeAt(this.state.pos + 1) && ++this.state.pos;
           case 10:
           case 8232:
           case 8233:
            ++this.state.pos, ++this.state.curLine, (this.state.lineStart = this.state.pos);
            break;
           case 47:
            switch (this.input.charCodeAt(this.state.pos + 1)) {
             case 42: {
              let e = this.skipBlockComment('*/');
              void 0 !== e && (this.addComment(e), null == t || t.push(e));
              break;
             }
             case 47: {
              let e = this.skipLineComment(2);
              void 0 !== e && (this.addComment(e), null == t || t.push(e));
              break;
             }
             default:
              break e;
            }
            break;
           default:
            if (ke(r)) ++this.state.pos;
            else if (45 === r && !this.inModule && 4096 & this.optionFlags) {
             let r = this.state.pos;
             if (45 !== this.input.charCodeAt(r + 1) || 62 !== this.input.charCodeAt(r + 2) || !(0 === e || this.state.lineStart > e)) break e;
             {
              let e = this.skipLineComment(3);
              void 0 !== e && (this.addComment(e), null == t || t.push(e));
             }
            } else {
             if (60 !== r || this.inModule || !(4096 & this.optionFlags)) break e;
             {
              let e = this.state.pos;
              if (33 !== this.input.charCodeAt(e + 1) || 45 !== this.input.charCodeAt(e + 2) || 45 !== this.input.charCodeAt(e + 3)) break e;
              {
               let e = this.skipLineComment(4);
               void 0 !== e && (this.addComment(e), null == t || t.push(e));
              }
             }
            }
          }
         }
         if ((null == t ? void 0 : t.length) > 0) {
          let r = this.state.pos,
           s = { start: this.sourceToOffsetPos(e), end: this.sourceToOffsetPos(r), comments: t, leadingNode: null, trailingNode: null, containingNode: null };
          this.state.commentStack.push(s);
         }
        }
        finishToken(e, t) {
         (this.state.end = this.state.pos), (this.state.endLoc = this.state.curPosition());
         let r = this.state.type;
         (this.state.type = e), (this.state.value = t), this.isLookahead || this.updateContext(r);
        }
        replaceToken(e) {
         (this.state.type = e), this.updateContext();
        }
        readToken_numberSign() {
         if (0 === this.state.pos && this.readToken_interpreter()) return;
         let e = this.state.pos + 1,
          t = this.codePointAtPos(e);
         if (t >= 48 && t <= 57) throw this.raise(y.UnexpectedDigitAfterHash, this.state.curPosition());
         if (123 === t || (91 === t && this.hasPlugin('recordAndTuple'))) {
          if ((this.expectPlugin('recordAndTuple'), 'bar' === this.getPluginOption('recordAndTuple', 'syntaxType'))) throw this.raise(123 === t ? y.RecordExpressionHashIncorrectStartSyntaxType : y.TupleExpressionHashIncorrectStartSyntaxType, this.state.curPosition());
          (this.state.pos += 2), 123 === t ? this.finishToken(7) : this.finishToken(1);
         } else ne(t) ? (++this.state.pos, this.finishToken(139, this.readWord1(t))) : 92 === t ? (++this.state.pos, this.finishToken(139, this.readWord1())) : this.finishOp(27, 1);
        }
        readToken_dot() {
         let e = this.input.charCodeAt(this.state.pos + 1);
         e >= 48 && e <= 57 ? this.readNumber(!0) : 46 === e && 46 === this.input.charCodeAt(this.state.pos + 2) ? ((this.state.pos += 3), this.finishToken(21)) : (++this.state.pos, this.finishToken(16));
        }
        readToken_slash() {
         61 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(31, 2) : this.finishOp(56, 1);
        }
        readToken_interpreter() {
         if (0 !== this.state.pos || this.length < 2) return !1;
         let e = this.input.charCodeAt(this.state.pos + 1);
         if (33 !== e) return !1;
         let t = this.state.pos;
         for (this.state.pos += 1; !Fe(e) && ++this.state.pos < this.length; ) e = this.input.charCodeAt(this.state.pos);
         let r = this.input.slice(t + 2, this.state.pos);
         return this.finishToken(28, r), !0;
        }
        readToken_mult_modulo(e) {
         let t = 42 === e ? 55 : 54,
          r = 1,
          s = this.input.charCodeAt(this.state.pos + 1);
         42 === e && 42 === s && (r++, (s = this.input.charCodeAt(this.state.pos + 2)), (t = 57)), 61 === s && !this.state.inType && (r++, (t = 37 === e ? 33 : 30)), this.finishOp(t, r);
        }
        readToken_pipe_amp(e) {
         let t = this.input.charCodeAt(this.state.pos + 1);
         if (t !== e) {
          if (124 === e) {
           if (62 === t) return void this.finishOp(39, 2);
           if (this.hasPlugin('recordAndTuple') && 125 === t) {
            if ('bar' !== this.getPluginOption('recordAndTuple', 'syntaxType')) throw this.raise(y.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
            return (this.state.pos += 2), void this.finishToken(9);
           }
           if (this.hasPlugin('recordAndTuple') && 93 === t) {
            if ('bar' !== this.getPluginOption('recordAndTuple', 'syntaxType')) throw this.raise(y.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
            return (this.state.pos += 2), void this.finishToken(4);
           }
          }
          61 !== t ? this.finishOp(124 === e ? 43 : 45, 1) : this.finishOp(30, 2);
         } else 61 === this.input.charCodeAt(this.state.pos + 2) ? this.finishOp(30, 3) : this.finishOp(124 === e ? 41 : 42, 2);
        }
        readToken_caret() {
         let e = this.input.charCodeAt(this.state.pos + 1);
         61 !== e || this.state.inType ? (94 === e && this.hasPlugin(['pipelineOperator', { proposal: 'hack', topicToken: '^^' }]) ? (this.finishOp(37, 2), 94 === this.input.codePointAt(this.state.pos) && this.unexpected()) : this.finishOp(44, 1)) : this.finishOp(32, 2);
        }
        readToken_atSign() {
         64 === this.input.charCodeAt(this.state.pos + 1) && this.hasPlugin(['pipelineOperator', { proposal: 'hack', topicToken: '@@' }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
        }
        readToken_plus_min(e) {
         let t = this.input.charCodeAt(this.state.pos + 1);
         t !== e ? (61 === t ? this.finishOp(30, 2) : this.finishOp(53, 1)) : this.finishOp(34, 2);
        }
        readToken_lt() {
         let { pos: e } = this.state,
          t = this.input.charCodeAt(e + 1);
         if (60 === t) return 61 === this.input.charCodeAt(e + 2) ? void this.finishOp(30, 3) : void this.finishOp(51, 2);
         61 !== t ? this.finishOp(47, 1) : this.finishOp(49, 2);
        }
        readToken_gt() {
         let { pos: e } = this.state,
          t = this.input.charCodeAt(e + 1);
         if (62 === t) {
          let t = 62 === this.input.charCodeAt(e + 2) ? 3 : 2;
          return 61 === this.input.charCodeAt(e + t) ? void this.finishOp(30, t + 1) : void this.finishOp(52, t);
         }
         61 !== t ? this.finishOp(48, 1) : this.finishOp(49, 2);
        }
        readToken_eq_excl(e) {
         let t = this.input.charCodeAt(this.state.pos + 1);
         if (61 !== t) return 61 === e && 62 === t ? ((this.state.pos += 2), void this.finishToken(19)) : void this.finishOp(61 === e ? 29 : 35, 1);
         this.finishOp(46, 61 === this.input.charCodeAt(this.state.pos + 2) ? 3 : 2);
        }
        readToken_question() {
         let e = this.input.charCodeAt(this.state.pos + 1),
          t = this.input.charCodeAt(this.state.pos + 2);
         63 === e ? (61 === t ? this.finishOp(30, 3) : this.finishOp(40, 2)) : 46 !== e || (t >= 48 && t <= 57) ? (++this.state.pos, this.finishToken(17)) : ((this.state.pos += 2), this.finishToken(18));
        }
        getTokenFromCode(e) {
         switch (e) {
          case 46:
           return void this.readToken_dot();
          case 40:
           return ++this.state.pos, void this.finishToken(10);
          case 41:
           return ++this.state.pos, void this.finishToken(11);
          case 59:
           return ++this.state.pos, void this.finishToken(13);
          case 44:
           return ++this.state.pos, void this.finishToken(12);
          case 91:
           if (this.hasPlugin('recordAndTuple') && 124 === this.input.charCodeAt(this.state.pos + 1)) {
            if ('bar' !== this.getPluginOption('recordAndTuple', 'syntaxType')) throw this.raise(y.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            (this.state.pos += 2), this.finishToken(2);
           } else ++this.state.pos, this.finishToken(0);
           return;
          case 93:
           return ++this.state.pos, void this.finishToken(3);
          case 123:
           if (this.hasPlugin('recordAndTuple') && 124 === this.input.charCodeAt(this.state.pos + 1)) {
            if ('bar' !== this.getPluginOption('recordAndTuple', 'syntaxType')) throw this.raise(y.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            (this.state.pos += 2), this.finishToken(6);
           } else ++this.state.pos, this.finishToken(5);
           return;
          case 125:
           return ++this.state.pos, void this.finishToken(8);
          case 58:
           return void (this.hasPlugin('functionBind') && 58 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(15, 2) : (++this.state.pos, this.finishToken(14)));
          case 63:
           return void this.readToken_question();
          case 96:
           return void this.readTemplateToken();
          case 48: {
           let e = this.input.charCodeAt(this.state.pos + 1);
           if (120 === e || 88 === e) return void this.readRadixNumber(16);
           if (111 === e || 79 === e) return void this.readRadixNumber(8);
           if (98 === e || 66 === e) return void this.readRadixNumber(2);
          }
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
           return void this.readNumber(!1);
          case 34:
          case 39:
           return void this.readString(e);
          case 47:
           return void this.readToken_slash();
          case 37:
          case 42:
           return void this.readToken_mult_modulo(e);
          case 124:
          case 38:
           return void this.readToken_pipe_amp(e);
          case 94:
           return void this.readToken_caret();
          case 43:
          case 45:
           return void this.readToken_plus_min(e);
          case 60:
           return void this.readToken_lt();
          case 62:
           return void this.readToken_gt();
          case 61:
          case 33:
           return void this.readToken_eq_excl(e);
          case 126:
           return void this.finishOp(36, 1);
          case 64:
           return void this.readToken_atSign();
          case 35:
           return void this.readToken_numberSign();
          case 92:
           return void this.readWord();
          default:
           if (ne(e)) return void this.readWord(e);
         }
         throw this.raise(y.InvalidOrUnexpectedToken, this.state.curPosition(), { unexpected: String.fromCodePoint(e) });
        }
        finishOp(e, t) {
         let r = this.input.slice(this.state.pos, this.state.pos + t);
         (this.state.pos += t), this.finishToken(e, r);
        }
        readRegexp() {
         let e,
          t,
          r = this.state.startLoc,
          s = this.state.start + 1,
          { pos: i } = this.state;
         for (; ; ++i) {
          if (i >= this.length) throw this.raise(y.UnterminatedRegExp, n(r, 1));
          let s = this.input.charCodeAt(i);
          if (Fe(s)) throw this.raise(y.UnterminatedRegExp, n(r, 1));
          if (e) e = !1;
          else {
           if (91 === s) t = !0;
           else if (93 === s && t) t = !1;
           else if (47 === s && !t) break;
           e = 92 === s;
          }
         }
         let a = this.input.slice(s, i);
         ++i;
         let o = '',
          u = () => n(r, i + 2 - s);
         for (; i < this.length; ) {
          let e = this.codePointAtPos(i),
           t = String.fromCharCode(e);
          if (qe.has(e)) 118 === e ? o.includes('u') && this.raise(y.IncompatibleRegExpUVFlags, u()) : 117 === e && o.includes('v') && this.raise(y.IncompatibleRegExpUVFlags, u()), o.includes(t) && this.raise(y.DuplicateRegExpFlags, u());
          else {
           if (!ie(e) && 92 !== e) break;
           this.raise(y.MalformedRegExpFlags, u());
          }
          ++i, (o += t);
         }
         (this.state.pos = i), this.finishToken(138, { pattern: a, flags: o });
        }
        readInt(e, t, r = !1, s = !0) {
         let { n: n, pos: i } = Re(this.input, this.state.pos, this.state.lineStart, this.state.curLine, e, t, r, s, this.errorHandlers_readInt, !1);
         return (this.state.pos = i), n;
        }
        readRadixNumber(e) {
         let t = this.state.pos,
          r = this.state.curPosition(),
          s = !1;
         this.state.pos += 2;
         let i = this.readInt(e);
         null == i && this.raise(y.InvalidDigit, n(r, 2), { radix: e });
         let a = this.input.charCodeAt(this.state.pos);
         if (110 === a) ++this.state.pos, (s = !0);
         else if (109 === a) throw this.raise(y.InvalidDecimal, r);
         if (ne(this.codePointAtPos(this.state.pos))) throw this.raise(y.NumberIdentifier, this.state.curPosition());
         if (s) {
          let e = this.input.slice(t, this.state.pos).replace(/[_n]/g, '');
          this.finishToken(136, e);
         } else this.finishToken(135, i);
        }
        readNumber(e) {
         let t = this.state.pos,
          r = this.state.curPosition(),
          s = !1,
          i = !1,
          a = !1,
          o = !1;
         !e && null === this.readInt(10) && this.raise(y.InvalidNumber, this.state.curPosition());
         let u = this.state.pos - t >= 2 && 48 === this.input.charCodeAt(t);
         if (u) {
          let e = this.input.slice(t, this.state.pos);
          if ((this.recordStrictModeErrors(y.StrictOctalLiteral, r), !this.state.strict)) {
           let t = e.indexOf('_');
           t > 0 && this.raise(y.ZeroDigitNumericSeparator, n(r, t));
          }
          o = u && !/[89]/.test(e);
         }
         let l = this.input.charCodeAt(this.state.pos);
         if ((46 === l && !o && (++this.state.pos, this.readInt(10), (s = !0), (l = this.input.charCodeAt(this.state.pos))), (69 === l || 101 === l) && !o && ((l = this.input.charCodeAt(++this.state.pos)), (43 === l || 45 === l) && ++this.state.pos, null === this.readInt(10) && this.raise(y.InvalidOrMissingExponent, r), (s = !0), (a = !0), (l = this.input.charCodeAt(this.state.pos))), 110 === l && ((s || u) && this.raise(y.InvalidBigIntLiteral, r), ++this.state.pos, (i = !0)), 109 === l)) {
          this.expectPlugin('decimal', this.state.curPosition()), (a || u) && this.raise(y.InvalidDecimal, r), ++this.state.pos;
          var p = !0;
         }
         if (ne(this.codePointAtPos(this.state.pos))) throw this.raise(y.NumberIdentifier, this.state.curPosition());
         let c = this.input.slice(t, this.state.pos).replace(/[_mn]/g, '');
         if (i) return void this.finishToken(136, c);
         if (p) return void this.finishToken(137, c);
         let h = o ? parseInt(c, 8) : parseFloat(c);
         this.finishToken(135, h);
        }
        readCodePoint(e) {
         let { code: t, pos: r } = Ue(this.input, this.state.pos, this.state.lineStart, this.state.curLine, e, this.errorHandlers_readCodePoint);
         return (this.state.pos = r), t;
        }
        readString(e) {
         let { str: t, pos: r, curLine: s, lineStart: n } = Le(34 === e ? 'double' : 'single', this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
         (this.state.pos = r + 1), (this.state.lineStart = n), (this.state.curLine = s), this.finishToken(134, t);
        }
        readTemplateContinuation() {
         this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
        }
        readTemplateToken() {
         let e = this.input[this.state.pos],
          { str: t, firstInvalidLoc: s, pos: n, curLine: i, lineStart: a } = Le('template', this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
         (this.state.pos = n + 1), (this.state.lineStart = a), (this.state.curLine = i), s && (this.state.firstInvalidTemplateEscapePos = new r(s.curLine, s.pos - s.lineStart, this.sourceToOffsetPos(s.pos))), 96 === this.input.codePointAt(n) ? this.finishToken(24, s ? null : e + t + '`') : (this.state.pos++, this.finishToken(25, s ? null : e + t + '${'));
        }
        recordStrictModeErrors(e, t) {
         let r = t.index;
         this.state.strict && !this.state.strictErrors.has(r) ? this.raise(e, t) : this.state.strictErrors.set(r, [e, t]);
        }
        readWord1(e) {
         this.state.containsEsc = !1;
         let t = '',
          r = this.state.pos,
          s = this.state.pos;
         for (void 0 !== e && (this.state.pos += e <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
          let e = this.codePointAtPos(this.state.pos);
          if (ie(e)) this.state.pos += e <= 65535 ? 1 : 2;
          else {
           if (92 !== e) break;
           {
            (this.state.containsEsc = !0), (t += this.input.slice(s, this.state.pos));
            let e = this.state.curPosition(),
             n = this.state.pos === r ? ne : ie;
            if (117 !== this.input.charCodeAt(++this.state.pos)) {
             this.raise(y.MissingUnicodeEscape, this.state.curPosition()), (s = this.state.pos - 1);
             continue;
            }
            ++this.state.pos;
            let i = this.readCodePoint(!0);
            null !== i && (n(i) || this.raise(y.EscapedCharNotAnIdentifier, e), (t += String.fromCodePoint(i))), (s = this.state.pos);
           }
          }
         }
         return t + this.input.slice(s, this.state.pos);
        }
        readWord(e) {
         let t = this.readWord1(e),
          r = S.get(t);
         void 0 !== r ? this.finishToken(r, H(r)) : this.finishToken(132, t);
        }
        checkKeywordEscapes() {
         let { type: e } = this.state;
         V(e) && this.state.containsEsc && this.raise(y.InvalidEscapedReservedWord, this.state.startLoc, { reservedWord: H(e) });
        }
        raise(e, t, s = {}) {
         let n = e(t instanceof r ? t : t.loc.start, s);
         if (!(1024 & this.optionFlags)) throw n;
         return this.isLookahead || this.state.errors.push(n), n;
        }
        raiseOverwrite(e, t, s = {}) {
         let n = t instanceof r ? t : t.loc.start,
          i = n.index,
          a = this.state.errors;
         for (let r = a.length - 1; r >= 0; r--) {
          let t = a[r];
          if (t.loc.index === i) return (a[r] = e(n, s));
          if (t.loc.index < i) break;
         }
         return this.raise(e, t, s);
        }
        updateContext(e) {}
        unexpected(e, t) {
         throw this.raise(y.UnexpectedToken, e ?? this.state.startLoc, { expected: t ? H(t) : null });
        }
        expectPlugin(e, t) {
         if (this.hasPlugin(e)) return !0;
         throw this.raise(y.MissingPlugin, t ?? this.state.startLoc, { missingPlugin: [e] });
        }
        expectOnePlugin(e) {
         if (!e.some((e) => this.hasPlugin(e))) throw this.raise(y.MissingOneOfPlugins, this.state.startLoc, { missingPlugin: e });
        }
        errorBuilder(e) {
         return (t, r, s) => {
          this.raise(e, $e(t, r, s));
         };
        }
       },
       ze = class {
        constructor() {
         (this.privateNames = new Set()), (this.loneAccessors = new Map()), (this.undefinedPrivateNames = new Map());
        }
       },
       Ve = class {
        constructor(e) {
         (this.parser = void 0), (this.stack = []), (this.undefinedPrivateNames = new Map()), (this.parser = e);
        }
        current() {
         return this.stack[this.stack.length - 1];
        }
        enter() {
         this.stack.push(new ze());
        }
        exit() {
         let e = this.stack.pop(),
          t = this.current();
         for (let [r, s] of Array.from(e.undefinedPrivateNames)) t ? t.undefinedPrivateNames.has(r) || t.undefinedPrivateNames.set(r, s) : this.parser.raise(y.InvalidPrivateFieldResolution, s, { identifierName: r });
        }
        declarePrivateName(e, t, r) {
         let { privateNames: s, loneAccessors: n, undefinedPrivateNames: i } = this.current(),
          a = s.has(e);
         if (3 & t) {
          let r = a && n.get(e);
          r ? ((a = (3 & r) == (3 & t) || (4 & r) != (4 & t)), a || n.delete(e)) : a || n.set(e, t);
         }
         a && this.parser.raise(y.PrivateNameRedeclaration, r, { identifierName: e }), s.add(e), i.delete(e);
        }
        usePrivateName(e, t) {
         let r;
         for (r of this.stack) if (r.privateNames.has(e)) return;
         r ? r.undefinedPrivateNames.set(e, t) : this.parser.raise(y.InvalidPrivateFieldResolution, t, { identifierName: e });
        }
       },
       He = class {
        constructor(e = 0) {
         this.type = e;
        }
        canBeArrowParameterDeclaration() {
         return 2 === this.type || 1 === this.type;
        }
        isCertainlyParameterDeclaration() {
         return 3 === this.type;
        }
       },
       Ke = class extends He {
        constructor(e) {
         super(e), (this.declarationErrors = new Map());
        }
        recordDeclarationError(e, t) {
         let r = t.index;
         this.declarationErrors.set(r, [e, t]);
        }
        clearDeclarationError(e) {
         this.declarationErrors.delete(e);
        }
        iterateErrors(e) {
         this.declarationErrors.forEach(e);
        }
       },
       Xe = class {
        constructor(e) {
         (this.parser = void 0), (this.stack = [new He()]), (this.parser = e);
        }
        enter(e) {
         this.stack.push(e);
        }
        exit() {
         this.stack.pop();
        }
        recordParameterInitializerError(e, t) {
         let r = t.loc.start,
          { stack: s } = this,
          n = s.length - 1,
          i = s[n];
         for (; !i.isCertainlyParameterDeclaration(); ) {
          if (!i.canBeArrowParameterDeclaration()) return;
          i.recordDeclarationError(e, r), (i = s[--n]);
         }
         this.parser.raise(e, r);
        }
        recordArrowParameterBindingError(e, t) {
         let { stack: r } = this,
          s = r[r.length - 1],
          n = t.loc.start;
         if (s.isCertainlyParameterDeclaration()) this.parser.raise(e, n);
         else {
          if (!s.canBeArrowParameterDeclaration()) return;
          s.recordDeclarationError(e, n);
         }
        }
        recordAsyncArrowParametersError(e) {
         let { stack: t } = this,
          r = t.length - 1,
          s = t[r];
         for (; s.canBeArrowParameterDeclaration(); ) 2 === s.type && s.recordDeclarationError(y.AwaitBindingIdentifier, e), (s = t[--r]);
        }
        validateAsPattern() {
         let { stack: e } = this,
          t = e[e.length - 1];
         t.canBeArrowParameterDeclaration() &&
          t.iterateErrors(([t, r]) => {
           this.parser.raise(t, r);
           let s = e.length - 2,
            n = e[s];
           for (; n.canBeArrowParameterDeclaration(); ) n.clearDeclarationError(r.index), (n = e[--s]);
          });
        }
       };
      function Ge() {
       return new He();
      }
      var Ye = class {
       constructor() {
        this.stacks = [];
       }
       enter(e) {
        this.stacks.push(e);
       }
       exit() {
        this.stacks.pop();
       }
       currentFlags() {
        return this.stacks[this.stacks.length - 1];
       }
       get hasAwait() {
        return (2 & this.currentFlags()) > 0;
       }
       get hasYield() {
        return (1 & this.currentFlags()) > 0;
       }
       get hasReturn() {
        return (4 & this.currentFlags()) > 0;
       }
       get hasIn() {
        return (8 & this.currentFlags()) > 0;
       }
      };
      function Qe(e, t) {
       return (e ? 2 : 0) | (t ? 1 : 0);
      }
      var Ze = class extends We {
        addExtra(e, t, r, s = !0) {
         if (!e) return;
         let { extra: n } = e;
         null == n && ((n = {}), (e.extra = n)), s ? (n[t] = r) : Object.defineProperty(n, t, { enumerable: s, value: r });
        }
        isContextual(e) {
         return this.state.type === e && !this.state.containsEsc;
        }
        isUnparsedContextual(e, t) {
         let r = e + t.length;
         if (this.input.slice(e, r) === t) {
          let e = this.input.charCodeAt(r);
          return !(ie(e) || 55296 == (64512 & e));
         }
         return !1;
        }
        isLookaheadContextual(e) {
         let t = this.nextTokenStart();
         return this.isUnparsedContextual(t, e);
        }
        eatContextual(e) {
         return !!this.isContextual(e) && (this.next(), !0);
        }
        expectContextual(e, t) {
         if (!this.eatContextual(e)) {
          if (null != t) throw this.raise(t, this.state.startLoc);
          this.unexpected(null, e);
         }
        }
        canInsertSemicolon() {
         return this.match(140) || this.match(8) || this.hasPrecedingLineBreak();
        }
        hasPrecedingLineBreak() {
         return we(this.input, this.offsetToSourcePos(this.state.lastTokEndLoc.index), this.state.start);
        }
        hasFollowingLineBreak() {
         return we(this.input, this.state.end, this.nextTokenStart());
        }
        isLineTerminator() {
         return this.eat(13) || this.canInsertSemicolon();
        }
        semicolon(e = !0) {
         (e ? this.isLineTerminator() : this.eat(13)) || this.raise(y.MissingSemicolon, this.state.lastTokEndLoc);
        }
        expect(e, t) {
         this.eat(e) || this.unexpected(t, e);
        }
        tryParse(e, t = this.state.clone()) {
         let r = { node: null };
         try {
          let s = e((e = null) => {
           throw ((r.node = e), r);
          });
          if (this.state.errors.length > t.errors.length) {
           let e = this.state;
           return (this.state = t), (this.state.tokensLength = e.tokensLength), { node: s, error: e.errors[t.errors.length], thrown: !1, aborted: !1, failState: e };
          }
          return { node: s, error: null, thrown: !1, aborted: !1, failState: null };
         } catch (s) {
          let e = this.state;
          if (((this.state = t), s instanceof SyntaxError)) return { node: null, error: s, thrown: !0, aborted: !1, failState: e };
          if (s === r) return { node: r.node, error: null, thrown: !1, aborted: !0, failState: e };
          throw s;
         }
        }
        checkExpressionErrors(e, t) {
         if (!e) return !1;
         let { shorthandAssignLoc: r, doubleProtoLoc: s, privateKeyLoc: n, optionalParametersLoc: i } = e;
         if (!t) return !!(r || s || i || n);
         null != r && this.raise(y.InvalidCoverInitializedName, r), null != s && this.raise(y.DuplicateProto, s), null != n && this.raise(y.UnexpectedPrivateField, n), null != i && this.unexpected(i);
        }
        isLiteralPropertyName() {
         return J(this.state.type);
        }
        isPrivateName(e) {
         return 'PrivateName' === e.type;
        }
        getPrivateNameSV(e) {
         return e.id.name;
        }
        hasPropertyAsPrivateName(e) {
         return ('MemberExpression' === e.type || 'OptionalMemberExpression' === e.type) && this.isPrivateName(e.property);
        }
        isObjectProperty(e) {
         return 'ObjectProperty' === e.type;
        }
        isObjectMethod(e) {
         return 'ObjectMethod' === e.type;
        }
        initializeScopes(e = 'module' === this.options.sourceType) {
         let t = this.state.labels;
         this.state.labels = [];
         let r = this.exportedIdentifiers;
         this.exportedIdentifiers = new Set();
         let s = this.inModule;
         this.inModule = e;
         let n = this.scope,
          i = this.getScopeHandler();
         this.scope = new i(this, e);
         let a = this.prodParam;
         this.prodParam = new Ye();
         let o = this.classScope;
         this.classScope = new Ve(this);
         let u = this.expressionScope;
         return (
          (this.expressionScope = new Xe(this)),
          () => {
           (this.state.labels = t), (this.exportedIdentifiers = r), (this.inModule = s), (this.scope = n), (this.prodParam = a), (this.classScope = o), (this.expressionScope = u);
          }
         );
        }
        enterInitialScopes() {
         let e = 0;
         this.inModule && (e |= 2), this.scope.enter(1), this.prodParam.enter(e);
        }
        checkDestructuringPrivate(e) {
         let { privateKeyLoc: t } = e;
         null !== t && this.expectPlugin('destructuringPrivate', t);
        }
       },
       et = class {
        constructor() {
         (this.shorthandAssignLoc = null), (this.doubleProtoLoc = null), (this.privateKeyLoc = null), (this.optionalParametersLoc = null);
        }
       },
       tt = class {
        constructor(e, t, r) {
         (this.type = ''), (this.start = t), (this.end = 0), (this.loc = new s(r)), 64 & (null == e ? void 0 : e.optionFlags) && (this.range = [t, 0]), null != e && e.filename && (this.loc.filename = e.filename);
        }
       },
       rt = tt.prototype;
      function st(e) {
       let { type: t, start: r, end: s, loc: n, range: i, extra: a, name: o } = e,
        u = Object.create(rt);
       return (u.type = t), (u.start = r), (u.end = s), (u.loc = n), (u.range = i), (u.extra = a), (u.name = o), 'Placeholder' === t && (u.expectedNode = e.expectedNode), u;
      }
      function nt(e) {
       let { type: t, start: r, end: s, loc: n, range: i, extra: a } = e;
       if ('Placeholder' === t)
        return (function (e) {
         return st(e);
        })(e);
       let o = Object.create(rt);
       return (o.type = t), (o.start = r), (o.end = s), (o.loc = n), (o.range = i), void 0 !== e.raw ? (o.raw = e.raw) : (o.extra = a), (o.value = e.value), o;
      }
      rt.__clone = function () {
       let e = new tt(void 0, this.start, this.loc.start),
        t = Object.keys(this);
       for (let r = 0, s = t.length; r < s; r++) {
        let s = t[r];
        'leadingComments' !== s && 'trailingComments' !== s && 'innerComments' !== s && (e[s] = this[s]);
       }
       return e;
      };
      var it = class extends Ze {
        startNode() {
         let e = this.state.startLoc;
         return new tt(this, e.index, e);
        }
        startNodeAt(e) {
         return new tt(this, e.index, e);
        }
        startNodeAtNode(e) {
         return this.startNodeAt(e.loc.start);
        }
        finishNode(e, t) {
         return this.finishNodeAt(e, t, this.state.lastTokEndLoc);
        }
        finishNodeAt(e, t, r) {
         return (e.type = t), (e.end = r.index), (e.loc.end = r), 64 & this.optionFlags && (e.range[1] = r.index), 2048 & this.optionFlags && this.processComment(e), e;
        }
        resetStartLocation(e, t) {
         (e.start = t.index), (e.loc.start = t), 64 & this.optionFlags && (e.range[0] = t.index);
        }
        resetEndLocation(e, t = this.state.lastTokEndLoc) {
         (e.end = t.index), (e.loc.end = t), 64 & this.optionFlags && (e.range[1] = t.index);
        }
        resetStartLocationFromNode(e, t) {
         this.resetStartLocation(e, t.loc.start);
        }
       },
       at = new Set(['_', 'any', 'bool', 'boolean', 'empty', 'extends', 'false', 'interface', 'mixed', 'null', 'number', 'static', 'string', 'true', 'typeof', 'void']),
       ot = m`flow`({ AmbiguousConditionalArrow: 'Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.', AmbiguousDeclareModuleKind: 'Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.', AssignReservedType: ({ reservedType: e }) => `Cannot overwrite reserved type ${e}.`, DeclareClassElement: 'The `declare` modifier can only appear on class fields.', DeclareClassFieldInitializer: 'Initializers are not allowed in fields with the `declare` modifier.', DuplicateDeclareModuleExports: 'Duplicate `declare module.exports` statement.', EnumBooleanMemberNotInitialized: ({ memberName: e, enumName: t }) => `Boolean enum members need to be initialized. Use either \`${e} = true,\` or \`${e} = false,\` in enum \`${t}\`.`, EnumDuplicateMemberName: ({ memberName: e, enumName: t }) => `Enum member names need to be unique, but the name \`${e}\` has already been used before in enum \`${t}\`.`, EnumInconsistentMemberValues: ({ enumName: e }) => `Enum \`${e}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`, EnumInvalidExplicitType: ({ invalidEnumType: e, enumName: t }) => `Enum type \`${e}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${t}\`.`, EnumInvalidExplicitTypeUnknownSupplied: ({ enumName: e }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${e}\`.`, EnumInvalidMemberInitializerPrimaryType: ({ enumName: e, memberName: t, explicitType: r }) => `Enum \`${e}\` has type \`${r}\`, so the initializer of \`${t}\` needs to be a ${r} literal.`, EnumInvalidMemberInitializerSymbolType: ({ enumName: e, memberName: t }) => `Symbol enum members cannot be initialized. Use \`${t},\` in enum \`${e}\`.`, EnumInvalidMemberInitializerUnknownType: ({ enumName: e, memberName: t }) => `The enum member initializer for \`${t}\` needs to be a literal (either a boolean, number, or string) in enum \`${e}\`.`, EnumInvalidMemberName: ({ enumName: e, memberName: t, suggestion: r }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${t}\`, consider using \`${r}\`, in enum \`${e}\`.`, EnumNumberMemberNotInitialized: ({ enumName: e, memberName: t }) => `Number enum members need to be initialized, e.g. \`${t} = 1\` in enum \`${e}\`.`, EnumStringMemberInconsistentlyInitialized: ({ enumName: e }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${e}\`.`, GetterMayNotHaveThisParam: 'A getter cannot have a `this` parameter.', ImportReflectionHasImportType: 'An `import module` declaration can not use `type` or `typeof` keyword.', ImportTypeShorthandOnlyInPureImport: 'The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.', InexactInsideExact: 'Explicit inexact syntax cannot appear inside an explicit exact object type.', InexactInsideNonObject: 'Explicit inexact syntax cannot appear in class or interface definitions.', InexactVariance: 'Explicit inexact syntax cannot have variance.', InvalidNonTypeImportInDeclareModule: 'Imports within a `declare module` body must always be `import type` or `import typeof`.', MissingTypeParamDefault: 'Type parameter declaration needs a default, since a preceding type parameter declaration has a default.', NestedDeclareModule: '`declare module` cannot be used inside another `declare module`.', NestedFlowComment: 'Cannot have a flow comment inside another flow comment.', PatternIsOptional: Object.assign({ message: 'A binding pattern parameter cannot be optional in an implementation signature.' }, { reasonCode: 'OptionalBindingPattern' }), SetterMayNotHaveThisParam: 'A setter cannot have a `this` parameter.', SpreadVariance: 'Spread properties cannot have variance.', ThisParamAnnotationRequired: 'A type annotation is required for the `this` parameter.', ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.", ThisParamMayNotBeOptional: 'The `this` parameter cannot be optional.', ThisParamMustBeFirst: 'The `this` parameter must be the first function parameter.', ThisParamNoDefault: 'The `this` parameter may not have a default value.', TypeBeforeInitializer: 'Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.', TypeCastInPattern: 'The type cast expression is expected to be wrapped with parenthesis.', UnexpectedExplicitInexactInObject: 'Explicit inexact syntax must appear at the end of an inexact object.', UnexpectedReservedType: ({ reservedType: e }) => `Unexpected reserved type ${e}.`, UnexpectedReservedUnderscore: '`_` is only allowed as a type argument to call or new.', UnexpectedSpaceBetweenModuloChecks: 'Spaces between `%` and `checks` are not allowed here.', UnexpectedSpreadType: 'Spread operator cannot appear in class or interface definitions.', UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".', UnexpectedTokenAfterTypeParameter: 'Expected an arrow function after this type parameter declaration.', UnexpectedTypeParameterBeforeAsyncArrowFunction: 'Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.', UnsupportedDeclareExportKind: ({ unsupportedExportKind: e, suggestion: t }) => `\`declare export ${e}\` is not supported. Use \`${t}\` instead.`, UnsupportedStatementInDeclareModule: 'Only declares and type imports are allowed inside declare module.', UnterminatedFlowComment: 'Unterminated flow-comment.' });
      function ut(e) {
       return 'type' === e.importKind || 'typeof' === e.importKind;
      }
      var lt = { const: 'declare export var', let: 'declare export var', type: 'export type', interface: 'export interface' },
       pt = /\*?\s*@((?:no)?flow)\b/,
       ct = m`jsx`({ AttributeIsEmpty: 'JSX attributes must only be assigned a non-empty expression.', MissingClosingTagElement: ({ openingTagName: e }) => `Expected corresponding JSX closing tag for <${e}>.`, MissingClosingTagFragment: 'Expected corresponding JSX closing tag for <>.', UnexpectedSequenceExpression: 'Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?', UnexpectedToken: ({ unexpected: e, HTMLEntity: t }) => `Unexpected token \`${e}\`. Did you mean \`${t}\` or \`{'${e}'}\`?`, UnsupportedJsxValue: 'JSX value should be either an expression or a quoted JSX text.', UnterminatedJsxContent: 'Unterminated JSX contents.', UnwrappedAdjacentJSXElements: 'Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?' });
      function ht(e) {
       return !!e && ('JSXOpeningFragment' === e.type || 'JSXClosingFragment' === e.type);
      }
      function dt(e) {
       if ('JSXIdentifier' === e.type) return e.name;
       if ('JSXNamespacedName' === e.type) return e.namespace.name + ':' + e.name.name;
       if ('JSXMemberExpression' === e.type) return dt(e.object) + '.' + dt(e.property);
       throw new Error('Node had unexpected type: ' + e.type);
      }
      var ft = class extends ye {
        constructor(...e) {
         super(...e), (this.tsNames = new Map());
        }
       },
       mt = class extends De {
        constructor(...e) {
         super(...e), (this.importsStack = []);
        }
        createScope(e) {
         return this.importsStack.push(new Set()), new ft(e);
        }
        enter(e) {
         256 === e && this.importsStack.push(new Set()), super.enter(e);
        }
        exit() {
         let e = super.exit();
         return 256 === e && this.importsStack.pop(), e;
        }
        hasImport(e, t) {
         let r = this.importsStack.length;
         if (this.importsStack[r - 1].has(e)) return !0;
         if (!t && r > 1) for (let s = 0; s < r - 1; s++) if (this.importsStack[s].has(e)) return !0;
         return !1;
        }
        declareName(e, t, r) {
         if (4096 & t) return this.hasImport(e, !0) && this.parser.raise(y.VarRedeclaration, r, { identifierName: e }), void this.importsStack[this.importsStack.length - 1].add(e);
         let s = this.currentScope(),
          n = s.tsNames.get(e) || 0;
         if (1024 & t) return this.maybeExportDefined(s, e), void s.tsNames.set(e, 16 | n);
         super.declareName(e, t, r), 2 & t && (1 & t || (this.checkRedeclarationInScope(s, e, t, r), this.maybeExportDefined(s, e)), (n |= 1)), 256 & t && (n |= 2), 512 & t && (n |= 4), 128 & t && (n |= 8), n && s.tsNames.set(e, n);
        }
        isRedeclaredInScope(e, t, r) {
         let s = e.tsNames.get(t);
         return (2 & s) > 0 ? !(256 & r) || !!(512 & r) != (4 & s) > 0 : 128 & r && (8 & s) > 0 ? !!(2 & e.names.get(t)) && !!(1 & r) : !!(2 & r && (1 & s) > 0) || super.isRedeclaredInScope(e, t, r);
        }
        checkLocalExport(e) {
         let { name: t } = e;
         if (!this.hasImport(t)) {
          for (let e = this.scopeStack.length - 1; e >= 0; e--) {
           let r = this.scopeStack[e].tsNames.get(t);
           if ((1 & r) > 0 || (16 & r) > 0) return;
          }
          super.checkLocalExport(e);
         }
        }
       },
       yt = (e) => ('ParenthesizedExpression' === e.type ? yt(e.expression) : e),
       Dt = class extends it {
        toAssignable(e, t = !1) {
         var r, s;
         let n;
         switch ((('ParenthesizedExpression' === e.type || (null != (r = e.extra) && r.parenthesized)) && ((n = yt(e)), t ? ('Identifier' === n.type ? this.expressionScope.recordArrowParameterBindingError(y.InvalidParenthesizedAssignment, e) : 'MemberExpression' !== n.type && !this.isOptionalMemberExpression(n) && this.raise(y.InvalidParenthesizedAssignment, e)) : this.raise(y.InvalidParenthesizedAssignment, e)), e.type)) {
          case 'Identifier':
          case 'ObjectPattern':
          case 'ArrayPattern':
          case 'AssignmentPattern':
          case 'RestElement':
           break;
          case 'ObjectExpression':
           e.type = 'ObjectPattern';
           for (let r = 0, s = e.properties.length, n = s - 1; r < s; r++) {
            var i;
            let s = e.properties[r],
             a = r === n;
            this.toAssignableObjectExpressionProp(s, a, t), a && 'RestElement' === s.type && null != (i = e.extra) && i.trailingCommaLoc && this.raise(y.RestTrailingComma, e.extra.trailingCommaLoc);
           }
           break;
          case 'ObjectProperty': {
           let { key: r, value: s } = e;
           this.isPrivateName(r) && this.classScope.usePrivateName(this.getPrivateNameSV(r), r.loc.start), this.toAssignable(s, t);
           break;
          }
          case 'SpreadElement':
           throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
          case 'ArrayExpression':
           (e.type = 'ArrayPattern'), this.toAssignableList(e.elements, null == (s = e.extra) ? void 0 : s.trailingCommaLoc, t);
           break;
          case 'AssignmentExpression':
           '=' !== e.operator && this.raise(y.MissingEqInAssignment, e.left.loc.end), (e.type = 'AssignmentPattern'), delete e.operator, this.toAssignable(e.left, t);
           break;
          case 'ParenthesizedExpression':
           this.toAssignable(n, t);
         }
        }
        toAssignableObjectExpressionProp(e, t, r) {
         if ('ObjectMethod' === e.type) this.raise('get' === e.kind || 'set' === e.kind ? y.PatternHasAccessor : y.PatternHasMethod, e.key);
         else if ('SpreadElement' === e.type) {
          e.type = 'RestElement';
          let s = e.argument;
          this.checkToRestConversion(s, !1), this.toAssignable(s, r), t || this.raise(y.RestTrailingComma, e);
         } else this.toAssignable(e, r);
        }
        toAssignableList(e, t, r) {
         let s = e.length - 1;
         for (let n = 0; n <= s; n++) {
          let i = e[n];
          if (i) {
           if ('SpreadElement' === i.type) {
            i.type = 'RestElement';
            let e = i.argument;
            this.checkToRestConversion(e, !0), this.toAssignable(e, r);
           } else this.toAssignable(i, r);
           'RestElement' === i.type && (n < s ? this.raise(y.RestTrailingComma, i) : t && this.raise(y.RestTrailingComma, t));
          }
         }
        }
        isAssignable(e, t) {
         switch (e.type) {
          case 'Identifier':
          case 'ObjectPattern':
          case 'ArrayPattern':
          case 'AssignmentPattern':
          case 'RestElement':
           return !0;
          case 'ObjectExpression': {
           let t = e.properties.length - 1;
           return e.properties.every((e, r) => 'ObjectMethod' !== e.type && (r === t || 'SpreadElement' !== e.type) && this.isAssignable(e));
          }
          case 'ObjectProperty':
           return this.isAssignable(e.value);
          case 'SpreadElement':
           return this.isAssignable(e.argument);
          case 'ArrayExpression':
           return e.elements.every((e) => null === e || this.isAssignable(e));
          case 'AssignmentExpression':
           return '=' === e.operator;
          case 'ParenthesizedExpression':
           return this.isAssignable(e.expression);
          case 'MemberExpression':
          case 'OptionalMemberExpression':
           return !t;
          default:
           return !1;
         }
        }
        toReferencedList(e, t) {
         return e;
        }
        toReferencedListDeep(e, t) {
         this.toReferencedList(e, t);
         for (let r of e) 'ArrayExpression' === (null == r ? void 0 : r.type) && this.toReferencedListDeep(r.elements);
        }
        parseSpread(e) {
         let t = this.startNode();
         return this.next(), (t.argument = this.parseMaybeAssignAllowIn(e, void 0)), this.finishNode(t, 'SpreadElement');
        }
        parseRestBinding() {
         let e = this.startNode();
         return this.next(), (e.argument = this.parseBindingAtom()), this.finishNode(e, 'RestElement');
        }
        parseBindingAtom() {
         switch (this.state.type) {
          case 0: {
           let e = this.startNode();
           return this.next(), (e.elements = this.parseBindingList(3, 93, 1)), this.finishNode(e, 'ArrayPattern');
          }
          case 5:
           return this.parseObjectLike(8, !0);
         }
         return this.parseIdentifier();
        }
        parseBindingList(e, t, r) {
         let s = 1 & r,
          n = [],
          i = !0;
         for (; !this.eat(e); )
          if ((i ? (i = !1) : this.expect(12), s && this.match(12))) n.push(null);
          else {
           if (this.eat(e)) break;
           if (this.match(21)) {
            let s = this.parseRestBinding();
            if (((this.hasPlugin('flow') || 2 & r) && (s = this.parseFunctionParamType(s)), n.push(s), !this.checkCommaAfterRest(t))) {
             this.expect(e);
             break;
            }
           } else {
            let e = [];
            for (this.match(26) && this.hasPlugin('decorators') && this.raise(y.UnsupportedParameterDecorator, this.state.startLoc); this.match(26); ) e.push(this.parseDecorator());
            n.push(this.parseAssignableListItem(r, e));
           }
          }
         return n;
        }
        parseBindingRestProperty(e) {
         return this.next(), (e.argument = this.parseIdentifier()), this.checkCommaAfterRest(125), this.finishNode(e, 'RestElement');
        }
        parseBindingProperty() {
         let { type: e, startLoc: t } = this.state;
         if (21 === e) return this.parseBindingRestProperty(this.startNode());
         let r = this.startNode();
         return 139 === e ? (this.expectPlugin('destructuringPrivate', t), this.classScope.usePrivateName(this.state.value, t), (r.key = this.parsePrivateName())) : this.parsePropertyName(r), (r.method = !1), this.parseObjPropValue(r, t, !1, !1, !0, !1);
        }
        parseAssignableListItem(e, t) {
         let r = this.parseMaybeDefault();
         (this.hasPlugin('flow') || 2 & e) && this.parseFunctionParamType(r);
         let s = this.parseMaybeDefault(r.loc.start, r);
         return t.length && (r.decorators = t), s;
        }
        parseFunctionParamType(e) {
         return e;
        }
        parseMaybeDefault(e, t) {
         var r;
         if ((null != e || (e = this.state.startLoc), (t = null != (r = t) ? r : this.parseBindingAtom()), !this.eat(29))) return t;
         let s = this.startNodeAt(e);
         return (s.left = t), (s.right = this.parseMaybeAssignAllowIn()), this.finishNode(s, 'AssignmentPattern');
        }
        isValidLVal(e, t, r) {
         switch (e) {
          case 'AssignmentPattern':
           return 'left';
          case 'RestElement':
           return 'argument';
          case 'ObjectProperty':
           return 'value';
          case 'ParenthesizedExpression':
           return 'expression';
          case 'ArrayPattern':
           return 'elements';
          case 'ObjectPattern':
           return 'properties';
         }
         return !1;
        }
        isOptionalMemberExpression(e) {
         return 'OptionalMemberExpression' === e.type;
        }
        checkLVal(e, t, r = 64, s = !1, n = !1, i = !1) {
         var a;
         let o = e.type;
         if (this.isObjectMethod(e)) return;
         let u = this.isOptionalMemberExpression(e);
         if (u || 'MemberExpression' === o) return u && (this.expectPlugin('optionalChainingAssign', e.loc.start), 'AssignmentExpression' !== t.type && this.raise(y.InvalidLhsOptionalChaining, e, { ancestor: t })), void (64 !== r && this.raise(y.InvalidPropertyBindingPattern, e));
         if ('Identifier' === o) {
          this.checkIdentifier(e, r, n);
          let { name: t } = e;
          return void (s && (s.has(t) ? this.raise(y.ParamDupe, e) : s.add(t)));
         }
         let l,
          p,
          c = this.isValidLVal(o, !(i || (null != (a = e.extra) && a.parenthesized)) && 'AssignmentExpression' === t.type, r);
         if (!0 === c) return;
         if (!1 === c) {
          let s = 64 === r ? y.InvalidLhs : y.InvalidLhsBinding;
          return void this.raise(s, e, { ancestor: t });
         }
         'string' == typeof c ? ((l = c), (p = 'ParenthesizedExpression' === o)) : ([l, p] = c);
         let h = 'ArrayPattern' === o || 'ObjectPattern' === o ? { type: o } : t,
          d = e[l];
         if (Array.isArray(d)) for (let f of d) f && this.checkLVal(f, h, r, s, n, p);
         else d && this.checkLVal(d, h, r, s, n, p);
        }
        checkIdentifier(e, t, r = !1) {
         this.state.strict && (r ? fe(e.name, this.inModule) : de(e.name)) && (64 === t ? this.raise(y.StrictEvalArguments, e, { referenceName: e.name }) : this.raise(y.StrictEvalArgumentsBinding, e, { bindingName: e.name })), 8192 & t && 'let' === e.name && this.raise(y.LetInLexicalBinding, e), 64 & t || this.declareNameFromIdentifier(e, t);
        }
        declareNameFromIdentifier(e, t) {
         this.scope.declareName(e.name, t, e.loc.start);
        }
        checkToRestConversion(e, t) {
         switch (e.type) {
          case 'ParenthesizedExpression':
           this.checkToRestConversion(e.expression, t);
           break;
          case 'Identifier':
          case 'MemberExpression':
           break;
          case 'ArrayExpression':
          case 'ObjectExpression':
           if (t) break;
          default:
           this.raise(y.InvalidRestAssignmentPattern, e);
         }
        }
        checkCommaAfterRest(e) {
         return !!this.match(12) && (this.raise(this.lookaheadCharCode() === e ? y.RestTrailingComma : y.ElementAfterRest, this.state.startLoc), !0);
        }
       };
      function gt(e) {
       if (!e) throw new Error('Assert fail');
      }
      var xt = m`typescript`({ AbstractMethodHasImplementation: ({ methodName: e }) => `Method '${e}' cannot have an implementation because it is marked abstract.`, AbstractPropertyHasInitializer: ({ propertyName: e }) => `Property '${e}' cannot have an initializer because it is marked abstract.`, AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.", AccessorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.", AccessorCannotHaveTypeParameters: 'An accessor cannot have type parameters.', ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.", ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.", ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.", ConstructorHasTypeParameters: 'Type parameters cannot appear on a constructor declaration.', DeclareAccessor: ({ kind: e }) => `'declare' is not allowed in ${e}ters.`, DeclareClassFieldHasInitializer: 'Initializers are not allowed in ambient contexts.', DeclareFunctionHasImplementation: 'An implementation cannot be declared in ambient contexts.', DuplicateAccessibilityModifier: ({ modifier: e }) => 'Accessibility modifier already seen.', DuplicateModifier: ({ modifier: e }) => `Duplicate modifier: '${e}'.`, EmptyHeritageClauseType: ({ token: e }) => `'${e}' list cannot be empty.`, EmptyTypeArguments: 'Type argument list cannot be empty.', EmptyTypeParameters: 'Type parameter list cannot be empty.', ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.", ImportAliasHasImportType: "An import alias can not use 'import type'.", ImportReflectionHasImportType: 'An `import module` declaration can not use `type` modifier', IncompatibleModifiers: ({ modifiers: e }) => `'${e[0]}' modifier cannot be used with '${e[1]}' modifier.`, IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.", IndexSignatureHasAccessibility: ({ modifier: e }) => `Index signatures cannot have an accessibility modifier ('${e}').`, IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.", IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.", IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.", InitializerNotAllowedInAmbientContext: 'Initializers are not allowed in ambient contexts.', InvalidModifierOnTypeMember: ({ modifier: e }) => `'${e}' modifier cannot appear on a type member.`, InvalidModifierOnTypeParameter: ({ modifier: e }) => `'${e}' modifier cannot appear on a type parameter.`, InvalidModifierOnTypeParameterPositions: ({ modifier: e }) => `'${e}' modifier can only appear on a type parameter of a class, interface or type alias.`, InvalidModifiersOrder: ({ orderedModifiers: e }) => `'${e[0]}' modifier must precede '${e[1]}' modifier.`, InvalidPropertyAccessAfterInstantiationExpression: 'Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.', InvalidTupleMemberLabel: 'Tuple members must be labeled with a simple identifier.', MissingInterfaceName: "'interface' declarations must be followed by an identifier.", NonAbstractClassHasAbstractMethod: 'Abstract methods can only appear within an abstract class.', NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.", OptionalTypeBeforeRequired: 'A required element cannot follow an optional element.', OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.", PatternIsOptional: 'A binding pattern parameter cannot be optional in an implementation signature.', PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.", PrivateElementHasAccessibility: ({ modifier: e }) => `Private elements cannot have an accessibility modifier ('${e}').`, ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.", ReservedArrowTypeParam: 'This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.', ReservedTypeAssertion: 'This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.', SetAccessorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.", SetAccessorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.", SetAccessorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.", SingleTypeParameterWithoutTrailingComma: ({ typeParameterName: e }) => `Single type parameter ${e} should have a trailing comma. Example usage: <${e},>.`, StaticBlockCannotHaveModifier: 'Static class blocks cannot have any modifier.', TupleOptionalAfterType: 'A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).', TypeAnnotationAfterAssign: 'Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.', TypeImportCannotSpecifyDefaultAndNamed: 'A type-only import can specify a default import or named bindings, but not both.', TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.", TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.", UnexpectedParameterModifier: 'A parameter property is only allowed in a constructor implementation.', UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.", UnexpectedTypeAnnotation: 'Did not expect a type annotation here.', UnexpectedTypeCastInParameter: 'Unexpected type cast in parameter position.', UnsupportedImportTypeArgument: 'Argument in a type import must be a string literal.', UnsupportedParameterPropertyKind: 'A parameter property may not be declared using a binding pattern.', UnsupportedSignatureParameterKind: ({ type: e }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${e}.` });
      function Et(e) {
       return 'private' === e || 'public' === e || 'protected' === e;
      }
      function bt(e) {
       return 'in' === e || 'out' === e;
      }
      function Tt(e) {
       if ('MemberExpression' !== e.type) return !1;
       let { computed: t, property: r } = e;
       return (!t || 'StringLiteral' === r.type || !('TemplateLiteral' !== r.type || r.expressions.length > 0)) && vt(e.object);
      }
      function At(e, t) {
       var r;
       let { type: s } = e;
       if (null != (r = e.extra) && r.parenthesized) return !1;
       if (t) {
        if ('Literal' === s) {
         let { value: t } = e;
         if ('string' == typeof t || 'boolean' == typeof t) return !0;
        }
       } else if ('StringLiteral' === s || 'BooleanLiteral' === s) return !0;
       return !!(
        Ct(e, t) ||
        (function (e, t) {
         if ('UnaryExpression' === e.type) {
          let { operator: r, argument: s } = e;
          if ('-' === r && Ct(s, t)) return !0;
         }
         return !1;
        })(e, t) ||
        ('TemplateLiteral' === s && 0 === e.expressions.length) ||
        Tt(e)
       );
      }
      function Ct(e, t) {
       return t ? 'Literal' === e.type && ('number' == typeof e.value || 'bigint' in e) : 'NumericLiteral' === e.type || 'BigIntLiteral' === e.type;
      }
      function vt(e) {
       return 'Identifier' === e.type || ('MemberExpression' === e.type && !e.computed && vt(e.object));
      }
      var Ft = m`placeholders`({ ClassNameIsRequired: 'A class name is required.', UnexpectedSpace: 'Unexpected space in placeholder.' }),
       wt = ['minimal', 'fsharp', 'hack', 'smart'],
       St = ['^^', '@@', '^', '%', '#'],
       Pt = {
        estree: (e) =>
         class extends e {
          parse() {
           let e = x(super.parse());
           return 128 & this.optionFlags && (e.tokens = e.tokens.map(x)), e;
          }
          parseRegExpLiteral({ pattern: e, flags: t }) {
           let r = null;
           try {
            r = new RegExp(e, t);
           } catch {}
           let s = this.estreeParseLiteral(r);
           return (s.regex = { pattern: e, flags: t }), s;
          }
          parseBigIntLiteral(e) {
           let t;
           try {
            t = BigInt(e);
           } catch {
            t = null;
           }
           let r = this.estreeParseLiteral(t);
           return (r.bigint = String(r.value || e)), r;
          }
          parseDecimalLiteral(e) {
           let t = this.estreeParseLiteral(null);
           return (t.decimal = String(t.value || e)), t;
          }
          estreeParseLiteral(e) {
           return this.parseLiteral(e, 'Literal');
          }
          parseStringLiteral(e) {
           return this.estreeParseLiteral(e);
          }
          parseNumericLiteral(e) {
           return this.estreeParseLiteral(e);
          }
          parseNullLiteral() {
           return this.estreeParseLiteral(null);
          }
          parseBooleanLiteral(e) {
           return this.estreeParseLiteral(e);
          }
          directiveToStmt(e) {
           let t = e.value;
           delete e.value, (t.type = 'Literal'), (t.raw = t.extra.raw), (t.value = t.extra.expressionValue);
           let r = e;
           return (r.type = 'ExpressionStatement'), (r.expression = t), (r.directive = t.extra.rawValue), delete t.extra, r;
          }
          initFunction(e, t) {
           super.initFunction(e, t), (e.expression = !1);
          }
          checkDeclaration(e) {
           null != e && this.isObjectProperty(e) ? this.checkDeclaration(e.value) : super.checkDeclaration(e);
          }
          getObjectOrClassMethodParams(e) {
           return e.value.params;
          }
          isValidDirective(e) {
           var t;
           return 'ExpressionStatement' === e.type && 'Literal' === e.expression.type && 'string' == typeof e.expression.value && !(null != (t = e.expression.extra) && t.parenthesized);
          }
          parseBlockBody(e, t, r, s, n) {
           super.parseBlockBody(e, t, r, s, n);
           let i = e.directives.map((e) => this.directiveToStmt(e));
           (e.body = i.concat(e.body)), delete e.directives;
          }
          parsePrivateName() {
           let e = super.parsePrivateName();
           return this.getPluginOption('estree', 'classFeatures') ? this.convertPrivateNameToPrivateIdentifier(e) : e;
          }
          convertPrivateNameToPrivateIdentifier(e) {
           let t = super.getPrivateNameSV(e);
           return delete e.id, (e.name = t), (e.type = 'PrivateIdentifier'), e;
          }
          isPrivateName(e) {
           return this.getPluginOption('estree', 'classFeatures') ? 'PrivateIdentifier' === e.type : super.isPrivateName(e);
          }
          getPrivateNameSV(e) {
           return this.getPluginOption('estree', 'classFeatures') ? e.name : super.getPrivateNameSV(e);
          }
          parseLiteral(e, t) {
           let r = super.parseLiteral(e, t);
           return (r.raw = r.extra.raw), delete r.extra, r;
          }
          parseFunctionBody(e, t, r = !1) {
           super.parseFunctionBody(e, t, r), (e.expression = 'BlockStatement' !== e.body.type);
          }
          parseMethod(e, t, r, s, n, i, a = !1) {
           let o = this.startNode();
           (o.kind = e.kind), (o = super.parseMethod(o, t, r, s, n, i, a)), (o.type = 'FunctionExpression'), delete o.kind, (e.value = o);
           let { typeParameters: u } = e;
           return u && (delete e.typeParameters, (o.typeParameters = u), this.resetStartLocationFromNode(o, u)), 'ClassPrivateMethod' === i && (e.computed = !1), this.finishNode(e, 'MethodDefinition');
          }
          nameIsConstructor(e) {
           return 'Literal' === e.type ? 'constructor' === e.value : super.nameIsConstructor(e);
          }
          parseClassProperty(...e) {
           let t = super.parseClassProperty(...e);
           return this.getPluginOption('estree', 'classFeatures') && (t.type = 'PropertyDefinition'), t;
          }
          parseClassPrivateProperty(...e) {
           let t = super.parseClassPrivateProperty(...e);
           return this.getPluginOption('estree', 'classFeatures') && ((t.type = 'PropertyDefinition'), (t.computed = !1)), t;
          }
          parseObjectMethod(e, t, r, s, n) {
           let i = super.parseObjectMethod(e, t, r, s, n);
           return i && ((i.type = 'Property'), 'method' === i.kind && (i.kind = 'init'), (i.shorthand = !1)), i;
          }
          parseObjectProperty(e, t, r, s) {
           let n = super.parseObjectProperty(e, t, r, s);
           return n && ((n.kind = 'init'), (n.type = 'Property')), n;
          }
          isValidLVal(e, t, r) {
           return 'Property' === e ? 'value' : super.isValidLVal(e, t, r);
          }
          isAssignable(e, t) {
           return null != e && this.isObjectProperty(e) ? this.isAssignable(e.value, t) : super.isAssignable(e, t);
          }
          toAssignable(e, t = !1) {
           if (null != e && this.isObjectProperty(e)) {
            let { key: r, value: s } = e;
            this.isPrivateName(r) && this.classScope.usePrivateName(this.getPrivateNameSV(r), r.loc.start), this.toAssignable(s, t);
           } else super.toAssignable(e, t);
          }
          toAssignableObjectExpressionProp(e, t, r) {
           'Property' !== e.type || ('get' !== e.kind && 'set' !== e.kind) ? ('Property' === e.type && e.method ? this.raise(y.PatternHasMethod, e.key) : super.toAssignableObjectExpressionProp(e, t, r)) : this.raise(y.PatternHasAccessor, e.key);
          }
          finishCallExpression(e, t) {
           let r = super.finishCallExpression(e, t);
           var s, n;
           return 'Import' === r.callee.type && ((r.type = 'ImportExpression'), (r.source = r.arguments[0]), (r.options = null != (s = r.arguments[1]) ? s : null), (r.attributes = null != (n = r.arguments[1]) ? n : null), delete r.arguments, delete r.callee), r;
          }
          toReferencedArguments(e) {
           'ImportExpression' !== e.type && super.toReferencedArguments(e);
          }
          parseExport(e, t) {
           let r = this.state.lastTokStartLoc,
            s = super.parseExport(e, t);
           switch (s.type) {
            case 'ExportAllDeclaration':
             s.exported = null;
             break;
            case 'ExportNamedDeclaration':
             1 === s.specifiers.length && 'ExportNamespaceSpecifier' === s.specifiers[0].type && ((s.type = 'ExportAllDeclaration'), (s.exported = s.specifiers[0].exported), delete s.specifiers);
            case 'ExportDefaultDeclaration': {
             var n;
             let { declaration: e } = s;
             'ClassDeclaration' === (null == e ? void 0 : e.type) && (null == (n = e.decorators) ? void 0 : n.length) > 0 && e.start === s.start && this.resetStartLocation(s, r);
            }
           }
           return s;
          }
          parseSubscript(e, t, r, s) {
           let n = super.parseSubscript(e, t, r, s);
           if (s.optionalChainMember) {
            if ((('OptionalMemberExpression' === n.type || 'OptionalCallExpression' === n.type) && (n.type = n.type.substring(8)), s.stop)) {
             let e = this.startNodeAtNode(n);
             return (e.expression = n), this.finishNode(e, 'ChainExpression');
            }
           } else ('MemberExpression' === n.type || 'CallExpression' === n.type) && (n.optional = !1);
           return n;
          }
          isOptionalMemberExpression(e) {
           return 'ChainExpression' === e.type ? 'MemberExpression' === e.expression.type : super.isOptionalMemberExpression(e);
          }
          hasPropertyAsPrivateName(e) {
           return 'ChainExpression' === e.type && (e = e.expression), super.hasPropertyAsPrivateName(e);
          }
          isObjectProperty(e) {
           return 'Property' === e.type && 'init' === e.kind && !e.method;
          }
          isObjectMethod(e) {
           return 'Property' === e.type && (e.method || 'get' === e.kind || 'set' === e.kind);
          }
          finishNodeAt(e, t, r) {
           return x(super.finishNodeAt(e, t, r));
          }
          resetStartLocation(e, t) {
           super.resetStartLocation(e, t), x(e);
          }
          resetEndLocation(e, t = this.state.lastTokEndLoc) {
           super.resetEndLocation(e, t), x(e);
          }
         },
        jsx: (e) =>
         class extends e {
          jsxReadToken() {
           let e = '',
            t = this.state.pos;
           for (;;) {
            if (this.state.pos >= this.length) throw this.raise(ct.UnterminatedJsxContent, this.state.startLoc);
            let r = this.input.charCodeAt(this.state.pos);
            switch (r) {
             case 60:
             case 123:
              return this.state.pos === this.state.start ? void (60 === r && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(143)) : super.getTokenFromCode(r)) : ((e += this.input.slice(t, this.state.pos)), void this.finishToken(142, e));
             case 38:
              (e += this.input.slice(t, this.state.pos)), (e += this.jsxReadEntity()), (t = this.state.pos);
              break;
             default:
              Fe(r) ? ((e += this.input.slice(t, this.state.pos)), (e += this.jsxReadNewLine(!0)), (t = this.state.pos)) : ++this.state.pos;
            }
           }
          }
          jsxReadNewLine(e) {
           let t,
            r = this.input.charCodeAt(this.state.pos);
           return ++this.state.pos, 13 === r && 10 === this.input.charCodeAt(this.state.pos) ? (++this.state.pos, (t = e ? '\n' : '\r\n')) : (t = String.fromCharCode(r)), ++this.state.curLine, (this.state.lineStart = this.state.pos), t;
          }
          jsxReadString(e) {
           let t = '',
            r = ++this.state.pos;
           for (;;) {
            if (this.state.pos >= this.length) throw this.raise(y.UnterminatedString, this.state.startLoc);
            let s = this.input.charCodeAt(this.state.pos);
            if (s === e) break;
            38 === s ? ((t += this.input.slice(r, this.state.pos)), (t += this.jsxReadEntity()), (r = this.state.pos)) : Fe(s) ? ((t += this.input.slice(r, this.state.pos)), (t += this.jsxReadNewLine(!1)), (r = this.state.pos)) : ++this.state.pos;
           }
           (t += this.input.slice(r, this.state.pos++)), this.finishToken(134, t);
          }
          jsxReadEntity() {
           let e = ++this.state.pos;
           if (35 === this.codePointAtPos(this.state.pos)) {
            ++this.state.pos;
            let e = 10;
            120 === this.codePointAtPos(this.state.pos) && ((e = 16), ++this.state.pos);
            let t = this.readInt(e, void 0, !1, 'bail');
            if (null !== t && 59 === this.codePointAtPos(this.state.pos)) return ++this.state.pos, String.fromCodePoint(t);
           } else {
            let t = 0,
             r = !1;
            for (; t++ < 10 && this.state.pos < this.length && !(r = 59 === this.codePointAtPos(this.state.pos)); ) ++this.state.pos;
            if (r) {
             let t;
             if ((this.input.slice(e, this.state.pos), ++this.state.pos, t)) return t;
            }
           }
           return (this.state.pos = e), '&';
          }
          jsxReadWord() {
           let e,
            t = this.state.pos;
           do {
            e = this.input.charCodeAt(++this.state.pos);
           } while (ie(e) || 45 === e);
           this.finishToken(141, this.input.slice(t, this.state.pos));
          }
          jsxParseIdentifier() {
           let e = this.startNode();
           return this.match(141) ? (e.name = this.state.value) : V(this.state.type) ? (e.name = H(this.state.type)) : this.unexpected(), this.next(), this.finishNode(e, 'JSXIdentifier');
          }
          jsxParseNamespacedName() {
           let e = this.state.startLoc,
            t = this.jsxParseIdentifier();
           if (!this.eat(14)) return t;
           let r = this.startNodeAt(e);
           return (r.namespace = t), (r.name = this.jsxParseIdentifier()), this.finishNode(r, 'JSXNamespacedName');
          }
          jsxParseElementName() {
           let e = this.state.startLoc,
            t = this.jsxParseNamespacedName();
           if ('JSXNamespacedName' === t.type) return t;
           for (; this.eat(16); ) {
            let r = this.startNodeAt(e);
            (r.object = t), (r.property = this.jsxParseIdentifier()), (t = this.finishNode(r, 'JSXMemberExpression'));
           }
           return t;
          }
          jsxParseAttributeValue() {
           let e;
           switch (this.state.type) {
            case 5:
             return (e = this.startNode()), this.setContext(b.brace), this.next(), (e = this.jsxParseExpressionContainer(e, b.j_oTag)), 'JSXEmptyExpression' === e.expression.type && this.raise(ct.AttributeIsEmpty, e), e;
            case 143:
            case 134:
             return this.parseExprAtom();
            default:
             throw this.raise(ct.UnsupportedJsxValue, this.state.startLoc);
           }
          }
          jsxParseEmptyExpression() {
           let e = this.startNodeAt(this.state.lastTokEndLoc);
           return this.finishNodeAt(e, 'JSXEmptyExpression', this.state.startLoc);
          }
          jsxParseSpreadChild(e) {
           return this.next(), (e.expression = this.parseExpression()), this.setContext(b.j_expr), (this.state.canStartJSXElement = !0), this.expect(8), this.finishNode(e, 'JSXSpreadChild');
          }
          jsxParseExpressionContainer(e, t) {
           if (this.match(8)) e.expression = this.jsxParseEmptyExpression();
           else {
            let t = this.parseExpression();
            e.expression = t;
           }
           return this.setContext(t), (this.state.canStartJSXElement = !0), this.expect(8), this.finishNode(e, 'JSXExpressionContainer');
          }
          jsxParseAttribute() {
           let e = this.startNode();
           return this.match(5) ? (this.setContext(b.brace), this.next(), this.expect(21), (e.argument = this.parseMaybeAssignAllowIn()), this.setContext(b.j_oTag), (this.state.canStartJSXElement = !0), this.expect(8), this.finishNode(e, 'JSXSpreadAttribute')) : ((e.name = this.jsxParseNamespacedName()), (e.value = this.eat(29) ? this.jsxParseAttributeValue() : null), this.finishNode(e, 'JSXAttribute'));
          }
          jsxParseOpeningElementAt(e) {
           let t = this.startNodeAt(e);
           return this.eat(144) ? this.finishNode(t, 'JSXOpeningFragment') : ((t.name = this.jsxParseElementName()), this.jsxParseOpeningElementAfterName(t));
          }
          jsxParseOpeningElementAfterName(e) {
           let t = [];
           for (; !this.match(56) && !this.match(144); ) t.push(this.jsxParseAttribute());
           return (e.attributes = t), (e.selfClosing = this.eat(56)), this.expect(144), this.finishNode(e, 'JSXOpeningElement');
          }
          jsxParseClosingElementAt(e) {
           let t = this.startNodeAt(e);
           return this.eat(144) ? this.finishNode(t, 'JSXClosingFragment') : ((t.name = this.jsxParseElementName()), this.expect(144), this.finishNode(t, 'JSXClosingElement'));
          }
          jsxParseElementAt(e) {
           let t = this.startNodeAt(e),
            r = [],
            s = this.jsxParseOpeningElementAt(e),
            n = null;
           if (!s.selfClosing) {
            e: for (;;)
             switch (this.state.type) {
              case 143:
               if (((e = this.state.startLoc), this.next(), this.eat(56))) {
                n = this.jsxParseClosingElementAt(e);
                break e;
               }
               r.push(this.jsxParseElementAt(e));
               break;
              case 142:
               r.push(this.parseLiteral(this.state.value, 'JSXText'));
               break;
              case 5: {
               let e = this.startNode();
               this.setContext(b.brace), this.next(), this.match(21) ? r.push(this.jsxParseSpreadChild(e)) : r.push(this.jsxParseExpressionContainer(e, b.j_expr));
               break;
              }
              default:
               this.unexpected();
             }
            ht(s) && !ht(n) && null !== n ? this.raise(ct.MissingClosingTagFragment, n) : ((!ht(s) && ht(n)) || (!ht(s) && !ht(n) && dt(n.name) !== dt(s.name))) && this.raise(ct.MissingClosingTagElement, n, { openingTagName: dt(s.name) });
           }
           if ((ht(s) ? ((t.openingFragment = s), (t.closingFragment = n)) : ((t.openingElement = s), (t.closingElement = n)), (t.children = r), this.match(47))) throw this.raise(ct.UnwrappedAdjacentJSXElements, this.state.startLoc);
           return ht(s) ? this.finishNode(t, 'JSXFragment') : this.finishNode(t, 'JSXElement');
          }
          jsxParseElement() {
           let e = this.state.startLoc;
           return this.next(), this.jsxParseElementAt(e);
          }
          setContext(e) {
           let { context: t } = this.state;
           t[t.length - 1] = e;
          }
          parseExprAtom(e) {
           return this.match(143) ? this.jsxParseElement() : this.match(47) && 33 !== this.input.charCodeAt(this.state.pos) ? (this.replaceToken(143), this.jsxParseElement()) : super.parseExprAtom(e);
          }
          skipSpace() {
           this.curContext().preserveSpace || super.skipSpace();
          }
          getTokenFromCode(e) {
           let t = this.curContext();
           if (t !== b.j_expr) {
            if (t === b.j_oTag || t === b.j_cTag) {
             if (ne(e)) return void this.jsxReadWord();
             if (62 === e) return ++this.state.pos, void this.finishToken(144);
             if ((34 === e || 39 === e) && t === b.j_oTag) return void this.jsxReadString(e);
            }
            if (60 === e && this.state.canStartJSXElement && 33 !== this.input.charCodeAt(this.state.pos + 1)) return ++this.state.pos, void this.finishToken(143);
            super.getTokenFromCode(e);
           } else this.jsxReadToken();
          }
          updateContext(e) {
           let { context: t, type: r } = this.state;
           if (56 === r && 143 === e) t.splice(-2, 2, b.j_cTag), (this.state.canStartJSXElement = !1);
           else if (143 === r) t.push(b.j_oTag);
           else if (144 === r) {
            let r = t[t.length - 1];
            (r === b.j_oTag && 56 === e) || r === b.j_cTag ? (t.pop(), (this.state.canStartJSXElement = t[t.length - 1] === b.j_expr)) : (this.setContext(b.j_expr), (this.state.canStartJSXElement = !0));
           } else
            this.state.canStartJSXElement = (function (e) {
             return L[e];
            })(r);
          }
         },
        flow: (e) =>
         class extends e {
          constructor(...e) {
           super(...e), (this.flowPragma = void 0);
          }
          getScopeHandler() {
           return xe;
          }
          shouldParseTypes() {
           return this.getPluginOption('flow', 'all') || 'flow' === this.flowPragma;
          }
          finishToken(e, t) {
           134 !== e && 13 !== e && 28 !== e && void 0 === this.flowPragma && (this.flowPragma = null), super.finishToken(e, t);
          }
          addComment(e) {
           if (void 0 === this.flowPragma) {
            let t = pt.exec(e.value);
            if (t)
             if ('flow' === t[1]) this.flowPragma = 'flow';
             else {
              if ('noflow' !== t[1]) throw new Error('Unexpected flow pragma');
              this.flowPragma = 'noflow';
             }
           }
           super.addComment(e);
          }
          flowParseTypeInitialiser(e) {
           let t = this.state.inType;
           (this.state.inType = !0), this.expect(e || 14);
           let r = this.flowParseType();
           return (this.state.inType = t), r;
          }
          flowParsePredicate() {
           let e = this.startNode(),
            t = this.state.startLoc;
           return this.next(), this.expectContextual(110), this.state.lastTokStartLoc.index > t.index + 1 && this.raise(ot.UnexpectedSpaceBetweenModuloChecks, t), this.eat(10) ? ((e.value = super.parseExpression()), this.expect(11), this.finishNode(e, 'DeclaredPredicate')) : this.finishNode(e, 'InferredPredicate');
          }
          flowParseTypeAndPredicateInitialiser() {
           let e = this.state.inType;
           (this.state.inType = !0), this.expect(14);
           let t = null,
            r = null;
           return this.match(54) ? ((this.state.inType = e), (r = this.flowParsePredicate())) : ((t = this.flowParseType()), (this.state.inType = e), this.match(54) && (r = this.flowParsePredicate())), [t, r];
          }
          flowParseDeclareClass(e) {
           return this.next(), this.flowParseInterfaceish(e, !0), this.finishNode(e, 'DeclareClass');
          }
          flowParseDeclareFunction(e) {
           this.next();
           let t = (e.id = this.parseIdentifier()),
            r = this.startNode(),
            s = this.startNode();
           this.match(47) ? (r.typeParameters = this.flowParseTypeParameterDeclaration()) : (r.typeParameters = null), this.expect(10);
           let n = this.flowParseFunctionTypeParams();
           return (r.params = n.params), (r.rest = n.rest), (r.this = n._this), this.expect(11), ([r.returnType, e.predicate] = this.flowParseTypeAndPredicateInitialiser()), (s.typeAnnotation = this.finishNode(r, 'FunctionTypeAnnotation')), (t.typeAnnotation = this.finishNode(s, 'TypeAnnotation')), this.resetEndLocation(t), this.semicolon(), this.scope.declareName(e.id.name, 2048, e.id.loc.start), this.finishNode(e, 'DeclareFunction');
          }
          flowParseDeclare(e, t) {
           return this.match(80) ? this.flowParseDeclareClass(e) : this.match(68) ? this.flowParseDeclareFunction(e) : this.match(74) ? this.flowParseDeclareVariable(e) : this.eatContextual(127) ? (this.match(16) ? this.flowParseDeclareModuleExports(e) : (t && this.raise(ot.NestedDeclareModule, this.state.lastTokStartLoc), this.flowParseDeclareModule(e))) : this.isContextual(130) ? this.flowParseDeclareTypeAlias(e) : this.isContextual(131) ? this.flowParseDeclareOpaqueType(e) : this.isContextual(129) ? this.flowParseDeclareInterface(e) : this.match(82) ? this.flowParseDeclareExportDeclaration(e, t) : void this.unexpected();
          }
          flowParseDeclareVariable(e) {
           return this.next(), (e.id = this.flowParseTypeAnnotatableIdentifier(!0)), this.scope.declareName(e.id.name, 5, e.id.loc.start), this.semicolon(), this.finishNode(e, 'DeclareVariable');
          }
          flowParseDeclareModule(e) {
           this.scope.enter(0), this.match(134) ? (e.id = super.parseExprAtom()) : (e.id = this.parseIdentifier());
           let t = (e.body = this.startNode()),
            r = (t.body = []);
           for (this.expect(5); !this.match(8); ) {
            let e = this.startNode();
            this.match(83) ? (this.next(), !this.isContextual(130) && !this.match(87) && this.raise(ot.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc), super.parseImport(e)) : (this.expectContextual(125, ot.UnsupportedStatementInDeclareModule), (e = this.flowParseDeclare(e, !0))), r.push(e);
           }
           this.scope.exit(), this.expect(8), this.finishNode(t, 'BlockStatement');
           let s = null,
            n = !1;
           return (
            r.forEach((e) => {
             !(function (e) {
              return 'DeclareExportAllDeclaration' === e.type || ('DeclareExportDeclaration' === e.type && (!e.declaration || ('TypeAlias' !== e.declaration.type && 'InterfaceDeclaration' !== e.declaration.type)));
             })(e)
              ? 'DeclareModuleExports' === e.type && (n && this.raise(ot.DuplicateDeclareModuleExports, e), 'ES' === s && this.raise(ot.AmbiguousDeclareModuleKind, e), (s = 'CommonJS'), (n = !0))
              : ('CommonJS' === s && this.raise(ot.AmbiguousDeclareModuleKind, e), (s = 'ES'));
            }),
            (e.kind = s || 'CommonJS'),
            this.finishNode(e, 'DeclareModule')
           );
          }
          flowParseDeclareExportDeclaration(e, t) {
           if ((this.expect(82), this.eat(65))) return this.match(68) || this.match(80) ? (e.declaration = this.flowParseDeclare(this.startNode())) : ((e.declaration = this.flowParseType()), this.semicolon()), (e.default = !0), this.finishNode(e, 'DeclareExportDeclaration');
           if (this.match(75) || this.isLet() || ((this.isContextual(130) || this.isContextual(129)) && !t)) {
            let e = this.state.value;
            throw this.raise(ot.UnsupportedDeclareExportKind, this.state.startLoc, { unsupportedExportKind: e, suggestion: lt[e] });
           }
           return this.match(74) || this.match(68) || this.match(80) || this.isContextual(131) ? ((e.declaration = this.flowParseDeclare(this.startNode())), (e.default = !1), this.finishNode(e, 'DeclareExportDeclaration')) : this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131) ? ('ExportNamedDeclaration' === (e = this.parseExport(e, null)).type && ((e.type = 'ExportDeclaration'), (e.default = !1), delete e.exportKind), (e.type = 'Declare' + e.type), e) : void this.unexpected();
          }
          flowParseDeclareModuleExports(e) {
           return this.next(), this.expectContextual(111), (e.typeAnnotation = this.flowParseTypeAnnotation()), this.semicolon(), this.finishNode(e, 'DeclareModuleExports');
          }
          flowParseDeclareTypeAlias(e) {
           this.next();
           let t = this.flowParseTypeAlias(e);
           return (t.type = 'DeclareTypeAlias'), t;
          }
          flowParseDeclareOpaqueType(e) {
           this.next();
           let t = this.flowParseOpaqueType(e, !0);
           return (t.type = 'DeclareOpaqueType'), t;
          }
          flowParseDeclareInterface(e) {
           return this.next(), this.flowParseInterfaceish(e, !1), this.finishNode(e, 'DeclareInterface');
          }
          flowParseInterfaceish(e, t) {
           if (((e.id = this.flowParseRestrictedIdentifier(!t, !0)), this.scope.declareName(e.id.name, t ? 17 : 8201, e.id.loc.start), this.match(47) ? (e.typeParameters = this.flowParseTypeParameterDeclaration()) : (e.typeParameters = null), (e.extends = []), this.eat(81)))
            do {
             e.extends.push(this.flowParseInterfaceExtends());
            } while (!t && this.eat(12));
           if (t) {
            if (((e.implements = []), (e.mixins = []), this.eatContextual(117)))
             do {
              e.mixins.push(this.flowParseInterfaceExtends());
             } while (this.eat(12));
            if (this.eatContextual(113))
             do {
              e.implements.push(this.flowParseInterfaceExtends());
             } while (this.eat(12));
           }
           e.body = this.flowParseObjectType({ allowStatic: t, allowExact: !1, allowSpread: !1, allowProto: t, allowInexact: !1 });
          }
          flowParseInterfaceExtends() {
           let e = this.startNode();
           return (e.id = this.flowParseQualifiedTypeIdentifier()), this.match(47) ? (e.typeParameters = this.flowParseTypeParameterInstantiation()) : (e.typeParameters = null), this.finishNode(e, 'InterfaceExtends');
          }
          flowParseInterface(e) {
           return this.flowParseInterfaceish(e, !1), this.finishNode(e, 'InterfaceDeclaration');
          }
          checkNotUnderscore(e) {
           '_' === e && this.raise(ot.UnexpectedReservedUnderscore, this.state.startLoc);
          }
          checkReservedType(e, t, r) {
           at.has(e) && this.raise(r ? ot.AssignReservedType : ot.UnexpectedReservedType, t, { reservedType: e });
          }
          flowParseRestrictedIdentifier(e, t) {
           return this.checkReservedType(this.state.value, this.state.startLoc, t), this.parseIdentifier(e);
          }
          flowParseTypeAlias(e) {
           return (e.id = this.flowParseRestrictedIdentifier(!1, !0)), this.scope.declareName(e.id.name, 8201, e.id.loc.start), this.match(47) ? (e.typeParameters = this.flowParseTypeParameterDeclaration()) : (e.typeParameters = null), (e.right = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(e, 'TypeAlias');
          }
          flowParseOpaqueType(e, t) {
           return this.expectContextual(130), (e.id = this.flowParseRestrictedIdentifier(!0, !0)), this.scope.declareName(e.id.name, 8201, e.id.loc.start), this.match(47) ? (e.typeParameters = this.flowParseTypeParameterDeclaration()) : (e.typeParameters = null), (e.supertype = null), this.match(14) && (e.supertype = this.flowParseTypeInitialiser(14)), (e.impltype = null), t || (e.impltype = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(e, 'OpaqueType');
          }
          flowParseTypeParameter(e = !1) {
           let t = this.state.startLoc,
            r = this.startNode(),
            s = this.flowParseVariance(),
            n = this.flowParseTypeAnnotatableIdentifier();
           return (r.name = n.name), (r.variance = s), (r.bound = n.typeAnnotation), this.match(29) ? (this.eat(29), (r.default = this.flowParseType())) : e && this.raise(ot.MissingTypeParamDefault, t), this.finishNode(r, 'TypeParameter');
          }
          flowParseTypeParameterDeclaration() {
           let e = this.state.inType,
            t = this.startNode();
           (t.params = []), (this.state.inType = !0), this.match(47) || this.match(143) ? this.next() : this.unexpected();
           let r = !1;
           do {
            let e = this.flowParseTypeParameter(r);
            t.params.push(e), e.default && (r = !0), this.match(48) || this.expect(12);
           } while (!this.match(48));
           return this.expect(48), (this.state.inType = e), this.finishNode(t, 'TypeParameterDeclaration');
          }
          flowInTopLevelContext(e) {
           if (this.curContext() === b.brace) return e();
           {
            let t = this.state.context;
            this.state.context = [t[0]];
            try {
             return e();
            } finally {
             this.state.context = t;
            }
           }
          }
          flowParseTypeParameterInstantiationInExpression() {
           if (47 === this.reScan_lt()) return this.flowParseTypeParameterInstantiation();
          }
          flowParseTypeParameterInstantiation() {
           let e = this.startNode(),
            t = this.state.inType;
           return (
            (this.state.inType = !0),
            (e.params = []),
            this.flowInTopLevelContext(() => {
             this.expect(47);
             let t = this.state.noAnonFunctionType;
             for (this.state.noAnonFunctionType = !1; !this.match(48); ) e.params.push(this.flowParseType()), this.match(48) || this.expect(12);
             this.state.noAnonFunctionType = t;
            }),
            (this.state.inType = t),
            !this.state.inType && this.curContext() === b.brace && this.reScan_lt_gt(),
            this.expect(48),
            this.finishNode(e, 'TypeParameterInstantiation')
           );
          }
          flowParseTypeParameterInstantiationCallOrNew() {
           if (47 !== this.reScan_lt()) return;
           let e = this.startNode(),
            t = this.state.inType;
           for (e.params = [], this.state.inType = !0, this.expect(47); !this.match(48); ) e.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
           return this.expect(48), (this.state.inType = t), this.finishNode(e, 'TypeParameterInstantiation');
          }
          flowParseInterfaceType() {
           let e = this.startNode();
           if ((this.expectContextual(129), (e.extends = []), this.eat(81)))
            do {
             e.extends.push(this.flowParseInterfaceExtends());
            } while (this.eat(12));
           return (e.body = this.flowParseObjectType({ allowStatic: !1, allowExact: !1, allowSpread: !1, allowProto: !1, allowInexact: !1 })), this.finishNode(e, 'InterfaceTypeAnnotation');
          }
          flowParseObjectPropertyKey() {
           return this.match(135) || this.match(134) ? super.parseExprAtom() : this.parseIdentifier(!0);
          }
          flowParseObjectTypeIndexer(e, t, r) {
           return (e.static = t), 14 === this.lookahead().type ? ((e.id = this.flowParseObjectPropertyKey()), (e.key = this.flowParseTypeInitialiser())) : ((e.id = null), (e.key = this.flowParseType())), this.expect(3), (e.value = this.flowParseTypeInitialiser()), (e.variance = r), this.finishNode(e, 'ObjectTypeIndexer');
          }
          flowParseObjectTypeInternalSlot(e, t) {
           return (e.static = t), (e.id = this.flowParseObjectPropertyKey()), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? ((e.method = !0), (e.optional = !1), (e.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e.loc.start)))) : ((e.method = !1), this.eat(17) && (e.optional = !0), (e.value = this.flowParseTypeInitialiser())), this.finishNode(e, 'ObjectTypeInternalSlot');
          }
          flowParseObjectTypeMethodish(e) {
           for (e.params = [], e.rest = null, e.typeParameters = null, e.this = null, this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), this.match(78) && ((e.this = this.flowParseFunctionTypeParam(!0)), (e.this.name = null), this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); ) e.params.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
           return this.eat(21) && (e.rest = this.flowParseFunctionTypeParam(!1)), this.expect(11), (e.returnType = this.flowParseTypeInitialiser()), this.finishNode(e, 'FunctionTypeAnnotation');
          }
          flowParseObjectTypeCallProperty(e, t) {
           let r = this.startNode();
           return (e.static = t), (e.value = this.flowParseObjectTypeMethodish(r)), this.finishNode(e, 'ObjectTypeCallProperty');
          }
          flowParseObjectType({ allowStatic: e, allowExact: t, allowSpread: r, allowProto: s, allowInexact: n }) {
           let i = this.state.inType;
           this.state.inType = !0;
           let a = this.startNode();
           (a.callProperties = []), (a.properties = []), (a.indexers = []), (a.internalSlots = []);
           let o,
            u,
            l = !1;
           for (t && this.match(6) ? (this.expect(6), (o = 9), (u = !0)) : (this.expect(5), (o = 8), (u = !1)), a.exact = u; !this.match(o); ) {
            let t = !1,
             i = null,
             o = null,
             p = this.startNode();
            if (s && this.isContextual(118)) {
             let t = this.lookahead();
             14 !== t.type && 17 !== t.type && (this.next(), (i = this.state.startLoc), (e = !1));
            }
            if (e && this.isContextual(106)) {
             let e = this.lookahead();
             14 !== e.type && 17 !== e.type && (this.next(), (t = !0));
            }
            let c = this.flowParseVariance();
            if (this.eat(0)) null != i && this.unexpected(i), this.eat(0) ? (c && this.unexpected(c.loc.start), a.internalSlots.push(this.flowParseObjectTypeInternalSlot(p, t))) : a.indexers.push(this.flowParseObjectTypeIndexer(p, t, c));
            else if (this.match(10) || this.match(47)) null != i && this.unexpected(i), c && this.unexpected(c.loc.start), a.callProperties.push(this.flowParseObjectTypeCallProperty(p, t));
            else {
             let e = 'init';
             (this.isContextual(99) || this.isContextual(104)) && J(this.lookahead().type) && ((e = this.state.value), this.next());
             let s = this.flowParseObjectTypeProperty(p, t, i, c, e, r, n ?? !u);
             null === s ? ((l = !0), (o = this.state.lastTokStartLoc)) : a.properties.push(s);
            }
            this.flowObjectTypeSemicolon(), o && !this.match(8) && !this.match(9) && this.raise(ot.UnexpectedExplicitInexactInObject, o);
           }
           this.expect(o), r && (a.inexact = l);
           let p = this.finishNode(a, 'ObjectTypeAnnotation');
           return (this.state.inType = i), p;
          }
          flowParseObjectTypeProperty(e, t, r, s, n, i, a) {
           if (this.eat(21)) return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (i ? a || this.raise(ot.InexactInsideExact, this.state.lastTokStartLoc) : this.raise(ot.InexactInsideNonObject, this.state.lastTokStartLoc), s && this.raise(ot.InexactVariance, s), null) : (i || this.raise(ot.UnexpectedSpreadType, this.state.lastTokStartLoc), null != r && this.unexpected(r), s && this.raise(ot.SpreadVariance, s), (e.argument = this.flowParseType()), this.finishNode(e, 'ObjectTypeSpreadProperty'));
           {
            (e.key = this.flowParseObjectPropertyKey()), (e.static = t), (e.proto = null != r), (e.kind = n);
            let a = !1;
            return this.match(47) || this.match(10) ? ((e.method = !0), null != r && this.unexpected(r), s && this.unexpected(s.loc.start), (e.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e.loc.start))), ('get' === n || 'set' === n) && this.flowCheckGetterSetterParams(e), !i && 'constructor' === e.key.name && e.value.this && this.raise(ot.ThisParamBannedInConstructor, e.value.this)) : ('init' !== n && this.unexpected(), (e.method = !1), this.eat(17) && (a = !0), (e.value = this.flowParseTypeInitialiser()), (e.variance = s)), (e.optional = a), this.finishNode(e, 'ObjectTypeProperty');
           }
          }
          flowCheckGetterSetterParams(e) {
           let t = 'get' === e.kind ? 0 : 1,
            r = e.value.params.length + (e.value.rest ? 1 : 0);
           e.value.this && this.raise('get' === e.kind ? ot.GetterMayNotHaveThisParam : ot.SetterMayNotHaveThisParam, e.value.this), r !== t && this.raise('get' === e.kind ? y.BadGetterArity : y.BadSetterArity, e), 'set' === e.kind && e.value.rest && this.raise(y.BadSetterRestParameter, e);
          }
          flowObjectTypeSemicolon() {
           !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
          }
          flowParseQualifiedTypeIdentifier(e, t) {
           null != e || (e = this.state.startLoc);
           let r = t || this.flowParseRestrictedIdentifier(!0);
           for (; this.eat(16); ) {
            let t = this.startNodeAt(e);
            (t.qualification = r), (t.id = this.flowParseRestrictedIdentifier(!0)), (r = this.finishNode(t, 'QualifiedTypeIdentifier'));
           }
           return r;
          }
          flowParseGenericType(e, t) {
           let r = this.startNodeAt(e);
           return (r.typeParameters = null), (r.id = this.flowParseQualifiedTypeIdentifier(e, t)), this.match(47) && (r.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(r, 'GenericTypeAnnotation');
          }
          flowParseTypeofType() {
           let e = this.startNode();
           return this.expect(87), (e.argument = this.flowParsePrimaryType()), this.finishNode(e, 'TypeofTypeAnnotation');
          }
          flowParseTupleType() {
           let e = this.startNode();
           for (e.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (e.types.push(this.flowParseType()), !this.match(3)); ) this.expect(12);
           return this.expect(3), this.finishNode(e, 'TupleTypeAnnotation');
          }
          flowParseFunctionTypeParam(e) {
           let t = null,
            r = !1,
            s = null,
            n = this.startNode(),
            i = this.lookahead(),
            a = 78 === this.state.type;
           return 14 === i.type || 17 === i.type ? (a && !e && this.raise(ot.ThisParamMustBeFirst, n), (t = this.parseIdentifier(a)), this.eat(17) && ((r = !0), a && this.raise(ot.ThisParamMayNotBeOptional, n)), (s = this.flowParseTypeInitialiser())) : (s = this.flowParseType()), (n.name = t), (n.optional = r), (n.typeAnnotation = s), this.finishNode(n, 'FunctionTypeParam');
          }
          reinterpretTypeAsFunctionTypeParam(e) {
           let t = this.startNodeAt(e.loc.start);
           return (t.name = null), (t.optional = !1), (t.typeAnnotation = e), this.finishNode(t, 'FunctionTypeParam');
          }
          flowParseFunctionTypeParams(e = []) {
           let t = null,
            r = null;
           for (this.match(78) && ((r = this.flowParseFunctionTypeParam(!0)), (r.name = null), this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); ) e.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
           return this.eat(21) && (t = this.flowParseFunctionTypeParam(!1)), { params: e, rest: t, _this: r };
          }
          flowIdentToTypeAnnotation(e, t, r) {
           switch (r.name) {
            case 'any':
             return this.finishNode(t, 'AnyTypeAnnotation');
            case 'bool':
            case 'boolean':
             return this.finishNode(t, 'BooleanTypeAnnotation');
            case 'mixed':
             return this.finishNode(t, 'MixedTypeAnnotation');
            case 'empty':
             return this.finishNode(t, 'EmptyTypeAnnotation');
            case 'number':
             return this.finishNode(t, 'NumberTypeAnnotation');
            case 'string':
             return this.finishNode(t, 'StringTypeAnnotation');
            case 'symbol':
             return this.finishNode(t, 'SymbolTypeAnnotation');
            default:
             return this.checkNotUnderscore(r.name), this.flowParseGenericType(e, r);
           }
          }
          flowParsePrimaryType() {
           let e,
            t,
            r = this.state.startLoc,
            s = this.startNode(),
            n = !1,
            i = this.state.noAnonFunctionType;
           switch (this.state.type) {
            case 5:
             return this.flowParseObjectType({ allowStatic: !1, allowExact: !1, allowSpread: !0, allowProto: !1, allowInexact: !0 });
            case 6:
             return this.flowParseObjectType({ allowStatic: !1, allowExact: !0, allowSpread: !0, allowProto: !1, allowInexact: !1 });
            case 0:
             return (this.state.noAnonFunctionType = !1), (t = this.flowParseTupleType()), (this.state.noAnonFunctionType = i), t;
            case 47: {
             let t = this.startNode();
             return (t.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), (e = this.flowParseFunctionTypeParams()), (t.params = e.params), (t.rest = e.rest), (t.this = e._this), this.expect(11), this.expect(19), (t.returnType = this.flowParseType()), this.finishNode(t, 'FunctionTypeAnnotation');
            }
            case 10: {
             let r = this.startNode();
             if ((this.next(), !this.match(11) && !this.match(21)))
              if ($(this.state.type) || this.match(78)) {
               let e = this.lookahead().type;
               n = 17 !== e && 14 !== e;
              } else n = !0;
             if (n) {
              if (((this.state.noAnonFunctionType = !1), (t = this.flowParseType()), (this.state.noAnonFunctionType = i), this.state.noAnonFunctionType || !(this.match(12) || (this.match(11) && 19 === this.lookahead().type)))) return this.expect(11), t;
              this.eat(12);
             }
             return (e = t ? this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(t)]) : this.flowParseFunctionTypeParams()), (r.params = e.params), (r.rest = e.rest), (r.this = e._this), this.expect(11), this.expect(19), (r.returnType = this.flowParseType()), (r.typeParameters = null), this.finishNode(r, 'FunctionTypeAnnotation');
            }
            case 134:
             return this.parseLiteral(this.state.value, 'StringLiteralTypeAnnotation');
            case 85:
            case 86:
             return (s.value = this.match(85)), this.next(), this.finishNode(s, 'BooleanLiteralTypeAnnotation');
            case 53:
             if ('-' === this.state.value) {
              if ((this.next(), this.match(135))) return this.parseLiteralAtNode(-this.state.value, 'NumberLiteralTypeAnnotation', s);
              if (this.match(136)) return this.parseLiteralAtNode(-this.state.value, 'BigIntLiteralTypeAnnotation', s);
              throw this.raise(ot.UnexpectedSubtractionOperand, this.state.startLoc);
             }
             return void this.unexpected();
            case 135:
             return this.parseLiteral(this.state.value, 'NumberLiteralTypeAnnotation');
            case 136:
             return this.parseLiteral(this.state.value, 'BigIntLiteralTypeAnnotation');
            case 88:
             return this.next(), this.finishNode(s, 'VoidTypeAnnotation');
            case 84:
             return this.next(), this.finishNode(s, 'NullLiteralTypeAnnotation');
            case 78:
             return this.next(), this.finishNode(s, 'ThisTypeAnnotation');
            case 55:
             return this.next(), this.finishNode(s, 'ExistsTypeAnnotation');
            case 87:
             return this.flowParseTypeofType();
            default:
             if (V(this.state.type)) {
              let e = H(this.state.type);
              return this.next(), super.createIdentifier(s, e);
             }
             if ($(this.state.type)) return this.isContextual(129) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(r, s, this.parseIdentifier());
           }
           this.unexpected();
          }
          flowParsePostfixType() {
           let e = this.state.startLoc,
            t = this.flowParsePrimaryType(),
            r = !1;
           for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
            let s = this.startNodeAt(e),
             n = this.eat(18);
            (r = r || n), this.expect(0), !n && this.match(3) ? ((s.elementType = t), this.next(), (t = this.finishNode(s, 'ArrayTypeAnnotation'))) : ((s.objectType = t), (s.indexType = this.flowParseType()), this.expect(3), r ? ((s.optional = n), (t = this.finishNode(s, 'OptionalIndexedAccessType'))) : (t = this.finishNode(s, 'IndexedAccessType')));
           }
           return t;
          }
          flowParsePrefixType() {
           let e = this.startNode();
           return this.eat(17) ? ((e.typeAnnotation = this.flowParsePrefixType()), this.finishNode(e, 'NullableTypeAnnotation')) : this.flowParsePostfixType();
          }
          flowParseAnonFunctionWithoutParens() {
           let e = this.flowParsePrefixType();
           if (!this.state.noAnonFunctionType && this.eat(19)) {
            let t = this.startNodeAt(e.loc.start);
            return (t.params = [this.reinterpretTypeAsFunctionTypeParam(e)]), (t.rest = null), (t.this = null), (t.returnType = this.flowParseType()), (t.typeParameters = null), this.finishNode(t, 'FunctionTypeAnnotation');
           }
           return e;
          }
          flowParseIntersectionType() {
           let e = this.startNode();
           this.eat(45);
           let t = this.flowParseAnonFunctionWithoutParens();
           for (e.types = [t]; this.eat(45); ) e.types.push(this.flowParseAnonFunctionWithoutParens());
           return 1 === e.types.length ? t : this.finishNode(e, 'IntersectionTypeAnnotation');
          }
          flowParseUnionType() {
           let e = this.startNode();
           this.eat(43);
           let t = this.flowParseIntersectionType();
           for (e.types = [t]; this.eat(43); ) e.types.push(this.flowParseIntersectionType());
           return 1 === e.types.length ? t : this.finishNode(e, 'UnionTypeAnnotation');
          }
          flowParseType() {
           let e = this.state.inType;
           this.state.inType = !0;
           let t = this.flowParseUnionType();
           return (this.state.inType = e), t;
          }
          flowParseTypeOrImplicitInstantiation() {
           if (132 === this.state.type && '_' === this.state.value) {
            let e = this.state.startLoc,
             t = this.parseIdentifier();
            return this.flowParseGenericType(e, t);
           }
           return this.flowParseType();
          }
          flowParseTypeAnnotation() {
           let e = this.startNode();
           return (e.typeAnnotation = this.flowParseTypeInitialiser()), this.finishNode(e, 'TypeAnnotation');
          }
          flowParseTypeAnnotatableIdentifier(e) {
           let t = e ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
           return this.match(14) && ((t.typeAnnotation = this.flowParseTypeAnnotation()), this.resetEndLocation(t)), t;
          }
          typeCastToParameter(e) {
           return (e.expression.typeAnnotation = e.typeAnnotation), this.resetEndLocation(e.expression, e.typeAnnotation.loc.end), e.expression;
          }
          flowParseVariance() {
           let e = null;
           return this.match(53) ? ((e = this.startNode()), '+' === this.state.value ? (e.kind = 'plus') : (e.kind = 'minus'), this.next(), this.finishNode(e, 'Variance')) : e;
          }
          parseFunctionBody(e, t, r = !1) {
           t ? this.forwardNoArrowParamsConversionAt(e, () => super.parseFunctionBody(e, !0, r)) : super.parseFunctionBody(e, !1, r);
          }
          parseFunctionBodyAndFinish(e, t, r = !1) {
           if (this.match(14)) {
            let t = this.startNode();
            ([t.typeAnnotation, e.predicate] = this.flowParseTypeAndPredicateInitialiser()), (e.returnType = t.typeAnnotation ? this.finishNode(t, 'TypeAnnotation') : null);
           }
           return super.parseFunctionBodyAndFinish(e, t, r);
          }
          parseStatementLike(e) {
           if (this.state.strict && this.isContextual(129)) {
            if (q(this.lookahead().type)) {
             let e = this.startNode();
             return this.next(), this.flowParseInterface(e);
            }
           } else if (this.isContextual(126)) {
            let e = this.startNode();
            return this.next(), this.flowParseEnumDeclaration(e);
           }
           let t = super.parseStatementLike(e);
           return void 0 === this.flowPragma && !this.isValidDirective(t) && (this.flowPragma = null), t;
          }
          parseExpressionStatement(e, t, r) {
           if ('Identifier' === t.type)
            if ('declare' === t.name) {
             if (this.match(80) || $(this.state.type) || this.match(68) || this.match(74) || this.match(82)) return this.flowParseDeclare(e);
            } else if ($(this.state.type)) {
             if ('interface' === t.name) return this.flowParseInterface(e);
             if ('type' === t.name) return this.flowParseTypeAlias(e);
             if ('opaque' === t.name) return this.flowParseOpaqueType(e, !1);
            }
           return super.parseExpressionStatement(e, t, r);
          }
          shouldParseExportDeclaration() {
           let { type: e } = this.state;
           return 126 === e || z(e) ? !this.state.containsEsc : super.shouldParseExportDeclaration();
          }
          isExportDefaultSpecifier() {
           let { type: e } = this.state;
           return 126 === e || z(e) ? this.state.containsEsc : super.isExportDefaultSpecifier();
          }
          parseExportDefaultExpression() {
           if (this.isContextual(126)) {
            let e = this.startNode();
            return this.next(), this.flowParseEnumDeclaration(e);
           }
           return super.parseExportDefaultExpression();
          }
          parseConditional(e, t, r) {
           if (!this.match(17)) return e;
           if (this.state.maybeInArrowParameters) {
            let t = this.lookaheadCharCode();
            if (44 === t || 61 === t || 58 === t || 41 === t) return this.setOptionalParametersError(r), e;
           }
           this.expect(17);
           let s = this.state.clone(),
            n = this.state.noArrowAt,
            i = this.startNodeAt(t),
            { consequent: a, failed: o } = this.tryParseConditionalConsequent(),
            [u, l] = this.getArrowLikeExpressions(a);
           if (o || l.length > 0) {
            let e = [...n];
            if (l.length > 0) {
             (this.state = s), (this.state.noArrowAt = e);
             for (let t = 0; t < l.length; t++) e.push(l[t].start);
             ({ consequent: a, failed: o } = this.tryParseConditionalConsequent()), ([u, l] = this.getArrowLikeExpressions(a));
            }
            o && u.length > 1 && this.raise(ot.AmbiguousConditionalArrow, s.startLoc), o && 1 === u.length && ((this.state = s), e.push(u[0].start), (this.state.noArrowAt = e), ({ consequent: a, failed: o } = this.tryParseConditionalConsequent()));
           }
           return this.getArrowLikeExpressions(a, !0), (this.state.noArrowAt = n), this.expect(14), (i.test = e), (i.consequent = a), (i.alternate = this.forwardNoArrowParamsConversionAt(i, () => this.parseMaybeAssign(void 0, void 0))), this.finishNode(i, 'ConditionalExpression');
          }
          tryParseConditionalConsequent() {
           this.state.noArrowParamsConversionAt.push(this.state.start);
           let e = this.parseMaybeAssignAllowIn(),
            t = !this.match(14);
           return this.state.noArrowParamsConversionAt.pop(), { consequent: e, failed: t };
          }
          getArrowLikeExpressions(e, t) {
           let r = [e],
            s = [];
           for (; 0 !== r.length; ) {
            let e = r.pop();
            'ArrowFunctionExpression' === e.type && 'BlockStatement' !== e.body.type ? (e.typeParameters || !e.returnType ? this.finishArrowValidation(e) : s.push(e), r.push(e.body)) : 'ConditionalExpression' === e.type && (r.push(e.consequent), r.push(e.alternate));
           }
           return t
            ? (s.forEach((e) => this.finishArrowValidation(e)), [s, []])
            : (function (e, t) {
               let r = [],
                s = [];
               for (let n = 0; n < e.length; n++) (t(e[n], n, e) ? r : s).push(e[n]);
               return [r, s];
              })(s, (e) => e.params.every((e) => this.isAssignable(e, !0)));
          }
          finishArrowValidation(e) {
           var t;
           this.toAssignableList(e.params, null == (t = e.extra) ? void 0 : t.trailingCommaLoc, !1), this.scope.enter(6), super.checkParams(e, !1, !0), this.scope.exit();
          }
          forwardNoArrowParamsConversionAt(e, t) {
           let r;
           return this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(e.start)) ? (this.state.noArrowParamsConversionAt.push(this.state.start), (r = t()), this.state.noArrowParamsConversionAt.pop()) : (r = t()), r;
          }
          parseParenItem(e, t) {
           let r = super.parseParenItem(e, t);
           if ((this.eat(17) && ((r.optional = !0), this.resetEndLocation(e)), this.match(14))) {
            let e = this.startNodeAt(t);
            return (e.expression = r), (e.typeAnnotation = this.flowParseTypeAnnotation()), this.finishNode(e, 'TypeCastExpression');
           }
           return r;
          }
          assertModuleNodeAllowed(e) {
           ('ImportDeclaration' === e.type && ('type' === e.importKind || 'typeof' === e.importKind)) || ('ExportNamedDeclaration' === e.type && 'type' === e.exportKind) || ('ExportAllDeclaration' === e.type && 'type' === e.exportKind) || super.assertModuleNodeAllowed(e);
          }
          parseExportDeclaration(e) {
           if (this.isContextual(130)) {
            e.exportKind = 'type';
            let t = this.startNode();
            return this.next(), this.match(5) ? ((e.specifiers = this.parseExportSpecifiers(!0)), super.parseExportFrom(e), null) : this.flowParseTypeAlias(t);
           }
           if (this.isContextual(131)) {
            e.exportKind = 'type';
            let t = this.startNode();
            return this.next(), this.flowParseOpaqueType(t, !1);
           }
           if (this.isContextual(129)) {
            e.exportKind = 'type';
            let t = this.startNode();
            return this.next(), this.flowParseInterface(t);
           }
           if (this.isContextual(126)) {
            e.exportKind = 'value';
            let t = this.startNode();
            return this.next(), this.flowParseEnumDeclaration(t);
           }
           return super.parseExportDeclaration(e);
          }
          eatExportStar(e) {
           return !!super.eatExportStar(e) || (!(!this.isContextual(130) || 55 !== this.lookahead().type) && ((e.exportKind = 'type'), this.next(), this.next(), !0));
          }
          maybeParseExportNamespaceSpecifier(e) {
           let { startLoc: t } = this.state,
            r = super.maybeParseExportNamespaceSpecifier(e);
           return r && 'type' === e.exportKind && this.unexpected(t), r;
          }
          parseClassId(e, t, r) {
           super.parseClassId(e, t, r), this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration());
          }
          parseClassMember(e, t, r) {
           let { startLoc: s } = this.state;
           if (this.isContextual(125)) {
            if (super.parseClassMemberFromModifier(e, t)) return;
            t.declare = !0;
           }
           super.parseClassMember(e, t, r), t.declare && ('ClassProperty' !== t.type && 'ClassPrivateProperty' !== t.type && 'PropertyDefinition' !== t.type ? this.raise(ot.DeclareClassElement, s) : t.value && this.raise(ot.DeclareClassFieldInitializer, t.value));
          }
          isIterator(e) {
           return 'iterator' === e || 'asyncIterator' === e;
          }
          readIterator() {
           let e = super.readWord1(),
            t = '@@' + e;
           (!this.isIterator(e) || !this.state.inType) && this.raise(y.InvalidIdentifier, this.state.curPosition(), { identifierName: t }), this.finishToken(132, t);
          }
          getTokenFromCode(e) {
           let t = this.input.charCodeAt(this.state.pos + 1);
           123 === e && 124 === t
            ? this.finishOp(6, 2)
            : !this.state.inType || (62 !== e && 60 !== e)
              ? this.state.inType && 63 === e
                ? 46 === t
                  ? this.finishOp(18, 2)
                  : this.finishOp(17, 1)
                : (function (e, t, r) {
                     return 64 === e && 64 === t && ne(r);
                    })(e, t, this.input.charCodeAt(this.state.pos + 2))
                  ? ((this.state.pos += 2), this.readIterator())
                  : super.getTokenFromCode(e)
              : this.finishOp(62 === e ? 48 : 47, 1);
          }
          isAssignable(e, t) {
           return 'TypeCastExpression' === e.type ? this.isAssignable(e.expression, t) : super.isAssignable(e, t);
          }
          toAssignable(e, t = !1) {
           !t && 'AssignmentExpression' === e.type && 'TypeCastExpression' === e.left.type && (e.left = this.typeCastToParameter(e.left)), super.toAssignable(e, t);
          }
          toAssignableList(e, t, r) {
           for (let s = 0; s < e.length; s++) {
            let t = e[s];
            'TypeCastExpression' === (null == t ? void 0 : t.type) && (e[s] = this.typeCastToParameter(t));
           }
           super.toAssignableList(e, t, r);
          }
          toReferencedList(e, t) {
           for (let s = 0; s < e.length; s++) {
            var r;
            let n = e[s];
            n && 'TypeCastExpression' === n.type && (null == (r = n.extra) || !r.parenthesized) && (e.length > 1 || !t) && this.raise(ot.TypeCastInPattern, n.typeAnnotation);
           }
           return e;
          }
          parseArrayLike(e, t, r, s) {
           let n = super.parseArrayLike(e, t, r, s);
           return t && !this.state.maybeInArrowParameters && this.toReferencedList(n.elements), n;
          }
          isValidLVal(e, t, r) {
           return 'TypeCastExpression' === e || super.isValidLVal(e, t, r);
          }
          parseClassProperty(e) {
           return this.match(14) && (e.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(e);
          }
          parseClassPrivateProperty(e) {
           return this.match(14) && (e.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(e);
          }
          isClassMethod() {
           return this.match(47) || super.isClassMethod();
          }
          isClassProperty() {
           return this.match(14) || super.isClassProperty();
          }
          isNonstaticConstructor(e) {
           return !this.match(14) && super.isNonstaticConstructor(e);
          }
          pushClassMethod(e, t, r, s, n, i) {
           if ((t.variance && this.unexpected(t.variance.loc.start), delete t.variance, this.match(47) && (t.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(e, t, r, s, n, i), t.params && n)) {
            let e = t.params;
            e.length > 0 && this.isThisParam(e[0]) && this.raise(ot.ThisParamBannedInConstructor, t);
           } else if ('MethodDefinition' === t.type && n && t.value.params) {
            let e = t.value.params;
            e.length > 0 && this.isThisParam(e[0]) && this.raise(ot.ThisParamBannedInConstructor, t);
           }
          }
          pushClassPrivateMethod(e, t, r, s) {
           t.variance && this.unexpected(t.variance.loc.start), delete t.variance, this.match(47) && (t.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(e, t, r, s);
          }
          parseClassSuper(e) {
           if ((super.parseClassSuper(e), e.superClass && (this.match(47) || this.match(51)) && (e.superTypeParameters = this.flowParseTypeParameterInstantiationInExpression()), this.isContextual(113))) {
            this.next();
            let t = (e.implements = []);
            do {
             let e = this.startNode();
             (e.id = this.flowParseRestrictedIdentifier(!0)), this.match(47) ? (e.typeParameters = this.flowParseTypeParameterInstantiation()) : (e.typeParameters = null), t.push(this.finishNode(e, 'ClassImplements'));
            } while (this.eat(12));
           }
          }
          checkGetterSetterParams(e) {
           super.checkGetterSetterParams(e);
           let t = this.getObjectOrClassMethodParams(e);
           if (t.length > 0) {
            let r = t[0];
            this.isThisParam(r) && 'get' === e.kind ? this.raise(ot.GetterMayNotHaveThisParam, r) : this.isThisParam(r) && this.raise(ot.SetterMayNotHaveThisParam, r);
           }
          }
          parsePropertyNamePrefixOperator(e) {
           e.variance = this.flowParseVariance();
          }
          parseObjPropValue(e, t, r, s, n, i, a) {
           let o;
           e.variance && this.unexpected(e.variance.loc.start), delete e.variance, this.match(47) && !i && ((o = this.flowParseTypeParameterDeclaration()), this.match(10) || this.unexpected());
           let u = super.parseObjPropValue(e, t, r, s, n, i, a);
           return o && ((u.value || u).typeParameters = o), u;
          }
          parseFunctionParamType(e) {
           return this.eat(17) && ('Identifier' !== e.type && this.raise(ot.PatternIsOptional, e), this.isThisParam(e) && this.raise(ot.ThisParamMayNotBeOptional, e), (e.optional = !0)), this.match(14) ? (e.typeAnnotation = this.flowParseTypeAnnotation()) : this.isThisParam(e) && this.raise(ot.ThisParamAnnotationRequired, e), this.match(29) && this.isThisParam(e) && this.raise(ot.ThisParamNoDefault, e), this.resetEndLocation(e), e;
          }
          parseMaybeDefault(e, t) {
           let r = super.parseMaybeDefault(e, t);
           return 'AssignmentPattern' === r.type && r.typeAnnotation && r.right.start < r.typeAnnotation.start && this.raise(ot.TypeBeforeInitializer, r.typeAnnotation), r;
          }
          checkImportReflection(e) {
           super.checkImportReflection(e), e.module && 'value' !== e.importKind && this.raise(ot.ImportReflectionHasImportType, e.specifiers[0].loc.start);
          }
          parseImportSpecifierLocal(e, t, r) {
           (t.local = ut(e) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier()), e.specifiers.push(this.finishImportSpecifier(t, r));
          }
          isPotentialImportPhase(e) {
           if (super.isPotentialImportPhase(e)) return !0;
           if (this.isContextual(130)) {
            if (!e) return !0;
            let t = this.lookaheadCharCode();
            return 123 === t || 42 === t;
           }
           return !e && this.isContextual(87);
          }
          applyImportPhase(e, t, r, s) {
           if ((super.applyImportPhase(e, t, r, s), t)) {
            if (!r && this.match(65)) return;
            e.exportKind = 'type' === r ? r : 'value';
           } else 'type' === r && this.match(55) && this.unexpected(), (e.importKind = 'type' === r || 'typeof' === r ? r : 'value');
          }
          parseImportSpecifier(e, t, r, s, n) {
           let i = e.imported,
            a = null;
           'Identifier' === i.type && ('type' === i.name ? (a = 'type') : 'typeof' === i.name && (a = 'typeof'));
           let o = !1;
           if (this.isContextual(93) && !this.isLookaheadContextual('as')) {
            let t = this.parseIdentifier(!0);
            null === a || q(this.state.type) ? ((e.imported = i), (e.importKind = null), (e.local = this.parseIdentifier())) : ((e.imported = t), (e.importKind = a), (e.local = st(t)));
           } else {
            if (null !== a && q(this.state.type)) (e.imported = this.parseIdentifier(!0)), (e.importKind = a);
            else {
             if (t) throw this.raise(y.ImportBindingIsString, e, { importName: i.value });
             (e.imported = i), (e.importKind = null);
            }
            this.eatContextual(93) ? (e.local = this.parseIdentifier()) : ((o = !0), (e.local = st(e.imported)));
           }
           let u = ut(e);
           return r && u && this.raise(ot.ImportTypeShorthandOnlyInPureImport, e), (r || u) && this.checkReservedType(e.local.name, e.local.loc.start, !0), o && !r && !u && this.checkReservedWord(e.local.name, e.loc.start, !0, !0), this.finishImportSpecifier(e, 'ImportSpecifier');
          }
          parseBindingAtom() {
           return 78 === this.state.type ? this.parseIdentifier(!0) : super.parseBindingAtom();
          }
          parseFunctionParams(e, t) {
           let r = e.kind;
           'get' !== r && 'set' !== r && this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(e, t);
          }
          parseVarId(e, t) {
           super.parseVarId(e, t), this.match(14) && ((e.id.typeAnnotation = this.flowParseTypeAnnotation()), this.resetEndLocation(e.id));
          }
          parseAsyncArrowFromCallExpression(e, t) {
           if (this.match(14)) {
            let t = this.state.noAnonFunctionType;
            (this.state.noAnonFunctionType = !0), (e.returnType = this.flowParseTypeAnnotation()), (this.state.noAnonFunctionType = t);
           }
           return super.parseAsyncArrowFromCallExpression(e, t);
          }
          shouldParseAsyncArrow() {
           return this.match(14) || super.shouldParseAsyncArrow();
          }
          parseMaybeAssign(e, t) {
           var r;
           let s,
            n = null;
           if (this.hasPlugin('jsx') && (this.match(143) || this.match(47))) {
            if (((n = this.state.clone()), (s = this.tryParse(() => super.parseMaybeAssign(e, t), n)), !s.error)) return s.node;
            let { context: r } = this.state,
             i = r[r.length - 1];
            (i === b.j_oTag || i === b.j_expr) && r.pop();
           }
           if ((null != (r = s) && r.error) || this.match(47)) {
            var i, a;
            n = n || this.state.clone();
            let r,
             o = this.tryParse((s) => {
              var n;
              r = this.flowParseTypeParameterDeclaration();
              let i = this.forwardNoArrowParamsConversionAt(r, () => {
               let s = super.parseMaybeAssign(e, t);
               return this.resetStartLocationFromNode(s, r), s;
              });
              null != (n = i.extra) && n.parenthesized && s();
              let a = this.maybeUnwrapTypeCastExpression(i);
              return 'ArrowFunctionExpression' !== a.type && s(), (a.typeParameters = r), this.resetStartLocationFromNode(a, r), i;
             }, n),
             u = null;
            if (o.node && 'ArrowFunctionExpression' === this.maybeUnwrapTypeCastExpression(o.node).type) {
             if (!o.error && !o.aborted) return o.node.async && this.raise(ot.UnexpectedTypeParameterBeforeAsyncArrowFunction, r), o.node;
             u = o.node;
            }
            if (null != (i = s) && i.node) return (this.state = s.failState), s.node;
            if (u) return (this.state = o.failState), u;
            throw null != (a = s) && a.thrown ? s.error : o.thrown ? o.error : this.raise(ot.UnexpectedTokenAfterTypeParameter, r);
           }
           return super.parseMaybeAssign(e, t);
          }
          parseArrow(e) {
           if (this.match(14)) {
            let t = this.tryParse(() => {
             let t = this.state.noAnonFunctionType;
             this.state.noAnonFunctionType = !0;
             let r = this.startNode();
             return ([r.typeAnnotation, e.predicate] = this.flowParseTypeAndPredicateInitialiser()), (this.state.noAnonFunctionType = t), this.canInsertSemicolon() && this.unexpected(), this.match(19) || this.unexpected(), r;
            });
            if (t.thrown) return null;
            t.error && (this.state = t.failState), (e.returnType = t.node.typeAnnotation ? this.finishNode(t.node, 'TypeAnnotation') : null);
           }
           return super.parseArrow(e);
          }
          shouldParseArrow(e) {
           return this.match(14) || super.shouldParseArrow(e);
          }
          setArrowFunctionParameters(e, t) {
           this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(e.start)) ? (e.params = t) : super.setArrowFunctionParameters(e, t);
          }
          checkParams(e, t, r, s = !0) {
           if (!r || !this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(e.start))) {
            for (let t = 0; t < e.params.length; t++) this.isThisParam(e.params[t]) && t > 0 && this.raise(ot.ThisParamMustBeFirst, e.params[t]);
            super.checkParams(e, t, r, s);
           }
          }
          parseParenAndDistinguishExpression(e) {
           return super.parseParenAndDistinguishExpression(e && !this.state.noArrowAt.includes(this.sourceToOffsetPos(this.state.start)));
          }
          parseSubscripts(e, t, r) {
           if ('Identifier' === e.type && 'async' === e.name && this.state.noArrowAt.includes(t.index)) {
            this.next();
            let r = this.startNodeAt(t);
            (r.callee = e), (r.arguments = super.parseCallExpressionArguments(11)), (e = this.finishNode(r, 'CallExpression'));
           } else if ('Identifier' === e.type && 'async' === e.name && this.match(47)) {
            let s = this.state.clone(),
             n = this.tryParse((e) => this.parseAsyncArrowWithTypeParameters(t) || e(), s);
            if (!n.error && !n.aborted) return n.node;
            let i = this.tryParse(() => super.parseSubscripts(e, t, r), s);
            if (i.node && !i.error) return i.node;
            if (n.node) return (this.state = n.failState), n.node;
            if (i.node) return (this.state = i.failState), i.node;
            throw n.error || i.error;
           }
           return super.parseSubscripts(e, t, r);
          }
          parseSubscript(e, t, r, s) {
           if (this.match(18) && this.isLookaheadToken_lt()) {
            if (((s.optionalChainMember = !0), r)) return (s.stop = !0), e;
            this.next();
            let n = this.startNodeAt(t);
            return (n.callee = e), (n.typeArguments = this.flowParseTypeParameterInstantiationInExpression()), this.expect(10), (n.arguments = this.parseCallExpressionArguments(11)), (n.optional = !0), this.finishCallExpression(n, !0);
           }
           if (!r && this.shouldParseTypes() && (this.match(47) || this.match(51))) {
            let r = this.startNodeAt(t);
            r.callee = e;
            let n = this.tryParse(() => ((r.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew()), this.expect(10), (r.arguments = super.parseCallExpressionArguments(11)), s.optionalChainMember && (r.optional = !1), this.finishCallExpression(r, s.optionalChainMember)));
            if (n.node) return n.error && (this.state = n.failState), n.node;
           }
           return super.parseSubscript(e, t, r, s);
          }
          parseNewCallee(e) {
           super.parseNewCallee(e);
           let t = null;
           this.shouldParseTypes() && this.match(47) && (t = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), (e.typeArguments = t);
          }
          parseAsyncArrowWithTypeParameters(e) {
           let t = this.startNodeAt(e);
           if ((this.parseFunctionParams(t, !1), this.parseArrow(t))) return super.parseArrowExpression(t, void 0, !0);
          }
          readToken_mult_modulo(e) {
           let t = this.input.charCodeAt(this.state.pos + 1);
           if (42 === e && 47 === t && this.state.hasFlowComment) return (this.state.hasFlowComment = !1), (this.state.pos += 2), void this.nextToken();
           super.readToken_mult_modulo(e);
          }
          readToken_pipe_amp(e) {
           let t = this.input.charCodeAt(this.state.pos + 1);
           124 !== e || 125 !== t ? super.readToken_pipe_amp(e) : this.finishOp(9, 2);
          }
          parseTopLevel(e, t) {
           let r = super.parseTopLevel(e, t);
           return this.state.hasFlowComment && this.raise(ot.UnterminatedFlowComment, this.state.curPosition()), r;
          }
          skipBlockComment() {
           if (!this.hasPlugin('flowComments') || !this.skipFlowComment()) return super.skipBlockComment(this.state.hasFlowComment ? '*-/' : '*/');
           {
            if (this.state.hasFlowComment) throw this.raise(ot.NestedFlowComment, this.state.startLoc);
            this.hasFlowCommentCompletion();
            let e = this.skipFlowComment();
            e && ((this.state.pos += e), (this.state.hasFlowComment = !0));
           }
          }
          skipFlowComment() {
           let { pos: e } = this.state,
            t = 2;
           for (; [32, 9].includes(this.input.charCodeAt(e + t)); ) t++;
           let r = this.input.charCodeAt(t + e),
            s = this.input.charCodeAt(t + e + 1);
           return 58 === r && 58 === s ? t + 2 : 'flow-include' === this.input.slice(t + e, t + e + 12) ? t + 12 : 58 === r && 58 !== s && t;
          }
          hasFlowCommentCompletion() {
           if (-1 === this.input.indexOf('*/', this.state.pos)) throw this.raise(y.UnterminatedComment, this.state.curPosition());
          }
          flowEnumErrorBooleanMemberNotInitialized(e, { enumName: t, memberName: r }) {
           this.raise(ot.EnumBooleanMemberNotInitialized, e, { memberName: r, enumName: t });
          }
          flowEnumErrorInvalidMemberInitializer(e, t) {
           return this.raise(t.explicitType ? ('symbol' === t.explicitType ? ot.EnumInvalidMemberInitializerSymbolType : ot.EnumInvalidMemberInitializerPrimaryType) : ot.EnumInvalidMemberInitializerUnknownType, e, t);
          }
          flowEnumErrorNumberMemberNotInitialized(e, t) {
           this.raise(ot.EnumNumberMemberNotInitialized, e, t);
          }
          flowEnumErrorStringMemberInconsistentlyInitialized(e, t) {
           this.raise(ot.EnumStringMemberInconsistentlyInitialized, e, t);
          }
          flowEnumMemberInit() {
           let e = this.state.startLoc,
            t = () => this.match(12) || this.match(8);
           switch (this.state.type) {
            case 135: {
             let r = this.parseNumericLiteral(this.state.value);
             return t() ? { type: 'number', loc: r.loc.start, value: r } : { type: 'invalid', loc: e };
            }
            case 134: {
             let r = this.parseStringLiteral(this.state.value);
             return t() ? { type: 'string', loc: r.loc.start, value: r } : { type: 'invalid', loc: e };
            }
            case 85:
            case 86: {
             let r = this.parseBooleanLiteral(this.match(85));
             return t() ? { type: 'boolean', loc: r.loc.start, value: r } : { type: 'invalid', loc: e };
            }
            default:
             return { type: 'invalid', loc: e };
           }
          }
          flowEnumMemberRaw() {
           let e = this.state.startLoc;
           return { id: this.parseIdentifier(!0), init: this.eat(29) ? this.flowEnumMemberInit() : { type: 'none', loc: e } };
          }
          flowEnumCheckExplicitTypeMismatch(e, t, r) {
           let { explicitType: s } = t;
           null !== s && s !== r && this.flowEnumErrorInvalidMemberInitializer(e, t);
          }
          flowEnumMembers({ enumName: e, explicitType: t }) {
           let r = new Set(),
            s = { booleanMembers: [], numberMembers: [], stringMembers: [], defaultedMembers: [] },
            n = !1;
           for (; !this.match(8); ) {
            if (this.eat(21)) {
             n = !0;
             break;
            }
            let i = this.startNode(),
             { id: a, init: o } = this.flowEnumMemberRaw(),
             u = a.name;
            if ('' === u) continue;
            /^[a-z]/.test(u) && this.raise(ot.EnumInvalidMemberName, a, { memberName: u, suggestion: u[0].toUpperCase() + u.slice(1), enumName: e }), r.has(u) && this.raise(ot.EnumDuplicateMemberName, a, { memberName: u, enumName: e }), r.add(u);
            let l = { enumName: e, explicitType: t, memberName: u };
            switch (((i.id = a), o.type)) {
             case 'boolean':
              this.flowEnumCheckExplicitTypeMismatch(o.loc, l, 'boolean'), (i.init = o.value), s.booleanMembers.push(this.finishNode(i, 'EnumBooleanMember'));
              break;
             case 'number':
              this.flowEnumCheckExplicitTypeMismatch(o.loc, l, 'number'), (i.init = o.value), s.numberMembers.push(this.finishNode(i, 'EnumNumberMember'));
              break;
             case 'string':
              this.flowEnumCheckExplicitTypeMismatch(o.loc, l, 'string'), (i.init = o.value), s.stringMembers.push(this.finishNode(i, 'EnumStringMember'));
              break;
             case 'invalid':
              throw this.flowEnumErrorInvalidMemberInitializer(o.loc, l);
             case 'none':
              switch (t) {
               case 'boolean':
                this.flowEnumErrorBooleanMemberNotInitialized(o.loc, l);
                break;
               case 'number':
                this.flowEnumErrorNumberMemberNotInitialized(o.loc, l);
                break;
               default:
                s.defaultedMembers.push(this.finishNode(i, 'EnumDefaultedMember'));
              }
            }
            this.match(8) || this.expect(12);
           }
           return { members: s, hasUnknownMembers: n };
          }
          flowEnumStringMembers(e, t, { enumName: r }) {
           if (0 === e.length) return t;
           if (0 === t.length) return e;
           if (t.length > e.length) {
            for (let t of e) this.flowEnumErrorStringMemberInconsistentlyInitialized(t, { enumName: r });
            return t;
           }
           for (let s of t) this.flowEnumErrorStringMemberInconsistentlyInitialized(s, { enumName: r });
           return e;
          }
          flowEnumParseExplicitType({ enumName: e }) {
           if (!this.eatContextual(102)) return null;
           if (!$(this.state.type)) throw this.raise(ot.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, { enumName: e });
           let { value: t } = this.state;
           return this.next(), 'boolean' !== t && 'number' !== t && 'string' !== t && 'symbol' !== t && this.raise(ot.EnumInvalidExplicitType, this.state.startLoc, { enumName: e, invalidEnumType: t }), t;
          }
          flowEnumBody(e, t) {
           let r = t.name,
            s = t.loc.start,
            n = this.flowEnumParseExplicitType({ enumName: r });
           this.expect(5);
           let { members: i, hasUnknownMembers: a } = this.flowEnumMembers({ enumName: r, explicitType: n });
           switch (((e.hasUnknownMembers = a), n)) {
            case 'boolean':
             return (e.explicitType = !0), (e.members = i.booleanMembers), this.expect(8), this.finishNode(e, 'EnumBooleanBody');
            case 'number':
             return (e.explicitType = !0), (e.members = i.numberMembers), this.expect(8), this.finishNode(e, 'EnumNumberBody');
            case 'string':
             return (e.explicitType = !0), (e.members = this.flowEnumStringMembers(i.stringMembers, i.defaultedMembers, { enumName: r })), this.expect(8), this.finishNode(e, 'EnumStringBody');
            case 'symbol':
             return (e.members = i.defaultedMembers), this.expect(8), this.finishNode(e, 'EnumSymbolBody');
            default: {
             let t = () => ((e.members = []), this.expect(8), this.finishNode(e, 'EnumStringBody'));
             e.explicitType = !1;
             let n = i.booleanMembers.length,
              a = i.numberMembers.length,
              o = i.stringMembers.length,
              u = i.defaultedMembers.length;
             if (!(n || a || o || u)) return t();
             if (!n && !a) return (e.members = this.flowEnumStringMembers(i.stringMembers, i.defaultedMembers, { enumName: r })), this.expect(8), this.finishNode(e, 'EnumStringBody');
             if (!a && !o && n >= u) {
              for (let e of i.defaultedMembers) this.flowEnumErrorBooleanMemberNotInitialized(e.loc.start, { enumName: r, memberName: e.id.name });
              return (e.members = i.booleanMembers), this.expect(8), this.finishNode(e, 'EnumBooleanBody');
             }
             if (!n && !o && a >= u) {
              for (let e of i.defaultedMembers) this.flowEnumErrorNumberMemberNotInitialized(e.loc.start, { enumName: r, memberName: e.id.name });
              return (e.members = i.numberMembers), this.expect(8), this.finishNode(e, 'EnumNumberBody');
             }
             return this.raise(ot.EnumInconsistentMemberValues, s, { enumName: r }), t();
            }
           }
          }
          flowParseEnumDeclaration(e) {
           let t = this.parseIdentifier();
           return (e.id = t), (e.body = this.flowEnumBody(this.startNode(), t)), this.finishNode(e, 'EnumDeclaration');
          }
          jsxParseOpeningElementAfterName(e) {
           return this.shouldParseTypes() && (this.match(47) || this.match(51)) && (e.typeArguments = this.flowParseTypeParameterInstantiationInExpression()), super.jsxParseOpeningElementAfterName(e);
          }
          isLookaheadToken_lt() {
           let e = this.nextTokenStart();
           if (60 === this.input.charCodeAt(e)) {
            let t = this.input.charCodeAt(e + 1);
            return 60 !== t && 61 !== t;
           }
           return !1;
          }
          reScan_lt_gt() {
           let { type: e } = this.state;
           47 === e ? ((this.state.pos -= 1), this.readToken_lt()) : 48 === e && ((this.state.pos -= 1), this.readToken_gt());
          }
          reScan_lt() {
           let { type: e } = this.state;
           return 51 === e ? ((this.state.pos -= 2), this.finishOp(47, 1), 47) : e;
          }
          maybeUnwrapTypeCastExpression(e) {
           return 'TypeCastExpression' === e.type ? e.expression : e;
          }
         },
        typescript: (e) =>
         class extends e {
          constructor(...e) {
           super(...e), (this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ['in', 'out'], disallowedModifiers: ['const', 'public', 'private', 'protected', 'readonly', 'declare', 'abstract', 'override'], errorTemplate: xt.InvalidModifierOnTypeParameter })), (this.tsParseConstModifier = this.tsParseModifiers.bind(this, { allowedModifiers: ['const'], disallowedModifiers: ['in', 'out'], errorTemplate: xt.InvalidModifierOnTypeParameterPositions })), (this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ['in', 'out', 'const'], disallowedModifiers: ['public', 'private', 'protected', 'readonly', 'declare', 'abstract', 'override'], errorTemplate: xt.InvalidModifierOnTypeParameter }));
          }
          getScopeHandler() {
           return mt;
          }
          tsIsIdentifier() {
           return $(this.state.type);
          }
          tsTokenCanFollowModifier() {
           return this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(139) || this.isLiteralPropertyName();
          }
          tsNextTokenOnSameLineAndCanFollowModifier() {
           return this.next(), !this.hasPrecedingLineBreak() && this.tsTokenCanFollowModifier();
          }
          tsNextTokenCanFollowModifier() {
           return this.match(106) ? (this.next(), this.tsTokenCanFollowModifier()) : this.tsNextTokenOnSameLineAndCanFollowModifier();
          }
          tsParseModifier(e, t) {
           if (!$(this.state.type) && 58 !== this.state.type && 75 !== this.state.type) return;
           let r = this.state.value;
           if (e.includes(r)) {
            if (t && this.tsIsStartOfStaticBlocks()) return;
            if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) return r;
           }
          }
          tsParseModifiers({ allowedModifiers: e, disallowedModifiers: t, stopOnStartOfClassStaticBlock: r, errorTemplate: s = xt.InvalidModifierOnTypeMember }, n) {
           let i = (e, t, r, s) => {
             t === r && n[s] && this.raise(xt.InvalidModifiersOrder, e, { orderedModifiers: [r, s] });
            },
            a = (e, t, r, s) => {
             ((n[r] && t === s) || (n[s] && t === r)) && this.raise(xt.IncompatibleModifiers, e, { modifiers: [r, s] });
            };
           for (;;) {
            let { startLoc: o } = this.state,
             u = this.tsParseModifier(e.concat(t ?? []), r);
            if (!u) break;
            Et(u) ? (n.accessibility ? this.raise(xt.DuplicateAccessibilityModifier, o, { modifier: u }) : (i(o, u, u, 'override'), i(o, u, u, 'static'), i(o, u, u, 'readonly'), (n.accessibility = u))) : bt(u) ? (n[u] && this.raise(xt.DuplicateModifier, o, { modifier: u }), (n[u] = !0), i(o, u, 'in', 'out')) : (hasOwnProperty.call(n, u) ? this.raise(xt.DuplicateModifier, o, { modifier: u }) : (i(o, u, 'static', 'readonly'), i(o, u, 'static', 'override'), i(o, u, 'override', 'readonly'), i(o, u, 'abstract', 'override'), a(o, u, 'declare', 'override'), a(o, u, 'static', 'abstract')), (n[u] = !0)), null != t && t.includes(u) && this.raise(s, o, { modifier: u });
           }
          }
          tsIsListTerminator(e) {
           switch (e) {
            case 'EnumMembers':
            case 'TypeMembers':
             return this.match(8);
            case 'HeritageClauseElement':
             return this.match(5);
            case 'TupleElementTypes':
             return this.match(3);
            case 'TypeParametersOrArguments':
             return this.match(48);
           }
          }
          tsParseList(e, t) {
           let r = [];
           for (; !this.tsIsListTerminator(e); ) r.push(t());
           return r;
          }
          tsParseDelimitedList(e, t, r) {
           return (function (e) {
            if (null == e) throw new Error(`Unexpected ${e} value.`);
            return e;
           })(this.tsParseDelimitedListWorker(e, t, !0, r));
          }
          tsParseDelimitedListWorker(e, t, r, s) {
           let n = [],
            i = -1;
           for (; !this.tsIsListTerminator(e); ) {
            i = -1;
            let s = t();
            if (null == s) return;
            if ((n.push(s), !this.eat(12))) {
             if (this.tsIsListTerminator(e)) break;
             return void (r && this.expect(12));
            }
            i = this.state.lastTokStartLoc.index;
           }
           return s && (s.value = i), n;
          }
          tsParseBracketedList(e, t, r, s, n) {
           s || (r ? this.expect(0) : this.expect(47));
           let i = this.tsParseDelimitedList(e, t, n);
           return r ? this.expect(3) : this.expect(48), i;
          }
          tsParseImportType() {
           let e = this.startNode();
           return this.expect(83), this.expect(10), this.match(134) ? (e.argument = this.parseStringLiteral(this.state.value)) : (this.raise(xt.UnsupportedImportTypeArgument, this.state.startLoc), (e.argument = super.parseExprAtom())), this.eat(12) && !this.match(11) ? ((e.options = super.parseMaybeAssignAllowIn()), this.eat(12)) : (e.options = null), this.expect(11), this.eat(16) && (e.qualifier = this.tsParseEntityName(3)), this.match(47) && (e.typeParameters = this.tsParseTypeArguments()), this.finishNode(e, 'TSImportType');
          }
          tsParseEntityName(e) {
           let t;
           if (1 & e && this.match(78))
            if (2 & e) t = this.parseIdentifier(!0);
            else {
             let e = this.startNode();
             this.next(), (t = this.finishNode(e, 'ThisExpression'));
            }
           else t = this.parseIdentifier(!!(1 & e));
           for (; this.eat(16); ) {
            let r = this.startNodeAtNode(t);
            (r.left = t), (r.right = this.parseIdentifier(!!(1 & e))), (t = this.finishNode(r, 'TSQualifiedName'));
           }
           return t;
          }
          tsParseTypeReference() {
           let e = this.startNode();
           return (e.typeName = this.tsParseEntityName(1)), !this.hasPrecedingLineBreak() && this.match(47) && (e.typeParameters = this.tsParseTypeArguments()), this.finishNode(e, 'TSTypeReference');
          }
          tsParseThisTypePredicate(e) {
           this.next();
           let t = this.startNodeAtNode(e);
           return (t.parameterName = e), (t.typeAnnotation = this.tsParseTypeAnnotation(!1)), (t.asserts = !1), this.finishNode(t, 'TSTypePredicate');
          }
          tsParseThisTypeNode() {
           let e = this.startNode();
           return this.next(), this.finishNode(e, 'TSThisType');
          }
          tsParseTypeQuery() {
           let e = this.startNode();
           return this.expect(87), this.match(83) ? (e.exprName = this.tsParseImportType()) : (e.exprName = this.tsParseEntityName(3)), !this.hasPrecedingLineBreak() && this.match(47) && (e.typeParameters = this.tsParseTypeArguments()), this.finishNode(e, 'TSTypeQuery');
          }
          tsParseTypeParameter(e) {
           let t = this.startNode();
           return e(t), (t.name = this.tsParseTypeParameterName()), (t.constraint = this.tsEatThenParseType(81)), (t.default = this.tsEatThenParseType(29)), this.finishNode(t, 'TSTypeParameter');
          }
          tsTryParseTypeParameters(e) {
           if (this.match(47)) return this.tsParseTypeParameters(e);
          }
          tsParseTypeParameters(e) {
           let t = this.startNode();
           this.match(47) || this.match(143) ? this.next() : this.unexpected();
           let r = { value: -1 };
           return (t.params = this.tsParseBracketedList('TypeParametersOrArguments', this.tsParseTypeParameter.bind(this, e), !1, !0, r)), 0 === t.params.length && this.raise(xt.EmptyTypeParameters, t), -1 !== r.value && this.addExtra(t, 'trailingComma', r.value), this.finishNode(t, 'TSTypeParameterDeclaration');
          }
          tsFillSignature(e, t) {
           let r = 19 === e,
            s = 'typeAnnotation';
           (t.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier)), this.expect(10), (t.parameters = this.tsParseBindingListForSignature()), (r || this.match(e)) && (t[s] = this.tsParseTypeOrTypePredicateAnnotation(e));
          }
          tsParseBindingListForSignature() {
           let e = super.parseBindingList(11, 41, 2);
           for (let t of e) {
            let { type: e } = t;
            ('AssignmentPattern' === e || 'TSParameterProperty' === e) && this.raise(xt.UnsupportedSignatureParameterKind, t, { type: e });
           }
           return e;
          }
          tsParseTypeMemberSemicolon() {
           !this.eat(12) && !this.isLineTerminator() && this.expect(13);
          }
          tsParseSignatureMember(e, t) {
           return this.tsFillSignature(14, t), this.tsParseTypeMemberSemicolon(), this.finishNode(t, e);
          }
          tsIsUnambiguouslyIndexSignature() {
           return this.next(), !!$(this.state.type) && (this.next(), this.match(14));
          }
          tsTryParseIndexSignature(e) {
           if (!this.match(0) || !this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))) return;
           this.expect(0);
           let t = this.parseIdentifier();
           (t.typeAnnotation = this.tsParseTypeAnnotation()), this.resetEndLocation(t), this.expect(3), (e.parameters = [t]);
           let r = this.tsTryParseTypeAnnotation();
           return r && (e.typeAnnotation = r), this.tsParseTypeMemberSemicolon(), this.finishNode(e, 'TSIndexSignature');
          }
          tsParsePropertyOrMethodSignature(e, t) {
           this.eat(17) && (e.optional = !0);
           let r = e;
           if (this.match(10) || this.match(47)) {
            t && this.raise(xt.ReadonlyForMethodSignature, e);
            let s = r;
            s.kind && this.match(47) && this.raise(xt.AccessorCannotHaveTypeParameters, this.state.curPosition()), this.tsFillSignature(14, s), this.tsParseTypeMemberSemicolon();
            let n = 'parameters',
             i = 'typeAnnotation';
            if ('get' === s.kind) s[n].length > 0 && (this.raise(y.BadGetterArity, this.state.curPosition()), this.isThisParam(s[n][0]) && this.raise(xt.AccessorCannotDeclareThisParameter, this.state.curPosition()));
            else if ('set' === s.kind) {
             if (1 !== s[n].length) this.raise(y.BadSetterArity, this.state.curPosition());
             else {
              let e = s[n][0];
              this.isThisParam(e) && this.raise(xt.AccessorCannotDeclareThisParameter, this.state.curPosition()), 'Identifier' === e.type && e.optional && this.raise(xt.SetAccessorCannotHaveOptionalParameter, this.state.curPosition()), 'RestElement' === e.type && this.raise(xt.SetAccessorCannotHaveRestParameter, this.state.curPosition());
             }
             s[i] && this.raise(xt.SetAccessorCannotHaveReturnType, s[i]);
            } else s.kind = 'method';
            return this.finishNode(s, 'TSMethodSignature');
           }
           {
            let e = r;
            t && (e.readonly = !0);
            let s = this.tsTryParseTypeAnnotation();
            return s && (e.typeAnnotation = s), this.tsParseTypeMemberSemicolon(), this.finishNode(e, 'TSPropertySignature');
           }
          }
          tsParseTypeMember() {
           let e = this.startNode();
           if (this.match(10) || this.match(47)) return this.tsParseSignatureMember('TSCallSignatureDeclaration', e);
           if (this.match(77)) {
            let t = this.startNode();
            return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember('TSConstructSignatureDeclaration', e) : ((e.key = this.createIdentifier(t, 'new')), this.tsParsePropertyOrMethodSignature(e, !1));
           }
           return this.tsParseModifiers({ allowedModifiers: ['readonly'], disallowedModifiers: ['declare', 'abstract', 'private', 'protected', 'public', 'static', 'override'] }, e), this.tsTryParseIndexSignature(e) || (super.parsePropertyName(e), !e.computed && 'Identifier' === e.key.type && ('get' === e.key.name || 'set' === e.key.name) && this.tsTokenCanFollowModifier() && ((e.kind = e.key.name), super.parsePropertyName(e)), this.tsParsePropertyOrMethodSignature(e, !!e.readonly));
          }
          tsParseTypeLiteral() {
           let e = this.startNode();
           return (e.members = this.tsParseObjectTypeMembers()), this.finishNode(e, 'TSTypeLiteral');
          }
          tsParseObjectTypeMembers() {
           this.expect(5);
           let e = this.tsParseList('TypeMembers', this.tsParseTypeMember.bind(this));
           return this.expect(8), e;
          }
          tsIsStartOfMappedType() {
           return this.next(), this.eat(53) ? this.isContextual(122) : (this.isContextual(122) && this.next(), !(!this.match(0) || (this.next(), !this.tsIsIdentifier())) && (this.next(), this.match(58)));
          }
          tsParseMappedType() {
           let e = this.startNode();
           this.expect(5), this.match(53) ? ((e.readonly = this.state.value), this.next(), this.expectContextual(122)) : this.eatContextual(122) && (e.readonly = !0), this.expect(0);
           {
            let t = this.startNode();
            (t.name = this.tsParseTypeParameterName()), (t.constraint = this.tsExpectThenParseType(58)), (e.typeParameter = this.finishNode(t, 'TSTypeParameter'));
           }
           return (e.nameType = this.eatContextual(93) ? this.tsParseType() : null), this.expect(3), this.match(53) ? ((e.optional = this.state.value), this.next(), this.expect(17)) : this.eat(17) && (e.optional = !0), (e.typeAnnotation = this.tsTryParseType()), this.semicolon(), this.expect(8), this.finishNode(e, 'TSMappedType');
          }
          tsParseTupleType() {
           let e = this.startNode();
           e.elementTypes = this.tsParseBracketedList('TupleElementTypes', this.tsParseTupleElementType.bind(this), !0, !1);
           let t = !1;
           return (
            e.elementTypes.forEach((e) => {
             let { type: r } = e;
             t && 'TSRestType' !== r && 'TSOptionalType' !== r && !('TSNamedTupleMember' === r && e.optional) && this.raise(xt.OptionalTypeBeforeRequired, e), t || (t = ('TSNamedTupleMember' === r && e.optional) || 'TSOptionalType' === r);
            }),
            this.finishNode(e, 'TSTupleType')
           );
          }
          tsParseTupleElementType() {
           let e,
            t,
            r,
            s,
            n = this.state.startLoc,
            i = this.eat(21),
            { startLoc: a } = this.state,
            o = q(this.state.type) ? this.lookaheadCharCode() : null;
           if (58 === o) (e = !0), (r = !1), (t = this.parseIdentifier(!0)), this.expect(14), (s = this.tsParseType());
           else if (63 === o) {
            r = !0;
            let n = this.state.value,
             i = this.tsParseNonArrayType();
            58 === this.lookaheadCharCode() ? ((e = !0), (t = this.createIdentifier(this.startNodeAt(a), n)), this.expect(17), this.expect(14), (s = this.tsParseType())) : ((e = !1), (s = i), this.expect(17));
           } else (s = this.tsParseType()), (r = this.eat(17)), (e = this.eat(14));
           if (e) {
            let e;
            t ? ((e = this.startNodeAt(a)), (e.optional = r), (e.label = t), (e.elementType = s), this.eat(17) && ((e.optional = !0), this.raise(xt.TupleOptionalAfterType, this.state.lastTokStartLoc))) : ((e = this.startNodeAt(a)), (e.optional = r), this.raise(xt.InvalidTupleMemberLabel, s), (e.label = s), (e.elementType = this.tsParseType())), (s = this.finishNode(e, 'TSNamedTupleMember'));
           } else if (r) {
            let e = this.startNodeAt(a);
            (e.typeAnnotation = s), (s = this.finishNode(e, 'TSOptionalType'));
           }
           if (i) {
            let e = this.startNodeAt(n);
            (e.typeAnnotation = s), (s = this.finishNode(e, 'TSRestType'));
           }
           return s;
          }
          tsParseParenthesizedType() {
           let e = this.startNode();
           return this.expect(10), (e.typeAnnotation = this.tsParseType()), this.expect(11), this.finishNode(e, 'TSParenthesizedType');
          }
          tsParseFunctionOrConstructorType(e, t) {
           let r = this.startNode();
           return 'TSConstructorType' === e && ((r.abstract = !!t), t && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, r)), this.finishNode(r, e);
          }
          tsParseLiteralTypeNode() {
           let e = this.startNode();
           switch (this.state.type) {
            case 135:
            case 136:
            case 134:
            case 85:
            case 86:
             e.literal = super.parseExprAtom();
             break;
            default:
             this.unexpected();
           }
           return this.finishNode(e, 'TSLiteralType');
          }
          tsParseTemplateLiteralType() {
           {
            let e = this.startNode();
            return (e.literal = super.parseTemplate(!1)), this.finishNode(e, 'TSLiteralType');
           }
          }
          parseTemplateSubstitution() {
           return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
          }
          tsParseThisTypeOrThisTypePredicate() {
           let e = this.tsParseThisTypeNode();
           return this.isContextual(116) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(e) : e;
          }
          tsParseNonArrayType() {
           switch (this.state.type) {
            case 134:
            case 135:
            case 136:
            case 85:
            case 86:
             return this.tsParseLiteralTypeNode();
            case 53:
             if ('-' === this.state.value) {
              let e = this.startNode(),
               t = this.lookahead();
              return 135 !== t.type && 136 !== t.type && this.unexpected(), (e.literal = this.parseMaybeUnary()), this.finishNode(e, 'TSLiteralType');
             }
             break;
            case 78:
             return this.tsParseThisTypeOrThisTypePredicate();
            case 87:
             return this.tsParseTypeQuery();
            case 83:
             return this.tsParseImportType();
            case 5:
             return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
            case 0:
             return this.tsParseTupleType();
            case 10:
             return this.tsParseParenthesizedType();
            case 25:
            case 24:
             return this.tsParseTemplateLiteralType();
            default: {
             let { type: e } = this.state;
             if ($(e) || 88 === e || 84 === e) {
              let t =
               88 === e
                ? 'TSVoidKeyword'
                : 84 === e
                  ? 'TSNullKeyword'
                  : (function (e) {
                     switch (e) {
                      case 'any':
                       return 'TSAnyKeyword';
                      case 'boolean':
                       return 'TSBooleanKeyword';
                      case 'bigint':
                       return 'TSBigIntKeyword';
                      case 'never':
                       return 'TSNeverKeyword';
                      case 'number':
                       return 'TSNumberKeyword';
                      case 'object':
                       return 'TSObjectKeyword';
                      case 'string':
                       return 'TSStringKeyword';
                      case 'symbol':
                       return 'TSSymbolKeyword';
                      case 'undefined':
                       return 'TSUndefinedKeyword';
                      case 'unknown':
                       return 'TSUnknownKeyword';
                      default:
                       return;
                     }
                    })(this.state.value);
              if (void 0 !== t && 46 !== this.lookaheadCharCode()) {
               let e = this.startNode();
               return this.next(), this.finishNode(e, t);
              }
              return this.tsParseTypeReference();
             }
            }
           }
           this.unexpected();
          }
          tsParseArrayTypeOrHigher() {
           let { startLoc: e } = this.state,
            t = this.tsParseNonArrayType();
           for (; !this.hasPrecedingLineBreak() && this.eat(0); )
            if (this.match(3)) {
             let r = this.startNodeAt(e);
             (r.elementType = t), this.expect(3), (t = this.finishNode(r, 'TSArrayType'));
            } else {
             let r = this.startNodeAt(e);
             (r.objectType = t), (r.indexType = this.tsParseType()), this.expect(3), (t = this.finishNode(r, 'TSIndexedAccessType'));
            }
           return t;
          }
          tsParseTypeOperator() {
           let e = this.startNode(),
            t = this.state.value;
           return this.next(), (e.operator = t), (e.typeAnnotation = this.tsParseTypeOperatorOrHigher()), 'readonly' === t && this.tsCheckTypeAnnotationForReadOnly(e), this.finishNode(e, 'TSTypeOperator');
          }
          tsCheckTypeAnnotationForReadOnly(e) {
           switch (e.typeAnnotation.type) {
            case 'TSTupleType':
            case 'TSArrayType':
             return;
            default:
             this.raise(xt.UnexpectedReadonly, e);
           }
          }
          tsParseInferType() {
           let e = this.startNode();
           this.expectContextual(115);
           let t = this.startNode();
           return (t.name = this.tsParseTypeParameterName()), (t.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType())), (e.typeParameter = this.finishNode(t, 'TSTypeParameter')), this.finishNode(e, 'TSInferType');
          }
          tsParseConstraintForInferType() {
           if (this.eat(81)) {
            let e = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
            if (this.state.inDisallowConditionalTypesContext || !this.match(17)) return e;
           }
          }
          tsParseTypeOperatorOrHigher() {
           return (function (e) {
            return e >= 121 && e <= 123;
           })(this.state.type) && !this.state.containsEsc
            ? this.tsParseTypeOperator()
            : this.isContextual(115)
              ? this.tsParseInferType()
              : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
          }
          tsParseUnionOrIntersectionType(e, t, r) {
           let s = this.startNode(),
            n = this.eat(r),
            i = [];
           do {
            i.push(t());
           } while (this.eat(r));
           return 1 !== i.length || n ? ((s.types = i), this.finishNode(s, e)) : i[0];
          }
          tsParseIntersectionTypeOrHigher() {
           return this.tsParseUnionOrIntersectionType('TSIntersectionType', this.tsParseTypeOperatorOrHigher.bind(this), 45);
          }
          tsParseUnionTypeOrHigher() {
           return this.tsParseUnionOrIntersectionType('TSUnionType', this.tsParseIntersectionTypeOrHigher.bind(this), 43);
          }
          tsIsStartOfFunctionType() {
           return !!this.match(47) || (this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this)));
          }
          tsSkipParameterStart() {
           if ($(this.state.type) || this.match(78)) return this.next(), !0;
           if (this.match(5)) {
            let { errors: e } = this.state,
             t = e.length;
            try {
             return this.parseObjectLike(8, !0), e.length === t;
            } catch {
             return !1;
            }
           }
           if (this.match(0)) {
            this.next();
            let { errors: e } = this.state,
             t = e.length;
            try {
             return super.parseBindingList(3, 93, 1), e.length === t;
            } catch {
             return !1;
            }
           }
           return !1;
          }
          tsIsUnambiguouslyStartOfFunctionType() {
           return this.next(), !!(this.match(11) || this.match(21) || (this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(17) || this.match(29) || (this.match(11) && (this.next(), this.match(19))))));
          }
          tsParseTypeOrTypePredicateAnnotation(e) {
           return this.tsInType(() => {
            let t = this.startNode();
            this.expect(e);
            let r = this.startNode(),
             s = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
            if (s && this.match(78)) {
             let e = this.tsParseThisTypeOrThisTypePredicate();
             return 'TSThisType' === e.type ? ((r.parameterName = e), (r.asserts = !0), (r.typeAnnotation = null), (e = this.finishNode(r, 'TSTypePredicate'))) : (this.resetStartLocationFromNode(e, r), (e.asserts = !0)), (t.typeAnnotation = e), this.finishNode(t, 'TSTypeAnnotation');
            }
            let n = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
            if (!n) return s ? ((r.parameterName = this.parseIdentifier()), (r.asserts = s), (r.typeAnnotation = null), (t.typeAnnotation = this.finishNode(r, 'TSTypePredicate')), this.finishNode(t, 'TSTypeAnnotation')) : this.tsParseTypeAnnotation(!1, t);
            let i = this.tsParseTypeAnnotation(!1);
            return (r.parameterName = n), (r.typeAnnotation = i), (r.asserts = s), (t.typeAnnotation = this.finishNode(r, 'TSTypePredicate')), this.finishNode(t, 'TSTypeAnnotation');
           });
          }
          tsTryParseTypeOrTypePredicateAnnotation() {
           if (this.match(14)) return this.tsParseTypeOrTypePredicateAnnotation(14);
          }
          tsTryParseTypeAnnotation() {
           if (this.match(14)) return this.tsParseTypeAnnotation();
          }
          tsTryParseType() {
           return this.tsEatThenParseType(14);
          }
          tsParseTypePredicatePrefix() {
           let e = this.parseIdentifier();
           if (this.isContextual(116) && !this.hasPrecedingLineBreak()) return this.next(), e;
          }
          tsParseTypePredicateAsserts() {
           if (109 !== this.state.type) return !1;
           let e = this.state.containsEsc;
           return this.next(), !((!$(this.state.type) && !this.match(78)) || (e && this.raise(y.InvalidEscapedReservedWord, this.state.lastTokStartLoc, { reservedWord: 'asserts' }), 0));
          }
          tsParseTypeAnnotation(e = !0, t = this.startNode()) {
           return (
            this.tsInType(() => {
             e && this.expect(14), (t.typeAnnotation = this.tsParseType());
            }),
            this.finishNode(t, 'TSTypeAnnotation')
           );
          }
          tsParseType() {
           gt(this.state.inType);
           let e = this.tsParseNonConditionalType();
           if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) return e;
           let t = this.startNodeAtNode(e);
           return (t.checkType = e), (t.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType())), this.expect(17), (t.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType())), this.expect(14), (t.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType())), this.finishNode(t, 'TSConditionalType');
          }
          isAbstractConstructorSignature() {
           return this.isContextual(124) && 77 === this.lookahead().type;
          }
          tsParseNonConditionalType() {
           return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType('TSFunctionType') : this.match(77) ? this.tsParseFunctionOrConstructorType('TSConstructorType') : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType('TSConstructorType', !0) : this.tsParseUnionTypeOrHigher();
          }
          tsParseTypeAssertion() {
           this.getPluginOption('typescript', 'disallowAmbiguousJSXLike') && this.raise(xt.ReservedTypeAssertion, this.state.startLoc);
           let e = this.startNode();
           return (e.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType()))), this.expect(48), (e.expression = this.parseMaybeUnary()), this.finishNode(e, 'TSTypeAssertion');
          }
          tsParseHeritageClause(e) {
           let t = this.state.startLoc,
            r = this.tsParseDelimitedList('HeritageClauseElement', () => {
             let e = this.startNode();
             return (e.expression = this.tsParseEntityName(3)), this.match(47) && (e.typeParameters = this.tsParseTypeArguments()), this.finishNode(e, 'TSExpressionWithTypeArguments');
            });
           return r.length || this.raise(xt.EmptyHeritageClauseType, t, { token: e }), r;
          }
          tsParseInterfaceDeclaration(e, t = {}) {
           if (this.hasFollowingLineBreak()) return null;
           this.expectContextual(129), t.declare && (e.declare = !0), $(this.state.type) ? ((e.id = this.parseIdentifier()), this.checkIdentifier(e.id, 130)) : ((e.id = null), this.raise(xt.MissingInterfaceName, this.state.startLoc)), (e.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers)), this.eat(81) && (e.extends = this.tsParseHeritageClause('extends'));
           let r = this.startNode();
           return (r.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this))), (e.body = this.finishNode(r, 'TSInterfaceBody')), this.finishNode(e, 'TSInterfaceDeclaration');
          }
          tsParseTypeAliasDeclaration(e) {
           return (
            (e.id = this.parseIdentifier()),
            this.checkIdentifier(e.id, 2),
            (e.typeAnnotation = this.tsInType(() => {
             if (((e.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers)), this.expect(29), this.isContextual(114) && 16 !== this.lookahead().type)) {
              let e = this.startNode();
              return this.next(), this.finishNode(e, 'TSIntrinsicKeyword');
             }
             return this.tsParseType();
            })),
            this.semicolon(),
            this.finishNode(e, 'TSTypeAliasDeclaration')
           );
          }
          tsInTopLevelContext(e) {
           if (this.curContext() === b.brace) return e();
           {
            let t = this.state.context;
            this.state.context = [t[0]];
            try {
             return e();
            } finally {
             this.state.context = t;
            }
           }
          }
          tsInType(e) {
           let t = this.state.inType;
           this.state.inType = !0;
           try {
            return e();
           } finally {
            this.state.inType = t;
           }
          }
          tsInDisallowConditionalTypesContext(e) {
           let t = this.state.inDisallowConditionalTypesContext;
           this.state.inDisallowConditionalTypesContext = !0;
           try {
            return e();
           } finally {
            this.state.inDisallowConditionalTypesContext = t;
           }
          }
          tsInAllowConditionalTypesContext(e) {
           let t = this.state.inDisallowConditionalTypesContext;
           this.state.inDisallowConditionalTypesContext = !1;
           try {
            return e();
           } finally {
            this.state.inDisallowConditionalTypesContext = t;
           }
          }
          tsEatThenParseType(e) {
           if (this.match(e)) return this.tsNextThenParseType();
          }
          tsExpectThenParseType(e) {
           return this.tsInType(() => (this.expect(e), this.tsParseType()));
          }
          tsNextThenParseType() {
           return this.tsInType(() => (this.next(), this.tsParseType()));
          }
          tsParseEnumMember() {
           let e = this.startNode();
           return (e.id = this.match(134) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(!0)), this.eat(29) && (e.initializer = super.parseMaybeAssignAllowIn()), this.finishNode(e, 'TSEnumMember');
          }
          tsParseEnumDeclaration(e, t = {}) {
           return t.const && (e.const = !0), t.declare && (e.declare = !0), this.expectContextual(126), (e.id = this.parseIdentifier()), this.checkIdentifier(e.id, e.const ? 8971 : 8459), this.expect(5), (e.members = this.tsParseDelimitedList('EnumMembers', this.tsParseEnumMember.bind(this))), this.expect(8), this.finishNode(e, 'TSEnumDeclaration');
          }
          tsParseEnumBody() {
           let e = this.startNode();
           return this.expect(5), (e.members = this.tsParseDelimitedList('EnumMembers', this.tsParseEnumMember.bind(this))), this.expect(8), this.finishNode(e, 'TSEnumBody');
          }
          tsParseModuleBlock() {
           let e = this.startNode();
           return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody((e.body = []), void 0, !0, 8), this.scope.exit(), this.finishNode(e, 'TSModuleBlock');
          }
          tsParseModuleOrNamespaceDeclaration(e, t = !1) {
           if (((e.id = this.parseIdentifier()), t || this.checkIdentifier(e.id, 1024), this.eat(16))) {
            let t = this.startNode();
            this.tsParseModuleOrNamespaceDeclaration(t, !0), (e.body = t);
           } else this.scope.enter(256), this.prodParam.enter(0), (e.body = this.tsParseModuleBlock()), this.prodParam.exit(), this.scope.exit();
           return this.finishNode(e, 'TSModuleDeclaration');
          }
          tsParseAmbientExternalModuleDeclaration(e) {
           return this.isContextual(112) ? ((e.kind = 'global'), (e.global = !0), (e.id = this.parseIdentifier())) : this.match(134) ? ((e.kind = 'module'), (e.id = super.parseStringLiteral(this.state.value))) : this.unexpected(), this.match(5) ? (this.scope.enter(256), this.prodParam.enter(0), (e.body = this.tsParseModuleBlock()), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(e, 'TSModuleDeclaration');
          }
          tsParseImportEqualsDeclaration(e, t, r) {
           (e.isExport = r || !1), (e.id = t || this.parseIdentifier()), this.checkIdentifier(e.id, 4096), this.expect(29);
           let s = this.tsParseModuleReference();
           return 'type' === e.importKind && 'TSExternalModuleReference' !== s.type && this.raise(xt.ImportAliasHasImportType, s), (e.moduleReference = s), this.semicolon(), this.finishNode(e, 'TSImportEqualsDeclaration');
          }
          tsIsExternalModuleReference() {
           return this.isContextual(119) && 40 === this.lookaheadCharCode();
          }
          tsParseModuleReference() {
           return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(0);
          }
          tsParseExternalModuleReference() {
           let e = this.startNode();
           return this.expectContextual(119), this.expect(10), this.match(134) || this.unexpected(), (e.expression = super.parseExprAtom()), this.expect(11), (this.sawUnambiguousESM = !0), this.finishNode(e, 'TSExternalModuleReference');
          }
          tsLookAhead(e) {
           let t = this.state.clone(),
            r = e();
           return (this.state = t), r;
          }
          tsTryParseAndCatch(e) {
           let t = this.tryParse((t) => e() || t());
           if (!t.aborted && t.node) return t.error && (this.state = t.failState), t.node;
          }
          tsTryParse(e) {
           let t = this.state.clone(),
            r = e();
           if (void 0 !== r && !1 !== r) return r;
           this.state = t;
          }
          tsTryParseDeclare(e) {
           if (this.isLineTerminator()) return;
           let t,
            r = this.state.type;
           return (
            this.isContextual(100) && ((r = 74), (t = 'let')),
            this.tsInAmbientContext(() => {
             switch (r) {
              case 68:
               return (e.declare = !0), super.parseFunctionStatement(e, !1, !1);
              case 80:
               return (e.declare = !0), this.parseClass(e, !0, !1);
              case 126:
               return this.tsParseEnumDeclaration(e, { declare: !0 });
              case 112:
               return this.tsParseAmbientExternalModuleDeclaration(e);
              case 75:
              case 74:
               return this.match(75) && this.isLookaheadContextual('enum') ? (this.expect(75), this.tsParseEnumDeclaration(e, { const: !0, declare: !0 })) : ((e.declare = !0), this.parseVarStatement(e, t || this.state.value, !0));
              case 129: {
               let t = this.tsParseInterfaceDeclaration(e, { declare: !0 });
               if (t) return t;
              }
              default:
               if ($(r)) return this.tsParseDeclaration(e, this.state.value, !0, null);
             }
            })
           );
          }
          tsTryParseExportDeclaration() {
           return this.tsParseDeclaration(this.startNode(), this.state.value, !0, null);
          }
          tsParseExpressionStatement(e, t, r) {
           switch (t.name) {
            case 'declare': {
             let t = this.tsTryParseDeclare(e);
             return t && (t.declare = !0), t;
            }
            case 'global':
             if (this.match(5)) {
              this.scope.enter(256), this.prodParam.enter(0);
              let r = e;
              return (r.kind = 'global'), (e.global = !0), (r.id = t), (r.body = this.tsParseModuleBlock()), this.scope.exit(), this.prodParam.exit(), this.finishNode(r, 'TSModuleDeclaration');
             }
             break;
            default:
             return this.tsParseDeclaration(e, t.name, !1, r);
           }
          }
          tsParseDeclaration(e, t, r, s) {
           switch (t) {
            case 'abstract':
             if (this.tsCheckLineTerminator(r) && (this.match(80) || $(this.state.type))) return this.tsParseAbstractDeclaration(e, s);
             break;
            case 'module':
             if (this.tsCheckLineTerminator(r)) {
              if (this.match(134)) return this.tsParseAmbientExternalModuleDeclaration(e);
              if ($(this.state.type)) return (e.kind = 'module'), this.tsParseModuleOrNamespaceDeclaration(e);
             }
             break;
            case 'namespace':
             if (this.tsCheckLineTerminator(r) && $(this.state.type)) return (e.kind = 'namespace'), this.tsParseModuleOrNamespaceDeclaration(e);
             break;
            case 'type':
             if (this.tsCheckLineTerminator(r) && $(this.state.type)) return this.tsParseTypeAliasDeclaration(e);
           }
          }
          tsCheckLineTerminator(e) {
           return e ? !this.hasFollowingLineBreak() && (this.next(), !0) : !this.isLineTerminator();
          }
          tsTryParseGenericAsyncArrowFunction(e) {
           if (!this.match(47)) return;
           let t = this.state.maybeInArrowParameters;
           this.state.maybeInArrowParameters = !0;
           let r = this.tsTryParseAndCatch(() => {
            let t = this.startNodeAt(e);
            return (t.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier)), super.parseFunctionParams(t), (t.returnType = this.tsTryParseTypeOrTypePredicateAnnotation()), this.expect(19), t;
           });
           return (this.state.maybeInArrowParameters = t), r ? super.parseArrowExpression(r, null, !0) : void 0;
          }
          tsParseTypeArgumentsInExpression() {
           if (47 === this.reScan_lt()) return this.tsParseTypeArguments();
          }
          tsParseTypeArguments() {
           let e = this.startNode();
           return (e.params = this.tsInType(() => this.tsInTopLevelContext(() => (this.expect(47), this.tsParseDelimitedList('TypeParametersOrArguments', this.tsParseType.bind(this)))))), 0 === e.params.length ? this.raise(xt.EmptyTypeArguments, e) : !this.state.inType && this.curContext() === b.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(e, 'TSTypeParameterInstantiation');
          }
          tsIsDeclarationStart() {
           return (function (e) {
            return e >= 124 && e <= 130;
           })(this.state.type);
          }
          isExportDefaultSpecifier() {
           return !this.tsIsDeclarationStart() && super.isExportDefaultSpecifier();
          }
          parseAssignableListItem(e, t) {
           let r = this.state.startLoc,
            s = {};
           this.tsParseModifiers({ allowedModifiers: ['public', 'private', 'protected', 'override', 'readonly'] }, s);
           let n = s.accessibility,
            i = s.override,
            a = s.readonly;
           !(4 & e) && (n || a || i) && this.raise(xt.UnexpectedParameterModifier, r);
           let o = this.parseMaybeDefault();
           2 & e && this.parseFunctionParamType(o);
           let u = this.parseMaybeDefault(o.loc.start, o);
           if (n || a || i) {
            let e = this.startNodeAt(r);
            return t.length && (e.decorators = t), n && (e.accessibility = n), a && (e.readonly = a), i && (e.override = i), 'Identifier' !== u.type && 'AssignmentPattern' !== u.type && this.raise(xt.UnsupportedParameterPropertyKind, e), (e.parameter = u), this.finishNode(e, 'TSParameterProperty');
           }
           return t.length && (o.decorators = t), u;
          }
          isSimpleParameter(e) {
           return ('TSParameterProperty' === e.type && super.isSimpleParameter(e.parameter)) || super.isSimpleParameter(e);
          }
          tsDisallowOptionalPattern(e) {
           for (let t of e.params) 'Identifier' !== t.type && t.optional && !this.state.isAmbientContext && this.raise(xt.PatternIsOptional, t);
          }
          setArrowFunctionParameters(e, t, r) {
           super.setArrowFunctionParameters(e, t, r), this.tsDisallowOptionalPattern(e);
          }
          parseFunctionBodyAndFinish(e, t, r = !1) {
           this.match(14) && (e.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
           let s = 'FunctionDeclaration' === t ? 'TSDeclareFunction' : 'ClassMethod' === t || 'ClassPrivateMethod' === t ? 'TSDeclareMethod' : void 0;
           return s && !this.match(5) && this.isLineTerminator() ? this.finishNode(e, s) : 'TSDeclareFunction' === s && this.state.isAmbientContext && (this.raise(xt.DeclareFunctionHasImplementation, e), e.declare) ? super.parseFunctionBodyAndFinish(e, s, r) : (this.tsDisallowOptionalPattern(e), super.parseFunctionBodyAndFinish(e, t, r));
          }
          registerFunctionStatementId(e) {
           !e.body && e.id ? this.checkIdentifier(e.id, 1024) : super.registerFunctionStatementId(e);
          }
          tsCheckForInvalidTypeCasts(e) {
           e.forEach((e) => {
            'TSTypeCastExpression' === (null == e ? void 0 : e.type) && this.raise(xt.UnexpectedTypeAnnotation, e.typeAnnotation);
           });
          }
          toReferencedList(e, t) {
           return this.tsCheckForInvalidTypeCasts(e), e;
          }
          parseArrayLike(e, t, r, s) {
           let n = super.parseArrayLike(e, t, r, s);
           return 'ArrayExpression' === n.type && this.tsCheckForInvalidTypeCasts(n.elements), n;
          }
          parseSubscript(e, t, r, s) {
           if (!this.hasPrecedingLineBreak() && this.match(35)) {
            (this.state.canStartJSXElement = !1), this.next();
            let r = this.startNodeAt(t);
            return (r.expression = e), this.finishNode(r, 'TSNonNullExpression');
           }
           let n = !1;
           if (this.match(18) && 60 === this.lookaheadCharCode()) {
            if (r) return (s.stop = !0), e;
            (s.optionalChainMember = n = !0), this.next();
           }
           if (this.match(47) || this.match(51)) {
            let i,
             a = this.tsTryParseAndCatch(() => {
              if (!r && this.atPossibleAsyncArrow(e)) {
               let e = this.tsTryParseGenericAsyncArrowFunction(t);
               if (e) return e;
              }
              let a = this.tsParseTypeArgumentsInExpression();
              if (!a) return;
              if (n && !this.match(10)) return void (i = this.state.curPosition());
              if (X(this.state.type)) {
               let r = super.parseTaggedTemplateExpression(e, t, s);
               return (r.typeParameters = a), r;
              }
              if (!r && this.eat(10)) {
               let r = this.startNodeAt(t);
               return (r.callee = e), (r.arguments = this.parseCallExpressionArguments(11)), this.tsCheckForInvalidTypeCasts(r.arguments), (r.typeParameters = a), s.optionalChainMember && (r.optional = n), this.finishCallExpression(r, s.optionalChainMember);
              }
              let o = this.state.type;
              if (48 === o || 52 === o || (10 !== o && W(o) && !this.hasPrecedingLineBreak())) return;
              let u = this.startNodeAt(t);
              return (u.expression = e), (u.typeParameters = a), this.finishNode(u, 'TSInstantiationExpression');
             });
            if ((i && this.unexpected(i, 10), a)) return 'TSInstantiationExpression' === a.type && (this.match(16) || (this.match(18) && 40 !== this.lookaheadCharCode())) && this.raise(xt.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc), a;
           }
           return super.parseSubscript(e, t, r, s);
          }
          parseNewCallee(e) {
           var t;
           super.parseNewCallee(e);
           let { callee: r } = e;
           'TSInstantiationExpression' === r.type && (null == (t = r.extra) || !t.parenthesized) && ((e.typeParameters = r.typeParameters), (e.callee = r.expression));
          }
          parseExprOp(e, t, r) {
           let s;
           if (K(58) > r && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (s = this.isContextual(120)))) {
            let n = this.startNodeAt(t);
            return (n.expression = e), (n.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (s && this.raise(y.UnexpectedKeyword, this.state.startLoc, { keyword: 'const' }), this.tsParseTypeReference()) : this.tsParseType()))), this.finishNode(n, s ? 'TSSatisfiesExpression' : 'TSAsExpression'), this.reScan_lt_gt(), this.parseExprOp(n, t, r);
           }
           return super.parseExprOp(e, t, r);
          }
          checkReservedWord(e, t, r, s) {
           this.state.isAmbientContext || super.checkReservedWord(e, t, r, s);
          }
          checkImportReflection(e) {
           super.checkImportReflection(e), e.module && 'value' !== e.importKind && this.raise(xt.ImportReflectionHasImportType, e.specifiers[0].loc.start);
          }
          checkDuplicateExports() {}
          isPotentialImportPhase(e) {
           if (super.isPotentialImportPhase(e)) return !0;
           if (this.isContextual(130)) {
            let t = this.lookaheadCharCode();
            return e ? 123 === t || 42 === t : 61 !== t;
           }
           return !e && this.isContextual(87);
          }
          applyImportPhase(e, t, r, s) {
           super.applyImportPhase(e, t, r, s), t ? (e.exportKind = 'type' === r ? 'type' : 'value') : (e.importKind = 'type' === r || 'typeof' === r ? r : 'value');
          }
          parseImport(e) {
           if (this.match(134)) return (e.importKind = 'value'), super.parseImport(e);
           let t;
           if ($(this.state.type) && 61 === this.lookaheadCharCode()) return (e.importKind = 'value'), this.tsParseImportEqualsDeclaration(e);
           if (this.isContextual(130)) {
            let r = this.parseMaybeImportPhase(e, !1);
            if (61 === this.lookaheadCharCode()) return this.tsParseImportEqualsDeclaration(e, r);
            t = super.parseImportSpecifiersAndAfter(e, r);
           } else t = super.parseImport(e);
           return 'type' === t.importKind && t.specifiers.length > 1 && 'ImportDefaultSpecifier' === t.specifiers[0].type && this.raise(xt.TypeImportCannotSpecifyDefaultAndNamed, t), t;
          }
          parseExport(e, t) {
           if (this.match(83)) {
            let t = e;
            this.next();
            let r = null;
            return this.isContextual(130) && this.isPotentialImportPhase(!1) ? (r = this.parseMaybeImportPhase(t, !1)) : (t.importKind = 'value'), this.tsParseImportEqualsDeclaration(t, r, !0);
           }
           if (this.eat(29)) {
            let t = e;
            return (t.expression = super.parseExpression()), this.semicolon(), (this.sawUnambiguousESM = !0), this.finishNode(t, 'TSExportAssignment');
           }
           if (this.eatContextual(93)) {
            let t = e;
            return this.expectContextual(128), (t.id = this.parseIdentifier()), this.semicolon(), this.finishNode(t, 'TSNamespaceExportDeclaration');
           }
           return super.parseExport(e, t);
          }
          isAbstractClass() {
           return this.isContextual(124) && 80 === this.lookahead().type;
          }
          parseExportDefaultExpression() {
           if (this.isAbstractClass()) {
            let e = this.startNode();
            return this.next(), (e.abstract = !0), this.parseClass(e, !0, !0);
           }
           if (this.match(129)) {
            let e = this.tsParseInterfaceDeclaration(this.startNode());
            if (e) return e;
           }
           return super.parseExportDefaultExpression();
          }
          parseVarStatement(e, t, r = !1) {
           let { isAmbientContext: s } = this.state,
            n = super.parseVarStatement(e, t, r || s);
           if (!s) return n;
           for (let { id: i, init: a } of n.declarations) a && ('const' !== t || i.typeAnnotation ? this.raise(xt.InitializerNotAllowedInAmbientContext, a) : At(a, this.hasPlugin('estree')) || this.raise(xt.ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference, a));
           return n;
          }
          parseStatementContent(e, t) {
           if (this.match(75) && this.isLookaheadContextual('enum')) {
            let e = this.startNode();
            return this.expect(75), this.tsParseEnumDeclaration(e, { const: !0 });
           }
           if (this.isContextual(126)) return this.tsParseEnumDeclaration(this.startNode());
           if (this.isContextual(129)) {
            let e = this.tsParseInterfaceDeclaration(this.startNode());
            if (e) return e;
           }
           return super.parseStatementContent(e, t);
          }
          parseAccessModifier() {
           return this.tsParseModifier(['public', 'protected', 'private']);
          }
          tsHasSomeModifiers(e, t) {
           return t.some((t) => (Et(t) ? e.accessibility === t : !!e[t]));
          }
          tsIsStartOfStaticBlocks() {
           return this.isContextual(106) && 123 === this.lookaheadCharCode();
          }
          parseClassMember(e, t, r) {
           let s = ['declare', 'private', 'public', 'protected', 'override', 'abstract', 'readonly', 'static'];
           this.tsParseModifiers({ allowedModifiers: s, disallowedModifiers: ['in', 'out'], stopOnStartOfClassStaticBlock: !0, errorTemplate: xt.InvalidModifierOnTypeParameterPositions }, t);
           let n = () => {
            this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(t, s) && this.raise(xt.StaticBlockCannotHaveModifier, this.state.curPosition()), super.parseClassStaticBlock(e, t)) : this.parseClassMemberWithIsStatic(e, t, r, !!t.static);
           };
           t.declare ? this.tsInAmbientContext(n) : n();
          }
          parseClassMemberWithIsStatic(e, t, r, s) {
           let n = this.tsTryParseIndexSignature(t);
           if (n) return e.body.push(n), t.abstract && this.raise(xt.IndexSignatureHasAbstract, t), t.accessibility && this.raise(xt.IndexSignatureHasAccessibility, t, { modifier: t.accessibility }), t.declare && this.raise(xt.IndexSignatureHasDeclare, t), void (t.override && this.raise(xt.IndexSignatureHasOverride, t));
           !this.state.inAbstractClass && t.abstract && this.raise(xt.NonAbstractClassHasAbstractMethod, t), t.override && (r.hadSuperClass || this.raise(xt.OverrideNotInSubClass, t)), super.parseClassMemberWithIsStatic(e, t, r, s);
          }
          parsePostMemberNameModifiers(e) {
           this.eat(17) && (e.optional = !0), e.readonly && this.match(10) && this.raise(xt.ClassMethodHasReadonly, e), e.declare && this.match(10) && this.raise(xt.ClassMethodHasDeclare, e);
          }
          parseExpressionStatement(e, t, r) {
           return ('Identifier' === t.type ? this.tsParseExpressionStatement(e, t, r) : void 0) || super.parseExpressionStatement(e, t, r);
          }
          shouldParseExportDeclaration() {
           return !!this.tsIsDeclarationStart() || super.shouldParseExportDeclaration();
          }
          parseConditional(e, t, r) {
           if (!this.state.maybeInArrowParameters || !this.match(17)) return super.parseConditional(e, t, r);
           let s = this.tryParse(() => super.parseConditional(e, t));
           return s.node ? (s.error && (this.state = s.failState), s.node) : (s.error && super.setOptionalParametersError(r, s.error), e);
          }
          parseParenItem(e, t) {
           let r = super.parseParenItem(e, t);
           if ((this.eat(17) && ((r.optional = !0), this.resetEndLocation(e)), this.match(14))) {
            let r = this.startNodeAt(t);
            return (r.expression = e), (r.typeAnnotation = this.tsParseTypeAnnotation()), this.finishNode(r, 'TSTypeCastExpression');
           }
           return e;
          }
          parseExportDeclaration(e) {
           if (!this.state.isAmbientContext && this.isContextual(125)) return this.tsInAmbientContext(() => this.parseExportDeclaration(e));
           let t = this.state.startLoc,
            r = this.eatContextual(125);
           if (r && (this.isContextual(125) || !this.shouldParseExportDeclaration())) throw this.raise(xt.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
           let s = ($(this.state.type) && this.tsTryParseExportDeclaration()) || super.parseExportDeclaration(e);
           return s ? (('TSInterfaceDeclaration' === s.type || 'TSTypeAliasDeclaration' === s.type || r) && (e.exportKind = 'type'), r && 'TSImportEqualsDeclaration' !== s.type && (this.resetStartLocation(s, t), (s.declare = !0)), s) : null;
          }
          parseClassId(e, t, r, s) {
           if ((!t || r) && this.isContextual(113)) return;
           super.parseClassId(e, t, r, e.declare ? 1024 : 8331);
           let n = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
           n && (e.typeParameters = n);
          }
          parseClassPropertyAnnotation(e) {
           e.optional || (this.eat(35) ? (e.definite = !0) : this.eat(17) && (e.optional = !0));
           let t = this.tsTryParseTypeAnnotation();
           t && (e.typeAnnotation = t);
          }
          parseClassProperty(e) {
           if ((this.parseClassPropertyAnnotation(e), this.state.isAmbientContext && !(e.readonly && !e.typeAnnotation) && this.match(29) && this.raise(xt.DeclareClassFieldHasInitializer, this.state.startLoc), e.abstract && this.match(29))) {
            let { key: t } = e;
            this.raise(xt.AbstractPropertyHasInitializer, this.state.startLoc, { propertyName: 'Identifier' !== t.type || e.computed ? `[${this.input.slice(this.offsetToSourcePos(t.start), this.offsetToSourcePos(t.end))}]` : t.name });
           }
           return super.parseClassProperty(e);
          }
          parseClassPrivateProperty(e) {
           return e.abstract && this.raise(xt.PrivateElementHasAbstract, e), e.accessibility && this.raise(xt.PrivateElementHasAccessibility, e, { modifier: e.accessibility }), this.parseClassPropertyAnnotation(e), super.parseClassPrivateProperty(e);
          }
          parseClassAccessorProperty(e) {
           return this.parseClassPropertyAnnotation(e), e.optional && this.raise(xt.AccessorCannotBeOptional, e), super.parseClassAccessorProperty(e);
          }
          pushClassMethod(e, t, r, s, n, i) {
           let a = this.tsTryParseTypeParameters(this.tsParseConstModifier);
           a && n && this.raise(xt.ConstructorHasTypeParameters, a);
           let { declare: o = !1, kind: u } = t;
           o && ('get' === u || 'set' === u) && this.raise(xt.DeclareAccessor, t, { kind: u }), a && (t.typeParameters = a), super.pushClassMethod(e, t, r, s, n, i);
          }
          pushClassPrivateMethod(e, t, r, s) {
           let n = this.tsTryParseTypeParameters(this.tsParseConstModifier);
           n && (t.typeParameters = n), super.pushClassPrivateMethod(e, t, r, s);
          }
          declareClassPrivateMethodInScope(e, t) {
           'TSDeclareMethod' !== e.type && (('MethodDefinition' === e.type && !hasOwnProperty.call(e.value, 'body')) || super.declareClassPrivateMethodInScope(e, t));
          }
          parseClassSuper(e) {
           super.parseClassSuper(e), e.superClass && (this.match(47) || this.match(51)) && (e.superTypeParameters = this.tsParseTypeArgumentsInExpression()), this.eatContextual(113) && (e.implements = this.tsParseHeritageClause('implements'));
          }
          parseObjPropValue(e, t, r, s, n, i, a) {
           let o = this.tsTryParseTypeParameters(this.tsParseConstModifier);
           return o && (e.typeParameters = o), super.parseObjPropValue(e, t, r, s, n, i, a);
          }
          parseFunctionParams(e, t) {
           let r = this.tsTryParseTypeParameters(this.tsParseConstModifier);
           r && (e.typeParameters = r), super.parseFunctionParams(e, t);
          }
          parseVarId(e, t) {
           super.parseVarId(e, t), 'Identifier' === e.id.type && !this.hasPrecedingLineBreak() && this.eat(35) && (e.definite = !0);
           let r = this.tsTryParseTypeAnnotation();
           r && ((e.id.typeAnnotation = r), this.resetEndLocation(e.id));
          }
          parseAsyncArrowFromCallExpression(e, t) {
           return this.match(14) && (e.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(e, t);
          }
          parseMaybeAssign(e, t) {
           var r, s, n, i, a;
           let o, u, l;
           if (this.hasPlugin('jsx') && (this.match(143) || this.match(47))) {
            if (((o = this.state.clone()), (u = this.tryParse(() => super.parseMaybeAssign(e, t), o)), !u.error)) return u.node;
            let { context: r } = this.state,
             s = r[r.length - 1];
            (s === b.j_oTag || s === b.j_expr) && r.pop();
           }
           if (!((null != (r = u) && r.error) || this.match(47))) return super.parseMaybeAssign(e, t);
           (!o || o === this.state) && (o = this.state.clone());
           let p,
            c = this.tryParse((r) => {
             var s, n;
             p = this.tsParseTypeParameters(this.tsParseConstModifier);
             let i = super.parseMaybeAssign(e, t);
             return ('ArrowFunctionExpression' !== i.type || (null != (s = i.extra) && s.parenthesized)) && r(), 0 !== (null == (n = p) ? void 0 : n.params.length) && this.resetStartLocationFromNode(i, p), (i.typeParameters = p), i;
            }, o);
           if (!c.error && !c.aborted) return p && this.reportReservedArrowTypeParam(p), c.node;
           if (!u && (gt(!this.hasPlugin('jsx')), (l = this.tryParse(() => super.parseMaybeAssign(e, t), o)), !l.error)) return l.node;
           if (null != (s = u) && s.node) return (this.state = u.failState), u.node;
           if (c.node) return (this.state = c.failState), p && this.reportReservedArrowTypeParam(p), c.node;
           if (null != (n = l) && n.node) return (this.state = l.failState), l.node;
           throw (null == (i = u) ? void 0 : i.error) || c.error || (null == (a = l) ? void 0 : a.error);
          }
          reportReservedArrowTypeParam(e) {
           var t;
           1 === e.params.length && !e.params[0].constraint && (null == (t = e.extra) || !t.trailingComma) && this.getPluginOption('typescript', 'disallowAmbiguousJSXLike') && this.raise(xt.ReservedArrowTypeParam, e);
          }
          parseMaybeUnary(e, t) {
           return !this.hasPlugin('jsx') && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(e, t);
          }
          parseArrow(e) {
           if (this.match(14)) {
            let t = this.tryParse((e) => {
             let t = this.tsParseTypeOrTypePredicateAnnotation(14);
             return (this.canInsertSemicolon() || !this.match(19)) && e(), t;
            });
            if (t.aborted) return;
            t.thrown || (t.error && (this.state = t.failState), (e.returnType = t.node));
           }
           return super.parseArrow(e);
          }
          parseFunctionParamType(e) {
           this.eat(17) && (e.optional = !0);
           let t = this.tsTryParseTypeAnnotation();
           return t && (e.typeAnnotation = t), this.resetEndLocation(e), e;
          }
          isAssignable(e, t) {
           switch (e.type) {
            case 'TSTypeCastExpression':
             return this.isAssignable(e.expression, t);
            case 'TSParameterProperty':
             return !0;
            default:
             return super.isAssignable(e, t);
           }
          }
          toAssignable(e, t = !1) {
           switch (e.type) {
            case 'ParenthesizedExpression':
             this.toAssignableParenthesizedExpression(e, t);
             break;
            case 'TSAsExpression':
            case 'TSSatisfiesExpression':
            case 'TSNonNullExpression':
            case 'TSTypeAssertion':
             t ? this.expressionScope.recordArrowParameterBindingError(xt.UnexpectedTypeCastInParameter, e) : this.raise(xt.UnexpectedTypeCastInParameter, e), this.toAssignable(e.expression, t);
             break;
            case 'AssignmentExpression':
             !t && 'TSTypeCastExpression' === e.left.type && (e.left = this.typeCastToParameter(e.left));
            default:
             super.toAssignable(e, t);
           }
          }
          toAssignableParenthesizedExpression(e, t) {
           switch (e.expression.type) {
            case 'TSAsExpression':
            case 'TSSatisfiesExpression':
            case 'TSNonNullExpression':
            case 'TSTypeAssertion':
            case 'ParenthesizedExpression':
             this.toAssignable(e.expression, t);
             break;
            default:
             super.toAssignable(e, t);
           }
          }
          checkToRestConversion(e, t) {
           switch (e.type) {
            case 'TSAsExpression':
            case 'TSSatisfiesExpression':
            case 'TSTypeAssertion':
            case 'TSNonNullExpression':
             this.checkToRestConversion(e.expression, !1);
             break;
            default:
             super.checkToRestConversion(e, t);
           }
          }
          isValidLVal(e, t, r) {
           switch (e) {
            case 'TSTypeCastExpression':
             return !0;
            case 'TSParameterProperty':
             return 'parameter';
            case 'TSNonNullExpression':
            case 'TSInstantiationExpression':
             return 'expression';
            case 'TSAsExpression':
            case 'TSSatisfiesExpression':
            case 'TSTypeAssertion':
             return (64 !== r || !t) && ['expression', !0];
            default:
             return super.isValidLVal(e, t, r);
           }
          }
          parseBindingAtom() {
           return 78 === this.state.type ? this.parseIdentifier(!0) : super.parseBindingAtom();
          }
          parseMaybeDecoratorArguments(e, t) {
           if (this.match(47) || this.match(51)) {
            let r = this.tsParseTypeArgumentsInExpression();
            if (this.match(10)) {
             let s = super.parseMaybeDecoratorArguments(e, t);
             return (s.typeParameters = r), s;
            }
            this.unexpected(null, 10);
           }
           return super.parseMaybeDecoratorArguments(e, t);
          }
          checkCommaAfterRest(e) {
           return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === e ? (this.next(), !1) : super.checkCommaAfterRest(e);
          }
          isClassMethod() {
           return this.match(47) || super.isClassMethod();
          }
          isClassProperty() {
           return this.match(35) || this.match(14) || super.isClassProperty();
          }
          parseMaybeDefault(e, t) {
           let r = super.parseMaybeDefault(e, t);
           return 'AssignmentPattern' === r.type && r.typeAnnotation && r.right.start < r.typeAnnotation.start && this.raise(xt.TypeAnnotationAfterAssign, r.typeAnnotation), r;
          }
          getTokenFromCode(e) {
           if (this.state.inType) {
            if (62 === e) return void this.finishOp(48, 1);
            if (60 === e) return void this.finishOp(47, 1);
           }
           super.getTokenFromCode(e);
          }
          reScan_lt_gt() {
           let { type: e } = this.state;
           47 === e ? ((this.state.pos -= 1), this.readToken_lt()) : 48 === e && ((this.state.pos -= 1), this.readToken_gt());
          }
          reScan_lt() {
           let { type: e } = this.state;
           return 51 === e ? ((this.state.pos -= 2), this.finishOp(47, 1), 47) : e;
          }
          toAssignableList(e, t, r) {
           for (let s = 0; s < e.length; s++) {
            let t = e[s];
            'TSTypeCastExpression' === (null == t ? void 0 : t.type) && (e[s] = this.typeCastToParameter(t));
           }
           super.toAssignableList(e, t, r);
          }
          typeCastToParameter(e) {
           return (e.expression.typeAnnotation = e.typeAnnotation), this.resetEndLocation(e.expression, e.typeAnnotation.loc.end), e.expression;
          }
          shouldParseArrow(e) {
           return this.match(14) ? e.every((e) => this.isAssignable(e, !0)) : super.shouldParseArrow(e);
          }
          shouldParseAsyncArrow() {
           return this.match(14) || super.shouldParseAsyncArrow();
          }
          canHaveLeadingDecorator() {
           return super.canHaveLeadingDecorator() || this.isAbstractClass();
          }
          jsxParseOpeningElementAfterName(e) {
           if (this.match(47) || this.match(51)) {
            let t = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
            t && (e.typeParameters = t);
           }
           return super.jsxParseOpeningElementAfterName(e);
          }
          getGetterSetterExpectedParamCount(e) {
           let t = super.getGetterSetterExpectedParamCount(e),
            r = this.getObjectOrClassMethodParams(e)[0];
           return r && this.isThisParam(r) ? t + 1 : t;
          }
          parseCatchClauseParam() {
           let e = super.parseCatchClauseParam(),
            t = this.tsTryParseTypeAnnotation();
           return t && ((e.typeAnnotation = t), this.resetEndLocation(e)), e;
          }
          tsInAmbientContext(e) {
           let { isAmbientContext: t, strict: r } = this.state;
           (this.state.isAmbientContext = !0), (this.state.strict = !1);
           try {
            return e();
           } finally {
            (this.state.isAmbientContext = t), (this.state.strict = r);
           }
          }
          parseClass(e, t, r) {
           let s = this.state.inAbstractClass;
           this.state.inAbstractClass = !!e.abstract;
           try {
            return super.parseClass(e, t, r);
           } finally {
            this.state.inAbstractClass = s;
           }
          }
          tsParseAbstractDeclaration(e, t) {
           if (this.match(80)) return (e.abstract = !0), this.maybeTakeDecorators(t, this.parseClass(e, !0, !1));
           if (this.isContextual(129)) {
            if (!this.hasFollowingLineBreak()) return (e.abstract = !0), this.raise(xt.NonClassMethodPropertyHasAbstractModifer, e), this.tsParseInterfaceDeclaration(e);
           } else this.unexpected(null, 80);
          }
          parseMethod(e, t, r, s, n, i, a) {
           let o = super.parseMethod(e, t, r, s, n, i, a);
           if (o.abstract && (this.hasPlugin('estree') ? o.value : o).body) {
            let { key: e } = o;
            this.raise(xt.AbstractMethodHasImplementation, o, { methodName: 'Identifier' !== e.type || o.computed ? `[${this.input.slice(this.offsetToSourcePos(e.start), this.offsetToSourcePos(e.end))}]` : e.name });
           }
           return o;
          }
          tsParseTypeParameterName() {
           return this.parseIdentifier().name;
          }
          shouldParseAsAmbientContext() {
           return !!this.getPluginOption('typescript', 'dts');
          }
          parse() {
           return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.parse();
          }
          getExpression() {
           return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.getExpression();
          }
          parseExportSpecifier(e, t, r, s) {
           return !t && s ? (this.parseTypeOnlyImportExportSpecifier(e, !1, r), this.finishNode(e, 'ExportSpecifier')) : ((e.exportKind = 'value'), super.parseExportSpecifier(e, t, r, s));
          }
          parseImportSpecifier(e, t, r, s, n) {
           return !t && s ? (this.parseTypeOnlyImportExportSpecifier(e, !0, r), this.finishNode(e, 'ImportSpecifier')) : ((e.importKind = 'value'), super.parseImportSpecifier(e, t, r, s, r ? 4098 : 4096));
          }
          parseTypeOnlyImportExportSpecifier(e, t, r) {
           let s,
            n = t ? 'imported' : 'local',
            i = t ? 'local' : 'exported',
            a = e[n],
            o = !1,
            u = !0,
            l = a.loc.start;
           if (this.isContextual(93)) {
            let e = this.parseIdentifier();
            if (this.isContextual(93)) {
             let r = this.parseIdentifier();
             q(this.state.type) ? ((o = !0), (a = e), (s = t ? this.parseIdentifier() : this.parseModuleExportName()), (u = !1)) : ((s = r), (u = !1));
            } else q(this.state.type) ? ((u = !1), (s = t ? this.parseIdentifier() : this.parseModuleExportName())) : ((o = !0), (a = e));
           } else q(this.state.type) && ((o = !0), t ? ((a = this.parseIdentifier(!0)), this.isContextual(93) || this.checkReservedWord(a.name, a.loc.start, !0, !0)) : (a = this.parseModuleExportName()));
           o && r && this.raise(t ? xt.TypeModifierIsUsedInTypeImports : xt.TypeModifierIsUsedInTypeExports, l), (e[n] = a), (e[i] = s), (e[t ? 'importKind' : 'exportKind'] = o ? 'type' : 'value'), u && this.eatContextual(93) && (e[i] = t ? this.parseIdentifier() : this.parseModuleExportName()), e[i] || (e[i] = st(e[n])), t && this.checkIdentifier(e[i], o ? 4098 : 4096);
          }
         },
        v8intrinsic: (e) =>
         class extends e {
          parseV8Intrinsic() {
           if (this.match(54)) {
            let e = this.state.startLoc,
             t = this.startNode();
            if ((this.next(), $(this.state.type))) {
             let e = this.parseIdentifierName(),
              r = this.createIdentifier(t, e);
             if (((r.type = 'V8IntrinsicIdentifier'), this.match(10))) return r;
            }
            this.unexpected(e);
           }
          }
          parseExprAtom(e) {
           return this.parseV8Intrinsic() || super.parseExprAtom(e);
          }
         },
        placeholders: (e) =>
         class extends e {
          parsePlaceholder(e) {
           if (this.match(133)) {
            let t = this.startNode();
            return this.next(), this.assertNoSpace(), (t.name = super.parseIdentifier(!0)), this.assertNoSpace(), this.expect(133), this.finishPlaceholder(t, e);
           }
          }
          finishPlaceholder(e, t) {
           let r = e;
           return (!r.expectedNode || !r.type) && (r = this.finishNode(r, 'Placeholder')), (r.expectedNode = t), r;
          }
          getTokenFromCode(e) {
           37 === e && 37 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(133, 2) : super.getTokenFromCode(e);
          }
          parseExprAtom(e) {
           return this.parsePlaceholder('Expression') || super.parseExprAtom(e);
          }
          parseIdentifier(e) {
           return this.parsePlaceholder('Identifier') || super.parseIdentifier(e);
          }
          checkReservedWord(e, t, r, s) {
           void 0 !== e && super.checkReservedWord(e, t, r, s);
          }
          parseBindingAtom() {
           return this.parsePlaceholder('Pattern') || super.parseBindingAtom();
          }
          isValidLVal(e, t, r) {
           return 'Placeholder' === e || super.isValidLVal(e, t, r);
          }
          toAssignable(e, t) {
           e && 'Placeholder' === e.type && 'Expression' === e.expectedNode ? (e.expectedNode = 'Pattern') : super.toAssignable(e, t);
          }
          chStartsBindingIdentifier(e, t) {
           return !(!super.chStartsBindingIdentifier(e, t) && 133 !== this.lookahead().type);
          }
          verifyBreakContinue(e, t) {
           (e.label && 'Placeholder' === e.label.type) || super.verifyBreakContinue(e, t);
          }
          parseExpressionStatement(e, t) {
           var r;
           if ('Placeholder' !== t.type || (null != (r = t.extra) && r.parenthesized)) return super.parseExpressionStatement(e, t);
           if (this.match(14)) {
            let r = e;
            return (r.label = this.finishPlaceholder(t, 'Identifier')), this.next(), (r.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration()), this.finishNode(r, 'LabeledStatement');
           }
           this.semicolon();
           let s = e;
           return (s.name = t.name), this.finishPlaceholder(s, 'Statement');
          }
          parseBlock(e, t, r) {
           return this.parsePlaceholder('BlockStatement') || super.parseBlock(e, t, r);
          }
          parseFunctionId(e) {
           return this.parsePlaceholder('Identifier') || super.parseFunctionId(e);
          }
          parseClass(e, t, r) {
           let s = t ? 'ClassDeclaration' : 'ClassExpression';
           this.next();
           let n = this.state.strict,
            i = this.parsePlaceholder('Identifier');
           if (i) {
            if (!(this.match(81) || this.match(133) || this.match(5))) {
             if (r || !t) return (e.id = null), (e.body = this.finishPlaceholder(i, 'ClassBody')), this.finishNode(e, s);
             throw this.raise(Ft.ClassNameIsRequired, this.state.startLoc);
            }
            e.id = i;
           } else this.parseClassId(e, t, r);
           return super.parseClassSuper(e), (e.body = this.parsePlaceholder('ClassBody') || super.parseClassBody(!!e.superClass, n)), this.finishNode(e, s);
          }
          parseExport(e, t) {
           let r = this.parsePlaceholder('Identifier');
           if (!r) return super.parseExport(e, t);
           let s = e;
           if (!this.isContextual(98) && !this.match(12)) return (s.specifiers = []), (s.source = null), (s.declaration = this.finishPlaceholder(r, 'Declaration')), this.finishNode(s, 'ExportNamedDeclaration');
           this.expectPlugin('exportDefaultFrom');
           let n = this.startNode();
           return (n.exported = r), (s.specifiers = [this.finishNode(n, 'ExportDefaultSpecifier')]), super.parseExport(s, t);
          }
          isExportDefaultSpecifier() {
           if (this.match(65)) {
            let e = this.nextTokenStart();
            if (this.isUnparsedContextual(e, 'from') && this.input.startsWith(H(133), this.nextTokenStartSince(e + 4))) return !0;
           }
           return super.isExportDefaultSpecifier();
          }
          maybeParseExportDefaultSpecifier(e, t) {
           var r;
           return !(null == (r = e.specifiers) || !r.length) || super.maybeParseExportDefaultSpecifier(e, t);
          }
          checkExport(e) {
           let { specifiers: t } = e;
           null != t && t.length && (e.specifiers = t.filter((e) => 'Placeholder' === e.exported.type)), super.checkExport(e), (e.specifiers = t);
          }
          parseImport(e) {
           let t = this.parsePlaceholder('Identifier');
           if (!t) return super.parseImport(e);
           if (((e.specifiers = []), !this.isContextual(98) && !this.match(12))) return (e.source = this.finishPlaceholder(t, 'StringLiteral')), this.semicolon(), this.finishNode(e, 'ImportDeclaration');
           let r = this.startNodeAtNode(t);
           return (r.local = t), e.specifiers.push(this.finishNode(r, 'ImportDefaultSpecifier')), this.eat(12) && (this.maybeParseStarImportSpecifier(e) || this.parseNamedImportSpecifiers(e)), this.expectContextual(98), (e.source = this.parseImportSource()), this.semicolon(), this.finishNode(e, 'ImportDeclaration');
          }
          parseImportSource() {
           return this.parsePlaceholder('StringLiteral') || super.parseImportSource();
          }
          assertNoSpace() {
           this.state.start > this.offsetToSourcePos(this.state.lastTokEndLoc.index) && this.raise(Ft.UnexpectedSpace, this.state.lastTokEndLoc);
          }
         },
       },
       kt = Object.keys(Pt),
       It = class extends Dt {
        checkProto(e, t, r, s) {
         if ('SpreadElement' === e.type || this.isObjectMethod(e) || e.computed || e.shorthand) return;
         let n = e.key;
         if ('__proto__' === ('Identifier' === n.type ? n.name : n.value)) {
          if (t) return void this.raise(y.RecordNoProto, n);
          r.used && (s ? null === s.doubleProtoLoc && (s.doubleProtoLoc = n.loc.start) : this.raise(y.DuplicateProto, n)), (r.used = !0);
         }
        }
        shouldExitDescending(e, t) {
         return 'ArrowFunctionExpression' === e.type && this.offsetToSourcePos(e.start) === t;
        }
        getExpression() {
         this.enterInitialScopes(), this.nextToken();
         let e = this.parseExpression();
         return this.match(140) || this.unexpected(), this.finalizeRemainingComments(), (e.comments = this.comments), (e.errors = this.state.errors), 128 & this.optionFlags && (e.tokens = this.tokens), e;
        }
        parseExpression(e, t) {
         return e ? this.disallowInAnd(() => this.parseExpressionBase(t)) : this.allowInAnd(() => this.parseExpressionBase(t));
        }
        parseExpressionBase(e) {
         let t = this.state.startLoc,
          r = this.parseMaybeAssign(e);
         if (this.match(12)) {
          let s = this.startNodeAt(t);
          for (s.expressions = [r]; this.eat(12); ) s.expressions.push(this.parseMaybeAssign(e));
          return this.toReferencedList(s.expressions), this.finishNode(s, 'SequenceExpression');
         }
         return r;
        }
        parseMaybeAssignDisallowIn(e, t) {
         return this.disallowInAnd(() => this.parseMaybeAssign(e, t));
        }
        parseMaybeAssignAllowIn(e, t) {
         return this.allowInAnd(() => this.parseMaybeAssign(e, t));
        }
        setOptionalParametersError(e, t) {
         var r;
         e.optionalParametersLoc = null != (r = null == t ? void 0 : t.loc) ? r : this.state.startLoc;
        }
        parseMaybeAssign(e, t) {
         let r,
          s = this.state.startLoc;
         if (this.isContextual(108) && this.prodParam.hasYield) {
          let e = this.parseYield();
          return t && (e = t.call(this, e, s)), e;
         }
         e ? (r = !1) : ((e = new et()), (r = !0));
         let { type: n } = this.state;
         (10 === n || $(n)) && (this.state.potentialArrowAt = this.state.start);
         let i = this.parseMaybeConditional(e);
         if ((t && (i = t.call(this, i, s)), (a = this.state.type) >= 29 && a <= 33)) {
          let t = this.startNodeAt(s),
           r = this.state.value;
          if (((t.operator = r), this.match(29))) {
           this.toAssignable(i, !0), (t.left = i);
           let r = s.index;
           null != e.doubleProtoLoc && e.doubleProtoLoc.index >= r && (e.doubleProtoLoc = null), null != e.shorthandAssignLoc && e.shorthandAssignLoc.index >= r && (e.shorthandAssignLoc = null), null != e.privateKeyLoc && e.privateKeyLoc.index >= r && (this.checkDestructuringPrivate(e), (e.privateKeyLoc = null));
          } else t.left = i;
          return this.next(), (t.right = this.parseMaybeAssign()), this.checkLVal(i, this.finishNode(t, 'AssignmentExpression')), t;
         }
         var a;
         return r && this.checkExpressionErrors(e, !0), i;
        }
        parseMaybeConditional(e) {
         let t = this.state.startLoc,
          r = this.state.potentialArrowAt,
          s = this.parseExprOps(e);
         return this.shouldExitDescending(s, r) ? s : this.parseConditional(s, t, e);
        }
        parseConditional(e, t, r) {
         if (this.eat(17)) {
          let r = this.startNodeAt(t);
          return (r.test = e), (r.consequent = this.parseMaybeAssignAllowIn()), this.expect(14), (r.alternate = this.parseMaybeAssign()), this.finishNode(r, 'ConditionalExpression');
         }
         return e;
        }
        parseMaybeUnaryOrPrivate(e) {
         return this.match(139) ? this.parsePrivateName() : this.parseMaybeUnary(e);
        }
        parseExprOps(e) {
         let t = this.state.startLoc,
          r = this.state.potentialArrowAt,
          s = this.parseMaybeUnaryOrPrivate(e);
         return this.shouldExitDescending(s, r) ? s : this.parseExprOp(s, t, -1);
        }
        parseExprOp(e, t, r) {
         if (this.isPrivateName(e)) {
          let t = this.getPrivateNameSV(e);
          (r >= K(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(y.PrivateInExpectedIn, e, { identifierName: t }), this.classScope.usePrivateName(t, e.loc.start);
         }
         let s = this.state.type;
         if ((n = s) >= 39 && n <= 59 && (this.prodParam.hasIn || !this.match(58))) {
          let n = K(s);
          if (n > r) {
           if (39 === s) {
            if ((this.expectPlugin('pipelineOperator'), this.state.inFSharpPipelineDirectBody)) return e;
            this.checkPipelineAtInfixOperator(e, t);
           }
           let i = this.startNodeAt(t);
           (i.left = e), (i.operator = this.state.value);
           let a = 41 === s || 42 === s,
            o = 40 === s;
           if ((o && (n = K(42)), this.next(), 39 === s && this.hasPlugin(['pipelineOperator', { proposal: 'minimal' }]) && 96 === this.state.type && this.prodParam.hasAwait)) throw this.raise(y.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
           i.right = this.parseExprOpRightExpr(s, n);
           let u = this.finishNode(i, a || o ? 'LogicalExpression' : 'BinaryExpression'),
            l = this.state.type;
           if ((o && (41 === l || 42 === l)) || (a && 40 === l)) throw this.raise(y.MixingCoalesceWithLogical, this.state.startLoc);
           return this.parseExprOp(u, t, r);
          }
         }
         var n;
         return e;
        }
        parseExprOpRightExpr(e, t) {
         let r = this.state.startLoc;
         if (39 === e) {
          switch (this.getPluginOption('pipelineOperator', 'proposal')) {
           case 'hack':
            return this.withTopicBindingContext(() => this.parseHackPipeBody());
           case 'fsharp':
            return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(t));
          }
          if ('smart' === this.getPluginOption('pipelineOperator', 'proposal'))
           return this.withTopicBindingContext(() => {
            if (this.prodParam.hasYield && this.isContextual(108)) throw this.raise(y.PipeBodyIsTighter, this.state.startLoc);
            return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(e, t), r);
           });
         }
         return this.parseExprOpBaseRightExpr(e, t);
        }
        parseExprOpBaseRightExpr(e, t) {
         let r = this.state.startLoc;
         return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), r, 57 === e ? t - 1 : t);
        }
        parseHackPipeBody() {
         var e;
         let { startLoc: t } = this.state,
          r = this.parseMaybeAssign();
         return p.has(r.type) && !(null != (e = r.extra) && e.parenthesized) && this.raise(y.PipeUnparenthesizedBody, t, { type: r.type }), this.topicReferenceWasUsedInCurrentContext() || this.raise(y.PipeTopicUnused, t), r;
        }
        checkExponentialAfterUnary(e) {
         this.match(57) && this.raise(y.UnexpectedTokenUnaryExponentiation, e.argument);
        }
        parseMaybeUnary(e, t) {
         let r = this.state.startLoc,
          s = this.isContextual(96);
         if (s && this.recordAwaitIfAllowed()) {
          this.next();
          let e = this.parseAwait(r);
          return t || this.checkExponentialAfterUnary(e), e;
         }
         let n = this.match(34),
          i = this.startNode();
         if (((a = this.state.type), j[a])) {
          (i.operator = this.state.value), (i.prefix = !0), this.match(72) && this.expectPlugin('throwExpressions');
          let r = this.match(89);
          if ((this.next(), (i.argument = this.parseMaybeUnary(null, !0)), this.checkExpressionErrors(e, !0), this.state.strict && r)) {
           let e = i.argument;
           'Identifier' === e.type ? this.raise(y.StrictDelete, i) : this.hasPropertyAsPrivateName(e) && this.raise(y.DeletePrivateField, i);
          }
          if (!n) return t || this.checkExponentialAfterUnary(i), this.finishNode(i, 'UnaryExpression');
         }
         var a;
         let o = this.parseUpdate(i, n, e);
         if (s) {
          let { type: e } = this.state;
          if ((this.hasPlugin('v8intrinsic') ? W(e) : W(e) && !this.match(54)) && !this.isAmbiguousAwait()) return this.raiseOverwrite(y.AwaitNotInAsyncContext, r), this.parseAwait(r);
         }
         return o;
        }
        parseUpdate(e, t, r) {
         if (t) {
          let t = e;
          return this.checkLVal(t.argument, this.finishNode(t, 'UpdateExpression')), e;
         }
         let s = this.state.startLoc,
          n = this.parseExprSubscripts(r);
         if (this.checkExpressionErrors(r, !1)) return n;
         for (; 34 === this.state.type && !this.canInsertSemicolon(); ) {
          let e = this.startNodeAt(s);
          (e.operator = this.state.value), (e.prefix = !1), (e.argument = n), this.next(), this.checkLVal(n, (n = this.finishNode(e, 'UpdateExpression')));
         }
         return n;
        }
        parseExprSubscripts(e) {
         let t = this.state.startLoc,
          r = this.state.potentialArrowAt,
          s = this.parseExprAtom(e);
         return this.shouldExitDescending(s, r) ? s : this.parseSubscripts(s, t);
        }
        parseSubscripts(e, t, r) {
         let s = { optionalChainMember: !1, maybeAsyncArrow: this.atPossibleAsyncArrow(e), stop: !1 };
         do {
          (e = this.parseSubscript(e, t, r, s)), (s.maybeAsyncArrow = !1);
         } while (!s.stop);
         return e;
        }
        parseSubscript(e, t, r, s) {
         let { type: n } = this.state;
         if (!r && 15 === n) return this.parseBind(e, t, r, s);
         if (X(n)) return this.parseTaggedTemplateExpression(e, t, s);
         let i = !1;
         if (18 === n) {
          if (r && (this.raise(y.OptionalChainingNoNew, this.state.startLoc), 40 === this.lookaheadCharCode())) return (s.stop = !0), e;
          (s.optionalChainMember = i = !0), this.next();
         }
         if (!r && this.match(10)) return this.parseCoverCallAndAsyncArrowHead(e, t, s, i);
         {
          let r = this.eat(0);
          return r || i || this.eat(16) ? this.parseMember(e, t, s, r, i) : ((s.stop = !0), e);
         }
        }
        parseMember(e, t, r, s, n) {
         let i = this.startNodeAt(t);
         return (i.object = e), (i.computed = s), s ? ((i.property = this.parseExpression()), this.expect(3)) : this.match(139) ? ('Super' === e.type && this.raise(y.SuperPrivateField, t), this.classScope.usePrivateName(this.state.value, this.state.startLoc), (i.property = this.parsePrivateName())) : (i.property = this.parseIdentifier(!0)), r.optionalChainMember ? ((i.optional = n), this.finishNode(i, 'OptionalMemberExpression')) : this.finishNode(i, 'MemberExpression');
        }
        parseBind(e, t, r, s) {
         let n = this.startNodeAt(t);
         return (n.object = e), this.next(), (n.callee = this.parseNoCallExpr()), (s.stop = !0), this.parseSubscripts(this.finishNode(n, 'BindExpression'), t, r);
        }
        parseCoverCallAndAsyncArrowHead(e, t, r, s) {
         let n = this.state.maybeInArrowParameters,
          i = null;
         (this.state.maybeInArrowParameters = !0), this.next();
         let a = this.startNodeAt(t);
         a.callee = e;
         let { maybeAsyncArrow: o, optionalChainMember: u } = r;
         o && (this.expressionScope.enter(new Ke(2)), (i = new et())), u && (a.optional = s), (a.arguments = s ? this.parseCallExpressionArguments(11) : this.parseCallExpressionArguments(11, 'Super' !== e.type, a, i));
         let l = this.finishCallExpression(a, u);
         return o && this.shouldParseAsyncArrow() && !s ? ((r.stop = !0), this.checkDestructuringPrivate(i), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), (l = this.parseAsyncArrowFromCallExpression(this.startNodeAt(t), l))) : (o && (this.checkExpressionErrors(i, !0), this.expressionScope.exit()), this.toReferencedArguments(l)), (this.state.maybeInArrowParameters = n), l;
        }
        toReferencedArguments(e, t) {
         this.toReferencedListDeep(e.arguments, t);
        }
        parseTaggedTemplateExpression(e, t, r) {
         let s = this.startNodeAt(t);
         return (s.tag = e), (s.quasi = this.parseTemplate(!0)), r.optionalChainMember && this.raise(y.OptionalChainingNoTemplate, t), this.finishNode(s, 'TaggedTemplateExpression');
        }
        atPossibleAsyncArrow(e) {
         return 'Identifier' === e.type && 'async' === e.name && this.state.lastTokEndLoc.index === e.end && !this.canInsertSemicolon() && e.end - e.start == 5 && this.offsetToSourcePos(e.start) === this.state.potentialArrowAt;
        }
        finishCallExpression(e, t) {
         if ('Import' === e.callee.type)
          if (0 === e.arguments.length || e.arguments.length > 2) this.raise(y.ImportCallArity, e);
          else for (let r of e.arguments) 'SpreadElement' === r.type && this.raise(y.ImportCallSpreadArgument, r);
         return this.finishNode(e, t ? 'OptionalCallExpression' : 'CallExpression');
        }
        parseCallExpressionArguments(e, t, r, s) {
         let n = [],
          i = !0,
          a = this.state.inFSharpPipelineDirectBody;
         for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(e); ) {
          if (i) i = !1;
          else if ((this.expect(12), this.match(e))) {
           r && this.addTrailingCommaExtraToNode(r), this.next();
           break;
          }
          n.push(this.parseExprListItem(!1, s, t));
         }
         return (this.state.inFSharpPipelineDirectBody = a), n;
        }
        shouldParseAsyncArrow() {
         return this.match(19) && !this.canInsertSemicolon();
        }
        parseAsyncArrowFromCallExpression(e, t) {
         var r;
         return this.resetPreviousNodeTrailingComments(t), this.expect(19), this.parseArrowExpression(e, t.arguments, !0, null == (r = t.extra) ? void 0 : r.trailingCommaLoc), t.innerComments && Te(e, t.innerComments), t.callee.trailingComments && Te(e, t.callee.trailingComments), e;
        }
        parseNoCallExpr() {
         let e = this.state.startLoc;
         return this.parseSubscripts(this.parseExprAtom(), e, !0);
        }
        parseExprAtom(e) {
         let t,
          r = null,
          { type: s } = this.state;
         switch (s) {
          case 79:
           return this.parseSuper();
          case 83:
           return (t = this.startNode()), this.next(), this.match(16) ? this.parseImportMetaProperty(t) : this.match(10) ? (256 & this.optionFlags ? this.parseImportCall(t) : this.finishNode(t, 'Import')) : (this.raise(y.UnsupportedImport, this.state.lastTokStartLoc), this.finishNode(t, 'Import'));
          case 78:
           return (t = this.startNode()), this.next(), this.finishNode(t, 'ThisExpression');
          case 90:
           return this.parseDo(this.startNode(), !1);
          case 56:
          case 31:
           return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
          case 135:
           return this.parseNumericLiteral(this.state.value);
          case 136:
           return this.parseBigIntLiteral(this.state.value);
          case 134:
           return this.parseStringLiteral(this.state.value);
          case 84:
           return this.parseNullLiteral();
          case 85:
           return this.parseBooleanLiteral(!0);
          case 86:
           return this.parseBooleanLiteral(!1);
          case 10: {
           let e = this.state.potentialArrowAt === this.state.start;
           return this.parseParenAndDistinguishExpression(e);
          }
          case 2:
          case 1:
           return this.parseArrayLike(2 === this.state.type ? 4 : 3, !1, !0);
          case 0:
           return this.parseArrayLike(3, !0, !1, e);
          case 6:
          case 7:
           return this.parseObjectLike(6 === this.state.type ? 9 : 8, !1, !0);
          case 5:
           return this.parseObjectLike(8, !1, !1, e);
          case 68:
           return this.parseFunctionOrFunctionSent();
          case 26:
           r = this.parseDecorators();
          case 80:
           return this.parseClass(this.maybeTakeDecorators(r, this.startNode()), !1);
          case 77:
           return this.parseNewOrNewTarget();
          case 25:
          case 24:
           return this.parseTemplate(!1);
          case 15: {
           (t = this.startNode()), this.next(), (t.object = null);
           let e = (t.callee = this.parseNoCallExpr());
           if ('MemberExpression' === e.type) return this.finishNode(t, 'BindExpression');
           throw this.raise(y.UnsupportedBind, e);
          }
          case 139:
           return this.raise(y.PrivateInExpectedIn, this.state.startLoc, { identifierName: this.state.value }), this.parsePrivateName();
          case 33:
           return this.parseTopicReferenceThenEqualsSign(54, '%');
          case 32:
           return this.parseTopicReferenceThenEqualsSign(44, '^');
          case 37:
          case 38:
           return this.parseTopicReference('hack');
          case 44:
          case 54:
          case 27: {
           let e = this.getPluginOption('pipelineOperator', 'proposal');
           if (e) return this.parseTopicReference(e);
           this.unexpected();
           break;
          }
          case 47: {
           let e = this.input.codePointAt(this.nextTokenStart());
           ne(e) || 62 === e ? this.expectOnePlugin(['jsx', 'flow', 'typescript']) : this.unexpected();
           break;
          }
          default:
           if (137 === s) return this.parseDecimalLiteral(this.state.value);
           if ($(s)) {
            if (this.isContextual(127) && 123 === this.lookaheadInLineCharCode()) return this.parseModuleExpression();
            let e = this.state.potentialArrowAt === this.state.start,
             t = this.state.containsEsc,
             r = this.parseIdentifier();
            if (!t && 'async' === r.name && !this.canInsertSemicolon()) {
             let { type: e } = this.state;
             if (68 === e) return this.resetPreviousNodeTrailingComments(r), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(r));
             if ($(e)) return 61 === this.lookaheadCharCode() ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(r)) : r;
             if (90 === e) return this.resetPreviousNodeTrailingComments(r), this.parseDo(this.startNodeAtNode(r), !0);
            }
            return e && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(r), [r], !1)) : r;
           }
           this.unexpected();
         }
        }
        parseTopicReferenceThenEqualsSign(e, t) {
         let r = this.getPluginOption('pipelineOperator', 'proposal');
         if (r) return (this.state.type = e), (this.state.value = t), this.state.pos--, this.state.end--, (this.state.endLoc = n(this.state.endLoc, -1)), this.parseTopicReference(r);
         this.unexpected();
        }
        parseTopicReference(e) {
         let t = this.startNode(),
          r = this.state.startLoc,
          s = this.state.type;
         return this.next(), this.finishTopicReference(t, r, e, s);
        }
        finishTopicReference(e, t, r, s) {
         if (this.testTopicReferenceConfiguration(r, t, s)) return 'hack' === r ? (this.topicReferenceIsAllowedInCurrentContext() || this.raise(y.PipeTopicUnbound, t), this.registerTopicReference(), this.finishNode(e, 'TopicReference')) : (this.topicReferenceIsAllowedInCurrentContext() || this.raise(y.PrimaryTopicNotAllowed, t), this.registerTopicReference(), this.finishNode(e, 'PipelinePrimaryTopicReference'));
         throw this.raise(y.PipeTopicUnconfiguredToken, t, { token: H(s) });
        }
        testTopicReferenceConfiguration(e, t, r) {
         switch (e) {
          case 'hack':
           return this.hasPlugin(['pipelineOperator', { topicToken: H(r) }]);
          case 'smart':
           return 27 === r;
          default:
           throw this.raise(y.PipeTopicRequiresHackPipes, t);
         }
        }
        parseAsyncArrowUnaryFunction(e) {
         this.prodParam.enter(Qe(!0, this.prodParam.hasYield));
         let t = [this.parseIdentifier()];
         return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(y.LineTerminatorBeforeArrow, this.state.curPosition()), this.expect(19), this.parseArrowExpression(e, t, !0);
        }
        parseDo(e, t) {
         this.expectPlugin('doExpressions'), t && this.expectPlugin('asyncDoExpressions'), (e.async = t), this.next();
         let r = this.state.labels;
         return (this.state.labels = []), t ? (this.prodParam.enter(2), (e.body = this.parseBlock()), this.prodParam.exit()) : (e.body = this.parseBlock()), (this.state.labels = r), this.finishNode(e, 'DoExpression');
        }
        parseSuper() {
         let e = this.startNode();
         return this.next(), !this.match(10) || this.scope.allowDirectSuper || 16 & this.optionFlags ? !this.scope.allowSuper && !(16 & this.optionFlags) && this.raise(y.UnexpectedSuper, e) : this.raise(y.SuperNotAllowed, e), !this.match(10) && !this.match(0) && !this.match(16) && this.raise(y.UnsupportedSuper, e), this.finishNode(e, 'Super');
        }
        parsePrivateName() {
         let e = this.startNode(),
          t = this.startNodeAt(n(this.state.startLoc, 1)),
          r = this.state.value;
         return this.next(), (e.id = this.createIdentifier(t, r)), this.finishNode(e, 'PrivateName');
        }
        parseFunctionOrFunctionSent() {
         let e = this.startNode();
         if ((this.next(), this.prodParam.hasYield && this.match(16))) {
          let t = this.createIdentifier(this.startNodeAtNode(e), 'function');
          return this.next(), this.match(103) ? this.expectPlugin('functionSent') : this.hasPlugin('functionSent') || this.unexpected(), this.parseMetaProperty(e, t, 'sent');
         }
         return this.parseFunction(e);
        }
        parseMetaProperty(e, t, r) {
         e.meta = t;
         let s = this.state.containsEsc;
         return (e.property = this.parseIdentifier(!0)), (e.property.name !== r || s) && this.raise(y.UnsupportedMetaProperty, e.property, { target: t.name, onlyValidPropertyName: r }), this.finishNode(e, 'MetaProperty');
        }
        parseImportMetaProperty(e) {
         let t = this.createIdentifier(this.startNodeAtNode(e), 'import');
         if ((this.next(), this.isContextual(101))) this.inModule || this.raise(y.ImportMetaOutsideModule, t), (this.sawUnambiguousESM = !0);
         else if (this.isContextual(105) || this.isContextual(97)) {
          let t = this.isContextual(105);
          if ((this.expectPlugin(t ? 'sourcePhaseImports' : 'deferredImportEvaluation'), !(256 & this.optionFlags))) throw this.raise(y.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, { phase: this.state.value });
          return this.next(), (e.phase = t ? 'source' : 'defer'), this.parseImportCall(e);
         }
         return this.parseMetaProperty(e, t, 'meta');
        }
        parseLiteralAtNode(e, t, r) {
         return this.addExtra(r, 'rawValue', e), this.addExtra(r, 'raw', this.input.slice(this.offsetToSourcePos(r.start), this.state.end)), (r.value = e), this.next(), this.finishNode(r, t);
        }
        parseLiteral(e, t) {
         let r = this.startNode();
         return this.parseLiteralAtNode(e, t, r);
        }
        parseStringLiteral(e) {
         return this.parseLiteral(e, 'StringLiteral');
        }
        parseNumericLiteral(e) {
         return this.parseLiteral(e, 'NumericLiteral');
        }
        parseBigIntLiteral(e) {
         return this.parseLiteral(e, 'BigIntLiteral');
        }
        parseDecimalLiteral(e) {
         return this.parseLiteral(e, 'DecimalLiteral');
        }
        parseRegExpLiteral(e) {
         let t = this.startNode();
         return this.addExtra(t, 'raw', this.input.slice(this.offsetToSourcePos(t.start), this.state.end)), (t.pattern = e.pattern), (t.flags = e.flags), this.next(), this.finishNode(t, 'RegExpLiteral');
        }
        parseBooleanLiteral(e) {
         let t = this.startNode();
         return (t.value = e), this.next(), this.finishNode(t, 'BooleanLiteral');
        }
        parseNullLiteral() {
         let e = this.startNode();
         return this.next(), this.finishNode(e, 'NullLiteral');
        }
        parseParenAndDistinguishExpression(e) {
         let t,
          r = this.state.startLoc;
         this.next(), this.expressionScope.enter(new Ke(1));
         let s = this.state.maybeInArrowParameters,
          n = this.state.inFSharpPipelineDirectBody;
         (this.state.maybeInArrowParameters = !0), (this.state.inFSharpPipelineDirectBody = !1);
         let i,
          a,
          o = this.state.startLoc,
          u = [],
          l = new et(),
          p = !0;
         for (; !this.match(11); ) {
          if (p) p = !1;
          else if ((this.expect(12, null === l.optionalParametersLoc ? null : l.optionalParametersLoc), this.match(11))) {
           a = this.state.startLoc;
           break;
          }
          if (this.match(21)) {
           let e = this.state.startLoc;
           if (((i = this.state.startLoc), u.push(this.parseParenItem(this.parseRestBinding(), e)), !this.checkCommaAfterRest(41))) break;
          } else u.push(this.parseMaybeAssignAllowIn(l, this.parseParenItem));
         }
         let c = this.state.lastTokEndLoc;
         this.expect(11), (this.state.maybeInArrowParameters = s), (this.state.inFSharpPipelineDirectBody = n);
         let h = this.startNodeAt(r);
         return e && this.shouldParseArrow(u) && (h = this.parseArrow(h)) ? (this.checkDestructuringPrivate(l), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(h, u, !1), h) : (this.expressionScope.exit(), u.length || this.unexpected(this.state.lastTokStartLoc), a && this.unexpected(a), i && this.unexpected(i), this.checkExpressionErrors(l, !0), this.toReferencedListDeep(u, !0), u.length > 1 ? ((t = this.startNodeAt(o)), (t.expressions = u), this.finishNode(t, 'SequenceExpression'), this.resetEndLocation(t, c)) : (t = u[0]), this.wrapParenthesis(r, t));
        }
        wrapParenthesis(e, t) {
         if (!(512 & this.optionFlags)) return this.addExtra(t, 'parenthesized', !0), this.addExtra(t, 'parenStart', e.index), this.takeSurroundingComments(t, e.index, this.state.lastTokEndLoc.index), t;
         let r = this.startNodeAt(e);
         return (r.expression = t), this.finishNode(r, 'ParenthesizedExpression');
        }
        shouldParseArrow(e) {
         return !this.canInsertSemicolon();
        }
        parseArrow(e) {
         if (this.eat(19)) return e;
        }
        parseParenItem(e, t) {
         return e;
        }
        parseNewOrNewTarget() {
         let e = this.startNode();
         if ((this.next(), this.match(16))) {
          let t = this.createIdentifier(this.startNodeAtNode(e), 'new');
          this.next();
          let r = this.parseMetaProperty(e, t, 'target');
          return !this.scope.inNonArrowFunction && !this.scope.inClass && !(4 & this.optionFlags) && this.raise(y.UnexpectedNewTarget, r), r;
         }
         return this.parseNew(e);
        }
        parseNew(e) {
         if ((this.parseNewCallee(e), this.eat(10))) {
          let t = this.parseExprList(11);
          this.toReferencedList(t), (e.arguments = t);
         } else e.arguments = [];
         return this.finishNode(e, 'NewExpression');
        }
        parseNewCallee(e) {
         let t = this.match(83),
          r = this.parseNoCallExpr();
         (e.callee = r), t && ('Import' === r.type || 'ImportExpression' === r.type) && this.raise(y.ImportCallNotNewExpression, r);
        }
        parseTemplateElement(e) {
         let { start: t, startLoc: r, end: s, value: i } = this.state,
          a = t + 1,
          o = this.startNodeAt(n(r, 1));
         null === i && (e || this.raise(y.InvalidEscapeSequenceTemplate, n(this.state.firstInvalidTemplateEscapePos, 1)));
         let u = this.match(24),
          l = u ? -1 : -2,
          p = s + l;
         (o.value = { raw: this.input.slice(a, p).replace(/\r\n?/g, '\n'), cooked: null === i ? null : i.slice(1, l) }), (o.tail = u), this.next();
         let c = this.finishNode(o, 'TemplateElement');
         return this.resetEndLocation(c, n(this.state.lastTokEndLoc, l)), c;
        }
        parseTemplate(e) {
         let t = this.startNode(),
          r = this.parseTemplateElement(e),
          s = [r],
          n = [];
         for (; !r.tail; ) n.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), s.push((r = this.parseTemplateElement(e)));
         return (t.expressions = n), (t.quasis = s), this.finishNode(t, 'TemplateLiteral');
        }
        parseTemplateSubstitution() {
         return this.parseExpression();
        }
        parseObjectLike(e, t, r, s) {
         r && this.expectPlugin('recordAndTuple');
         let n = this.state.inFSharpPipelineDirectBody;
         this.state.inFSharpPipelineDirectBody = !1;
         let i = Object.create(null),
          a = !0,
          o = this.startNode();
         for (o.properties = [], this.next(); !this.match(e); ) {
          if (a) a = !1;
          else if ((this.expect(12), this.match(e))) {
           this.addTrailingCommaExtraToNode(o);
           break;
          }
          let n;
          t ? (n = this.parseBindingProperty()) : ((n = this.parsePropertyDefinition(s)), this.checkProto(n, r, i, s)), r && !this.isObjectProperty(n) && 'SpreadElement' !== n.type && this.raise(y.InvalidRecordProperty, n), n.shorthand && this.addExtra(n, 'shorthand', !0), o.properties.push(n);
         }
         this.next(), (this.state.inFSharpPipelineDirectBody = n);
         let u = 'ObjectExpression';
         return t ? (u = 'ObjectPattern') : r && (u = 'RecordExpression'), this.finishNode(o, u);
        }
        addTrailingCommaExtraToNode(e) {
         this.addExtra(e, 'trailingComma', this.state.lastTokStartLoc.index), this.addExtra(e, 'trailingCommaLoc', this.state.lastTokStartLoc, !1);
        }
        maybeAsyncOrAccessorProp(e) {
         return !e.computed && 'Identifier' === e.key.type && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
        }
        parsePropertyDefinition(e) {
         let t = [];
         if (this.match(26)) for (this.hasPlugin('decorators') && this.raise(y.UnsupportedPropertyDecorator, this.state.startLoc); this.match(26); ) t.push(this.parseDecorator());
         let r,
          s = this.startNode(),
          n = !1,
          i = !1;
         if (this.match(21)) return t.length && this.unexpected(), this.parseSpread();
         t.length && ((s.decorators = t), (t = [])), (s.method = !1), e && (r = this.state.startLoc);
         let a = this.eat(55);
         this.parsePropertyNamePrefixOperator(s);
         let o = this.state.containsEsc;
         if ((this.parsePropertyName(s, e), !a && !o && this.maybeAsyncOrAccessorProp(s))) {
          let { key: e } = s,
           t = e.name;
          'async' === t && !this.hasPrecedingLineBreak() && ((n = !0), this.resetPreviousNodeTrailingComments(e), (a = this.eat(55)), this.parsePropertyName(s)), ('get' === t || 'set' === t) && ((i = !0), this.resetPreviousNodeTrailingComments(e), (s.kind = t), this.match(55) && ((a = !0), this.raise(y.AccessorIsGenerator, this.state.curPosition(), { kind: t }), this.next()), this.parsePropertyName(s));
         }
         return this.parseObjPropValue(s, r, a, n, !1, i, e);
        }
        getGetterSetterExpectedParamCount(e) {
         return 'get' === e.kind ? 0 : 1;
        }
        getObjectOrClassMethodParams(e) {
         return e.params;
        }
        checkGetterSetterParams(e) {
         var t;
         let r = this.getGetterSetterExpectedParamCount(e),
          s = this.getObjectOrClassMethodParams(e);
         s.length !== r && this.raise('get' === e.kind ? y.BadGetterArity : y.BadSetterArity, e), 'set' === e.kind && 'RestElement' === (null == (t = s[s.length - 1]) ? void 0 : t.type) && this.raise(y.BadSetterRestParameter, e);
        }
        parseObjectMethod(e, t, r, s, n) {
         if (n) {
          let r = this.parseMethod(e, t, !1, !1, !1, 'ObjectMethod');
          return this.checkGetterSetterParams(r), r;
         }
         if (r || t || this.match(10)) return s && this.unexpected(), (e.kind = 'method'), (e.method = !0), this.parseMethod(e, t, r, !1, !1, 'ObjectMethod');
        }
        parseObjectProperty(e, t, r, s) {
         if (((e.shorthand = !1), this.eat(14))) return (e.value = r ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(s)), this.finishNode(e, 'ObjectProperty');
         if (!e.computed && 'Identifier' === e.key.type) {
          if ((this.checkReservedWord(e.key.name, e.key.loc.start, !0, !1), r)) e.value = this.parseMaybeDefault(t, st(e.key));
          else if (this.match(29)) {
           let r = this.state.startLoc;
           null != s ? null === s.shorthandAssignLoc && (s.shorthandAssignLoc = r) : this.raise(y.InvalidCoverInitializedName, r), (e.value = this.parseMaybeDefault(t, st(e.key)));
          } else e.value = st(e.key);
          return (e.shorthand = !0), this.finishNode(e, 'ObjectProperty');
         }
        }
        parseObjPropValue(e, t, r, s, n, i, a) {
         let o = this.parseObjectMethod(e, r, s, n, i) || this.parseObjectProperty(e, t, n, a);
         return o || this.unexpected(), o;
        }
        parsePropertyName(e, t) {
         if (this.eat(0)) (e.computed = !0), (e.key = this.parseMaybeAssignAllowIn()), this.expect(3);
         else {
          let r,
           { type: s, value: n } = this.state;
          if (q(s)) r = this.parseIdentifier(!0);
          else
           switch (s) {
            case 135:
             r = this.parseNumericLiteral(n);
             break;
            case 134:
             r = this.parseStringLiteral(n);
             break;
            case 136:
             r = this.parseBigIntLiteral(n);
             break;
            case 139: {
             let e = this.state.startLoc;
             null != t ? null === t.privateKeyLoc && (t.privateKeyLoc = e) : this.raise(y.UnexpectedPrivateField, e), (r = this.parsePrivateName());
             break;
            }
            default:
             if (137 === s) {
              r = this.parseDecimalLiteral(n);
              break;
             }
             this.unexpected();
           }
          (e.key = r), 139 !== s && (e.computed = !1);
         }
        }
        initFunction(e, t) {
         (e.id = null), (e.generator = !1), (e.async = t);
        }
        parseMethod(e, t, r, s, n, i, a = !1) {
         this.initFunction(e, r), (e.generator = t), this.scope.enter(18 | (a ? 64 : 0) | (n ? 32 : 0)), this.prodParam.enter(Qe(r, e.generator)), this.parseFunctionParams(e, s);
         let o = this.parseFunctionBodyAndFinish(e, i, !0);
         return this.prodParam.exit(), this.scope.exit(), o;
        }
        parseArrayLike(e, t, r, s) {
         r && this.expectPlugin('recordAndTuple');
         let n = this.state.inFSharpPipelineDirectBody;
         this.state.inFSharpPipelineDirectBody = !1;
         let i = this.startNode();
         return this.next(), (i.elements = this.parseExprList(e, !r, s, i)), (this.state.inFSharpPipelineDirectBody = n), this.finishNode(i, r ? 'TupleExpression' : 'ArrayExpression');
        }
        parseArrowExpression(e, t, r, s) {
         this.scope.enter(6);
         let n = Qe(r, !1);
         !this.match(5) && this.prodParam.hasIn && (n |= 8), this.prodParam.enter(n), this.initFunction(e, r);
         let i = this.state.maybeInArrowParameters;
         return t && ((this.state.maybeInArrowParameters = !0), this.setArrowFunctionParameters(e, t, s)), (this.state.maybeInArrowParameters = !1), this.parseFunctionBody(e, !0), this.prodParam.exit(), this.scope.exit(), (this.state.maybeInArrowParameters = i), this.finishNode(e, 'ArrowFunctionExpression');
        }
        setArrowFunctionParameters(e, t, r) {
         this.toAssignableList(t, r, !1), (e.params = t);
        }
        parseFunctionBodyAndFinish(e, t, r = !1) {
         return this.parseFunctionBody(e, !1, r), this.finishNode(e, t);
        }
        parseFunctionBody(e, t, r = !1) {
         let s = t && !this.match(5);
         if ((this.expressionScope.enter(Ge()), s)) (e.body = this.parseMaybeAssign()), this.checkParams(e, !1, t, !1);
         else {
          let s = this.state.strict,
           n = this.state.labels;
          (this.state.labels = []),
           this.prodParam.enter(4 | this.prodParam.currentFlags()),
           (e.body = this.parseBlock(!0, !1, (n) => {
            let i = !this.isSimpleParamList(e.params);
            n && i && this.raise(y.IllegalLanguageModeDirective, ('method' !== e.kind && 'constructor' !== e.kind) || !e.key ? e : e.key.loc.end);
            let a = !s && this.state.strict;
            this.checkParams(e, !(this.state.strict || t || r || i), t, a), this.state.strict && e.id && this.checkIdentifier(e.id, 65, a);
           })),
           this.prodParam.exit(),
           (this.state.labels = n);
         }
         this.expressionScope.exit();
        }
        isSimpleParameter(e) {
         return 'Identifier' === e.type;
        }
        isSimpleParamList(e) {
         for (let t = 0, r = e.length; t < r; t++) if (!this.isSimpleParameter(e[t])) return !1;
         return !0;
        }
        checkParams(e, t, r, s = !0) {
         let n = !t && new Set(),
          i = { type: 'FormalParameters' };
         for (let a of e.params) this.checkLVal(a, i, 5, n, s);
        }
        parseExprList(e, t, r, s) {
         let n = [],
          i = !0;
         for (; !this.eat(e); ) {
          if (i) i = !1;
          else if ((this.expect(12), this.match(e))) {
           s && this.addTrailingCommaExtraToNode(s), this.next();
           break;
          }
          n.push(this.parseExprListItem(t, r));
         }
         return n;
        }
        parseExprListItem(e, t, r) {
         let s;
         if (this.match(12)) e || this.raise(y.UnexpectedToken, this.state.curPosition(), { unexpected: ',' }), (s = null);
         else if (this.match(21)) {
          let e = this.state.startLoc;
          s = this.parseParenItem(this.parseSpread(t), e);
         } else if (this.match(17)) {
          this.expectPlugin('partialApplication'), r || this.raise(y.UnexpectedArgumentPlaceholder, this.state.startLoc);
          let e = this.startNode();
          this.next(), (s = this.finishNode(e, 'ArgumentPlaceholder'));
         } else s = this.parseMaybeAssignAllowIn(t, this.parseParenItem);
         return s;
        }
        parseIdentifier(e) {
         let t = this.startNode(),
          r = this.parseIdentifierName(e);
         return this.createIdentifier(t, r);
        }
        createIdentifier(e, t) {
         return (e.name = t), (e.loc.identifierName = t), this.finishNode(e, 'Identifier');
        }
        parseIdentifierName(e) {
         let t,
          { startLoc: r, type: s } = this.state;
         q(s) ? (t = this.state.value) : this.unexpected();
         let n = s <= 92;
         return e ? n && this.replaceToken(132) : this.checkReservedWord(t, r, n, !1), this.next(), t;
        }
        checkReservedWord(e, t, r, s) {
         var n;
         if (!(e.length > 10) && ((n = e), me.has(n)))
          if (
           r &&
           (function (e) {
            return ue.has(e);
           })(e)
          )
           this.raise(y.UnexpectedKeyword, t, { keyword: e });
          else if ((this.state.strict ? (s ? fe : he) : ce)(e, this.inModule)) this.raise(y.UnexpectedReservedWord, t, { reservedWord: e });
          else if ('yield' === e) {
           if (this.prodParam.hasYield) return void this.raise(y.YieldBindingIdentifier, t);
          } else if ('await' === e) {
           if (this.prodParam.hasAwait) return void this.raise(y.AwaitBindingIdentifier, t);
           if (this.scope.inStaticBlock) return void this.raise(y.AwaitBindingIdentifierInStaticBlock, t);
           this.expressionScope.recordAsyncArrowParametersError(t);
          } else if ('arguments' === e && this.scope.inClassAndNotInNonArrowFunction) return void this.raise(y.ArgumentsInClass, t);
        }
        recordAwaitIfAllowed() {
         let e = this.prodParam.hasAwait || (1 & this.optionFlags && !this.scope.inFunction);
         return e && !this.scope.inFunction && (this.state.hasTopLevelAwait = !0), e;
        }
        parseAwait(e) {
         let t = this.startNodeAt(e);
         return this.expressionScope.recordParameterInitializerError(y.AwaitExpressionFormalParameter, t), this.eat(55) && this.raise(y.ObsoleteAwaitStar, t), !this.scope.inFunction && !(1 & this.optionFlags) && (this.isAmbiguousAwait() ? (this.ambiguousScriptDifferentAst = !0) : (this.sawUnambiguousESM = !0)), this.state.soloAwait || (t.argument = this.parseMaybeUnary(null, !0)), this.finishNode(t, 'AwaitExpression');
        }
        isAmbiguousAwait() {
         if (this.hasPrecedingLineBreak()) return !0;
         let { type: e } = this.state;
         return 53 === e || 10 === e || 0 === e || X(e) || (102 === e && !this.state.containsEsc) || 138 === e || 56 === e || (this.hasPlugin('v8intrinsic') && 54 === e);
        }
        parseYield() {
         let e = this.startNode();
         this.expressionScope.recordParameterInitializerError(y.YieldInParameter, e), this.next();
         let t = !1,
          r = null;
         if (!this.hasPrecedingLineBreak())
          switch (((t = this.eat(55)), this.state.type)) {
           case 13:
           case 140:
           case 8:
           case 11:
           case 3:
           case 9:
           case 14:
           case 12:
            if (!t) break;
           default:
            r = this.parseMaybeAssign();
          }
         return (e.delegate = t), (e.argument = r), this.finishNode(e, 'YieldExpression');
        }
        parseImportCall(e) {
         if ((this.next(), (e.source = this.parseMaybeAssignAllowIn()), (e.options = null), this.eat(12) && !this.match(11) && ((e.options = this.parseMaybeAssignAllowIn()), this.eat(12) && !this.match(11)))) {
          do {
           this.parseMaybeAssignAllowIn();
          } while (this.eat(12) && !this.match(11));
          this.raise(y.ImportCallArity, e);
         }
         return this.expect(11), this.finishNode(e, 'ImportExpression');
        }
        checkPipelineAtInfixOperator(e, t) {
         this.hasPlugin(['pipelineOperator', { proposal: 'smart' }]) && 'SequenceExpression' === e.type && this.raise(y.PipelineHeadSequenceExpression, t);
        }
        parseSmartPipelineBodyInStyle(e, t) {
         if (this.isSimpleReference(e)) {
          let r = this.startNodeAt(t);
          return (r.callee = e), this.finishNode(r, 'PipelineBareFunction');
         }
         {
          let r = this.startNodeAt(t);
          return this.checkSmartPipeTopicBodyEarlyErrors(t), (r.expression = e), this.finishNode(r, 'PipelineTopicExpression');
         }
        }
        isSimpleReference(e) {
         switch (e.type) {
          case 'MemberExpression':
           return !e.computed && this.isSimpleReference(e.object);
          case 'Identifier':
           return !0;
          default:
           return !1;
         }
        }
        checkSmartPipeTopicBodyEarlyErrors(e) {
         if (this.match(19)) throw this.raise(y.PipelineBodyNoArrow, this.state.startLoc);
         this.topicReferenceWasUsedInCurrentContext() || this.raise(y.PipelineTopicUnused, e);
        }
        withTopicBindingContext(e) {
         let t = this.state.topicContext;
         this.state.topicContext = { maxNumOfResolvableTopics: 1, maxTopicIndex: null };
         try {
          return e();
         } finally {
          this.state.topicContext = t;
         }
        }
        withSmartMixTopicForbiddingContext(e) {
         if (!this.hasPlugin(['pipelineOperator', { proposal: 'smart' }])) return e();
         {
          let t = this.state.topicContext;
          this.state.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null };
          try {
           return e();
          } finally {
           this.state.topicContext = t;
          }
         }
        }
        withSoloAwaitPermittingContext(e) {
         let t = this.state.soloAwait;
         this.state.soloAwait = !0;
         try {
          return e();
         } finally {
          this.state.soloAwait = t;
         }
        }
        allowInAnd(e) {
         let t = this.prodParam.currentFlags();
         if (8 & ~t) {
          this.prodParam.enter(8 | t);
          try {
           return e();
          } finally {
           this.prodParam.exit();
          }
         }
         return e();
        }
        disallowInAnd(e) {
         let t = this.prodParam.currentFlags();
         if (8 & t) {
          this.prodParam.enter(-9 & t);
          try {
           return e();
          } finally {
           this.prodParam.exit();
          }
         }
         return e();
        }
        registerTopicReference() {
         this.state.topicContext.maxTopicIndex = 0;
        }
        topicReferenceIsAllowedInCurrentContext() {
         return this.state.topicContext.maxNumOfResolvableTopics >= 1;
        }
        topicReferenceWasUsedInCurrentContext() {
         return null != this.state.topicContext.maxTopicIndex && this.state.topicContext.maxTopicIndex >= 0;
        }
        parseFSharpPipelineBody(e) {
         let t = this.state.startLoc;
         this.state.potentialArrowAt = this.state.start;
         let r = this.state.inFSharpPipelineDirectBody;
         this.state.inFSharpPipelineDirectBody = !0;
         let s = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), t, e);
         return (this.state.inFSharpPipelineDirectBody = r), s;
        }
        parseModuleExpression() {
         this.expectPlugin('moduleBlocks');
         let e = this.startNode();
         this.next(), this.match(5) || this.unexpected(null, 5);
         let t = this.startNodeAt(this.state.endLoc);
         this.next();
         let r = this.initializeScopes(!0);
         this.enterInitialScopes();
         try {
          e.body = this.parseProgram(t, 8, 'module');
         } finally {
          r();
         }
         return this.finishNode(e, 'ModuleExpression');
        }
        parsePropertyNamePrefixOperator(e) {}
       },
       Nt = { kind: 1 },
       Bt = { kind: 2 },
       Ot = /[\uD800-\uDFFF]/u,
       Lt = /in(?:stanceof)?/y,
       Mt = class extends It {
        parseTopLevel(e, t) {
         return (
          (e.program = this.parseProgram(t)),
          (e.comments = this.comments),
          128 & this.optionFlags &&
           (e.tokens = (function (e, t, r) {
            for (let s = 0; s < e.length; s++) {
             let i = e[s],
              { type: a } = i;
             if ('number' == typeof a) {
              if (139 === a) {
               let { loc: t, start: r, value: a, end: o } = i,
                u = r + 1,
                l = n(t.start, 1);
               e.splice(s, 1, new Je({ type: G(27), value: '#', start: r, end: u, startLoc: t.start, endLoc: l }), new Je({ type: G(132), value: a, start: u, end: o, startLoc: l, endLoc: t.end })), s++;
               continue;
              }
              if (X(a)) {
               let o,
                u,
                l,
                p,
                c,
                { loc: h, start: d, value: f, end: m } = i,
                y = d + 1,
                D = n(h.start, 1);
               (o = 96 === t.charCodeAt(d - r) ? new Je({ type: G(22), value: '`', start: d, end: y, startLoc: h.start, endLoc: D }) : new Je({ type: G(8), value: '}', start: d, end: y, startLoc: h.start, endLoc: D })), 24 === a ? ((l = m - 1), (p = n(h.end, -1)), (u = null === f ? null : f.slice(1, -1)), (c = new Je({ type: G(22), value: '`', start: l, end: m, startLoc: p, endLoc: h.end }))) : ((l = m - 2), (p = n(h.end, -2)), (u = null === f ? null : f.slice(1, -2)), (c = new Je({ type: G(23), value: '${', start: l, end: m, startLoc: p, endLoc: h.end }))), e.splice(s, 1, o, new Je({ type: G(20), value: u, start: y, end: l, startLoc: D, endLoc: p }), c), (s += 2);
               continue;
              }
              i.type = G(a);
             }
            }
            return e;
           })(this.tokens, this.input, this.startIndex)),
          this.finishNode(e, 'File')
         );
        }
        parseProgram(e, t = 140, r = this.options.sourceType) {
         if (((e.sourceType = r), (e.interpreter = this.parseInterpreterDirective()), this.parseBlockBody(e, !0, !0, t), this.inModule)) {
          if (!(32 & this.optionFlags) && this.scope.undefinedExports.size > 0) for (let [e, t] of Array.from(this.scope.undefinedExports)) this.raise(y.ModuleExportUndefined, t, { localName: e });
          this.addExtra(e, 'topLevelAwait', this.state.hasTopLevelAwait);
         }
         let s;
         return (s = 140 === t ? this.finishNode(e, 'Program') : this.finishNodeAt(e, 'Program', n(this.state.startLoc, -1))), s;
        }
        stmtToDirective(e) {
         let t = e;
         (t.type = 'Directive'), (t.value = t.expression), delete t.expression;
         let r = t.value,
          s = r.value,
          n = this.input.slice(this.offsetToSourcePos(r.start), this.offsetToSourcePos(r.end)),
          i = (r.value = n.slice(1, -1));
         return this.addExtra(r, 'raw', n), this.addExtra(r, 'rawValue', i), this.addExtra(r, 'expressionValue', s), (r.type = 'DirectiveLiteral'), t;
        }
        parseInterpreterDirective() {
         if (!this.match(28)) return null;
         let e = this.startNode();
         return (e.value = this.state.value), this.next(), this.finishNode(e, 'InterpreterDirective');
        }
        isLet() {
         return !!this.isContextual(100) && this.hasFollowingBindingAtom();
        }
        chStartsBindingIdentifier(e, t) {
         if (ne(e)) {
          if (((Lt.lastIndex = t), Lt.test(this.input))) {
           let e = this.codePointAtPos(Lt.lastIndex);
           if (!ie(e) && 92 !== e) return !1;
          }
          return !0;
         }
         return 92 === e;
        }
        chStartsBindingPattern(e) {
         return 91 === e || 123 === e;
        }
        hasFollowingBindingAtom() {
         let e = this.nextTokenStart(),
          t = this.codePointAtPos(e);
         return this.chStartsBindingPattern(t) || this.chStartsBindingIdentifier(t, e);
        }
        hasInLineFollowingBindingIdentifierOrBrace() {
         let e = this.nextTokenInLineStart(),
          t = this.codePointAtPos(e);
         return 123 === t || this.chStartsBindingIdentifier(t, e);
        }
        startsUsingForOf() {
         let { type: e, containsEsc: t } = this.lookahead();
         return !(102 === e && !t) && ($(e) && !this.hasFollowingLineBreak() ? (this.expectPlugin('explicitResourceManagement'), !0) : void 0);
        }
        startsAwaitUsing() {
         let e = this.nextTokenInLineStart();
         if (this.isUnparsedContextual(e, 'using')) {
          e = this.nextTokenInLineStartSince(e + 5);
          let t = this.codePointAtPos(e);
          if (this.chStartsBindingIdentifier(t, e)) return this.expectPlugin('explicitResourceManagement'), !0;
         }
         return !1;
        }
        parseModuleItem() {
         return this.parseStatementLike(15);
        }
        parseStatementListItem() {
         return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
        }
        parseStatementOrSloppyAnnexBFunctionDeclaration(e = !1) {
         let t = 0;
         return this.options.annexB && !this.state.strict && ((t |= 4), e && (t |= 8)), this.parseStatementLike(t);
        }
        parseStatement() {
         return this.parseStatementLike(0);
        }
        parseStatementLike(e) {
         let t = null;
         return this.match(26) && (t = this.parseDecorators(!0)), this.parseStatementContent(e, t);
        }
        parseStatementContent(e, t) {
         let r = this.state.type,
          s = this.startNode(),
          n = !!(2 & e),
          i = !!(4 & e),
          a = 1 & e;
         switch (r) {
          case 60:
           return this.parseBreakContinueStatement(s, !0);
          case 63:
           return this.parseBreakContinueStatement(s, !1);
          case 64:
           return this.parseDebuggerStatement(s);
          case 90:
           return this.parseDoWhileStatement(s);
          case 91:
           return this.parseForStatement(s);
          case 68:
           if (46 === this.lookaheadCharCode()) break;
           return i || this.raise(this.state.strict ? y.StrictFunction : this.options.annexB ? y.SloppyFunctionAnnexB : y.SloppyFunction, this.state.startLoc), this.parseFunctionStatement(s, !1, !n && i);
          case 80:
           return n || this.unexpected(), this.parseClass(this.maybeTakeDecorators(t, s), !0);
          case 69:
           return this.parseIfStatement(s);
          case 70:
           return this.parseReturnStatement(s);
          case 71:
           return this.parseSwitchStatement(s);
          case 72:
           return this.parseThrowStatement(s);
          case 73:
           return this.parseTryStatement(s);
          case 96:
           if (!this.state.containsEsc && this.startsAwaitUsing()) return this.recordAwaitIfAllowed() ? n || this.raise(y.UnexpectedLexicalDeclaration, s) : this.raise(y.AwaitUsingNotInAsyncContext, s), this.next(), this.parseVarStatement(s, 'await using');
           break;
          case 107:
           if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifierOrBrace()) break;
           return this.expectPlugin('explicitResourceManagement'), !this.scope.inModule && this.scope.inTopLevel ? this.raise(y.UnexpectedUsingDeclaration, this.state.startLoc) : n || this.raise(y.UnexpectedLexicalDeclaration, this.state.startLoc), this.parseVarStatement(s, 'using');
          case 100: {
           if (this.state.containsEsc) break;
           let e = this.nextTokenStart(),
            t = this.codePointAtPos(e);
           if (91 !== t && ((!n && this.hasFollowingLineBreak()) || (!this.chStartsBindingIdentifier(t, e) && 123 !== t))) break;
          }
          case 75:
           n || this.raise(y.UnexpectedLexicalDeclaration, this.state.startLoc);
          case 74: {
           let e = this.state.value;
           return this.parseVarStatement(s, e);
          }
          case 92:
           return this.parseWhileStatement(s);
          case 76:
           return this.parseWithStatement(s);
          case 5:
           return this.parseBlock();
          case 13:
           return this.parseEmptyStatement(s);
          case 83: {
           let e = this.lookaheadCharCode();
           if (40 === e || 46 === e) break;
          }
          case 82: {
           let e;
           return !(8 & this.optionFlags) && !a && this.raise(y.UnexpectedImportExport, this.state.startLoc), this.next(), 83 === r ? ((e = this.parseImport(s)), 'ImportDeclaration' === e.type && (!e.importKind || 'value' === e.importKind) && (this.sawUnambiguousESM = !0)) : ((e = this.parseExport(s, t)), (('ExportNamedDeclaration' === e.type && (!e.exportKind || 'value' === e.exportKind)) || ('ExportAllDeclaration' === e.type && (!e.exportKind || 'value' === e.exportKind)) || 'ExportDefaultDeclaration' === e.type) && (this.sawUnambiguousESM = !0)), this.assertModuleNodeAllowed(e), e;
          }
          default:
           if (this.isAsyncFunction()) return n || this.raise(y.AsyncFunctionInSingleStatementContext, this.state.startLoc), this.next(), this.parseFunctionStatement(s, !0, !n && i);
         }
         let o = this.state.value,
          u = this.parseExpression();
         return $(r) && 'Identifier' === u.type && this.eat(14) ? this.parseLabeledStatement(s, o, u, e) : this.parseExpressionStatement(s, u, t);
        }
        assertModuleNodeAllowed(e) {
         !(8 & this.optionFlags) && !this.inModule && this.raise(y.ImportOutsideModule, e);
        }
        decoratorsEnabledBeforeExport() {
         return !!this.hasPlugin('decorators-legacy') || (this.hasPlugin('decorators') && !1 !== this.getPluginOption('decorators', 'decoratorsBeforeExport'));
        }
        maybeTakeDecorators(e, t, r) {
         var s;
         return e && (null != (s = t.decorators) && s.length ? ('boolean' != typeof this.getPluginOption('decorators', 'decoratorsBeforeExport') && this.raise(y.DecoratorsBeforeAfterExport, t.decorators[0]), t.decorators.unshift(...e)) : (t.decorators = e), this.resetStartLocationFromNode(t, e[0]), r && this.resetStartLocationFromNode(r, t)), t;
        }
        canHaveLeadingDecorator() {
         return this.match(80);
        }
        parseDecorators(e) {
         let t = [];
         do {
          t.push(this.parseDecorator());
         } while (this.match(26));
         if (this.match(82)) e || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(y.DecoratorExportClass, this.state.startLoc);
         else if (!this.canHaveLeadingDecorator()) throw this.raise(y.UnexpectedLeadingDecorator, this.state.startLoc);
         return t;
        }
        parseDecorator() {
         this.expectOnePlugin(['decorators', 'decorators-legacy']);
         let e = this.startNode();
         if ((this.next(), this.hasPlugin('decorators'))) {
          let t,
           r = this.state.startLoc;
          if (this.match(10)) {
           let r = this.state.startLoc;
           this.next(), (t = this.parseExpression()), this.expect(11), (t = this.wrapParenthesis(r, t));
           let s = this.state.startLoc;
           (e.expression = this.parseMaybeDecoratorArguments(t, r)), !1 === this.getPluginOption('decorators', 'allowCallParenthesized') && e.expression !== t && this.raise(y.DecoratorArgumentsOutsideParentheses, s);
          } else {
           for (t = this.parseIdentifier(!1); this.eat(16); ) {
            let e = this.startNodeAt(r);
            (e.object = t), this.match(139) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), (e.property = this.parsePrivateName())) : (e.property = this.parseIdentifier(!0)), (e.computed = !1), (t = this.finishNode(e, 'MemberExpression'));
           }
           e.expression = this.parseMaybeDecoratorArguments(t, r);
          }
         } else e.expression = this.parseExprSubscripts();
         return this.finishNode(e, 'Decorator');
        }
        parseMaybeDecoratorArguments(e, t) {
         if (this.eat(10)) {
          let r = this.startNodeAt(t);
          return (r.callee = e), (r.arguments = this.parseCallExpressionArguments(11)), this.toReferencedList(r.arguments), this.finishNode(r, 'CallExpression');
         }
         return e;
        }
        parseBreakContinueStatement(e, t) {
         return this.next(), this.isLineTerminator() ? (e.label = null) : ((e.label = this.parseIdentifier()), this.semicolon()), this.verifyBreakContinue(e, t), this.finishNode(e, t ? 'BreakStatement' : 'ContinueStatement');
        }
        verifyBreakContinue(e, t) {
         let r;
         for (r = 0; r < this.state.labels.length; ++r) {
          let s = this.state.labels[r];
          if ((null == e.label || s.name === e.label.name) && ((null != s.kind && (t || 1 === s.kind)) || (e.label && t))) break;
         }
         if (r === this.state.labels.length) {
          let r = t ? 'BreakStatement' : 'ContinueStatement';
          this.raise(y.IllegalBreakContinue, e, { type: r });
         }
        }
        parseDebuggerStatement(e) {
         return this.next(), this.semicolon(), this.finishNode(e, 'DebuggerStatement');
        }
        parseHeaderExpression() {
         this.expect(10);
         let e = this.parseExpression();
         return this.expect(11), e;
        }
        parseDoWhileStatement(e) {
         return this.next(), this.state.labels.push(Nt), (e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement())), this.state.labels.pop(), this.expect(92), (e.test = this.parseHeaderExpression()), this.eat(13), this.finishNode(e, 'DoWhileStatement');
        }
        parseForStatement(e) {
         this.next(), this.state.labels.push(Nt);
         let t = null;
         if ((this.isContextual(96) && this.recordAwaitIfAllowed() && ((t = this.state.startLoc), this.next()), this.scope.enter(0), this.expect(10), this.match(13))) return null !== t && this.unexpected(t), this.parseFor(e, null);
         let r = this.isContextual(100);
         {
          let s = this.isContextual(96) && this.startsAwaitUsing(),
           n = s || (this.isContextual(107) && this.startsUsingForOf()),
           i = (r && this.hasFollowingBindingAtom()) || n;
          if (this.match(74) || this.match(75) || i) {
           let r,
            i = this.startNode();
           s ? ((r = 'await using'), this.recordAwaitIfAllowed() || this.raise(y.AwaitUsingNotInAsyncContext, this.state.startLoc), this.next()) : (r = this.state.value), this.next(), this.parseVar(i, !0, r);
           let a = this.finishNode(i, 'VariableDeclaration'),
            o = this.match(58);
           return o && n && this.raise(y.ForInUsing, a), (o || this.isContextual(102)) && 1 === a.declarations.length ? this.parseForIn(e, a, t) : (null !== t && this.unexpected(t), this.parseFor(e, a));
          }
         }
         let s = this.isContextual(95),
          n = new et(),
          i = this.parseExpression(!0, n),
          a = this.isContextual(102);
         if ((a && (r && this.raise(y.ForOfLet, i), null === t && s && 'Identifier' === i.type && this.raise(y.ForOfAsync, i)), a || this.match(58))) {
          this.checkDestructuringPrivate(n), this.toAssignable(i, !0);
          let r = a ? 'ForOfStatement' : 'ForInStatement';
          return this.checkLVal(i, { type: r }), this.parseForIn(e, i, t);
         }
         return this.checkExpressionErrors(n, !0), null !== t && this.unexpected(t), this.parseFor(e, i);
        }
        parseFunctionStatement(e, t, r) {
         return this.next(), this.parseFunction(e, 1 | (r ? 2 : 0) | (t ? 8 : 0));
        }
        parseIfStatement(e) {
         return this.next(), (e.test = this.parseHeaderExpression()), (e.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration()), (e.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null), this.finishNode(e, 'IfStatement');
        }
        parseReturnStatement(e) {
         return !this.prodParam.hasReturn && !(2 & this.optionFlags) && this.raise(y.IllegalReturn, this.state.startLoc), this.next(), this.isLineTerminator() ? (e.argument = null) : ((e.argument = this.parseExpression()), this.semicolon()), this.finishNode(e, 'ReturnStatement');
        }
        parseSwitchStatement(e) {
         this.next(), (e.discriminant = this.parseHeaderExpression());
         let t,
          r = (e.cases = []);
         this.expect(5), this.state.labels.push(Bt), this.scope.enter(0);
         for (let s; !this.match(8); )
          if (this.match(61) || this.match(65)) {
           let e = this.match(61);
           t && this.finishNode(t, 'SwitchCase'), r.push((t = this.startNode())), (t.consequent = []), this.next(), e ? (t.test = this.parseExpression()) : (s && this.raise(y.MultipleDefaultsInSwitch, this.state.lastTokStartLoc), (s = !0), (t.test = null)), this.expect(14);
          } else t ? t.consequent.push(this.parseStatementListItem()) : this.unexpected();
         return this.scope.exit(), t && this.finishNode(t, 'SwitchCase'), this.next(), this.state.labels.pop(), this.finishNode(e, 'SwitchStatement');
        }
        parseThrowStatement(e) {
         return this.next(), this.hasPrecedingLineBreak() && this.raise(y.NewlineAfterThrow, this.state.lastTokEndLoc), (e.argument = this.parseExpression()), this.semicolon(), this.finishNode(e, 'ThrowStatement');
        }
        parseCatchClauseParam() {
         let e = this.parseBindingAtom();
         return this.scope.enter(this.options.annexB && 'Identifier' === e.type ? 8 : 0), this.checkLVal(e, { type: 'CatchClause' }, 9), e;
        }
        parseTryStatement(e) {
         if ((this.next(), (e.block = this.parseBlock()), (e.handler = null), this.match(62))) {
          let t = this.startNode();
          this.next(), this.match(10) ? (this.expect(10), (t.param = this.parseCatchClauseParam()), this.expect(11)) : ((t.param = null), this.scope.enter(0)), (t.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(!1, !1))), this.scope.exit(), (e.handler = this.finishNode(t, 'CatchClause'));
         }
         return (e.finalizer = this.eat(67) ? this.parseBlock() : null), !e.handler && !e.finalizer && this.raise(y.NoCatchOrFinally, e), this.finishNode(e, 'TryStatement');
        }
        parseVarStatement(e, t, r = !1) {
         return this.next(), this.parseVar(e, !1, t, r), this.semicolon(), this.finishNode(e, 'VariableDeclaration');
        }
        parseWhileStatement(e) {
         return this.next(), (e.test = this.parseHeaderExpression()), this.state.labels.push(Nt), (e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement())), this.state.labels.pop(), this.finishNode(e, 'WhileStatement');
        }
        parseWithStatement(e) {
         return this.state.strict && this.raise(y.StrictWith, this.state.startLoc), this.next(), (e.object = this.parseHeaderExpression()), (e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement())), this.finishNode(e, 'WithStatement');
        }
        parseEmptyStatement(e) {
         return this.next(), this.finishNode(e, 'EmptyStatement');
        }
        parseLabeledStatement(e, t, r, s) {
         for (let a of this.state.labels) a.name === t && this.raise(y.LabelRedeclaration, r, { labelName: t });
         let n = (i = this.state.type) >= 90 && i <= 92 ? 1 : this.match(71) ? 2 : null;
         var i;
         for (let a = this.state.labels.length - 1; a >= 0; a--) {
          let t = this.state.labels[a];
          if (t.statementStart !== e.start) break;
          (t.statementStart = this.sourceToOffsetPos(this.state.start)), (t.kind = n);
         }
         return this.state.labels.push({ name: t, kind: n, statementStart: this.sourceToOffsetPos(this.state.start) }), (e.body = 8 & s ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(!0) : this.parseStatement()), this.state.labels.pop(), (e.label = r), this.finishNode(e, 'LabeledStatement');
        }
        parseExpressionStatement(e, t, r) {
         return (e.expression = t), this.semicolon(), this.finishNode(e, 'ExpressionStatement');
        }
        parseBlock(e = !1, t = !0, r) {
         let s = this.startNode();
         return e && this.state.strictErrors.clear(), this.expect(5), t && this.scope.enter(0), this.parseBlockBody(s, e, !1, 8, r), t && this.scope.exit(), this.finishNode(s, 'BlockStatement');
        }
        isValidDirective(e) {
         return 'ExpressionStatement' === e.type && 'StringLiteral' === e.expression.type && !e.expression.extra.parenthesized;
        }
        parseBlockBody(e, t, r, s, n) {
         let i = (e.body = []),
          a = (e.directives = []);
         this.parseBlockOrModuleBlockBody(i, t ? a : void 0, r, s, n);
        }
        parseBlockOrModuleBlockBody(e, t, r, s, n) {
         let i = this.state.strict,
          a = !1,
          o = !1;
         for (; !this.match(s); ) {
          let s = r ? this.parseModuleItem() : this.parseStatementListItem();
          if (t && !o) {
           if (this.isValidDirective(s)) {
            let e = this.stmtToDirective(s);
            t.push(e), !a && 'use strict' === e.value.value && ((a = !0), this.setStrict(!0));
            continue;
           }
           (o = !0), this.state.strictErrors.clear();
          }
          e.push(s);
         }
         null == n || n.call(this, a), i || this.setStrict(!1), this.next();
        }
        parseFor(e, t) {
         return (e.init = t), this.semicolon(!1), (e.test = this.match(13) ? null : this.parseExpression()), this.semicolon(!1), (e.update = this.match(11) ? null : this.parseExpression()), this.expect(11), (e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement())), this.scope.exit(), this.state.labels.pop(), this.finishNode(e, 'ForStatement');
        }
        parseForIn(e, t, r) {
         let s = this.match(58);
         return this.next(), s ? null !== r && this.unexpected(r) : (e.await = null !== r), 'VariableDeclaration' === t.type && null != t.declarations[0].init && (!s || !this.options.annexB || this.state.strict || 'var' !== t.kind || 'Identifier' !== t.declarations[0].id.type) && this.raise(y.ForInOfLoopInitializer, t, { type: s ? 'ForInStatement' : 'ForOfStatement' }), 'AssignmentPattern' === t.type && this.raise(y.InvalidLhs, t, { ancestor: { type: 'ForStatement' } }), (e.left = t), (e.right = s ? this.parseExpression() : this.parseMaybeAssignAllowIn()), this.expect(11), (e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement())), this.scope.exit(), this.state.labels.pop(), this.finishNode(e, s ? 'ForInStatement' : 'ForOfStatement');
        }
        parseVar(e, t, r, s = !1) {
         let n = (e.declarations = []);
         for (e.kind = r; ; ) {
          let e = this.startNode();
          if ((this.parseVarId(e, r), (e.init = this.eat(29) ? (t ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn()) : null), null === e.init && !s && ('Identifier' === e.id.type || (t && (this.match(58) || this.isContextual(102))) ? ('const' === r || 'using' === r || 'await using' === r) && !(this.match(58) || this.isContextual(102)) && this.raise(y.DeclarationMissingInitializer, this.state.lastTokEndLoc, { kind: r }) : this.raise(y.DeclarationMissingInitializer, this.state.lastTokEndLoc, { kind: 'destructuring' })), n.push(this.finishNode(e, 'VariableDeclarator')), !this.eat(12))) break;
         }
         return e;
        }
        parseVarId(e, t) {
         let r = this.parseBindingAtom();
         ('using' === t || 'await using' === t) && ('ArrayPattern' === r.type || 'ObjectPattern' === r.type) && this.raise(y.UsingDeclarationHasBindingPattern, r.loc.start), this.checkLVal(r, { type: 'VariableDeclarator' }, 'var' === t ? 5 : 8201), (e.id = r);
        }
        parseAsyncFunctionExpression(e) {
         return this.parseFunction(e, 8);
        }
        parseFunction(e, t = 0) {
         let r = 2 & t,
          s = !!(1 & t),
          n = s && !(4 & t),
          i = !!(8 & t);
         this.initFunction(e, i), this.match(55) && (r && this.raise(y.GeneratorInSingleStatementContext, this.state.startLoc), this.next(), (e.generator = !0)), s && (e.id = this.parseFunctionId(n));
         let a = this.state.maybeInArrowParameters;
         return (
          (this.state.maybeInArrowParameters = !1),
          this.scope.enter(2),
          this.prodParam.enter(Qe(i, e.generator)),
          s || (e.id = this.parseFunctionId()),
          this.parseFunctionParams(e, !1),
          this.withSmartMixTopicForbiddingContext(() => {
           this.parseFunctionBodyAndFinish(e, s ? 'FunctionDeclaration' : 'FunctionExpression');
          }),
          this.prodParam.exit(),
          this.scope.exit(),
          s && !r && this.registerFunctionStatementId(e),
          (this.state.maybeInArrowParameters = a),
          e
         );
        }
        parseFunctionId(e) {
         return e || $(this.state.type) ? this.parseIdentifier() : null;
        }
        parseFunctionParams(e, t) {
         this.expect(10), this.expressionScope.enter(new He(3)), (e.params = this.parseBindingList(11, 41, 2 | (t ? 4 : 0))), this.expressionScope.exit();
        }
        registerFunctionStatementId(e) {
         e.id && this.scope.declareName(e.id.name, !this.options.annexB || this.state.strict || e.generator || e.async ? (this.scope.treatFunctionsAsVar ? 5 : 8201) : 17, e.id.loc.start);
        }
        parseClass(e, t, r) {
         this.next();
         let s = this.state.strict;
         return (this.state.strict = !0), this.parseClassId(e, t, r), this.parseClassSuper(e), (e.body = this.parseClassBody(!!e.superClass, s)), this.finishNode(e, t ? 'ClassDeclaration' : 'ClassExpression');
        }
        isClassProperty() {
         return this.match(29) || this.match(13) || this.match(8);
        }
        isClassMethod() {
         return this.match(10);
        }
        nameIsConstructor(e) {
         return ('Identifier' === e.type && 'constructor' === e.name) || ('StringLiteral' === e.type && 'constructor' === e.value);
        }
        isNonstaticConstructor(e) {
         return !e.computed && !e.static && this.nameIsConstructor(e.key);
        }
        parseClassBody(e, t) {
         this.classScope.enter();
         let r = { hadConstructor: !1, hadSuperClass: e },
          s = [],
          n = this.startNode();
         if (
          ((n.body = []),
          this.expect(5),
          this.withSmartMixTopicForbiddingContext(() => {
           for (; !this.match(8); ) {
            if (this.eat(13)) {
             if (s.length > 0) throw this.raise(y.DecoratorSemicolon, this.state.lastTokEndLoc);
             continue;
            }
            if (this.match(26)) {
             s.push(this.parseDecorator());
             continue;
            }
            let e = this.startNode();
            s.length && ((e.decorators = s), this.resetStartLocationFromNode(e, s[0]), (s = [])), this.parseClassMember(n, e, r), 'constructor' === e.kind && e.decorators && e.decorators.length > 0 && this.raise(y.DecoratorConstructor, e);
           }
          }),
          (this.state.strict = t),
          this.next(),
          s.length)
         )
          throw this.raise(y.TrailingDecorator, this.state.startLoc);
         return this.classScope.exit(), this.finishNode(n, 'ClassBody');
        }
        parseClassMemberFromModifier(e, t) {
         let r = this.parseIdentifier(!0);
         if (this.isClassMethod()) {
          let s = t;
          return (s.kind = 'method'), (s.computed = !1), (s.key = r), (s.static = !1), this.pushClassMethod(e, s, !1, !1, !1, !1), !0;
         }
         if (this.isClassProperty()) {
          let s = t;
          return (s.computed = !1), (s.key = r), (s.static = !1), e.body.push(this.parseClassProperty(s)), !0;
         }
         return this.resetPreviousNodeTrailingComments(r), !1;
        }
        parseClassMember(e, t, r) {
         let s = this.isContextual(106);
         if (s) {
          if (this.parseClassMemberFromModifier(e, t)) return;
          if (this.eat(5)) return void this.parseClassStaticBlock(e, t);
         }
         this.parseClassMemberWithIsStatic(e, t, r, s);
        }
        parseClassMemberWithIsStatic(e, t, r, s) {
         let n = t,
          i = t,
          a = t,
          o = t,
          u = t,
          l = n,
          p = n;
         if (((t.static = s), this.parsePropertyNamePrefixOperator(t), this.eat(55))) {
          l.kind = 'method';
          let t = this.match(139);
          return this.parseClassElementName(l), t ? void this.pushClassPrivateMethod(e, i, !0, !1) : (this.isNonstaticConstructor(n) && this.raise(y.ConstructorIsGenerator, n.key), void this.pushClassMethod(e, n, !0, !1, !1, !1));
         }
         let c = !this.state.containsEsc && $(this.state.type),
          h = this.parseClassElementName(t),
          d = c ? h.name : null,
          f = this.isPrivateName(h),
          m = this.state.startLoc;
         if ((this.parsePostMemberNameModifiers(p), this.isClassMethod())) {
          if (((l.kind = 'method'), f)) return void this.pushClassPrivateMethod(e, i, !1, !1);
          let s = this.isNonstaticConstructor(n),
           a = !1;
          s && ((n.kind = 'constructor'), r.hadConstructor && !this.hasPlugin('typescript') && this.raise(y.DuplicateConstructor, h), s && this.hasPlugin('typescript') && t.override && this.raise(y.OverrideOnConstructor, h), (r.hadConstructor = !0), (a = r.hadSuperClass)), this.pushClassMethod(e, n, !1, !1, s, a);
         } else if (this.isClassProperty()) f ? this.pushClassPrivateProperty(e, o) : this.pushClassProperty(e, a);
         else if ('async' !== d || this.isLineTerminator())
          if (('get' !== d && 'set' !== d) || (this.match(55) && this.isLineTerminator()))
           if ('accessor' !== d || this.isLineTerminator()) this.isLineTerminator() ? (f ? this.pushClassPrivateProperty(e, o) : this.pushClassProperty(e, a)) : this.unexpected();
           else {
            this.expectPlugin('decoratorAutoAccessors'), this.resetPreviousNodeTrailingComments(h);
            let t = this.match(139);
            this.parseClassElementName(a), this.pushClassAccessorProperty(e, u, t);
           }
          else {
           this.resetPreviousNodeTrailingComments(h), (l.kind = d);
           let t = this.match(139);
           this.parseClassElementName(n), t ? this.pushClassPrivateMethod(e, i, !1, !1) : (this.isNonstaticConstructor(n) && this.raise(y.ConstructorIsAccessor, n.key), this.pushClassMethod(e, n, !1, !1, !1, !1)), this.checkGetterSetterParams(n);
          }
         else {
          this.resetPreviousNodeTrailingComments(h);
          let t = this.eat(55);
          p.optional && this.unexpected(m), (l.kind = 'method');
          let r = this.match(139);
          this.parseClassElementName(l), this.parsePostMemberNameModifiers(p), r ? this.pushClassPrivateMethod(e, i, t, !0) : (this.isNonstaticConstructor(n) && this.raise(y.ConstructorIsAsync, n.key), this.pushClassMethod(e, n, t, !0, !1, !1));
         }
        }
        parseClassElementName(e) {
         let { type: t, value: r } = this.state;
         if (((132 === t || 134 === t) && e.static && 'prototype' === r && this.raise(y.StaticPrototype, this.state.startLoc), 139 === t)) {
          'constructor' === r && this.raise(y.ConstructorClassPrivateField, this.state.startLoc);
          let t = this.parsePrivateName();
          return (e.key = t), t;
         }
         return this.parsePropertyName(e), e.key;
        }
        parseClassStaticBlock(e, t) {
         var r;
         this.scope.enter(208);
         let s = this.state.labels;
         (this.state.labels = []), this.prodParam.enter(0);
         let n = (t.body = []);
         this.parseBlockOrModuleBlockBody(n, void 0, !1, 8), this.prodParam.exit(), this.scope.exit(), (this.state.labels = s), e.body.push(this.finishNode(t, 'StaticBlock')), null != (r = t.decorators) && r.length && this.raise(y.DecoratorStaticBlock, t);
        }
        pushClassProperty(e, t) {
         !t.computed && this.nameIsConstructor(t.key) && this.raise(y.ConstructorClassField, t.key), e.body.push(this.parseClassProperty(t));
        }
        pushClassPrivateProperty(e, t) {
         let r = this.parseClassPrivateProperty(t);
         e.body.push(r), this.classScope.declarePrivateName(this.getPrivateNameSV(r.key), 0, r.key.loc.start);
        }
        pushClassAccessorProperty(e, t, r) {
         !r && !t.computed && this.nameIsConstructor(t.key) && this.raise(y.ConstructorClassField, t.key);
         let s = this.parseClassAccessorProperty(t);
         e.body.push(s), r && this.classScope.declarePrivateName(this.getPrivateNameSV(s.key), 0, s.key.loc.start);
        }
        pushClassMethod(e, t, r, s, n, i) {
         e.body.push(this.parseMethod(t, r, s, n, i, 'ClassMethod', !0));
        }
        pushClassPrivateMethod(e, t, r, s) {
         let n = this.parseMethod(t, r, s, !1, !1, 'ClassPrivateMethod', !0);
         e.body.push(n);
         let i = 'get' === n.kind ? (n.static ? 6 : 2) : 'set' === n.kind ? (n.static ? 5 : 1) : 0;
         this.declareClassPrivateMethodInScope(n, i);
        }
        declareClassPrivateMethodInScope(e, t) {
         this.classScope.declarePrivateName(this.getPrivateNameSV(e.key), t, e.key.loc.start);
        }
        parsePostMemberNameModifiers(e) {}
        parseClassPrivateProperty(e) {
         return this.parseInitializer(e), this.semicolon(), this.finishNode(e, 'ClassPrivateProperty');
        }
        parseClassProperty(e) {
         return this.parseInitializer(e), this.semicolon(), this.finishNode(e, 'ClassProperty');
        }
        parseClassAccessorProperty(e) {
         return this.parseInitializer(e), this.semicolon(), this.finishNode(e, 'ClassAccessorProperty');
        }
        parseInitializer(e) {
         this.scope.enter(80), this.expressionScope.enter(Ge()), this.prodParam.enter(0), (e.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null), this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
        }
        parseClassId(e, t, r, s = 8331) {
         if ($(this.state.type)) (e.id = this.parseIdentifier()), t && this.declareNameFromIdentifier(e.id, s);
         else {
          if (!r && t) throw this.raise(y.MissingClassName, this.state.startLoc);
          e.id = null;
         }
        }
        parseClassSuper(e) {
         e.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
        }
        parseExport(e, t) {
         let r = this.parseMaybeImportPhase(e, !0),
          s = this.maybeParseExportDefaultSpecifier(e, r),
          n = !s || this.eat(12),
          i = n && this.eatExportStar(e),
          a = i && this.maybeParseExportNamespaceSpecifier(e),
          o = n && (!a || this.eat(12)),
          u = s || i;
         if (i && !a) {
          if ((s && this.unexpected(), t)) throw this.raise(y.UnsupportedDecoratorExport, e);
          return this.parseExportFrom(e, !0), this.finishNode(e, 'ExportAllDeclaration');
         }
         let l,
          p = this.maybeParseExportNamedSpecifiers(e);
         if ((s && n && !i && !p && this.unexpected(null, 5), a && o && this.unexpected(null, 98), u || p)) {
          if (((l = !1), t)) throw this.raise(y.UnsupportedDecoratorExport, e);
          this.parseExportFrom(e, u);
         } else l = this.maybeParseExportDeclaration(e);
         if (u || p || l) {
          var c;
          let r = e;
          if ((this.checkExport(r, !0, !1, !!r.source), 'ClassDeclaration' === (null == (c = r.declaration) ? void 0 : c.type))) this.maybeTakeDecorators(t, r.declaration, r);
          else if (t) throw this.raise(y.UnsupportedDecoratorExport, e);
          return this.finishNode(r, 'ExportNamedDeclaration');
         }
         if (this.eat(65)) {
          let r = e,
           s = this.parseExportDefaultExpression();
          if (((r.declaration = s), 'ClassDeclaration' === s.type)) this.maybeTakeDecorators(t, s, r);
          else if (t) throw this.raise(y.UnsupportedDecoratorExport, e);
          return this.checkExport(r, !0, !0), this.finishNode(r, 'ExportDefaultDeclaration');
         }
         this.unexpected(null, 5);
        }
        eatExportStar(e) {
         return this.eat(55);
        }
        maybeParseExportDefaultSpecifier(e, t) {
         if (t || this.isExportDefaultSpecifier()) {
          this.expectPlugin('exportDefaultFrom', null == t ? void 0 : t.loc.start);
          let r = t || this.parseIdentifier(!0),
           s = this.startNodeAtNode(r);
          return (s.exported = r), (e.specifiers = [this.finishNode(s, 'ExportDefaultSpecifier')]), !0;
         }
         return !1;
        }
        maybeParseExportNamespaceSpecifier(e) {
         if (this.isContextual(93)) {
          var t;
          null != (t = e).specifiers || (t.specifiers = []);
          let r = this.startNodeAt(this.state.lastTokStartLoc);
          return this.next(), (r.exported = this.parseModuleExportName()), e.specifiers.push(this.finishNode(r, 'ExportNamespaceSpecifier')), !0;
         }
         return !1;
        }
        maybeParseExportNamedSpecifiers(e) {
         if (this.match(5)) {
          let t = e;
          t.specifiers || (t.specifiers = []);
          let r = 'type' === t.exportKind;
          return t.specifiers.push(...this.parseExportSpecifiers(r)), (t.source = null), (t.declaration = null), this.hasPlugin('importAssertions') && (t.assertions = []), !0;
         }
         return !1;
        }
        maybeParseExportDeclaration(e) {
         return !!this.shouldParseExportDeclaration() && ((e.specifiers = []), (e.source = null), this.hasPlugin('importAssertions') && (e.assertions = []), (e.declaration = this.parseExportDeclaration(e)), !0);
        }
        isAsyncFunction() {
         if (!this.isContextual(95)) return !1;
         let e = this.nextTokenInLineStart();
         return this.isUnparsedContextual(e, 'function');
        }
        parseExportDefaultExpression() {
         let e = this.startNode();
         if (this.match(68)) return this.next(), this.parseFunction(e, 5);
         if (this.isAsyncFunction()) return this.next(), this.next(), this.parseFunction(e, 13);
         if (this.match(80)) return this.parseClass(e, !0, !0);
         if (this.match(26)) return this.hasPlugin('decorators') && !0 === this.getPluginOption('decorators', 'decoratorsBeforeExport') && this.raise(y.DecoratorBeforeExport, this.state.startLoc), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(!1), this.startNode()), !0, !0);
         if (this.match(75) || this.match(74) || this.isLet()) throw this.raise(y.UnsupportedDefaultExport, this.state.startLoc);
         let t = this.parseMaybeAssignAllowIn();
         return this.semicolon(), t;
        }
        parseExportDeclaration(e) {
         return this.match(80) ? this.parseClass(this.startNode(), !0, !1) : this.parseStatementListItem();
        }
        isExportDefaultSpecifier() {
         let { type: e } = this.state;
         if ($(e)) {
          if ((95 === e && !this.state.containsEsc) || 100 === e) return !1;
          if ((130 === e || 129 === e) && !this.state.containsEsc) {
           let { type: e } = this.lookahead();
           if (($(e) && 98 !== e) || 5 === e) return this.expectOnePlugin(['flow', 'typescript']), !1;
          }
         } else if (!this.match(65)) return !1;
         let t = this.nextTokenStart(),
          r = this.isUnparsedContextual(t, 'from');
         if (44 === this.input.charCodeAt(t) || ($(this.state.type) && r)) return !0;
         if (this.match(65) && r) {
          let e = this.input.charCodeAt(this.nextTokenStartSince(t + 4));
          return 34 === e || 39 === e;
         }
         return !1;
        }
        parseExportFrom(e, t) {
         this.eatContextual(98) ? ((e.source = this.parseImportSource()), this.checkExport(e), this.maybeParseImportAttributes(e), this.checkJSONModuleImport(e)) : t && this.unexpected(), this.semicolon();
        }
        shouldParseExportDeclaration() {
         let { type: e } = this.state;
         return 26 === e && (this.expectOnePlugin(['decorators', 'decorators-legacy']), this.hasPlugin('decorators')) ? (!0 === this.getPluginOption('decorators', 'decoratorsBeforeExport') && this.raise(y.DecoratorBeforeExport, this.state.startLoc), !0) : this.isContextual(107) || (this.isContextual(96) && this.startsAwaitUsing()) ? (this.raise(y.UsingDeclarationExport, this.state.startLoc), !0) : 74 === e || 75 === e || 68 === e || 80 === e || this.isLet() || this.isAsyncFunction();
        }
        checkExport(e, t, r, s) {
         var n;
         if (t)
          if (r) {
           if ((this.checkDuplicateExports(e, 'default'), this.hasPlugin('exportDefaultFrom'))) {
            var i;
            let t = e.declaration;
            'Identifier' === t.type && 'from' === t.name && t.end - t.start == 4 && (null == (i = t.extra) || !i.parenthesized) && this.raise(y.ExportDefaultFromAsIdentifier, t);
           }
          } else if (null != (n = e.specifiers) && n.length)
           for (let a of e.specifiers) {
            let { exported: e } = a,
             t = 'Identifier' === e.type ? e.name : e.value;
            if ((this.checkDuplicateExports(a, t), !s && a.local)) {
             let { local: e } = a;
             'Identifier' !== e.type ? this.raise(y.ExportBindingIsString, a, { localName: e.value, exportName: t }) : (this.checkReservedWord(e.name, e.loc.start, !0, !1), this.scope.checkLocalExport(e));
            }
           }
          else if (e.declaration) {
           let t = e.declaration;
           if ('FunctionDeclaration' === t.type || 'ClassDeclaration' === t.type) {
            let { id: r } = t;
            if (!r) throw new Error('Assertion failure');
            this.checkDuplicateExports(e, r.name);
           } else if ('VariableDeclaration' === t.type) for (let e of t.declarations) this.checkDeclaration(e.id);
          }
        }
        checkDeclaration(e) {
         if ('Identifier' === e.type) this.checkDuplicateExports(e, e.name);
         else if ('ObjectPattern' === e.type) for (let t of e.properties) this.checkDeclaration(t);
         else if ('ArrayPattern' === e.type) for (let t of e.elements) t && this.checkDeclaration(t);
         else 'ObjectProperty' === e.type ? this.checkDeclaration(e.value) : 'RestElement' === e.type ? this.checkDeclaration(e.argument) : 'AssignmentPattern' === e.type && this.checkDeclaration(e.left);
        }
        checkDuplicateExports(e, t) {
         this.exportedIdentifiers.has(t) && ('default' === t ? this.raise(y.DuplicateDefaultExport, e) : this.raise(y.DuplicateExport, e, { exportName: t })), this.exportedIdentifiers.add(t);
        }
        parseExportSpecifiers(e) {
         let t = [],
          r = !0;
         for (this.expect(5); !this.eat(8); ) {
          if (r) r = !1;
          else if ((this.expect(12), this.eat(8))) break;
          let s = this.isContextual(130),
           n = this.match(134),
           i = this.startNode();
          (i.local = this.parseModuleExportName()), t.push(this.parseExportSpecifier(i, n, e, s));
         }
         return t;
        }
        parseExportSpecifier(e, t, r, s) {
         return this.eatContextual(93) ? (e.exported = this.parseModuleExportName()) : t ? (e.exported = nt(e.local)) : e.exported || (e.exported = st(e.local)), this.finishNode(e, 'ExportSpecifier');
        }
        parseModuleExportName() {
         if (this.match(134)) {
          let e = this.parseStringLiteral(this.state.value),
           t = Ot.exec(e.value);
          return t && this.raise(y.ModuleExportNameHasLoneSurrogate, e, { surrogateCharCode: t[0].charCodeAt(0) }), e;
         }
         return this.parseIdentifier(!0);
        }
        isJSONModuleImport(e) {
         return null != e.assertions && e.assertions.some(({ key: e, value: t }) => 'json' === t.value && ('Identifier' === e.type ? 'type' === e.name : 'type' === e.value));
        }
        checkImportReflection(e) {
         let { specifiers: t } = e,
          r = 1 === t.length ? t[0].type : null;
         if ('source' === e.phase) 'ImportDefaultSpecifier' !== r && this.raise(y.SourcePhaseImportRequiresDefault, t[0].loc.start);
         else if ('defer' === e.phase) 'ImportNamespaceSpecifier' !== r && this.raise(y.DeferImportRequiresNamespace, t[0].loc.start);
         else if (e.module) {
          var s;
          'ImportDefaultSpecifier' !== r && this.raise(y.ImportReflectionNotBinding, t[0].loc.start), (null == (s = e.assertions) ? void 0 : s.length) > 0 && this.raise(y.ImportReflectionHasAssertion, t[0].loc.start);
         }
        }
        checkJSONModuleImport(e) {
         if (this.isJSONModuleImport(e) && 'ExportAllDeclaration' !== e.type) {
          let { specifiers: t } = e;
          if (null != t) {
           let e = t.find((e) => {
            let t;
            if (('ExportSpecifier' === e.type ? (t = e.local) : 'ImportSpecifier' === e.type && (t = e.imported), void 0 !== t)) return 'Identifier' === t.type ? 'default' !== t.name : 'default' !== t.value;
           });
           void 0 !== e && this.raise(y.ImportJSONBindingNotDefault, e.loc.start);
          }
         }
        }
        isPotentialImportPhase(e) {
         return !e && (this.isContextual(105) || this.isContextual(97) || this.isContextual(127));
        }
        applyImportPhase(e, t, r, s) {
         t || ('module' === r ? (this.expectPlugin('importReflection', s), (e.module = !0)) : this.hasPlugin('importReflection') && (e.module = !1), 'source' === r ? (this.expectPlugin('sourcePhaseImports', s), (e.phase = 'source')) : 'defer' === r ? (this.expectPlugin('deferredImportEvaluation', s), (e.phase = 'defer')) : this.hasPlugin('sourcePhaseImports') && (e.phase = null));
        }
        parseMaybeImportPhase(e, t) {
         if (!this.isPotentialImportPhase(t)) return this.applyImportPhase(e, t, null), null;
         let r = this.parseIdentifier(!0),
          { type: s } = this.state;
         return (q(s) ? 98 !== s || 102 === this.lookaheadCharCode() : 12 !== s) ? (this.resetPreviousIdentifierLeadingComments(r), this.applyImportPhase(e, t, r.name, r.loc.start), null) : (this.applyImportPhase(e, t, null), r);
        }
        isPrecedingIdImportPhase(e) {
         let { type: t } = this.state;
         return $(t) ? 98 !== t || 102 === this.lookaheadCharCode() : 12 !== t;
        }
        parseImport(e) {
         return this.match(134) ? this.parseImportSourceAndAttributes(e) : this.parseImportSpecifiersAndAfter(e, this.parseMaybeImportPhase(e, !1));
        }
        parseImportSpecifiersAndAfter(e, t) {
         e.specifiers = [];
         let r = !this.maybeParseDefaultImportSpecifier(e, t) || this.eat(12),
          s = r && this.maybeParseStarImportSpecifier(e);
         return r && !s && this.parseNamedImportSpecifiers(e), this.expectContextual(98), this.parseImportSourceAndAttributes(e);
        }
        parseImportSourceAndAttributes(e) {
         return null != e.specifiers || (e.specifiers = []), (e.source = this.parseImportSource()), this.maybeParseImportAttributes(e), this.checkImportReflection(e), this.checkJSONModuleImport(e), this.semicolon(), this.finishNode(e, 'ImportDeclaration');
        }
        parseImportSource() {
         return this.match(134) || this.unexpected(), this.parseExprAtom();
        }
        parseImportSpecifierLocal(e, t, r) {
         (t.local = this.parseIdentifier()), e.specifiers.push(this.finishImportSpecifier(t, r));
        }
        finishImportSpecifier(e, t, r = 8201) {
         return this.checkLVal(e.local, { type: t }, r), this.finishNode(e, t);
        }
        parseImportAttributes() {
         this.expect(5);
         let e = [],
          t = new Set();
         do {
          if (this.match(8)) break;
          let r = this.startNode(),
           s = this.state.value;
          if ((t.has(s) && this.raise(y.ModuleAttributesWithDuplicateKeys, this.state.startLoc, { key: s }), t.add(s), this.match(134) ? (r.key = this.parseStringLiteral(s)) : (r.key = this.parseIdentifier(!0)), this.expect(14), !this.match(134))) throw this.raise(y.ModuleAttributeInvalidValue, this.state.startLoc);
          (r.value = this.parseStringLiteral(this.state.value)), e.push(this.finishNode(r, 'ImportAttribute'));
         } while (this.eat(12));
         return this.expect(8), e;
        }
        parseModuleAttributes() {
         let e = [],
          t = new Set();
         do {
          let r = this.startNode();
          if (((r.key = this.parseIdentifier(!0)), 'type' !== r.key.name && this.raise(y.ModuleAttributeDifferentFromType, r.key), t.has(r.key.name) && this.raise(y.ModuleAttributesWithDuplicateKeys, r.key, { key: r.key.name }), t.add(r.key.name), this.expect(14), !this.match(134))) throw this.raise(y.ModuleAttributeInvalidValue, this.state.startLoc);
          (r.value = this.parseStringLiteral(this.state.value)), e.push(this.finishNode(r, 'ImportAttribute'));
         } while (this.eat(12));
         return e;
        }
        maybeParseImportAttributes(e) {
         let t;
         var r = !1;
         if (this.match(76)) {
          if (this.hasPrecedingLineBreak() && 40 === this.lookaheadCharCode()) return;
          this.next(), (t = this.hasPlugin('moduleAttributes') ? this.parseModuleAttributes() : this.parseImportAttributes()), (r = !0);
         } else this.isContextual(94) && !this.hasPrecedingLineBreak() ? (!this.hasPlugin('deprecatedImportAssert') && !this.hasPlugin('importAssertions') && this.raise(y.ImportAttributesUseAssert, this.state.startLoc), this.hasPlugin('importAssertions') || this.addExtra(e, 'deprecatedAssertSyntax', !0), this.next(), (t = this.parseImportAttributes())) : (t = []);
         !r && this.hasPlugin('importAssertions') ? (e.assertions = t) : (e.attributes = t);
        }
        maybeParseDefaultImportSpecifier(e, t) {
         if (t) {
          let r = this.startNodeAtNode(t);
          return (r.local = t), e.specifiers.push(this.finishImportSpecifier(r, 'ImportDefaultSpecifier')), !0;
         }
         return !!q(this.state.type) && (this.parseImportSpecifierLocal(e, this.startNode(), 'ImportDefaultSpecifier'), !0);
        }
        maybeParseStarImportSpecifier(e) {
         if (this.match(55)) {
          let t = this.startNode();
          return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(e, t, 'ImportNamespaceSpecifier'), !0;
         }
         return !1;
        }
        parseNamedImportSpecifiers(e) {
         let t = !0;
         for (this.expect(5); !this.eat(8); ) {
          if (t) t = !1;
          else {
           if (this.eat(14)) throw this.raise(y.DestructureNamedImport, this.state.startLoc);
           if ((this.expect(12), this.eat(8))) break;
          }
          let r = this.startNode(),
           s = this.match(134),
           n = this.isContextual(130);
          r.imported = this.parseModuleExportName();
          let i = this.parseImportSpecifier(r, s, 'type' === e.importKind || 'typeof' === e.importKind, n, void 0);
          e.specifiers.push(i);
         }
        }
        parseImportSpecifier(e, t, r, s, n) {
         if (this.eatContextual(93)) e.local = this.parseIdentifier();
         else {
          let { imported: r } = e;
          if (t) throw this.raise(y.ImportBindingIsString, e, { importName: r.value });
          this.checkReservedWord(r.name, e.loc.start, !0, !0), e.local || (e.local = st(r));
         }
         return this.finishImportSpecifier(e, 'ImportSpecifier', n);
        }
        isThisParam(e) {
         return 'Identifier' === e.type && 'this' === e.name;
        }
       },
       jt = class extends Mt {
        constructor(e, t, r) {
         (e = (function (e) {
          let t = { sourceType: 'script', sourceFilename: void 0, startIndex: 0, startColumn: 0, startLine: 1, allowAwaitOutsideFunction: !1, allowReturnOutsideFunction: !1, allowNewTargetOutsideFunction: !1, allowImportExportEverywhere: !1, allowSuperOutsideMethod: !1, allowUndeclaredExports: !1, plugins: [], strictMode: null, ranges: !1, tokens: !1, createImportExpressions: !1, createParenthesizedExpressions: !1, errorRecovery: !1, attachComment: !0, annexB: !0 };
          if (null == e) return t;
          if (null != e.annexB && !1 !== e.annexB) throw new Error('The `annexB` option can only be set to `false`.');
          for (let r of Object.keys(t)) null != e[r] && (t[r] = e[r]);
          if (1 === t.startLine) null == e.startIndex && t.startColumn > 0 ? (t.startIndex = t.startColumn) : null == e.startColumn && t.startIndex > 0 && (t.startColumn = t.startIndex);
          else if ((null == e.startColumn || null == e.startIndex) && null != e.startIndex) throw new Error('With a `startLine > 1` you must also specify `startIndex` and `startColumn`.');
          return t;
         })(e)),
          super(e, t),
          (this.options = e),
          this.initializeScopes(),
          (this.plugins = r),
          (this.filename = e.sourceFilename),
          (this.startIndex = e.startIndex);
         let s = 0;
         e.allowAwaitOutsideFunction && (s |= 1), e.allowReturnOutsideFunction && (s |= 2), e.allowImportExportEverywhere && (s |= 8), e.allowSuperOutsideMethod && (s |= 16), e.allowUndeclaredExports && (s |= 32), e.allowNewTargetOutsideFunction && (s |= 4), e.ranges && (s |= 64), e.tokens && (s |= 128), e.createImportExpressions && (s |= 256), e.createParenthesizedExpressions && (s |= 512), e.errorRecovery && (s |= 1024), e.attachComment && (s |= 2048), e.annexB && (s |= 4096), (this.optionFlags = s);
        }
        getScopeHandler() {
         return De;
        }
        parse() {
         this.enterInitialScopes();
         let e = this.startNode(),
          t = this.startNode();
         return this.nextToken(), (e.errors = null), this.parseTopLevel(e, t), (e.errors = this.state.errors), (e.comments.length = this.state.commentsLen), e;
        }
       },
       _t = (function (e) {
        let t = {};
        for (let r of Object.keys(e)) t[r] = G(e[r]);
        return t;
       })(U);
      function Rt(e, t) {
       let r = jt,
        s = new Map();
       if (null != e && e.plugins) {
        for (let t of e.plugins) {
         let e, r;
         'string' == typeof t ? (e = t) : ([e, r] = t), s.has(e) || s.set(e, r || {});
        }
        (function (e) {
         if (e.has('decorators')) {
          if (e.has('decorators-legacy')) throw new Error('Cannot use the decorators and decorators-legacy plugin together');
          let t = e.get('decorators').decoratorsBeforeExport;
          if (null != t && 'boolean' != typeof t) throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
          let r = e.get('decorators').allowCallParenthesized;
          if (null != r && 'boolean' != typeof r) throw new Error("'allowCallParenthesized' must be a boolean.");
         }
         if (e.has('flow') && e.has('typescript')) throw new Error('Cannot combine flow and typescript plugins.');
         if (e.has('placeholders') && e.has('v8intrinsic')) throw new Error('Cannot combine placeholders and v8intrinsic plugins.');
         if (e.has('pipelineOperator')) {
          var t;
          let r = e.get('pipelineOperator').proposal;
          if (!wt.includes(r)) {
           let e = wt.map((e) => `"${e}"`).join(', ');
           throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${e}.`);
          }
          let s = 'hash' === (null == (t = e.get('recordAndTuple')) ? void 0 : t.syntaxType);
          if ('hack' === r) {
           if (e.has('placeholders')) throw new Error('Cannot combine placeholders plugin and Hack-style pipes.');
           if (e.has('v8intrinsic')) throw new Error('Cannot combine v8intrinsic plugin and Hack-style pipes.');
           let t = e.get('pipelineOperator').topicToken;
           if (!St.includes(t)) {
            let e = St.map((e) => `"${e}"`).join(', ');
            throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${e}.`);
           }
           if ('#' === t && s) throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "hack", topicToken: "#" }]\` and \`${JSON.stringify(['recordAndTuple', e.get('recordAndTuple')])}\`.`);
          } else if ('smart' === r && s) throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "smart" }]\` and \`${JSON.stringify(['recordAndTuple', e.get('recordAndTuple')])}\`.`);
         }
         if (e.has('moduleAttributes')) {
          if (e.has('deprecatedImportAssert') || e.has('importAssertions')) throw new Error('Cannot combine importAssertions, deprecatedImportAssert and moduleAttributes plugins.');
          if ('may-2020' !== e.get('moduleAttributes').version) throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
         }
         if (e.has('importAssertions') && e.has('deprecatedImportAssert')) throw new Error('Cannot combine importAssertions and deprecatedImportAssert plugins.');
         if ((!e.has('deprecatedImportAssert') && e.has('importAttributes') && e.get('importAttributes').deprecatedAssertSyntax && e.set('deprecatedImportAssert', {}), e.has('recordAndTuple'))) {
          let t = e.get('recordAndTuple').syntaxType;
          if (null != t) {
           let e = ['hash', 'bar'];
           if (!e.includes(t)) throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + e.map((e) => `'${e}'`).join(', '));
          }
         }
         if (e.has('asyncDoExpressions') && !e.has('doExpressions')) {
          let e = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
          throw ((e.missingPlugins = 'doExpressions'), e);
         }
         if (e.has('optionalChainingAssign') && '2023-07' !== e.get('optionalChainingAssign').version) throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'.");
        })(s),
         (r = (function (e) {
          let t = [];
          for (let n of kt) e.has(n) && t.push(n);
          let r = t.join('|'),
           s = Ut.get(r);
          if (!s) {
           s = jt;
           for (let e of t) s = Pt[e](s);
           Ut.set(r, s);
          }
          return s;
         })(s));
       }
       return new r(e, t, s);
      }
      var Ut = new Map();
      (e.parse = function (e, t) {
       var r;
       if ('unambiguous' !== (null == (r = t) ? void 0 : r.sourceType)) return Rt(t, e).parse();
       t = Object.assign({}, t);
       try {
        t.sourceType = 'module';
        let r = Rt(t, e),
         s = r.parse();
        if (r.sawUnambiguousESM) return s;
        if (r.ambiguousScriptDifferentAst)
         try {
          return (t.sourceType = 'script'), Rt(t, e).parse();
         } catch {}
        else s.program.sourceType = 'script';
        return s;
       } catch (s) {
        try {
         return (t.sourceType = 'script'), Rt(t, e).parse();
        } catch {}
        throw s;
       }
      }),
       (e.parseExpression = function (e, t) {
        let r = Rt(t, e);
        return r.options.strictMode && (r.state.strict = !0), r.getExpression();
       }),
       (e.tokTypes = _t);
     }),
     () => (n || s((n = { exports: {} }).exports, n), n.exports)),
    d = {};
   ((e, t) => {
    for (var r in t) a(e, r, { get: t[r], enumerable: !0 });
   })(d, { parsers: () => Ae });
   var f = c(h(), 1);
   function m(e) {
    return (t, r, s) => {
     let n = !(null == s || !s.backwards);
     if (!1 === r) return !1;
     let { length: i } = t,
      a = r;
     for (; a >= 0 && a < i; ) {
      let r = t.charAt(a);
      if (e instanceof RegExp) {
       if (!e.test(r)) return a;
      } else if (!e.includes(r)) return a;
      n ? a-- : a++;
     }
     return (-1 === a || a === i) && a;
    };
   }
   m(/\s/u);
   var y = m(' \t'),
    D = (m(',; \t'), m(/[^\n\r]/u));
   var g = function (e, t) {
    if (!1 === t) return !1;
    if ('/' === e.charAt(t) && '*' === e.charAt(t + 1)) for (let r = t + 2; r < e.length; ++r) if ('*' === e.charAt(r) && '/' === e.charAt(r + 1)) return r + 2;
    return t;
   };
   var x = function (e, t, r) {
    let s = !(null == r || !r.backwards);
    if (!1 === t) return !1;
    let n = e.charAt(t);
    if (s) {
     if ('\r' === e.charAt(t - 1) && '\n' === n) return t - 2;
     if ('\n' === n || '\r' === n || '\u2028' === n || '\u2029' === n) return t - 1;
    } else {
     if ('\r' === n && '\n' === e.charAt(t + 1)) return t + 2;
     if ('\n' === n || '\r' === n || '\u2028' === n || '\u2029' === n) return t + 1;
    }
    return t;
   };
   var E = function (e, t) {
    return !1 !== t && ('/' === e.charAt(t) && '/' === e.charAt(t + 1) ? D(e, t) : t);
   };
   var b = function (e, t) {
    let r = null,
     s = t;
    for (; s !== r; ) (r = s), (s = y(e, s)), (s = g(e, s)), (s = E(e, s)), (s = x(e, s));
    return s;
   };
   var T = function (e) {
    let t = [];
    for (let s of e)
     try {
      return s();
     } catch (r) {
      t.push(r);
     }
    throw Object.assign(new Error('All combinations failed'), { errors: t });
   };
   var A = function (e) {
     if (!e.startsWith('#!')) return '';
     let t = e.indexOf('\n');
     return -1 === t ? e : e.slice(0, t);
    },
    C = (e, t, r) => {
     if (!e || null != t) return Array.isArray(t) || 'string' == typeof t ? t[r < 0 ? t.length + r : r] : t.at(r);
    };
   var v = function (e) {
    return Array.isArray(e) && e.length > 0;
   };
   function F(e) {
    var t, r, s;
    let n = (null == (t = e.range) ? void 0 : t[0]) ?? e.start,
     i = null == (s = (null == (r = e.declaration) ? void 0 : r.decorators) ?? e.decorators) ? void 0 : s[0];
    return i ? Math.min(F(i), n) : n;
   }
   function w(e) {
    var t;
    return (null == (t = e.range) ? void 0 : t[1]) ?? e.end;
   }
   var S = function (e) {
     let t = new Set(e);
     return (e) => t.has(null == e ? void 0 : e.type);
    },
    P = S(['Block', 'CommentBlock', 'MultiLine']);
   var k = function (e) {
    let t = `*${e.value}*`.split('\n');
    return t.length > 1 && t.every((e) => '*' === e.trimStart()[0]);
   };
   var I = function (e) {
     return P(e) && '*' === e.value[0] && /@(?:type|satisfies)\b/u.test(e.value);
    },
    N = null;
   function B(e) {
    if (null !== N && (N.property, 1)) {
     let e = N;
     return (N = B.prototype = null), e;
    }
    return (N = B.prototype = e ?? Object.create(null)), new B();
   }
   for (let ve = 0; ve <= 10; ve++) B();
   var O = function (e, t = 'type') {
     return (
      (function (e) {
       B(e);
      })(e),
      function (r) {
       let s = r[t],
        n = e[s];
       if (!Array.isArray(n)) throw Object.assign(new Error(`Missing visitor keys for '${s}'.`), { node: r });
       return n;
      }
     );
    },
    L = O({ ArrayExpression: ['elements'], AssignmentExpression: ['left', 'right'], BinaryExpression: ['left', 'right'], InterpreterDirective: [], Directive: ['value'], DirectiveLiteral: [], BlockStatement: ['directives', 'body'], BreakStatement: ['label'], CallExpression: ['callee', 'arguments', 'typeParameters', 'typeArguments'], CatchClause: ['param', 'body'], ConditionalExpression: ['test', 'consequent', 'alternate'], ContinueStatement: ['label'], DebuggerStatement: [], DoWhileStatement: ['body', 'test'], EmptyStatement: [], ExpressionStatement: ['expression'], File: ['program'], ForInStatement: ['left', 'right', 'body'], ForStatement: ['init', 'test', 'update', 'body'], FunctionDeclaration: ['id', 'typeParameters', 'params', 'predicate', 'returnType', 'body'], FunctionExpression: ['id', 'typeParameters', 'params', 'returnType', 'body'], Identifier: ['typeAnnotation', 'decorators'], IfStatement: ['test', 'consequent', 'alternate'], LabeledStatement: ['label', 'body'], StringLiteral: [], NumericLiteral: [], NullLiteral: [], BooleanLiteral: [], RegExpLiteral: [], LogicalExpression: ['left', 'right'], MemberExpression: ['object', 'property'], NewExpression: ['callee', 'arguments', 'typeParameters', 'typeArguments'], Program: ['directives', 'body'], ObjectExpression: ['properties'], ObjectMethod: ['decorators', 'key', 'typeParameters', 'params', 'returnType', 'body'], ObjectProperty: ['key', 'value', 'decorators'], RestElement: ['argument', 'typeAnnotation', 'decorators'], ReturnStatement: ['argument'], SequenceExpression: ['expressions'], ParenthesizedExpression: ['expression'], SwitchCase: ['test', 'consequent'], SwitchStatement: ['discriminant', 'cases'], ThisExpression: [], ThrowStatement: ['argument'], TryStatement: ['block', 'handler', 'finalizer'], UnaryExpression: ['argument'], UpdateExpression: ['argument'], VariableDeclaration: ['declarations'], VariableDeclarator: ['id', 'init'], WhileStatement: ['test', 'body'], WithStatement: ['object', 'body'], AssignmentPattern: ['left', 'right', 'decorators', 'typeAnnotation'], ArrayPattern: ['elements', 'typeAnnotation', 'decorators'], ArrowFunctionExpression: ['typeParameters', 'params', 'predicate', 'returnType', 'body'], ClassBody: ['body'], ClassExpression: ['decorators', 'id', 'typeParameters', 'superClass', 'superTypeParameters', 'mixins', 'implements', 'body', 'superTypeArguments'], ClassDeclaration: ['decorators', 'id', 'typeParameters', 'superClass', 'superTypeParameters', 'mixins', 'implements', 'body', 'superTypeArguments'], ExportAllDeclaration: ['source', 'attributes', 'exported'], ExportDefaultDeclaration: ['declaration'], ExportNamedDeclaration: ['declaration', 'specifiers', 'source', 'attributes'], ExportSpecifier: ['local', 'exported'], ForOfStatement: ['left', 'right', 'body'], ImportDeclaration: ['specifiers', 'source', 'attributes'], ImportDefaultSpecifier: ['local'], ImportNamespaceSpecifier: ['local'], ImportSpecifier: ['imported', 'local'], ImportExpression: ['source', 'options'], MetaProperty: ['meta', 'property'], ClassMethod: ['decorators', 'key', 'typeParameters', 'params', 'returnType', 'body'], ObjectPattern: ['properties', 'typeAnnotation', 'decorators'], SpreadElement: ['argument'], Super: [], TaggedTemplateExpression: ['tag', 'typeParameters', 'quasi', 'typeArguments'], TemplateElement: [], TemplateLiteral: ['quasis', 'expressions'], YieldExpression: ['argument'], AwaitExpression: ['argument'], BigIntLiteral: [], ExportNamespaceSpecifier: ['exported'], OptionalMemberExpression: ['object', 'property'], OptionalCallExpression: ['callee', 'arguments', 'typeParameters', 'typeArguments'], ClassProperty: ['decorators', 'variance', 'key', 'typeAnnotation', 'value'], ClassAccessorProperty: ['decorators', 'key', 'typeAnnotation', 'value'], ClassPrivateProperty: ['decorators', 'variance', 'key', 'typeAnnotation', 'value'], ClassPrivateMethod: ['decorators', 'key', 'typeParameters', 'params', 'returnType', 'body'], PrivateName: ['id'], StaticBlock: ['body'], AnyTypeAnnotation: [], ArrayTypeAnnotation: ['elementType'], BooleanTypeAnnotation: [], BooleanLiteralTypeAnnotation: [], NullLiteralTypeAnnotation: [], ClassImplements: ['id', 'typeParameters'], DeclareClass: ['id', 'typeParameters', 'extends', 'mixins', 'implements', 'body'], DeclareFunction: ['id', 'predicate'], DeclareInterface: ['id', 'typeParameters', 'extends', 'body'], DeclareModule: ['id', 'body'], DeclareModuleExports: ['typeAnnotation'], DeclareTypeAlias: ['id', 'typeParameters', 'right'], DeclareOpaqueType: ['id', 'typeParameters', 'supertype'], DeclareVariable: ['id'], DeclareExportDeclaration: ['declaration', 'specifiers', 'source', 'attributes'], DeclareExportAllDeclaration: ['source', 'attributes'], DeclaredPredicate: ['value'], ExistsTypeAnnotation: [], FunctionTypeAnnotation: ['typeParameters', 'this', 'params', 'rest', 'returnType'], FunctionTypeParam: ['name', 'typeAnnotation'], GenericTypeAnnotation: ['id', 'typeParameters'], InferredPredicate: [], InterfaceExtends: ['id', 'typeParameters'], InterfaceDeclaration: ['id', 'typeParameters', 'extends', 'body'], InterfaceTypeAnnotation: ['extends', 'body'], IntersectionTypeAnnotation: ['types'], MixedTypeAnnotation: [], EmptyTypeAnnotation: [], NullableTypeAnnotation: ['typeAnnotation'], NumberLiteralTypeAnnotation: [], NumberTypeAnnotation: [], ObjectTypeAnnotation: ['properties', 'indexers', 'callProperties', 'internalSlots'], ObjectTypeInternalSlot: ['id', 'value'], ObjectTypeCallProperty: ['value'], ObjectTypeIndexer: ['variance', 'id', 'key', 'value'], ObjectTypeProperty: ['key', 'value', 'variance'], ObjectTypeSpreadProperty: ['argument'], OpaqueType: ['id', 'typeParameters', 'supertype', 'impltype'], QualifiedTypeIdentifier: ['qualification', 'id'], StringLiteralTypeAnnotation: [], StringTypeAnnotation: [], SymbolTypeAnnotation: [], ThisTypeAnnotation: [], TupleTypeAnnotation: ['types', 'elementTypes'], TypeofTypeAnnotation: ['argument', 'typeArguments'], TypeAlias: ['id', 'typeParameters', 'right'], TypeAnnotation: ['typeAnnotation'], TypeCastExpression: ['expression', 'typeAnnotation'], TypeParameter: ['bound', 'default', 'variance'], TypeParameterDeclaration: ['params'], TypeParameterInstantiation: ['params'], UnionTypeAnnotation: ['types'], Variance: [], VoidTypeAnnotation: [], EnumDeclaration: ['id', 'body'], EnumBooleanBody: ['members'], EnumNumberBody: ['members'], EnumStringBody: ['members'], EnumSymbolBody: ['members'], EnumBooleanMember: ['id', 'init'], EnumNumberMember: ['id', 'init'], EnumStringMember: ['id', 'init'], EnumDefaultedMember: ['id'], IndexedAccessType: ['objectType', 'indexType'], OptionalIndexedAccessType: ['objectType', 'indexType'], JSXAttribute: ['name', 'value'], JSXClosingElement: ['name'], JSXElement: ['openingElement', 'children', 'closingElement'], JSXEmptyExpression: [], JSXExpressionContainer: ['expression'], JSXSpreadChild: ['expression'], JSXIdentifier: [], JSXMemberExpression: ['object', 'property'], JSXNamespacedName: ['namespace', 'name'], JSXOpeningElement: ['name', 'typeParameters', 'typeArguments', 'attributes'], JSXSpreadAttribute: ['argument'], JSXText: [], JSXFragment: ['openingFragment', 'children', 'closingFragment'], JSXOpeningFragment: [], JSXClosingFragment: [], Noop: [], Placeholder: [], V8IntrinsicIdentifier: [], ArgumentPlaceholder: [], BindExpression: ['object', 'callee'], ImportAttribute: ['key', 'value'], Decorator: ['expression'], DoExpression: ['body'], ExportDefaultSpecifier: ['exported'], RecordExpression: ['properties'], TupleExpression: ['elements'], ModuleExpression: ['body'], TopicReference: [], PipelineTopicExpression: ['expression'], PipelineBareFunction: ['callee'], PipelinePrimaryTopicReference: [], TSParameterProperty: ['parameter', 'decorators'], TSDeclareFunction: ['id', 'typeParameters', 'params', 'returnType', 'body'], TSDeclareMethod: ['decorators', 'key', 'typeParameters', 'params', 'returnType'], TSQualifiedName: ['left', 'right'], TSCallSignatureDeclaration: ['typeParameters', 'parameters', 'typeAnnotation', 'params', 'returnType'], TSConstructSignatureDeclaration: ['typeParameters', 'parameters', 'typeAnnotation', 'params', 'returnType'], TSPropertySignature: ['key', 'typeAnnotation'], TSMethodSignature: ['key', 'typeParameters', 'parameters', 'typeAnnotation', 'params', 'returnType'], TSIndexSignature: ['parameters', 'typeAnnotation'], TSAnyKeyword: [], TSBooleanKeyword: [], TSBigIntKeyword: [], TSIntrinsicKeyword: [], TSNeverKeyword: [], TSNullKeyword: [], TSNumberKeyword: [], TSObjectKeyword: [], TSStringKeyword: [], TSSymbolKeyword: [], TSUndefinedKeyword: [], TSUnknownKeyword: [], TSVoidKeyword: [], TSThisType: [], TSFunctionType: ['typeParameters', 'parameters', 'typeAnnotation', 'params', 'returnType'], TSConstructorType: ['typeParameters', 'parameters', 'typeAnnotation', 'params', 'returnType'], TSTypeReference: ['typeName', 'typeParameters', 'typeArguments'], TSTypePredicate: ['parameterName', 'typeAnnotation'], TSTypeQuery: ['exprName', 'typeParameters', 'typeArguments'], TSTypeLiteral: ['members'], TSArrayType: ['elementType'], TSTupleType: ['elementTypes'], TSOptionalType: ['typeAnnotation'], TSRestType: ['typeAnnotation'], TSNamedTupleMember: ['label', 'elementType'], TSUnionType: ['types'], TSIntersectionType: ['types'], TSConditionalType: ['checkType', 'extendsType', 'trueType', 'falseType'], TSInferType: ['typeParameter'], TSParenthesizedType: ['typeAnnotation'], TSTypeOperator: ['typeAnnotation'], TSIndexedAccessType: ['objectType', 'indexType'], TSMappedType: ['typeParameter', 'nameType', 'typeAnnotation'], TSTemplateLiteralType: ['quasis', 'types'], TSLiteralType: ['literal'], TSExpressionWithTypeArguments: ['expression', 'typeParameters'], TSInterfaceDeclaration: ['id', 'typeParameters', 'extends', 'body'], TSInterfaceBody: ['body'], TSTypeAliasDeclaration: ['id', 'typeParameters', 'typeAnnotation'], TSInstantiationExpression: ['expression', 'typeParameters', 'typeArguments'], TSAsExpression: ['expression', 'typeAnnotation'], TSSatisfiesExpression: ['expression', 'typeAnnotation'], TSTypeAssertion: ['typeAnnotation', 'expression'], TSEnumBody: ['members'], TSEnumDeclaration: ['id', 'members'], TSEnumMember: ['id', 'initializer'], TSModuleDeclaration: ['id', 'body'], TSModuleBlock: ['body'], TSImportType: ['argument', 'options', 'qualifier', 'typeParameters', 'typeArguments'], TSImportEqualsDeclaration: ['id', 'moduleReference'], TSExternalModuleReference: ['expression'], TSNonNullExpression: ['expression'], TSExportAssignment: ['expression'], TSNamespaceExportDeclaration: ['id'], TSTypeAnnotation: ['typeAnnotation'], TSTypeParameterInstantiation: ['params'], TSTypeParameterDeclaration: ['params'], TSTypeParameter: ['constraint', 'default', 'name'], ChainExpression: ['expression'], ExperimentalRestProperty: ['argument'], ExperimentalSpreadProperty: ['argument'], Literal: [], MethodDefinition: ['decorators', 'key', 'value'], PrivateIdentifier: [], Property: ['key', 'value'], PropertyDefinition: ['decorators', 'key', 'typeAnnotation', 'value', 'variance'], AccessorProperty: ['decorators', 'key', 'typeAnnotation', 'value'], TSAbstractAccessorProperty: ['decorators', 'key', 'typeAnnotation'], TSAbstractKeyword: [], TSAbstractMethodDefinition: ['key', 'value'], TSAbstractPropertyDefinition: ['decorators', 'key', 'typeAnnotation'], TSAsyncKeyword: [], TSClassImplements: ['expression', 'typeArguments', 'typeParameters'], TSDeclareKeyword: [], TSEmptyBodyFunctionExpression: ['id', 'typeParameters', 'params', 'returnType'], TSExportKeyword: [], TSInterfaceHeritage: ['expression', 'typeArguments', 'typeParameters'], TSPrivateKeyword: [], TSProtectedKeyword: [], TSPublicKeyword: [], TSReadonlyKeyword: [], TSStaticKeyword: [], AsConstExpression: ['expression'], AsExpression: ['expression', 'typeAnnotation'], BigIntLiteralTypeAnnotation: [], BigIntTypeAnnotation: [], ComponentDeclaration: ['id', 'params', 'body', 'typeParameters', 'rendersType'], ComponentParameter: ['name', 'local'], ComponentTypeAnnotation: ['params', 'rest', 'typeParameters', 'rendersType'], ComponentTypeParameter: ['name', 'typeAnnotation'], ConditionalTypeAnnotation: ['checkType', 'extendsType', 'trueType', 'falseType'], DeclareComponent: ['id', 'params', 'rest', 'typeParameters', 'rendersType'], DeclareEnum: ['id', 'body'], DeclareHook: ['id'], DeclareNamespace: ['id', 'body'], EnumBigIntBody: ['members'], EnumBigIntMember: ['id', 'init'], HookDeclaration: ['id', 'params', 'body', 'typeParameters', 'returnType'], HookTypeAnnotation: ['params', 'returnType', 'rest', 'typeParameters'], InferTypeAnnotation: ['typeParameter'], KeyofTypeAnnotation: ['argument'], ObjectTypeMappedTypeProperty: ['keyTparam', 'propType', 'sourceType', 'variance'], QualifiedTypeofIdentifier: ['qualification', 'id'], TupleTypeLabeledElement: ['label', 'elementType', 'variance'], TupleTypeSpreadElement: ['label', 'typeAnnotation'], TypeOperator: ['typeAnnotation'], TypePredicate: ['parameterName', 'typeAnnotation', 'asserts'], NGRoot: ['node'], NGPipeExpression: ['left', 'right', 'arguments'], NGChainedExpression: ['expressions'], NGEmptyExpression: [], NGMicrosyntax: ['body'], NGMicrosyntaxKey: [], NGMicrosyntaxExpression: ['expression', 'alias'], NGMicrosyntaxKeyedExpression: ['key', 'expression'], NGMicrosyntaxLet: ['key', 'value'], NGMicrosyntaxAs: ['key', 'alias'], JsExpressionRoot: ['node'], JsonRoot: ['node'], TSJSDocAllType: [], TSJSDocUnknownType: [], TSJSDocNullableType: ['typeAnnotation'], TSJSDocNonNullableType: ['typeAnnotation'], NeverTypeAnnotation: [], UndefinedTypeAnnotation: [], UnknownTypeAnnotation: [], SatisfiesExpression: ['expression', 'typeAnnotation'] });
   var M = function e(t, r) {
    if (null === t || 'object' != typeof t) return t;
    if (Array.isArray(t)) {
     for (let s = 0; s < t.length; s++) t[s] = e(t[s], r);
     return t;
    }
    let s = L(t);
    for (let n = 0; n < s.length; n++) t[s[n]] = e(t[s[n]], r);
    return r(t) || t;
   };
   function j(e) {
    return 'LogicalExpression' === e.type && 'LogicalExpression' === e.right.type && e.operator === e.right.operator;
   }
   function _(e) {
    return j(e) ? _({ type: 'LogicalExpression', operator: e.operator, left: _({ type: 'LogicalExpression', operator: e.operator, left: e.left, right: e.right.left, range: [F(e.left), w(e.right.left)] }), right: e.right.right, range: [F(e), w(e)] }) : e;
   }
   var R = function (e, t) {
    let { parser: r, text: s } = t;
    if ('File' === e.type && e.program.interpreter) {
     let {
      program: { interpreter: t },
      comments: r,
     } = e;
     delete e.program.interpreter, r.unshift(t);
    }
    if ('babel' === r) {
     let t = new Set();
     (e = M(e, (e) => {
      var r;
      null != (r = e.leadingComments) && r.some(I) && t.add(F(e));
     })),
      (e = M(e, (e) => {
       if ('ParenthesizedExpression' === e.type) {
        let { expression: r } = e;
        if ('TypeCastExpression' === r.type) return (r.range = [...e.range]), r;
        let s = F(e);
        if (!t.has(s)) return (r.extra = { ...r.extra, parenthesized: !0 }), r;
       }
      }));
    }
    if (
     ((e = M(e, (t) => {
      switch (t.type) {
       case 'LogicalExpression':
        if (j(t)) return _(t);
        break;
       case 'VariableDeclaration': {
        let e = C(!1, t.declarations, -1);
        null != e && e.init && ';' !== s[w(e)] && (t.range = [F(t), w(e)]);
        break;
       }
       case 'TSParenthesizedType':
        return t.typeAnnotation;
       case 'TSTypeParameter':
        if ('string' == typeof t.name) {
         let e = F(t);
         t.name = { type: 'Identifier', name: t.name, range: [e, e + t.name.length] };
        }
        break;
       case 'TopicReference':
        e.extra = { ...e.extra, __isUsingHackPipeline: !0 };
        break;
       case 'TSUnionType':
       case 'TSIntersectionType':
        if (1 === t.types.length) return t.types[0];
      }
     })),
     v(e.comments))
    ) {
     let t = C(!1, e.comments, -1);
     for (let r = e.comments.length - 2; r >= 0; r--) {
      let s = e.comments[r];
      w(s) === F(t) && P(s) && P(t) && k(s) && k(t) && (e.comments.splice(r + 1, 1), (s.value += '*//*' + t.value), (s.range = [F(s), w(t)])), (t = s);
     }
    }
    return 'Program' === e.type && (e.range = [0, s.length]), e;
   };
   var U = function (e, t) {
    let r = new SyntaxError(e + ' (' + t.loc.start.line + ':' + t.loc.start.column + ')');
    return Object.assign(r, t);
   };
   var $ = function (e) {
     let {
       message: t,
       loc: { line: r, column: s },
       reasonCode: n,
      } = e,
      i = e;
     ('MissingPlugin' === n || 'MissingOneOfPlugins' === n) && ((t = 'Unexpected token.'), (i = void 0));
     let a = ` (${r}:${s})`;
     return t.endsWith(a) && (t = t.slice(0, -a.length)), U(t, { loc: { start: { line: r, column: s + 1 } }, cause: i });
    },
    q = (e, t, r, s) => {
     if (!e || null != t) return t.replaceAll ? t.replaceAll(r, s) : r.global ? t.replace(r, s) : t.split(r).join(s);
    },
    J = /\*\/$/,
    W = /^\/\*\*?/,
    z = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/,
    V = /(^|\s+)\/\/([^\n\r]*)/g,
    H = /^(\r?\n)+/,
    K = /(?:^|\r?\n) *(@[^\n\r]*?) *\r?\n *(?![^\n\r@]*\/\/[^]*)([^\s@][^\n\r@]+?) *\r?\n/g,
    X = /(?:^|\r?\n) *@(\S+) *([^\n\r]*)/g,
    G = /(\r?\n|^) *\* ?/g,
    Y = [];
   function Q(e) {
    let t = A(e);
    t && (e = e.slice(t.length + 1));
    let r = (function (e) {
      let t = e.match(z);
      return t ? t[0].trimStart() : '';
     })(e),
     { pragmas: s, comments: n } = (function (e) {
      e = q(!1, e.replace(W, '').replace(J, ''), G, '$1');
      let t = '';
      for (; t !== e; ) (t = e), (e = q(!1, e, K, '\n$1 $2\n'));
      e = e.replace(H, '').trimEnd();
      let r,
       s = Object.create(null),
       n = q(!1, e, X, '').replace(H, '').trimEnd();
      for (; (r = X.exec(e)); ) {
       let e = q(!1, r[2], V, '');
       if ('string' == typeof s[r[1]] || Array.isArray(s[r[1]])) {
        let t = s[r[1]];
        s[r[1]] = [...Y, ...(Array.isArray(t) ? t : [t]), e];
       } else s[r[1]] = e;
      }
      return { comments: n, pragmas: s };
     })(r);
    return { shebang: t, text: e, pragmas: s, comments: n };
   }
   function Z(e) {
    let { pragmas: t } = Q(e);
    return Object.prototype.hasOwnProperty.call(t, 'prettier') || Object.prototype.hasOwnProperty.call(t, 'format');
   }
   var ee = function (e) {
    return (e = 'function' == typeof e ? { parse: e } : e), { astFormat: 'estree', hasPragma: Z, locStart: F, locEnd: w, ...e };
   };
   var te = function (e) {
    let { filepath: t } = e;
    if (t) {
     if (((t = t.toLowerCase()), t.endsWith('.cjs') || t.endsWith('.cts'))) return 'script';
     if (t.endsWith('.mjs') || t.endsWith('.mts')) return 'module';
    }
   };
   var re = function (e, t) {
     let { type: r = 'JsExpressionRoot', rootMarker: s, text: n } = t,
      { tokens: i, comments: a } = e;
     return delete e.tokens, delete e.comments, { tokens: i, comments: a, type: r, node: e, range: [0, n.length], rootMarker: s };
    },
    se = (e) =>
     ee(
      (function ({ isExpression: e = !1, optionsCombinations: t }) {
       return (r, s = {}) => {
        if (
         ('babel' === s.parser || '__babel_estree' === s.parser) &&
         (function (e, t) {
          var r;
          if (null != (r = t.filepath) && r.endsWith('.js.flow')) return !0;
          let s = A(e);
          s && (e = e.slice(s.length));
          let n = b(e, 0);
          return !1 !== n && (e = e.slice(0, n)), ue.test(e);
         })(r, s)
        )
         return (s.parser = 'babel-flow'), me.parse(r, s);
        let n = t;
        'script' === (s.__babelSourceType ?? te(s)) && (n = n.map((e) => ({ ...e, sourceType: 'script' })));
        let i = /%[A-Z]/u.test(r);
        r.includes('|>') ? (n = (i ? [...ae, ie] : ae).flatMap((e) => n.map((t) => oe([e], t)))) : i && (n = n.map((e) => oe([ie], e)));
        let a,
         o = e ? f.parseExpression : f.parse;
        try {
         a = T(
          n.map(
           (e) => () =>
            (function (e, t, r) {
             let s = e(t, r),
              n = s.errors.find((e) => !le.has(e.reasonCode));
             if (n) throw n;
             return s;
            })(o, r, e),
          ),
         );
        } catch ({ errors: [u] }) {
         throw $(u);
        }
        return e && (a = re(a, { text: r, rootMarker: s.rootMarker })), R(a, { parser: 'babel', text: r });
       };
      })(e),
     ),
    ne = { sourceType: 'module', allowImportExportEverywhere: !0, allowReturnOutsideFunction: !0, allowNewTargetOutsideFunction: !0, allowSuperOutsideMethod: !0, allowUndeclaredExports: !0, errorRecovery: !0, createParenthesizedExpressions: !0, createImportExpressions: !0, plugins: ['doExpressions', 'exportDefaultFrom', 'functionBind', 'functionSent', 'throwExpressions', 'partialApplication', 'decorators', 'moduleBlocks', 'asyncDoExpressions', 'destructuringPrivate', 'decoratorAutoAccessors', 'explicitResourceManagement', 'sourcePhaseImports', 'deferredImportEvaluation', ['optionalChainingAssign', { version: '2023-07' }], 'recordAndTuple'], tokens: !0, ranges: !0 },
    ie = 'v8intrinsic',
    ae = [
     ['pipelineOperator', { proposal: 'hack', topicToken: '%' }],
     ['pipelineOperator', { proposal: 'fsharp' }],
    ],
    oe = (e, t = ne) => ({ ...t, plugins: [...t.plugins, ...e] }),
    ue = /@(?:no)?flow\b/u;
   var le = new Set(['StrictNumericEscape', 'StrictWith', 'StrictOctalLiteral', 'StrictDelete', 'StrictEvalArguments', 'StrictEvalArgumentsBinding', 'StrictFunction', 'ForInOfLoopInitializer', 'EmptyTypeArguments', 'EmptyTypeParameters', 'ConstructorHasTypeParameters', 'UnsupportedParameterPropertyKind', 'DecoratorExportClass', 'ParamDupe', 'InvalidDecimal', 'RestTrailingComma', 'UnsupportedParameterDecorator', 'UnterminatedJsxContent', 'UnexpectedReservedWord', 'ModuleAttributesWithDuplicateKeys', 'LineTerminatorBeforeArrow', 'InvalidEscapeSequenceTemplate', 'NonAbstractClassHasAbstractMethod', 'OptionalTypeBeforeRequired', 'PatternIsOptional', 'OptionalBindingPattern', 'DeclareClassFieldHasInitializer', 'TypeImportCannotSpecifyDefaultAndNamed', 'ConstructorClassField', 'VarRedeclaration', 'InvalidPrivateFieldResolution', 'DuplicateExport', 'ImportAttributesUseAssert']),
    pe = [oe(['jsx'])],
    ce = se({ optionsCombinations: pe }),
    he = se({ optionsCombinations: [oe(['jsx', 'typescript']), oe(['typescript'])] }),
    de = se({ isExpression: !0, optionsCombinations: [oe(['jsx'])] }),
    fe = se({ isExpression: !0, optionsCombinations: [oe(['typescript'])] }),
    me = se({ optionsCombinations: [oe(['jsx', ['flow', { all: !0 }], 'flowComments'])] }),
    ye = se({ optionsCombinations: pe.map((e) => oe(['estree'], e)) }),
    De = { babel: ce, 'babel-flow': me, 'babel-ts': he, __js_expression: de, __ts_expression: fe, __vue_expression: de, __vue_ts_expression: fe, __vue_event_binding: ce, __vue_ts_event_binding: he, __babel_estree: ye },
    ge = c(h(), 1);
   function xe(e = {}) {
    let { allowComments: t = !0 } = e;
    return function (e) {
     let r;
     try {
      r = (0, ge.parseExpression)(e, { tokens: !0, ranges: !0, attachComment: !1 });
     } catch (s) {
      throw $(s);
     }
     if (!t && v(r.comments)) throw Ee(r.comments[0], 'Comment');
     return be(r), re(r, { type: 'JsonRoot', text: e });
    };
   }
   function Ee(e, t) {
    let [r, s] = [e.loc.start, e.loc.end].map(({ line: e, column: t }) => ({ line: e, column: t + 1 }));
    return U(`${t} is not allowed in JSON.`, { loc: { start: r, end: s } });
   }
   function be(e) {
    switch (e.type) {
     case 'ArrayExpression':
      for (let t of e.elements) null !== t && be(t);
      return;
     case 'ObjectExpression':
      for (let t of e.properties) be(t);
      return;
     case 'ObjectProperty':
      if (e.computed) throw Ee(e.key, 'Computed key');
      if (e.shorthand) throw Ee(e.key, 'Shorthand property');
      return 'Identifier' !== e.key.type && be(e.key), void be(e.value);
     case 'UnaryExpression': {
      let { operator: t, argument: r } = e;
      if ('+' !== t && '-' !== t) throw Ee(e, `Operator '${e.operator}'`);
      if ('NumericLiteral' === r.type || ('Identifier' === r.type && ('Infinity' === r.name || 'NaN' === r.name))) return;
      throw Ee(r, `Operator '${t}' before '${r.type}'`);
     }
     case 'Identifier':
      if ('Infinity' !== e.name && 'NaN' !== e.name && 'undefined' !== e.name) throw Ee(e, `Identifier '${e.name}'`);
      return;
     case 'TemplateLiteral':
      if (v(e.expressions)) throw Ee(e.expressions[0], "'TemplateLiteral' with expression");
      for (let t of e.quasis) be(t);
      return;
     case 'NullLiteral':
     case 'BooleanLiteral':
     case 'NumericLiteral':
     case 'StringLiteral':
     case 'TemplateElement':
      return;
     default:
      throw Ee(e, `'${e.type}'`);
    }
   }
   var Te = xe(),
    Ae = { ...De, ...{ json: ee({ parse: Te, hasPragma: () => !0 }), json5: ee(Te), jsonc: ee(Te), 'json-stringify': ee({ parse: xe({ allowComments: !1 }), astFormat: 'estree-json' }) } },
    Ce = d;
  },
  93872: (e, t, r) => {
   r.d(t, { ZP: () => $o });
   var s = Object.defineProperty,
    n = (e) => {
     throw TypeError(e);
    },
    i = (e, t) => {
     for (var r in t) s(e, r, { get: t[r], enumerable: !0 });
    },
    a = (e, t, r) => t.has(e) || n('Cannot ' + r),
    o = (e, t, r) => (a(e, t, 'read from private field'), r ? r.call(e) : t.get(e)),
    u = {};
   i(u, { languages: () => Uo, options: () => _o, printers: () => Ro });
   var l = {};
   i(l, { canAttachComment: () => ys, embed: () => Zs, experimentalFeatures: () => Po, getCommentChildNodes: () => Ds, getVisitorKeys: () => $, handleComments: () => Dr, insertPragma: () => dn, isBlockComment: () => J, isGap: () => xs, massageAstNode: () => ct, print: () => So, printComment: () => yr, willPrintOwnComments: () => gs });
   var p = (e, t, r, s) => {
     if (!e || null != t) return t.replaceAll ? t.replaceAll(r, s) : r.global ? t.replace(r, s) : t.split(r).join(s);
    },
    c = (e, t, r) => {
     if (!e || null != t) return Array.isArray(t) || 'string' == typeof t ? t[r < 0 ? t.length + r : r] : t.at(r);
    };
   var h = function (e) {
    return null !== e && 'object' == typeof e;
   };
   function* d(e, t) {
    let { getVisitorKeys: r, filter: s = () => !0 } = t,
     n = (e) => h(e) && s(e);
    for (let i of r(e)) {
     let t = e[i];
     if (Array.isArray(t)) for (let e of t) n(e) && (yield e);
     else n(t) && (yield t);
    }
   }
   function f(e, { getVisitorKeys: t, predicate: r }) {
    for (let s of (function* (e, t) {
     let r = [e];
     for (let s = 0; s < r.length; s++) {
      let e = r[s];
      for (let s of d(e, t)) yield s, r.push(s);
     }
    })(e, { getVisitorKeys: t }))
     if (r(s)) return !0;
    return !1;
   }
   var m = (e) =>
     !(
      (function (e) {
       return 12288 === e || (e >= 65281 && e <= 65376) || (e >= 65504 && e <= 65510);
      })(e) ||
      (function (e) {
       return (e >= 4352 && e <= 4447) || 8986 === e || 8987 === e || 9001 === e || 9002 === e || (e >= 9193 && e <= 9196) || 9200 === e || 9203 === e || 9725 === e || 9726 === e || 9748 === e || 9749 === e || (e >= 9776 && e <= 9783) || (e >= 9800 && e <= 9811) || 9855 === e || (e >= 9866 && e <= 9871) || 9875 === e || 9889 === e || 9898 === e || 9899 === e || 9917 === e || 9918 === e || 9924 === e || 9925 === e || 9934 === e || 9940 === e || 9962 === e || 9970 === e || 9971 === e || 9973 === e || 9978 === e || 9981 === e || 9989 === e || 9994 === e || 9995 === e || 10024 === e || 10060 === e || 10062 === e || (e >= 10067 && e <= 10069) || 10071 === e || (e >= 10133 && e <= 10135) || 10160 === e || 10175 === e || 11035 === e || 11036 === e || 11088 === e || 11093 === e || (e >= 11904 && e <= 11929) || (e >= 11931 && e <= 12019) || (e >= 12032 && e <= 12245) || (e >= 12272 && e <= 12287) || (e >= 12289 && e <= 12350) || (e >= 12353 && e <= 12438) || (e >= 12441 && e <= 12543) || (e >= 12549 && e <= 12591) || (e >= 12593 && e <= 12686) || (e >= 12688 && e <= 12773) || (e >= 12783 && e <= 12830) || (e >= 12832 && e <= 12871) || (e >= 12880 && e <= 42124) || (e >= 42128 && e <= 42182) || (e >= 43360 && e <= 43388) || (e >= 44032 && e <= 55203) || (e >= 63744 && e <= 64255) || (e >= 65040 && e <= 65049) || (e >= 65072 && e <= 65106) || (e >= 65108 && e <= 65126) || (e >= 65128 && e <= 65131) || (e >= 94176 && e <= 94180) || 94192 === e || 94193 === e || (e >= 94208 && e <= 100343) || (e >= 100352 && e <= 101589) || (e >= 101631 && e <= 101640) || (e >= 110576 && e <= 110579) || (e >= 110581 && e <= 110587) || 110589 === e || 110590 === e || (e >= 110592 && e <= 110882) || 110898 === e || (e >= 110928 && e <= 110930) || 110933 === e || (e >= 110948 && e <= 110951) || (e >= 110960 && e <= 111355) || (e >= 119552 && e <= 119638) || (e >= 119648 && e <= 119670) || 126980 === e || 127183 === e || 127374 === e || (e >= 127377 && e <= 127386) || (e >= 127488 && e <= 127490) || (e >= 127504 && e <= 127547) || (e >= 127552 && e <= 127560) || 127568 === e || 127569 === e || (e >= 127584 && e <= 127589) || (e >= 127744 && e <= 127776) || (e >= 127789 && e <= 127797) || (e >= 127799 && e <= 127868) || (e >= 127870 && e <= 127891) || (e >= 127904 && e <= 127946) || (e >= 127951 && e <= 127955) || (e >= 127968 && e <= 127984) || 127988 === e || (e >= 127992 && e <= 128062) || 128064 === e || (e >= 128066 && e <= 128252) || (e >= 128255 && e <= 128317) || (e >= 128331 && e <= 128334) || (e >= 128336 && e <= 128359) || 128378 === e || 128405 === e || 128406 === e || 128420 === e || (e >= 128507 && e <= 128591) || (e >= 128640 && e <= 128709) || 128716 === e || (e >= 128720 && e <= 128722) || (e >= 128725 && e <= 128727) || (e >= 128732 && e <= 128735) || 128747 === e || 128748 === e || (e >= 128756 && e <= 128764) || (e >= 128992 && e <= 129003) || 129008 === e || (e >= 129292 && e <= 129338) || (e >= 129340 && e <= 129349) || (e >= 129351 && e <= 129535) || (e >= 129648 && e <= 129660) || (e >= 129664 && e <= 129673) || (e >= 129679 && e <= 129734) || (e >= 129742 && e <= 129756) || (e >= 129759 && e <= 129769) || (e >= 129776 && e <= 129784) || (e >= 131072 && e <= 196605) || (e >= 196608 && e <= 262141);
      })(e)
     ),
    y = /[^\x20-\x7F]/u;
   var D = function (e) {
    if (!e) return 0;
    if (!y.test(e)) return e.length;
    e = e.replace(/[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE89\uDE8F-\uDEC2\uDEC6\uDECE-\uDEDC\uDEDF-\uDEE9]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g, '  ');
    let t = 0;
    for (let r of e) {
     let e = r.codePointAt(0);
     e <= 31 || (e >= 127 && e <= 159) || (e >= 768 && e <= 879) || (t += m(e) ? 1 : 2);
    }
    return t;
   };
   function g(e) {
    return (t, r, s) => {
     let n = !(null == s || !s.backwards);
     if (!1 === r) return !1;
     let { length: i } = t,
      a = r;
     for (; a >= 0 && a < i; ) {
      let r = t.charAt(a);
      if (e instanceof RegExp) {
       if (!e.test(r)) return a;
      } else if (!e.includes(r)) return a;
      n ? a-- : a++;
     }
     return (-1 === a || a === i) && a;
    };
   }
   g(/\s/u);
   var x = g(' \t'),
    E = g(',; \t'),
    b = g(/[^\n\r]/u);
   var T = function (e, t, r) {
    let s = !(null == r || !r.backwards);
    if (!1 === t) return !1;
    let n = e.charAt(t);
    if (s) {
     if ('\r' === e.charAt(t - 1) && '\n' === n) return t - 2;
     if ('\n' === n || '\r' === n || '\u2028' === n || '\u2029' === n) return t - 1;
    } else {
     if ('\r' === n && '\n' === e.charAt(t + 1)) return t + 2;
     if ('\n' === n || '\r' === n || '\u2028' === n || '\u2029' === n) return t + 1;
    }
    return t;
   };
   var A = function (e, t, r = {}) {
    let s = x(e, r.backwards ? t - 1 : t, r);
    return s !== T(e, s, r);
   };
   var C = function (e, t) {
    if (!1 === t) return !1;
    if ('/' === e.charAt(t) && '*' === e.charAt(t + 1)) for (let r = t + 2; r < e.length; ++r) if ('*' === e.charAt(r) && '/' === e.charAt(r + 1)) return r + 2;
    return t;
   };
   var v = function (e, t) {
    return !1 !== t && ('/' === e.charAt(t) && '/' === e.charAt(t + 1) ? b(e, t) : t);
   };
   var F = function (e, t) {
    let r = null,
     s = t;
    for (; s !== r; ) (r = s), (s = E(e, s)), (s = C(e, s)), (s = x(e, s));
    return (s = v(e, s)), (s = T(e, s)), !1 !== s && A(e, s);
   };
   var w = function (e) {
     return Array.isArray(e) && e.length > 0;
    },
    S = new Proxy(() => {}, { get: () => S }),
    P = S,
    k = "'";
   var I = function (e, t) {
    let r = !0 === t || t === k ? k : '"',
     s = r === k ? '"' : k,
     n = 0,
     i = 0;
    for (let a of e) a === r ? n++ : a === s && i++;
    return n > i ? s : r;
   };
   var N = function (e, t, r) {
    let s = '"' === t ? "'" : '"',
     n = p(!1, e, /\\(.)|(["'])/gsu, (e, n, i) => (n === s ? n : i === t ? '\\' + i : i || (r && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/u.test(n) ? n : '\\' + n)));
    return t + n + t;
   };
   var B = function (e, t) {
    P(/^(?<quote>["']).*\k<quote>$/su.test(e));
    let r = e.slice(1, -1),
     s = 'json' === t.parser || 'jsonc' === t.parser || ('json5' === t.parser && 'preserve' === t.quoteProps && !t.singleQuote) ? '"' : t.__isInHtmlAttribute ? "'" : I(r, t.singleQuote);
    return e.charAt(0) === s ? e : N(r, s, !1);
   };
   function O(e) {
    var t, r, s;
    let n = (null == (t = e.range) ? void 0 : t[0]) ?? e.start,
     i = null == (s = (null == (r = e.declaration) ? void 0 : r.decorators) ?? e.decorators) ? void 0 : s[0];
    return i ? Math.min(O(i), n) : n;
   }
   function L(e) {
    var t;
    return (null == (t = e.range) ? void 0 : t[1]) ?? e.end;
   }
   function M(e, t) {
    let r = O(e);
    return Number.isInteger(r) && r === O(t);
   }
   function j(e, t) {
    return (
     M(e, t) &&
     (function (e, t) {
      let r = L(e);
      return Number.isInteger(r) && r === L(t);
     })(e, t)
    );
   }
   var _ = null;
   function R(e) {
    if (null !== _ && (_.property, 1)) {
     let e = _;
     return (_ = R.prototype = null), e;
    }
    return (_ = R.prototype = e ?? Object.create(null)), new R();
   }
   for (let qo = 0; qo <= 10; qo++) R();
   var U = function (e, t = 'type') {
     return (
      (function (e) {
       R(e);
      })(e),
      function (r) {
       let s = r[t],
        n = e[s];
       if (!Array.isArray(n)) throw Object.assign(new Error(`Missing visitor keys for '${s}'.`), { node: r });
       return n;
      }
     );
    },
    $ = U({ ArrayExpression: ['elements'], AssignmentExpression: ['left', 'right'], BinaryExpression: ['left', 'right'], InterpreterDirective: [], Directive: ['value'], DirectiveLiteral: [], BlockStatement: ['directives', 'body'], BreakStatement: ['label'], CallExpression: ['callee', 'arguments', 'typeParameters', 'typeArguments'], CatchClause: ['param', 'body'], ConditionalExpression: ['test', 'consequent', 'alternate'], ContinueStatement: ['label'], DebuggerStatement: [], DoWhileStatement: ['body', 'test'], EmptyStatement: [], ExpressionStatement: ['expression'], File: ['program'], ForInStatement: ['left', 'right', 'body'], ForStatement: ['init', 'test', 'update', 'body'], FunctionDeclaration: ['id', 'typeParameters', 'params', 'predicate', 'returnType', 'body'], FunctionExpression: ['id', 'typeParameters', 'params', 'returnType', 'body'], Identifier: ['typeAnnotation', 'decorators'], IfStatement: ['test', 'consequent', 'alternate'], LabeledStatement: ['label', 'body'], StringLiteral: [], NumericLiteral: [], NullLiteral: [], BooleanLiteral: [], RegExpLiteral: [], LogicalExpression: ['left', 'right'], MemberExpression: ['object', 'property'], NewExpression: ['callee', 'arguments', 'typeParameters', 'typeArguments'], Program: ['directives', 'body'], ObjectExpression: ['properties'], ObjectMethod: ['decorators', 'key', 'typeParameters', 'params', 'returnType', 'body'], ObjectProperty: ['key', 'value', 'decorators'], RestElement: ['argument', 'typeAnnotation', 'decorators'], ReturnStatement: ['argument'], SequenceExpression: ['expressions'], ParenthesizedExpression: ['expression'], SwitchCase: ['test', 'consequent'], SwitchStatement: ['discriminant', 'cases'], ThisExpression: [], ThrowStatement: ['argument'], TryStatement: ['block', 'handler', 'finalizer'], UnaryExpression: ['argument'], UpdateExpression: ['argument'], VariableDeclaration: ['declarations'], VariableDeclarator: ['id', 'init'], WhileStatement: ['test', 'body'], WithStatement: ['object', 'body'], AssignmentPattern: ['left', 'right', 'decorators', 'typeAnnotation'], ArrayPattern: ['elements', 'typeAnnotation', 'decorators'], ArrowFunctionExpression: ['typeParameters', 'params', 'predicate', 'returnType', 'body'], ClassBody: ['body'], ClassExpression: ['decorators', 'id', 'typeParameters', 'superClass', 'superTypeParameters', 'mixins', 'implements', 'body', 'superTypeArguments'], ClassDeclaration: ['decorators', 'id', 'typeParameters', 'superClass', 'superTypeParameters', 'mixins', 'implements', 'body', 'superTypeArguments'], ExportAllDeclaration: ['source', 'attributes', 'exported'], ExportDefaultDeclaration: ['declaration'], ExportNamedDeclaration: ['declaration', 'specifiers', 'source', 'attributes'], ExportSpecifier: ['local', 'exported'], ForOfStatement: ['left', 'right', 'body'], ImportDeclaration: ['specifiers', 'source', 'attributes'], ImportDefaultSpecifier: ['local'], ImportNamespaceSpecifier: ['local'], ImportSpecifier: ['imported', 'local'], ImportExpression: ['source', 'options'], MetaProperty: ['meta', 'property'], ClassMethod: ['decorators', 'key', 'typeParameters', 'params', 'returnType', 'body'], ObjectPattern: ['properties', 'typeAnnotation', 'decorators'], SpreadElement: ['argument'], Super: [], TaggedTemplateExpression: ['tag', 'typeParameters', 'quasi', 'typeArguments'], TemplateElement: [], TemplateLiteral: ['quasis', 'expressions'], YieldExpression: ['argument'], AwaitExpression: ['argument'], BigIntLiteral: [], ExportNamespaceSpecifier: ['exported'], OptionalMemberExpression: ['object', 'property'], OptionalCallExpression: ['callee', 'arguments', 'typeParameters', 'typeArguments'], ClassProperty: ['decorators', 'variance', 'key', 'typeAnnotation', 'value'], ClassAccessorProperty: ['decorators', 'key', 'typeAnnotation', 'value'], ClassPrivateProperty: ['decorators', 'variance', 'key', 'typeAnnotation', 'value'], ClassPrivateMethod: ['decorators', 'key', 'typeParameters', 'params', 'returnType', 'body'], PrivateName: ['id'], StaticBlock: ['body'], AnyTypeAnnotation: [], ArrayTypeAnnotation: ['elementType'], BooleanTypeAnnotation: [], BooleanLiteralTypeAnnotation: [], NullLiteralTypeAnnotation: [], ClassImplements: ['id', 'typeParameters'], DeclareClass: ['id', 'typeParameters', 'extends', 'mixins', 'implements', 'body'], DeclareFunction: ['id', 'predicate'], DeclareInterface: ['id', 'typeParameters', 'extends', 'body'], DeclareModule: ['id', 'body'], DeclareModuleExports: ['typeAnnotation'], DeclareTypeAlias: ['id', 'typeParameters', 'right'], DeclareOpaqueType: ['id', 'typeParameters', 'supertype'], DeclareVariable: ['id'], DeclareExportDeclaration: ['declaration', 'specifiers', 'source', 'attributes'], DeclareExportAllDeclaration: ['source', 'attributes'], DeclaredPredicate: ['value'], ExistsTypeAnnotation: [], FunctionTypeAnnotation: ['typeParameters', 'this', 'params', 'rest', 'returnType'], FunctionTypeParam: ['name', 'typeAnnotation'], GenericTypeAnnotation: ['id', 'typeParameters'], InferredPredicate: [], InterfaceExtends: ['id', 'typeParameters'], InterfaceDeclaration: ['id', 'typeParameters', 'extends', 'body'], InterfaceTypeAnnotation: ['extends', 'body'], IntersectionTypeAnnotation: ['types'], MixedTypeAnnotation: [], EmptyTypeAnnotation: [], NullableTypeAnnotation: ['typeAnnotation'], NumberLiteralTypeAnnotation: [], NumberTypeAnnotation: [], ObjectTypeAnnotation: ['properties', 'indexers', 'callProperties', 'internalSlots'], ObjectTypeInternalSlot: ['id', 'value'], ObjectTypeCallProperty: ['value'], ObjectTypeIndexer: ['variance', 'id', 'key', 'value'], ObjectTypeProperty: ['key', 'value', 'variance'], ObjectTypeSpreadProperty: ['argument'], OpaqueType: ['id', 'typeParameters', 'supertype', 'impltype'], QualifiedTypeIdentifier: ['qualification', 'id'], StringLiteralTypeAnnotation: [], StringTypeAnnotation: [], SymbolTypeAnnotation: [], ThisTypeAnnotation: [], TupleTypeAnnotation: ['types', 'elementTypes'], TypeofTypeAnnotation: ['argument', 'typeArguments'], TypeAlias: ['id', 'typeParameters', 'right'], TypeAnnotation: ['typeAnnotation'], TypeCastExpression: ['expression', 'typeAnnotation'], TypeParameter: ['bound', 'default', 'variance'], TypeParameterDeclaration: ['params'], TypeParameterInstantiation: ['params'], UnionTypeAnnotation: ['types'], Variance: [], VoidTypeAnnotation: [], EnumDeclaration: ['id', 'body'], EnumBooleanBody: ['members'], EnumNumberBody: ['members'], EnumStringBody: ['members'], EnumSymbolBody: ['members'], EnumBooleanMember: ['id', 'init'], EnumNumberMember: ['id', 'init'], EnumStringMember: ['id', 'init'], EnumDefaultedMember: ['id'], IndexedAccessType: ['objectType', 'indexType'], OptionalIndexedAccessType: ['objectType', 'indexType'], JSXAttribute: ['name', 'value'], JSXClosingElement: ['name'], JSXElement: ['openingElement', 'children', 'closingElement'], JSXEmptyExpression: [], JSXExpressionContainer: ['expression'], JSXSpreadChild: ['expression'], JSXIdentifier: [], JSXMemberExpression: ['object', 'property'], JSXNamespacedName: ['namespace', 'name'], JSXOpeningElement: ['name', 'typeParameters', 'typeArguments', 'attributes'], JSXSpreadAttribute: ['argument'], JSXText: [], JSXFragment: ['openingFragment', 'children', 'closingFragment'], JSXOpeningFragment: [], JSXClosingFragment: [], Noop: [], Placeholder: [], V8IntrinsicIdentifier: [], ArgumentPlaceholder: [], BindExpression: ['object', 'callee'], ImportAttribute: ['key', 'value'], Decorator: ['expression'], DoExpression: ['body'], ExportDefaultSpecifier: ['exported'], RecordExpression: ['properties'], TupleExpression: ['elements'], ModuleExpression: ['body'], TopicReference: [], PipelineTopicExpression: ['expression'], PipelineBareFunction: ['callee'], PipelinePrimaryTopicReference: [], TSParameterProperty: ['parameter', 'decorators'], TSDeclareFunction: ['id', 'typeParameters', 'params', 'returnType', 'body'], TSDeclareMethod: ['decorators', 'key', 'typeParameters', 'params', 'returnType'], TSQualifiedName: ['left', 'right'], TSCallSignatureDeclaration: ['typeParameters', 'parameters', 'typeAnnotation', 'params', 'returnType'], TSConstructSignatureDeclaration: ['typeParameters', 'parameters', 'typeAnnotation', 'params', 'returnType'], TSPropertySignature: ['key', 'typeAnnotation'], TSMethodSignature: ['key', 'typeParameters', 'parameters', 'typeAnnotation', 'params', 'returnType'], TSIndexSignature: ['parameters', 'typeAnnotation'], TSAnyKeyword: [], TSBooleanKeyword: [], TSBigIntKeyword: [], TSIntrinsicKeyword: [], TSNeverKeyword: [], TSNullKeyword: [], TSNumberKeyword: [], TSObjectKeyword: [], TSStringKeyword: [], TSSymbolKeyword: [], TSUndefinedKeyword: [], TSUnknownKeyword: [], TSVoidKeyword: [], TSThisType: [], TSFunctionType: ['typeParameters', 'parameters', 'typeAnnotation', 'params', 'returnType'], TSConstructorType: ['typeParameters', 'parameters', 'typeAnnotation', 'params', 'returnType'], TSTypeReference: ['typeName', 'typeParameters', 'typeArguments'], TSTypePredicate: ['parameterName', 'typeAnnotation'], TSTypeQuery: ['exprName', 'typeParameters', 'typeArguments'], TSTypeLiteral: ['members'], TSArrayType: ['elementType'], TSTupleType: ['elementTypes'], TSOptionalType: ['typeAnnotation'], TSRestType: ['typeAnnotation'], TSNamedTupleMember: ['label', 'elementType'], TSUnionType: ['types'], TSIntersectionType: ['types'], TSConditionalType: ['checkType', 'extendsType', 'trueType', 'falseType'], TSInferType: ['typeParameter'], TSParenthesizedType: ['typeAnnotation'], TSTypeOperator: ['typeAnnotation'], TSIndexedAccessType: ['objectType', 'indexType'], TSMappedType: ['typeParameter', 'nameType', 'typeAnnotation'], TSTemplateLiteralType: ['quasis', 'types'], TSLiteralType: ['literal'], TSExpressionWithTypeArguments: ['expression', 'typeParameters'], TSInterfaceDeclaration: ['id', 'typeParameters', 'extends', 'body'], TSInterfaceBody: ['body'], TSTypeAliasDeclaration: ['id', 'typeParameters', 'typeAnnotation'], TSInstantiationExpression: ['expression', 'typeParameters', 'typeArguments'], TSAsExpression: ['expression', 'typeAnnotation'], TSSatisfiesExpression: ['expression', 'typeAnnotation'], TSTypeAssertion: ['typeAnnotation', 'expression'], TSEnumBody: ['members'], TSEnumDeclaration: ['id', 'members'], TSEnumMember: ['id', 'initializer'], TSModuleDeclaration: ['id', 'body'], TSModuleBlock: ['body'], TSImportType: ['argument', 'options', 'qualifier', 'typeParameters', 'typeArguments'], TSImportEqualsDeclaration: ['id', 'moduleReference'], TSExternalModuleReference: ['expression'], TSNonNullExpression: ['expression'], TSExportAssignment: ['expression'], TSNamespaceExportDeclaration: ['id'], TSTypeAnnotation: ['typeAnnotation'], TSTypeParameterInstantiation: ['params'], TSTypeParameterDeclaration: ['params'], TSTypeParameter: ['constraint', 'default', 'name'], ChainExpression: ['expression'], ExperimentalRestProperty: ['argument'], ExperimentalSpreadProperty: ['argument'], Literal: [], MethodDefinition: ['decorators', 'key', 'value'], PrivateIdentifier: [], Property: ['key', 'value'], PropertyDefinition: ['decorators', 'key', 'typeAnnotation', 'value', 'variance'], AccessorProperty: ['decorators', 'key', 'typeAnnotation', 'value'], TSAbstractAccessorProperty: ['decorators', 'key', 'typeAnnotation'], TSAbstractKeyword: [], TSAbstractMethodDefinition: ['key', 'value'], TSAbstractPropertyDefinition: ['decorators', 'key', 'typeAnnotation'], TSAsyncKeyword: [], TSClassImplements: ['expression', 'typeArguments', 'typeParameters'], TSDeclareKeyword: [], TSEmptyBodyFunctionExpression: ['id', 'typeParameters', 'params', 'returnType'], TSExportKeyword: [], TSInterfaceHeritage: ['expression', 'typeArguments', 'typeParameters'], TSPrivateKeyword: [], TSProtectedKeyword: [], TSPublicKeyword: [], TSReadonlyKeyword: [], TSStaticKeyword: [], AsConstExpression: ['expression'], AsExpression: ['expression', 'typeAnnotation'], BigIntLiteralTypeAnnotation: [], BigIntTypeAnnotation: [], ComponentDeclaration: ['id', 'params', 'body', 'typeParameters', 'rendersType'], ComponentParameter: ['name', 'local'], ComponentTypeAnnotation: ['params', 'rest', 'typeParameters', 'rendersType'], ComponentTypeParameter: ['name', 'typeAnnotation'], ConditionalTypeAnnotation: ['checkType', 'extendsType', 'trueType', 'falseType'], DeclareComponent: ['id', 'params', 'rest', 'typeParameters', 'rendersType'], DeclareEnum: ['id', 'body'], DeclareHook: ['id'], DeclareNamespace: ['id', 'body'], EnumBigIntBody: ['members'], EnumBigIntMember: ['id', 'init'], HookDeclaration: ['id', 'params', 'body', 'typeParameters', 'returnType'], HookTypeAnnotation: ['params', 'returnType', 'rest', 'typeParameters'], InferTypeAnnotation: ['typeParameter'], KeyofTypeAnnotation: ['argument'], ObjectTypeMappedTypeProperty: ['keyTparam', 'propType', 'sourceType', 'variance'], QualifiedTypeofIdentifier: ['qualification', 'id'], TupleTypeLabeledElement: ['label', 'elementType', 'variance'], TupleTypeSpreadElement: ['label', 'typeAnnotation'], TypeOperator: ['typeAnnotation'], TypePredicate: ['parameterName', 'typeAnnotation', 'asserts'], NGRoot: ['node'], NGPipeExpression: ['left', 'right', 'arguments'], NGChainedExpression: ['expressions'], NGEmptyExpression: [], NGMicrosyntax: ['body'], NGMicrosyntaxKey: [], NGMicrosyntaxExpression: ['expression', 'alias'], NGMicrosyntaxKeyedExpression: ['key', 'expression'], NGMicrosyntaxLet: ['key', 'value'], NGMicrosyntaxAs: ['key', 'alias'], JsExpressionRoot: ['node'], JsonRoot: ['node'], TSJSDocAllType: [], TSJSDocUnknownType: [], TSJSDocNullableType: ['typeAnnotation'], TSJSDocNonNullableType: ['typeAnnotation'], NeverTypeAnnotation: [], UndefinedTypeAnnotation: [], UnknownTypeAnnotation: [], SatisfiesExpression: ['expression', 'typeAnnotation'] });
   var q = function (e) {
     let t = new Set(e);
     return (e) => t.has(null == e ? void 0 : e.type);
    },
    J = q(['Block', 'CommentBlock', 'MultiLine']),
    W = q(['AnyTypeAnnotation', 'ThisTypeAnnotation', 'NumberTypeAnnotation', 'VoidTypeAnnotation', 'BooleanTypeAnnotation', 'BigIntTypeAnnotation', 'SymbolTypeAnnotation', 'StringTypeAnnotation', 'NeverTypeAnnotation', 'UndefinedTypeAnnotation', 'UnknownTypeAnnotation', 'EmptyTypeAnnotation', 'MixedTypeAnnotation']);
   var z = function (e, t) {
    return t.some((t) =>
     (function (e, t) {
      let r = t.split('.');
      for (let s = r.length - 1; s >= 0; s--) {
       let t = r[s];
       if (0 === s) return 'Identifier' === e.type && e.name === t;
       if ('MemberExpression' !== e.type || e.optional || e.computed || 'Identifier' !== e.property.type || e.property.name !== t) return !1;
       e = e.object;
      }
     })(e, t),
    );
   };
   var V = function ({ type: e }) {
    return e.startsWith('TS') && e.endsWith('Keyword');
   };
   function H(e, t) {
    return t(e) || f(e, { getVisitorKeys: $, predicate: t });
   }
   function K(e) {
    return 'AssignmentExpression' === e.type || 'BinaryExpression' === e.type || 'LogicalExpression' === e.type || 'NGPipeExpression' === e.type || 'ConditionalExpression' === e.type || Ee(e) || be(e) || 'SequenceExpression' === e.type || 'TaggedTemplateExpression' === e.type || 'BindExpression' === e.type || ('UpdateExpression' === e.type && !e.prefix) || it(e) || 'TSNonNullExpression' === e.type || 'ChainExpression' === e.type;
   }
   function X(e) {
    return e.expressions ? e.expressions[0] : (e.left ?? e.test ?? e.callee ?? e.object ?? e.tag ?? e.argument ?? e.expression);
   }
   function G(e) {
    if (e.expressions) return ['expressions', 0];
    if (e.left) return ['left'];
    if (e.test) return ['test'];
    if (e.object) return ['object'];
    if (e.callee) return ['callee'];
    if (e.tag) return ['tag'];
    if (e.argument) return ['argument'];
    if (e.expression) return ['expression'];
    throw new Error('Unexpected node has no left side.');
   }
   var Y = q(['Line', 'CommentLine', 'SingleLine', 'HashbangComment', 'HTMLOpen', 'HTMLClose', 'Hashbang', 'InterpreterDirective']),
    Q = q(['ExportDefaultDeclaration', 'DeclareExportDeclaration', 'ExportNamedDeclaration', 'ExportAllDeclaration', 'DeclareExportAllDeclaration']),
    Z = q(['ArrayExpression', 'TupleExpression']),
    ee = q(['ObjectExpression', 'RecordExpression']);
   function te(e) {
    return 'NumericLiteral' === e.type || ('Literal' === e.type && 'number' == typeof e.value);
   }
   function re(e) {
    return 'UnaryExpression' === e.type && ('+' === e.operator || '-' === e.operator) && te(e.argument);
   }
   function se(e) {
    return !(!e || ('StringLiteral' !== e.type && ('Literal' !== e.type || 'string' != typeof e.value)));
   }
   function ne(e) {
    return 'RegExpLiteral' === e.type || ('Literal' === e.type && !!e.regex);
   }
   var ie = q(['Literal', 'BooleanLiteral', 'BigIntLiteral', 'DirectiveLiteral', 'NullLiteral', 'NumericLiteral', 'RegExpLiteral', 'StringLiteral']),
    ae = q(['Identifier', 'ThisExpression', 'Super', 'PrivateName', 'PrivateIdentifier']),
    oe = q(['ObjectTypeAnnotation', 'TSTypeLiteral', 'TSMappedType']),
    ue = q(['FunctionExpression', 'ArrowFunctionExpression']);
   function le(e) {
    return Ee(e) && 'Identifier' === e.callee.type && ['async', 'inject', 'fakeAsync', 'waitForAsync'].includes(e.callee.name);
   }
   var pe = q(['JSXElement', 'JSXFragment']);
   function ce(e) {
    return (e.method && 'init' === e.kind) || 'get' === e.kind || 'set' === e.kind;
   }
   function he(e) {
    return !(('ObjectTypeProperty' !== e.type && 'ObjectTypeInternalSlot' !== e.type) || e.static || e.method || 'get' === e.kind || 'set' === e.kind || 'FunctionTypeAnnotation' !== e.value.type);
   }
   var de = q(['BinaryExpression', 'LogicalExpression', 'NGPipeExpression']);
   function fe(e) {
    return be(e) || ('BindExpression' === e.type && !!e.object);
   }
   var me = q(['TSThisType', 'NullLiteralTypeAnnotation', 'BooleanLiteralTypeAnnotation', 'StringLiteralTypeAnnotation', 'BigIntLiteralTypeAnnotation', 'NumberLiteralTypeAnnotation', 'TSLiteralType', 'TSTemplateLiteralType']);
   function ye(e) {
    return V(e) || W(e) || me(e) || (('GenericTypeAnnotation' === e.type || 'TSTypeReference' === e.type) && !e.typeParameters && !e.typeArguments);
   }
   var De = ['it', 'it.only', 'it.skip', 'describe', 'describe.only', 'describe.skip', 'test', 'test.only', 'test.skip', 'test.step', 'test.describe', 'test.describe.only', 'test.describe.parallel', 'test.describe.parallel.only', 'test.describe.serial', 'test.describe.serial.only', 'skip', 'xit', 'xdescribe', 'xtest', 'fit', 'fdescribe', 'ftest'];
   function ge(e, t) {
    if ('CallExpression' !== (null == e ? void 0 : e.type) || e.optional) return !1;
    let r = He(e);
    if (1 === r.length) {
     if (le(e) && ge(t)) return ue(r[0]);
     if (
      (function (e) {
       return 'Identifier' === e.type && ('beforeEach' === e.name || 'beforeAll' === e.name || 'afterEach' === e.name || 'afterAll' === e.name);
      })(e.callee)
     )
      return le(r[0]);
    } else if (
     (2 === r.length || 3 === r.length) &&
     ('TemplateLiteral' === r[0].type || se(r[0])) &&
     (function (e) {
      return z(e, De);
     })(e.callee)
    )
     return (
      !(r[2] && !te(r[2])) &&
      ((2 === r.length
       ? ue(r[1])
       : (function (e) {
          return 'FunctionExpression' === e.type || ('ArrowFunctionExpression' === e.type && 'BlockStatement' === e.body.type);
         })(r[1]) && ze(r[1]).length <= 1) ||
       le(r[1]))
     );
    return !1;
   }
   var xe = (e) => (t) => ('ChainExpression' === (null == t ? void 0 : t.type) && (t = t.expression), e(t)),
    Ee = xe(q(['CallExpression', 'OptionalCallExpression'])),
    be = xe(q(['MemberExpression', 'OptionalMemberExpression']));
   function Te(e, t = 5) {
    return Ae(e, t) <= t;
   }
   function Ae(e, t) {
    let r = 0;
    for (let s in e) {
     let n = e[s];
     if ((n && 'object' == typeof n && 'string' == typeof n.type && (r++, (r += Ae(n, t - r))), r > t)) return r;
    }
    return r;
   }
   var Ce = 0.25;
   function ve(e, t) {
    let { printWidth: r } = t;
    if (et(e)) return !1;
    let s = r * Ce;
    if ('ThisExpression' === e.type || ('Identifier' === e.type && e.name.length <= s) || (re(e) && !et(e.argument))) return !0;
    let n = ('Literal' === e.type && 'regex' in e && e.regex.pattern) || ('RegExpLiteral' === e.type && e.pattern);
    return n ? n.length <= s : se(e) ? B(Be(e), t).length <= s : 'TemplateLiteral' === e.type ? 0 === e.expressions.length && e.quasis[0].value.raw.length <= s && !e.quasis[0].value.raw.includes('\n') : 'UnaryExpression' === e.type ? ve(e.argument, { printWidth: r }) : 'CallExpression' === e.type && 0 === e.arguments.length && 'Identifier' === e.callee.type ? e.callee.name.length <= s - 2 : ie(e);
   }
   function Fe(e, t) {
    return pe(t) ? Ye(t) : et(t, Qe.Leading, (t) => A(e, L(t)));
   }
   function we(e) {
    return e.quasis.some((e) => e.value.raw.includes('\n'));
   }
   function Se(e, t) {
    return (('TemplateLiteral' === e.type && we(e)) || ('TaggedTemplateExpression' === e.type && we(e.quasi))) && !A(t, O(e), { backwards: !0 });
   }
   function Pe(e) {
    if (!et(e)) return !1;
    let t = c(!1, tt(e, Qe.Dangling), -1);
    return t && !J(t);
   }
   function ke(e) {
    let { node: t, parent: r, key: s } = e;
    return 'callee' === s && Ee(t) && Ee(r) && r.arguments.length > 0 && t.arguments.length > r.arguments.length;
   }
   var Ie = new Set(['!', '-', '+', '~']);
   function Ne(e, t = 2) {
    if (t <= 0) return !1;
    if ('ChainExpression' === e.type || 'TSNonNullExpression' === e.type) return Ne(e.expression, t);
    let r = (e) => Ne(e, t - 1);
    if (ne(e)) return D(e.pattern ?? e.regex.pattern) <= 5;
    if (ie(e) || ae(e) || 'ArgumentPlaceholder' === e.type) return !0;
    if ('TemplateLiteral' === e.type) return e.quasis.every((e) => !e.value.raw.includes('\n')) && e.expressions.every(r);
    if (ee(e)) return e.properties.every((e) => !e.computed && (e.shorthand || (e.value && r(e.value))));
    if (Z(e)) return e.elements.every((e) => null === e || r(e));
    if (st(e)) {
     if ('ImportExpression' === e.type || Ne(e.callee, t)) {
      let s = He(e);
      return s.length <= t && s.every(r);
     }
     return !1;
    }
    return be(e) ? Ne(e.object, t) && Ne(e.property, t) : !!(('UnaryExpression' === e.type && Ie.has(e.operator)) || 'UpdateExpression' === e.type) && Ne(e.argument, t);
   }
   function Be(e) {
    var t;
    return (null == (t = e.extra) ? void 0 : t.raw) ?? e.raw;
   }
   function Oe(e) {
    return e;
   }
   function Le(e, t = 'es5') {
    return ('es5' === e.trailingComma && 'es5' === t) || ('all' === e.trailingComma && ('all' === t || 'es5' === t));
   }
   function Me(e, t) {
    switch (e.type) {
     case 'BinaryExpression':
     case 'LogicalExpression':
     case 'AssignmentExpression':
     case 'NGPipeExpression':
      return Me(e.left, t);
     case 'MemberExpression':
     case 'OptionalMemberExpression':
      return Me(e.object, t);
     case 'TaggedTemplateExpression':
      return 'FunctionExpression' !== e.tag.type && Me(e.tag, t);
     case 'CallExpression':
     case 'OptionalCallExpression':
      return 'FunctionExpression' !== e.callee.type && Me(e.callee, t);
     case 'ConditionalExpression':
      return Me(e.test, t);
     case 'UpdateExpression':
      return !e.prefix && Me(e.argument, t);
     case 'BindExpression':
      return e.object && Me(e.object, t);
     case 'SequenceExpression':
      return Me(e.expressions[0], t);
     case 'ChainExpression':
     case 'TSSatisfiesExpression':
     case 'TSAsExpression':
     case 'TSNonNullExpression':
     case 'AsExpression':
     case 'AsConstExpression':
     case 'SatisfiesExpression':
      return Me(e.expression, t);
     default:
      return t(e);
    }
   }
   var je = { '==': !0, '!=': !0, '===': !0, '!==': !0 },
    _e = { '*': !0, '/': !0, '%': !0 },
    Re = { '>>': !0, '>>>': !0, '<<': !0 };
   function Ue(e, t) {
    return !(qe(t) !== qe(e) || '**' === e || (je[e] && je[t]) || ('%' === t && _e[e]) || ('%' === e && _e[t]) || (t !== e && _e[t] && _e[e]) || (Re[e] && Re[t]));
   }
   var $e = new Map([['|>'], ['??'], ['||'], ['&&'], ['|'], ['^'], ['&'], ['==', '===', '!=', '!=='], ['<', '>', '<=', '>=', 'in', 'instanceof'], ['>>', '<<', '>>>'], ['+', '-'], ['*', '/', '%'], ['**']].flatMap((e, t) => e.map((e) => [e, t])));
   function qe(e) {
    return $e.get(e);
   }
   function Je(e) {
    var t;
    if (e.rest) return !0;
    let r = ze(e);
    return 'RestElement' === (null == (t = c(!1, r, -1)) ? void 0 : t.type);
   }
   var We = new WeakMap();
   function ze(e) {
    if (We.has(e)) return We.get(e);
    let t = [];
    return e.this && t.push(e.this), Array.isArray(e.parameters) ? t.push(...e.parameters) : Array.isArray(e.params) && t.push(...e.params), e.rest && t.push(e.rest), We.set(e, t), t;
   }
   var Ve = new WeakMap();
   function He(e) {
    if (Ve.has(e)) return Ve.get(e);
    if ('ChainExpression' === e.type) return He(e.expression);
    let t = e.arguments;
    return 'ImportExpression' === e.type && ((t = [e.source]), e.options && t.push(e.options)), Ve.set(e, t), t;
   }
   function Ke(e, t) {
    let { node: r } = e;
    if ('ChainExpression' === r.type) return e.call(() => Ke(e, t), 'expression');
    'ImportExpression' === r.type ? (e.call((e) => t(e, 0), 'source'), r.options && e.call((e) => t(e, 1), 'options')) : e.each(t, 'arguments');
   }
   function Xe(e, t) {
    let r = [];
    if (('ChainExpression' === e.type && ((e = e.expression), r.push('expression')), 'ImportExpression' === e.type)) {
     if (0 === t || t === (e.options ? -2 : -1)) return [...r, 'source'];
     if (e.options && (1 === t || -1 === t)) return [...r, 'options'];
     throw new RangeError('Invalid argument index');
    }
    if ((t < 0 && (t = e.arguments.length + t), t < 0 || t >= e.arguments.length)) throw new RangeError('Invalid argument index');
    return [...r, 'arguments', t];
   }
   function Ge(e) {
    return 'prettier-ignore' === e.value.trim() && !e.unignore;
   }
   function Ye(e) {
    return (null == e ? void 0 : e.prettierIgnore) || et(e, Qe.PrettierIgnore);
   }
   var Qe = { Leading: 2, Trailing: 4, Dangling: 8, Block: 16, Line: 32, PrettierIgnore: 64, First: 128, Last: 256 },
    Ze = (e, t) => {
     if (('function' == typeof e && ((t = e), (e = 0)), e || t)) return (r, s, n) => !((e & Qe.Leading && !r.leading) || (e & Qe.Trailing && !r.trailing) || (e & Qe.Dangling && (r.leading || r.trailing)) || (e & Qe.Block && !J(r)) || (e & Qe.Line && !Y(r)) || (e & Qe.First && 0 !== s) || (e & Qe.Last && s !== n.length - 1) || (e & Qe.PrettierIgnore && !Ge(r)) || (t && !t(r)));
    };
   function et(e, t, r) {
    if (!w(null == e ? void 0 : e.comments)) return !1;
    let s = Ze(t, r);
    return !s || e.comments.some(s);
   }
   function tt(e, t, r) {
    if (!Array.isArray(null == e ? void 0 : e.comments)) return [];
    let s = Ze(t, r);
    return s ? e.comments.filter(s) : e.comments;
   }
   var rt = (e, { originalText: t }) => F(t, L(e));
   function st(e) {
    return Ee(e) || 'NewExpression' === e.type || 'ImportExpression' === e.type;
   }
   function nt(e) {
    return e && ('ObjectProperty' === e.type || ('Property' === e.type && !ce(e)));
   }
   var it = q(['TSAsExpression', 'TSSatisfiesExpression', 'AsExpression', 'AsConstExpression', 'SatisfiesExpression']),
    at = q(['UnionTypeAnnotation', 'TSUnionType']),
    ot = q(['IntersectionTypeAnnotation', 'TSIntersectionType']),
    ut = new Set(['range', 'raw', 'comments', 'leadingComments', 'trailingComments', 'innerComments', 'extra', 'start', 'end', 'loc', 'flags', 'errors', 'tokens']),
    lt = (e) => {
     for (let t of e.quasis) delete t.value;
    };
   function pt(e, t, r) {
    var s, n;
    if (('Program' === e.type && delete t.sourceType, ('BigIntLiteral' === e.type || 'BigIntLiteralTypeAnnotation' === e.type) && e.value && (t.value = e.value.toLowerCase()), ('BigIntLiteral' === e.type || 'Literal' === e.type) && e.bigint && (t.bigint = e.bigint.toLowerCase()), 'EmptyStatement' === e.type || 'JSXText' === e.type || ('JSXExpressionContainer' === e.type && ('Literal' === e.expression.type || 'StringLiteral' === e.expression.type) && ' ' === e.expression.value))) return null;
    if (('Property' === e.type || 'ObjectProperty' === e.type || 'MethodDefinition' === e.type || 'ClassProperty' === e.type || 'ClassMethod' === e.type || 'PropertyDefinition' === e.type || 'TSDeclareMethod' === e.type || 'TSPropertySignature' === e.type || 'ObjectTypeProperty' === e.type || 'ImportAttribute' === e.type) && e.key && !e.computed) {
     let { key: r } = e;
     se(r) || te(r) ? (t.key = String(r.value)) : 'Identifier' === r.type && (t.key = r.name);
    }
    if ('JSXElement' === e.type && 'style' === e.openingElement.name.name && e.openingElement.attributes.some((e) => 'JSXAttribute' === e.type && 'jsx' === e.name.name)) for (let { type: a, expression: o } of t.children) 'JSXExpressionContainer' === a && 'TemplateLiteral' === o.type && lt(o);
    'JSXAttribute' === e.type && 'css' === e.name.name && 'JSXExpressionContainer' === e.value.type && 'TemplateLiteral' === e.value.expression.type && lt(t.value.expression), 'JSXAttribute' === e.type && 'Literal' === (null == (s = e.value) ? void 0 : s.type) && /["']|&quot;|&apos;/u.test(e.value.value) && (t.value.value = p(!1, e.value.value, /["']|&quot;|&apos;/gu, '"'));
    let i = e.expression || e.callee;
    if ('Decorator' === e.type && 'CallExpression' === i.type && 'Component' === i.callee.name && 1 === i.arguments.length) {
     let r = e.expression.arguments[0].properties;
     for (let [e, s] of t.expression.arguments[0].properties.entries())
      switch (r[e].key.name) {
       case 'styles':
        Z(s.value) && lt(s.value.elements[0]);
        break;
       case 'template':
        'TemplateLiteral' === s.value.type && lt(s.value);
      }
    }
    'TaggedTemplateExpression' === e.type && ('MemberExpression' === e.tag.type || ('Identifier' === e.tag.type && ('gql' === e.tag.name || 'graphql' === e.tag.name || 'css' === e.tag.name || 'md' === e.tag.name || 'markdown' === e.tag.name || 'html' === e.tag.name)) || 'CallExpression' === e.tag.type) && lt(t.quasi), 'TemplateLiteral' === e.type && ((null != (n = e.leadingComments) && n.some((e) => J(e) && ['GraphQL', 'HTML'].some((t) => e.value === ` ${t} `))) || ('CallExpression' === r.type && 'graphql' === r.callee.name) || !e.leadingComments) && lt(t), 'ChainExpression' === e.type && 'TSNonNullExpression' === e.expression.type && ((t.type = 'TSNonNullExpression'), (t.expression.type = 'ChainExpression')), 'TSMappedType' === e.type && (delete t.key, delete t.constraint), 'TSEnumDeclaration' === e.type && delete t.body;
   }
   pt.ignoredProperties = ut;
   var ct = pt,
    ht = 'string',
    dt = 'array',
    ft = 'cursor',
    mt = 'indent',
    yt = 'align',
    Dt = 'trim',
    gt = 'group',
    xt = 'fill',
    Et = 'if-break',
    bt = 'indent-if-break',
    Tt = 'line-suffix',
    At = 'line-suffix-boundary',
    Ct = 'line',
    vt = 'label',
    Ft = 'break-parent',
    wt = new Set([ft, mt, yt, Dt, gt, xt, Et, bt, Tt, At, Ct, vt, Ft]);
   var St = function (e) {
    if ('string' == typeof e) return ht;
    if (Array.isArray(e)) return dt;
    if (!e) return;
    let { type: t } = e;
    return wt.has(t) ? t : void 0;
   };
   function Pt(e) {
    let t = null === e ? 'null' : typeof e;
    if ('string' !== t && 'object' !== t) return `Unexpected doc '${t}', \nExpected it to be 'string' or 'object'.`;
    if (St(e)) throw new Error('doc is valid.');
    let r = Object.prototype.toString.call(e);
    if ('[object Object]' !== r) return `Unexpected doc '${r}'.`;
    let s = ((e) => new Intl.ListFormat('en-US', { type: 'disjunction' }).format(e))([...wt].map((e) => `'${e}'`));
    return `Unexpected doc.type '${e.type}'.\nExpected it to be ${s}.`;
   }
   var kt = class extends Error {
     name = 'InvalidDocError';
     constructor(e) {
      super(Pt(e)), (this.doc = e);
     }
    },
    It = {};
   var Nt = function (e, t, r, s) {
    let n = [e];
    for (; n.length > 0; ) {
     let e = n.pop();
     if (e === It) {
      r(n.pop());
      continue;
     }
     r && n.push(e, It);
     let i = St(e);
     if (!i) throw new kt(e);
     if (!1 !== (null == t ? void 0 : t(e)))
      switch (i) {
       case dt:
       case xt: {
        let t = i === dt ? e : e.parts;
        for (let e = t.length - 1; e >= 0; --e) n.push(t[e]);
        break;
       }
       case Et:
        n.push(e.flatContents, e.breakContents);
        break;
       case gt:
        if (s && e.expandedStates) for (let t = e.expandedStates.length - 1; t >= 0; --t) n.push(e.expandedStates[t]);
        else n.push(e.contents);
        break;
       case yt:
       case mt:
       case bt:
       case vt:
       case Tt:
        n.push(e.contents);
        break;
       case ht:
       case ft:
       case Dt:
       case At:
       case Ct:
       case Ft:
        break;
       default:
        throw new kt(e);
      }
    }
   };
   function Bt(e, t) {
    if ('string' == typeof e) return t(e);
    let r = new Map();
    return s(e);
    function s(e) {
     if (r.has(e)) return r.get(e);
     let n = (function (e) {
      switch (St(e)) {
       case dt:
        return t(e.map(s));
       case xt:
        return t({ ...e, parts: e.parts.map(s) });
       case Et:
        return t({ ...e, breakContents: s(e.breakContents), flatContents: s(e.flatContents) });
       case gt: {
        let { expandedStates: r, contents: n } = e;
        return r ? ((r = r.map(s)), (n = r[0])) : (n = s(n)), t({ ...e, contents: n, expandedStates: r });
       }
       case yt:
       case mt:
       case bt:
       case vt:
       case Tt:
        return t({ ...e, contents: s(e.contents) });
       case ht:
       case ft:
       case Dt:
       case At:
       case Ct:
       case Ft:
        return t(e);
       default:
        throw new kt(e);
      }
     })(e);
     return r.set(e, n), n;
    }
   }
   function Ot(e, t, r) {
    let s = r,
     n = !1;
    return (
     Nt(e, function (e) {
      if (n) return !1;
      let r = t(e);
      void 0 !== r && ((n = !0), (s = r));
     }),
     s
    );
   }
   function Lt(e) {
    if ((e.type === gt && e.break) || (e.type === Ct && e.hard) || e.type === Ft) return !0;
   }
   function Mt(e) {
    return Ot(e, Lt, !1);
   }
   function jt(e) {
    if (e.length > 0) {
     let t = c(!1, e, -1);
     !t.expandedStates && !t.break && (t.break = 'propagated');
    }
    return null;
   }
   function _t(e) {
    return e.type !== Ct || e.hard ? (e.type === Et ? e.flatContents : e) : e.soft ? '' : ' ';
   }
   function Rt(e) {
    return Bt(e, _t);
   }
   function Ut(e) {
    return Bt(e, (e) =>
     (function (e) {
      switch (St(e)) {
       case xt:
        if (e.parts.every((e) => '' === e)) return '';
        break;
       case gt:
        if (!(e.contents || e.id || e.break || e.expandedStates)) return '';
        if (e.contents.type === gt && e.contents.id === e.id && e.contents.break === e.break && e.contents.expandedStates === e.expandedStates) return e.contents;
        break;
       case yt:
       case mt:
       case bt:
       case Tt:
        if (!e.contents) return '';
        break;
       case Et:
        if (!e.flatContents && !e.breakContents) return '';
        break;
       case dt: {
        let t = [];
        for (let r of e) {
         if (!r) continue;
         let [e, ...s] = Array.isArray(r) ? r : [r];
         'string' == typeof e && 'string' == typeof c(!1, t, -1) ? (t[t.length - 1] += e) : t.push(e), t.push(...s);
        }
        return 0 === t.length ? '' : 1 === t.length ? t[0] : t;
       }
       case ht:
       case ft:
       case Dt:
       case At:
       case Ct:
       case vt:
       case Ft:
        break;
       default:
        throw new kt(e);
      }
      return e;
     })(e),
    );
   }
   function $t(e, t = cr) {
    return Bt(e, (e) => ('string' == typeof e ? dr(t, e.split('\n')) : e));
   }
   function qt(e) {
    if (e.type === Ct) return !0;
   }
   function Jt(e, t) {
    return e.type === vt ? { ...e, contents: t(e.contents) } : t(e);
   }
   function Wt(e) {
    let t = !0;
    return (
     Nt(e, (e) => {
      switch (St(e)) {
       case ht:
        if ('' === e) break;
       case Dt:
       case At:
       case Ct:
       case Ft:
        return (t = !1), !1;
      }
     }),
     t
    );
   }
   var zt = () => {},
    Vt = zt,
    Ht = zt,
    Kt = zt;
   function Xt(e) {
    return Vt(e), { type: mt, contents: e };
   }
   function Gt(e, t) {
    return Vt(t), { type: yt, contents: t, n: e };
   }
   function Yt(e, t = {}) {
    return Vt(e), Ht(t.expandedStates, !0), { type: gt, id: t.id, contents: e, break: !!t.shouldBreak, expandedStates: t.expandedStates };
   }
   function Qt(e) {
    return Gt(Number.NEGATIVE_INFINITY, e);
   }
   function Zt(e) {
    return Gt(-1, e);
   }
   function er(e, t) {
    return Yt(e[0], { ...t, expandedStates: e });
   }
   function tr(e) {
    return Kt(e), { type: xt, parts: e };
   }
   function rr(e, t = '', r = {}) {
    return Vt(e), '' !== t && Vt(t), { type: Et, breakContents: e, flatContents: t, groupId: r.groupId };
   }
   function sr(e, t) {
    return Vt(e), { type: bt, contents: e, groupId: t.groupId, negate: t.negate };
   }
   function nr(e) {
    return Vt(e), { type: Tt, contents: e };
   }
   var ir = { type: At },
    ar = { type: Ft },
    or = { type: Ct, hard: !0 },
    ur = { type: Ct },
    lr = { type: Ct, soft: !0 },
    pr = [or, ar],
    cr = [{ type: Ct, hard: !0, literal: !0 }, ar],
    hr = { type: ft };
   function dr(e, t) {
    Vt(e), Ht(t);
    let r = [];
    for (let s = 0; s < t.length; s++) 0 !== s && r.push(e), r.push(t[s]);
    return r;
   }
   function fr(e, t) {
    return Vt(t), e ? { type: vt, label: e, contents: t } : t;
   }
   var mr = function (e) {
    let t = `*${e.value}*`.split('\n');
    return t.length > 1 && t.every((e) => '*' === e.trimStart()[0]);
   };
   function yr(e, t) {
    let r = e.node;
    if (Y(r)) return t.originalText.slice(O(r), L(r)).trimEnd();
    if (J(r))
     return mr(r)
      ? (function (e) {
         let t = e.value.split('\n');
         return [
          '/*',
          dr(
           pr,
           t.map((e, r) => (0 === r ? e.trimEnd() : ' ' + (r < t.length - 1 ? e.trim() : e.trimStart()))),
          ),
          '*/',
         ];
        })(r)
      : ['/*', $t(r.value), '*/'];
    throw new Error('Not a comment: ' + JSON.stringify(r));
   }
   var Dr = {};
   function gr(e, t) {
    (e.comments ?? (e.comments = [])).push(t),
     (t.printed = !1),
     (t.nodeDescription = (function (e) {
      let t = e.type || e.kind || '(unknown type)',
       r = String(e.name || (e.id && ('object' == typeof e.id ? e.id.name : e.id)) || (e.key && ('object' == typeof e.key ? e.key.name : e.key)) || (e.value && ('object' == typeof e.value ? '' : String(e.value))) || e.operator || '');
      return r.length > 20 && (r = r.slice(0, 19) + '\u2026'), t + (r ? ' ' + r : '');
     })(e));
   }
   function xr(e, t) {
    (t.leading = !0), (t.trailing = !1), gr(e, t);
   }
   function Er(e, t, r) {
    (t.leading = !1), (t.trailing = !1), r && (t.marker = r), gr(e, t);
   }
   function br(e, t) {
    (t.leading = !1), (t.trailing = !0), gr(e, t);
   }
   i(Dr, { endOfLine: () => wr, ownLine: () => Fr, remaining: () => Sr });
   var Tr = function (e, t) {
    let r = null,
     s = t;
    for (; s !== r; ) (r = s), (s = x(e, s)), (s = C(e, s)), (s = v(e, s)), (s = T(e, s));
    return s;
   };
   var Ar = function (e, t) {
    let r = Tr(e, t);
    return !1 === r ? '' : e.charAt(r);
   };
   var Cr = function (e, t, r) {
    for (let s = t; s < r; ++s) if ('\n' === e.charAt(s)) return !0;
    return !1;
   };
   var vr = function (e) {
    return J(e) && '*' === e.value[0] && /@(?:type|satisfies)\b/u.test(e.value);
   };
   function Fr(e) {
    return [us, jr, Kr, Hr, Lr, Nr, Br, Or, Ur, ts, Qr, es, rs, ss, qr, Xr, Gr, Mr, hs].some((t) => t(e));
   }
   function wr(e) {
    return [Ir, Kr, jr, rs, Nr, Br, Or, Ur, Xr, Yr, Zr, es, as, Gr, ps, cs, ds].some((t) => t(e));
   }
   function Sr(e) {
    return [us, Nr, Br, _r, Vr, qr, es, zr, Wr, ls, Gr, os].some((t) => t(e));
   }
   function Pr(e, t) {
    let r = (e.body || e.properties).find(({ type: e }) => 'EmptyStatement' !== e);
    r ? xr(r, t) : Er(e, t);
   }
   function kr(e, t) {
    'BlockStatement' === e.type ? Pr(e, t) : xr(e, t);
   }
   function Ir({ comment: e, followingNode: t }) {
    return !(!t || !vr(e)) && (xr(t, e), !0);
   }
   function Nr({ comment: e, precedingNode: t, enclosingNode: r, followingNode: s, text: n }) {
    if ('IfStatement' !== (null == r ? void 0 : r.type) || !s) return !1;
    if (')' === Ar(n, L(e))) return br(t, e), !0;
    if (t === r.consequent && s === r.alternate) {
     let s = Tr(n, L(r.consequent));
     if (O(e) < s || 'BlockStatement' === r.alternate.type) {
      if ('BlockStatement' === t.type) br(t, e);
      else {
       let s = Y(e) || e.loc.start.line === e.loc.end.line,
        n = e.loc.start.line === t.loc.start.line;
       s && n ? br(t, e) : Er(r, e);
      }
      return !0;
     }
    }
    return 'BlockStatement' === s.type ? (Pr(s, e), !0) : 'IfStatement' === s.type ? (kr(s.consequent, e), !0) : r.consequent === s && (xr(s, e), !0);
   }
   function Br({ comment: e, precedingNode: t, enclosingNode: r, followingNode: s, text: n }) {
    return !('WhileStatement' !== (null == r ? void 0 : r.type) || !s) && (')' === Ar(n, L(e)) ? (br(t, e), !0) : 'BlockStatement' === s.type ? (Pr(s, e), !0) : r.body === s && (xr(s, e), !0));
   }
   function Or({ comment: e, precedingNode: t, enclosingNode: r, followingNode: s }) {
    return !(('TryStatement' !== (null == r ? void 0 : r.type) && 'CatchClause' !== (null == r ? void 0 : r.type)) || !s) && ('CatchClause' === r.type && t ? (br(t, e), !0) : 'BlockStatement' === s.type ? (Pr(s, e), !0) : 'TryStatement' === s.type ? (kr(s.finalizer, e), !0) : 'CatchClause' === s.type && (kr(s.body, e), !0));
   }
   function Lr({ comment: e, enclosingNode: t, followingNode: r }) {
    return !(!be(t) || 'Identifier' !== (null == r ? void 0 : r.type)) && (xr(t, e), !0);
   }
   function Mr({ comment: e, enclosingNode: t, followingNode: r, options: s }) {
    return !(!s.experimentalTernaries || ('ConditionalExpression' !== (null == t ? void 0 : t.type) && 'ConditionalTypeAnnotation' !== (null == t ? void 0 : t.type) && 'TSConditionalType' !== (null == t ? void 0 : t.type))) && ('ConditionalExpression' === (null == r ? void 0 : r.type) || 'ConditionalTypeAnnotation' === (null == r ? void 0 : r.type) || 'TSConditionalType' === (null == r ? void 0 : r.type)) && (Er(t, e), !0);
   }
   function jr({ comment: e, precedingNode: t, enclosingNode: r, followingNode: s, text: n, options: i }) {
    let a = t && !Cr(n, L(t), O(e));
    return !((t && a) || ('ConditionalExpression' !== (null == r ? void 0 : r.type) && 'ConditionalTypeAnnotation' !== (null == r ? void 0 : r.type) && 'TSConditionalType' !== (null == r ? void 0 : r.type)) || !s) && (!i.experimentalTernaries || r.alternate !== s || (J(e) && !Cr(i.originalText, O(e), L(e))) ? (xr(s, e), !0) : (Er(r, e), !0));
   }
   function _r({ comment: e, precedingNode: t, enclosingNode: r }) {
    return !(!nt(r) || !r.shorthand || r.key !== t || 'AssignmentPattern' !== r.value.type) && (br(r.value.left, e), !0);
   }
   var Rr = new Set(['ClassDeclaration', 'ClassExpression', 'DeclareClass', 'DeclareInterface', 'InterfaceDeclaration', 'TSInterfaceDeclaration']);
   function Ur({ comment: e, precedingNode: t, enclosingNode: r, followingNode: s }) {
    if (Rr.has(null == r ? void 0 : r.type)) {
     if (w(r.decorators) && 'Decorator' !== (null == s ? void 0 : s.type)) return br(c(!1, r.decorators, -1), e), !0;
     if (r.body && s === r.body) return Pr(r.body, e), !0;
     if (s) {
      if (r.superClass && s === r.superClass && t && (t === r.id || t === r.typeParameters)) return br(t, e), !0;
      for (let n of ['implements', 'extends', 'mixins']) if (r[n] && s === r[n][0]) return !t || (t !== r.id && t !== r.typeParameters && t !== r.superClass) ? Er(r, e, n) : br(t, e), !0;
     }
    }
    return !1;
   }
   var $r = new Set(['ClassMethod', 'ClassProperty', 'PropertyDefinition', 'TSAbstractPropertyDefinition', 'TSAbstractMethodDefinition', 'TSDeclareMethod', 'MethodDefinition', 'ClassAccessorProperty', 'AccessorProperty', 'TSAbstractAccessorProperty', 'TSParameterProperty']);
   function qr({ comment: e, precedingNode: t, enclosingNode: r, text: s }) {
    return ((r && t && '(' === Ar(s, L(e)) && ('Property' === r.type || 'TSDeclareMethod' === r.type || 'TSAbstractMethodDefinition' === r.type) && 'Identifier' === t.type && r.key === t && ':' !== Ar(s, L(t))) || !('Decorator' !== (null == t ? void 0 : t.type) || !$r.has(null == r ? void 0 : r.type) || (!Y(e) && 'ownLine' !== e.placement))) && (br(t, e), !0);
   }
   var Jr = new Set(['FunctionDeclaration', 'FunctionExpression', 'ClassMethod', 'MethodDefinition', 'ObjectMethod']);
   function Wr({ comment: e, precedingNode: t, enclosingNode: r, text: s }) {
    return '(' === Ar(s, L(e)) && !(!t || !Jr.has(null == r ? void 0 : r.type)) && (br(t, e), !0);
   }
   function zr({ comment: e, enclosingNode: t, text: r }) {
    if ('ArrowFunctionExpression' !== (null == t ? void 0 : t.type)) return !1;
    let s = Tr(r, L(e));
    return !1 !== s && '=>' === r.slice(s, s + 2) && (Er(t, e), !0);
   }
   function Vr({ comment: e, enclosingNode: t, text: r }) {
    return ')' === Ar(r, L(e)) && (t && ((fs(t) && 0 === ze(t).length) || (st(t) && 0 === He(t).length)) ? (Er(t, e), !0) : ('MethodDefinition' === (null == t ? void 0 : t.type) || 'TSAbstractMethodDefinition' === (null == t ? void 0 : t.type)) && 0 === ze(t.value).length && (Er(t.value, e), !0));
   }
   function Hr({ comment: e, precedingNode: t, enclosingNode: r, followingNode: s, text: n }) {
    return 'ComponentTypeParameter' !== (null == t ? void 0 : t.type) || ('DeclareComponent' !== (null == r ? void 0 : r.type) && 'ComponentTypeAnnotation' !== (null == r ? void 0 : r.type)) || 'ComponentTypeParameter' === (null == s ? void 0 : s.type) ? ('ComponentParameter' === (null == t ? void 0 : t.type) || 'RestElement' === (null == t ? void 0 : t.type)) && 'ComponentDeclaration' === (null == r ? void 0 : r.type) && ')' === Ar(n, L(e)) && (br(t, e), !0) : (br(t, e), !0);
   }
   function Kr({ comment: e, precedingNode: t, enclosingNode: r, followingNode: s, text: n }) {
    return 'FunctionTypeParam' === (null == t ? void 0 : t.type) && 'FunctionTypeAnnotation' === (null == r ? void 0 : r.type) && 'FunctionTypeParam' !== (null == s ? void 0 : s.type) ? (br(t, e), !0) : ('Identifier' !== (null == t ? void 0 : t.type) && 'AssignmentPattern' !== (null == t ? void 0 : t.type) && 'ObjectPattern' !== (null == t ? void 0 : t.type) && 'ArrayPattern' !== (null == t ? void 0 : t.type) && 'RestElement' !== (null == t ? void 0 : t.type) && 'TSParameterProperty' !== (null == t ? void 0 : t.type)) || !fs(r) || ')' !== Ar(n, L(e)) ? !(J(e) || ('FunctionDeclaration' !== (null == r ? void 0 : r.type) && 'FunctionExpression' !== (null == r ? void 0 : r.type) && 'ObjectMethod' !== (null == r ? void 0 : r.type)) || 'BlockStatement' !== (null == s ? void 0 : s.type) || r.body !== s || Tr(n, L(e)) !== O(s)) && (Pr(s, e), !0) : (br(t, e), !0);
   }
   function Xr({ comment: e, enclosingNode: t }) {
    return 'LabeledStatement' === (null == t ? void 0 : t.type) && (xr(t, e), !0);
   }
   function Gr({ comment: e, enclosingNode: t }) {
    return !(('ContinueStatement' !== (null == t ? void 0 : t.type) && 'BreakStatement' !== (null == t ? void 0 : t.type)) || t.label) && (br(t, e), !0);
   }
   function Yr({ comment: e, precedingNode: t, enclosingNode: r }) {
    return !!(Ee(r) && t && r.callee === t && r.arguments.length > 0) && (xr(r.arguments[0], e), !0);
   }
   function Qr({ comment: e, precedingNode: t, enclosingNode: r, followingNode: s }) {
    return at(r) ? (Ge(e) && ((s.prettierIgnore = !0), (e.unignore = !0)), !!t && (br(t, e), !0)) : (at(s) && Ge(e) && ((s.types[0].prettierIgnore = !0), (e.unignore = !0)), !1);
   }
   function Zr({ comment: e, enclosingNode: t }) {
    return !!nt(t) && (xr(t, e), !0);
   }
   function es({ comment: e, enclosingNode: t, ast: r, isLastComment: s }) {
    var n;
    return 0 === (null == (n = null == r ? void 0 : r.body) ? void 0 : n.length) ? (s ? Er(r, e) : xr(r, e), !0) : 'Program' === (null == t ? void 0 : t.type) && 0 === t.body.length && !w(t.directives) && (s ? Er(t, e) : xr(t, e), !0);
   }
   function ts({ comment: e, enclosingNode: t }) {
    return ('ForInStatement' === (null == t ? void 0 : t.type) || 'ForOfStatement' === (null == t ? void 0 : t.type)) && (xr(t, e), !0);
   }
   function rs({ comment: e, precedingNode: t, enclosingNode: r, text: s }) {
    if ('ImportSpecifier' === (null == r ? void 0 : r.type) || 'ExportSpecifier' === (null == r ? void 0 : r.type)) return xr(r, e), !0;
    let n = 'ImportSpecifier' === (null == t ? void 0 : t.type) && 'ImportDeclaration' === (null == r ? void 0 : r.type),
     i = 'ExportSpecifier' === (null == t ? void 0 : t.type) && 'ExportNamedDeclaration' === (null == r ? void 0 : r.type);
    return !((!n && !i) || !A(s, L(e))) && (br(t, e), !0);
   }
   function ss({ comment: e, enclosingNode: t }) {
    return 'AssignmentPattern' === (null == t ? void 0 : t.type) && (xr(t, e), !0);
   }
   var ns = new Set(['VariableDeclarator', 'AssignmentExpression', 'TypeAlias', 'TSTypeAliasDeclaration']),
    is = new Set(['ObjectExpression', 'RecordExpression', 'ArrayExpression', 'TupleExpression', 'TemplateLiteral', 'TaggedTemplateExpression', 'ObjectTypeAnnotation', 'TSTypeLiteral']);
   function as({ comment: e, enclosingNode: t, followingNode: r }) {
    return !(!ns.has(null == t ? void 0 : t.type) || !r || (!is.has(r.type) && !J(e))) && (xr(r, e), !0);
   }
   function os({ comment: e, enclosingNode: t, followingNode: r, text: s }) {
    return !(r || ('TSMethodSignature' !== (null == t ? void 0 : t.type) && 'TSDeclareFunction' !== (null == t ? void 0 : t.type) && 'TSAbstractMethodDefinition' !== (null == t ? void 0 : t.type)) || ';' !== Ar(s, L(e))) && (br(t, e), !0);
   }
   function us({ comment: e, enclosingNode: t, followingNode: r }) {
    if (Ge(e) && 'TSMappedType' === (null == t ? void 0 : t.type) && 'TSTypeParameter' === (null == r ? void 0 : r.type) && r.constraint) return (t.prettierIgnore = !0), (e.unignore = !0), !0;
   }
   function ls({ comment: e, precedingNode: t, enclosingNode: r, followingNode: s }) {
    return 'TSMappedType' === (null == r ? void 0 : r.type) && ('TSTypeParameter' === (null == s ? void 0 : s.type) && s.name ? (xr(s.name, e), !0) : !('TSTypeParameter' !== (null == t ? void 0 : t.type) || !t.constraint) && (br(t.constraint, e), !0));
   }
   function ps({ comment: e, enclosingNode: t, followingNode: r }) {
    return !(!t || 'SwitchCase' !== t.type || t.test || !r || r !== t.consequent[0]) && ('BlockStatement' === r.type && Y(e) ? Pr(r, e) : Er(t, e), !0);
   }
   function cs({ comment: e, precedingNode: t, enclosingNode: r, followingNode: s }) {
    return !(!at(t) || ((('TSArrayType' !== r.type && 'ArrayTypeAnnotation' !== r.type) || s) && !ot(r))) && (br(c(!1, t.types, -1), e), !0);
   }
   function hs({ comment: e, enclosingNode: t, precedingNode: r, followingNode: s }) {
    if (('ObjectPattern' === (null == t ? void 0 : t.type) || 'ArrayPattern' === (null == t ? void 0 : t.type)) && 'TSTypeAnnotation' === (null == s ? void 0 : s.type)) return r ? br(r, e) : Er(t, e), !0;
   }
   function ds({ comment: e, precedingNode: t, enclosingNode: r, followingNode: s }) {
    var n;
    if (!s && 'UnaryExpression' === (null == r ? void 0 : r.type) && ('LogicalExpression' === (null == t ? void 0 : t.type) || 'BinaryExpression' === (null == t ? void 0 : t.type))) {
     let s = (null == (n = r.argument.loc) ? void 0 : n.start.line) !== t.right.loc.start.line,
      i = Y(e) || e.loc.start.line === e.loc.end.line,
      a = e.loc.start.line === t.right.loc.start.line;
     if (s && i && a) return br(t.right, e), !0;
    }
    return !1;
   }
   var fs = q(['ArrowFunctionExpression', 'FunctionExpression', 'FunctionDeclaration', 'ObjectMethod', 'ClassMethod', 'TSDeclareFunction', 'TSCallSignatureDeclaration', 'TSConstructSignatureDeclaration', 'TSMethodSignature', 'TSConstructorType', 'TSFunctionType', 'TSDeclareMethod']),
    ms = new Set(['EmptyStatement', 'TemplateElement', 'TSEmptyBodyFunctionExpression', 'ChainExpression']);
   function ys(e) {
    return !ms.has(e.type);
   }
   function Ds(e, t) {
    var r;
    if (('typescript' === t.parser || 'flow' === t.parser || 'acorn' === t.parser || 'espree' === t.parser || 'meriyah' === t.parser || '__babel_estree' === t.parser) && 'MethodDefinition' === e.type && 'FunctionExpression' === (null == (r = e.value) ? void 0 : r.type) && 0 === ze(e.value).length && !e.value.returnType && !w(e.value.typeParameters) && e.value.body) return [...(e.decorators || []), e.key, e.value.body];
   }
   function gs(e) {
    let { node: t, parent: r } = e;
    return (pe(t) || (r && ('JSXSpreadAttribute' === r.type || 'JSXSpreadChild' === r.type || at(r) || (('ClassDeclaration' === r.type || 'ClassExpression' === r.type) && r.superClass === t)))) && (!Ye(t) || at(r));
   }
   function xs(e, { parser: t }) {
    if ('flow' === t || 'babel-flow' === t) return '' === (e = p(!1, e, /[\s(]/gu, '')) || '/*' === e || '/*::' === e;
   }
   var Es = Symbol('MODE_BREAK'),
    bs = Symbol('MODE_FLAT'),
    Ts = Symbol('cursor'),
    As = Symbol('DOC_FILL_PRINTED_LENGTH');
   function Cs(e, t) {
    return Fs(e, { type: 'indent' }, t);
   }
   function vs(e, t, r) {
    return t === Number.NEGATIVE_INFINITY ? e.root || { value: '', length: 0, queue: [] } : t < 0 ? Fs(e, { type: 'dedent' }, r) : t ? ('root' === t.type ? { ...e, root: e } : Fs(e, { type: 'string' == typeof t ? 'stringAlign' : 'numberAlign', n: t }, r)) : e;
   }
   function Fs(e, t, r) {
    let s = 'dedent' === t.type ? e.queue.slice(0, -1) : [...e.queue, t],
     n = '',
     i = 0,
     a = 0,
     o = 0;
    for (let d of s)
     switch (d.type) {
      case 'indent':
       p(), r.useTabs ? u(1) : l(r.tabWidth);
       break;
      case 'stringAlign':
       p(), (n += d.n), (i += d.n.length);
       break;
      case 'numberAlign':
       (a += 1), (o += d.n);
       break;
      default:
       throw new Error(`Unexpected type '${d.type}'`);
     }
    return c(), { ...e, value: n, length: i, queue: s };
    function u(e) {
     (n += '\t'.repeat(e)), (i += r.tabWidth * e);
    }
    function l(e) {
     (n += ' '.repeat(e)), (i += e);
    }
    function p() {
     r.useTabs ? (a > 0 && u(a), h()) : c();
    }
    function c() {
     o > 0 && l(o), h();
    }
    function h() {
     (a = 0), (o = 0);
    }
   }
   function ws(e) {
    let t = 0,
     r = 0,
     s = e.length;
    e: for (; s--; ) {
     let n = e[s];
     if (n !== Ts)
      for (let r = n.length - 1; r >= 0; r--) {
       let i = n[r];
       if (' ' !== i && '\t' !== i) {
        e[s] = n.slice(0, r + 1);
        break e;
       }
       t++;
      }
     else r++;
    }
    if (t > 0 || r > 0) for (e.length = s + 1; r-- > 0; ) e.push(Ts);
    return t;
   }
   function Ss(e, t, r, s, n, i) {
    if (r === Number.POSITIVE_INFINITY) return !0;
    let a = t.length,
     o = [e],
     u = [];
    for (; r >= 0; ) {
     if (0 === o.length) {
      if (0 === a) return !0;
      o.push(t[--a]);
      continue;
     }
     let { mode: e, doc: l } = o.pop(),
      p = St(l);
     switch (p) {
      case ht:
       u.push(l), (r -= D(l));
       break;
      case dt:
      case xt: {
       let t = p === dt ? l : l.parts,
        r = l[As] ?? 0;
       for (let s = t.length - 1; s >= r; s--) o.push({ mode: e, doc: t[s] });
       break;
      }
      case mt:
      case yt:
      case bt:
      case vt:
       o.push({ mode: e, doc: l.contents });
       break;
      case Dt:
       r += ws(u);
       break;
      case gt: {
       if (i && l.break) return !1;
       let t = l.break ? Es : e,
        r = l.expandedStates && t === Es ? c(!1, l.expandedStates, -1) : l.contents;
       o.push({ mode: t, doc: r });
       break;
      }
      case Et: {
       let t = (l.groupId ? n[l.groupId] || bs : e) === Es ? l.breakContents : l.flatContents;
       t && o.push({ mode: e, doc: t });
       break;
      }
      case Ct:
       if (e === Es || l.hard) return !0;
       l.soft || (u.push(' '), r--);
       break;
      case Tt:
       s = !0;
       break;
      case At:
       if (s) return !1;
     }
    }
    return !1;
   }
   function Ps(e, t) {
    let r = {},
     s = t.printWidth,
     n = (function (e) {
      switch (e) {
       case 'cr':
        return '\r';
       case 'crlf':
        return '\r\n';
       default:
        return '\n';
      }
     })(t.endOfLine),
     i = 0,
     a = [{ ind: { value: '', length: 0, queue: [] }, mode: Es, doc: e }],
     o = [],
     u = !1,
     l = [],
     h = 0;
    for (
     (function (e) {
      let t = new Set(),
       r = [];
      Nt(
       e,
       function (e) {
        if ((e.type === Ft && jt(r), e.type === gt)) {
         if ((r.push(e), t.has(e))) return !1;
         t.add(e);
        }
       },
       function (e) {
        e.type === gt && r.pop().break && jt(r);
       },
       !0,
      );
     })(e);
     a.length > 0;

    ) {
     let { ind: e, mode: d, doc: f } = a.pop();
     switch (St(f)) {
      case ht: {
       let e = '\n' !== n ? p(!1, f, '\n', n) : f;
       o.push(e), a.length > 0 && (i += D(e));
       break;
      }
      case dt:
       for (let t = f.length - 1; t >= 0; t--) a.push({ ind: e, mode: d, doc: f[t] });
       break;
      case ft:
       if (h >= 2) throw new Error("There are too many 'cursor' in doc.");
       o.push(Ts), h++;
       break;
      case mt:
       a.push({ ind: Cs(e, t), mode: d, doc: f.contents });
       break;
      case yt:
       a.push({ ind: vs(e, f.n, t), mode: d, doc: f.contents });
       break;
      case Dt:
       i -= ws(o);
       break;
      case gt:
       switch (d) {
        case bs:
         if (!u) {
          a.push({ ind: e, mode: f.break ? Es : bs, doc: f.contents });
          break;
         }
        case Es: {
         u = !1;
         let t = { ind: e, mode: bs, doc: f.contents },
          n = s - i,
          o = l.length > 0;
         if (!f.break && Ss(t, a, n, o, r)) a.push(t);
         else if (f.expandedStates) {
          let t = c(!1, f.expandedStates, -1);
          if (f.break) {
           a.push({ ind: e, mode: Es, doc: t });
           break;
          }
          for (let s = 1; s < f.expandedStates.length + 1; s++) {
           if (s >= f.expandedStates.length) {
            a.push({ ind: e, mode: Es, doc: t });
            break;
           }
           {
            let t = f.expandedStates[s],
             i = { ind: e, mode: bs, doc: t };
            if (Ss(i, a, n, o, r)) {
             a.push(i);
             break;
            }
           }
          }
         } else a.push({ ind: e, mode: Es, doc: f.contents });
         break;
        }
       }
       f.id && (r[f.id] = c(!1, a, -1).mode);
       break;
      case xt: {
       let t = s - i,
        n = f[As] ?? 0,
        { parts: o } = f,
        u = o.length - n;
       if (0 === u) break;
       let p = o[n + 0],
        c = o[n + 1],
        h = { ind: e, mode: bs, doc: p },
        m = { ind: e, mode: Es, doc: p },
        y = Ss(h, [], t, l.length > 0, r, !0);
       if (1 === u) {
        y ? a.push(h) : a.push(m);
        break;
       }
       let D = { ind: e, mode: bs, doc: c },
        g = { ind: e, mode: Es, doc: c };
       if (2 === u) {
        y ? a.push(D, h) : a.push(g, m);
        break;
       }
       let x = o[n + 2],
        E = { ind: e, mode: d, doc: { ...f, [As]: n + 2 } };
       Ss({ ind: e, mode: bs, doc: [p, c, x] }, [], t, l.length > 0, r, !0) ? a.push(E, D, h) : y ? a.push(E, g, h) : a.push(E, g, m);
       break;
      }
      case Et:
      case bt: {
       let t = f.groupId ? r[f.groupId] : d;
       if (t === Es) {
        let t = f.type === Et ? f.breakContents : f.negate ? f.contents : Xt(f.contents);
        t && a.push({ ind: e, mode: d, doc: t });
       }
       if (t === bs) {
        let t = f.type === Et ? f.flatContents : f.negate ? Xt(f.contents) : f.contents;
        t && a.push({ ind: e, mode: d, doc: t });
       }
       break;
      }
      case Tt:
       l.push({ ind: e, mode: d, doc: f.contents });
       break;
      case At:
       l.length > 0 && a.push({ ind: e, mode: d, doc: or });
       break;
      case Ct:
       switch (d) {
        case bs:
         if (!f.hard) {
          f.soft || (o.push(' '), (i += 1));
          break;
         }
         u = !0;
        case Es:
         if (l.length > 0) {
          a.push({ ind: e, mode: d, doc: f }, ...l.reverse()), (l.length = 0);
          break;
         }
         f.literal ? (e.root ? (o.push(n, e.root.value), (i = e.root.length)) : (o.push(n), (i = 0))) : ((i -= ws(o)), o.push(n + e.value), (i = e.length));
       }
       break;
      case vt:
       a.push({ ind: e, mode: d, doc: f.contents });
       break;
      case Ft:
       break;
      default:
       throw new kt(f);
     }
     0 === a.length && l.length > 0 && (a.push(...l.reverse()), (l.length = 0));
    }
    let d = o.indexOf(Ts);
    if (-1 !== d) {
     let e = o.indexOf(Ts, d + 1);
     if (-1 === e) return { formatted: o.filter((e) => e !== Ts).join('') };
     let t = o.slice(0, d).join(''),
      r = o.slice(d + 1, e).join('');
     return { formatted: t + r + o.slice(e + 1).join(''), cursorNodeStart: t.length, cursorNodeText: r };
    }
    return { formatted: o.join('') };
   }
   var ks = function (e, t, r = 0) {
    let s = 0;
    for (let n = r; n < e.length; ++n) '\t' === e[n] ? (s = s + t - (s % t)) : s++;
    return s;
   };
   var Is = function (e, t) {
    let r = e.lastIndexOf('\n');
    return -1 === r ? 0 : ks(e.slice(r + 1).match(/^[\t ]*/u)[0], t);
   };
   function Ns(e, t, r) {
    let { node: s } = e;
    if (
     'TemplateLiteral' === s.type &&
     (function ({ node: e, parent: t }) {
      let r = /^[fx]?(?:describe|it|test)$/u;
      return 'TaggedTemplateExpression' === t.type && t.quasi === e && 'MemberExpression' === t.tag.type && 'Identifier' === t.tag.property.type && 'each' === t.tag.property.name && (('Identifier' === t.tag.object.type && r.test(t.tag.object.name)) || ('MemberExpression' === t.tag.object.type && 'Identifier' === t.tag.object.property.type && ('only' === t.tag.object.property.name || 'skip' === t.tag.object.property.name) && 'Identifier' === t.tag.object.object.type && r.test(t.tag.object.object.name)));
     })(e)
    ) {
     let s = (function (e, t, r) {
      let { node: s } = e,
       n = s.quasis[0].value.raw.trim().split(/\s*\|\s*/u);
      if (n.length > 1 || n.some((e) => e.length > 0)) {
       t.__inJestEach = !0;
       let i = e.map(r, 'expressions');
       t.__inJestEach = !1;
       let a = [],
        o = i.map((e) => '${' + Ps(e, { ...t, printWidth: Number.POSITIVE_INFINITY, endOfLine: 'lf' }).formatted + '}'),
        u = [{ hasLineBreak: !1, cells: [] }];
       for (let e = 1; e < s.quasis.length; e++) {
        let t = c(!1, u, -1),
         r = o[e - 1];
        t.cells.push(r), r.includes('\n') && (t.hasLineBreak = !0), s.quasis[e].value.raw.includes('\n') && u.push({ hasLineBreak: !1, cells: [] });
       }
       let l = Math.max(n.length, ...u.map((e) => e.cells.length)),
        p = Array.from({ length: l }).fill(0),
        h = [{ cells: n }, ...u.filter((e) => e.cells.length > 0)];
       for (let { cells: e } of h.filter((e) => !e.hasLineBreak)) for (let [t, r] of e.entries()) p[t] = Math.max(p[t], D(r));
       return (
        a.push(
         ir,
         '`',
         Xt([
          pr,
          dr(
           pr,
           h.map((e) =>
            dr(
             ' | ',
             e.cells.map((t, r) => (e.hasLineBreak ? t : t + ' '.repeat(p[r] - D(t)))),
            ),
           ),
          ),
         ]),
         pr,
         '`',
        ),
        a
       );
      }
     })(e, r, t);
     if (s) return s;
    }
    let n = 'expressions';
    'TSTemplateLiteralType' === s.type && (n = 'types');
    let i = [],
     a = e.map(t, n);
    i.push(ir, '`');
    let o = 0;
    return (
     e.each(({ index: e, node: u }) => {
      if ((i.push(t()), u.tail)) return;
      let { tabWidth: l } = r,
       p = u.value.raw,
       c = p.includes('\n') ? Is(p, l) : o;
      o = c;
      let h = a[e],
       d = s[n][e],
       f = Cr(r.originalText, L(u), O(s.quasis[e + 1]));
      if (!f) {
       let e = Ps(h, { ...r, printWidth: Number.POSITIVE_INFINITY }).formatted;
       e.includes('\n') ? (f = !0) : (h = e);
      }
      f && (et(d) || 'Identifier' === d.type || be(d) || 'ConditionalExpression' === d.type || 'SequenceExpression' === d.type || it(d) || de(d)) && (h = [Xt([lr, h]), lr]);
      let m =
       0 === c && p.endsWith('\n')
        ? Gt(Number.NEGATIVE_INFINITY, h)
        : (function (e, t, r) {
           Vt(e);
           let s = e;
           if (t > 0) {
            for (let e = 0; e < Math.floor(t / r); ++e) s = Xt(s);
            (s = Gt(t % r, s)), (s = Gt(Number.NEGATIVE_INFINITY, s));
           }
           return s;
          })(h, c, l);
      i.push(Yt(['${', m, ir, '}']));
     }, 'quasis'),
     i.push('`'),
     i
    );
   }
   function Bs(e, t) {
    return e.map(
     (e) =>
      (function (e, t) {
       let { node: r } = e,
        s = t();
       return et(r) && (s = Yt([Xt([lr, s]), lr])), ['${', s, ir, '}'];
      })(e, t),
     'expressions',
    );
   }
   function Os(e, t) {
    return Bt(e, (e) => ('string' == typeof e ? (t ? p(!1, e, /(\\*)`/gu, '$1$1\\`') : Ls(e)) : e));
   }
   function Ls(e) {
    return p(!1, e, /([\\`]|\$\{)/gu, String.raw`\$1`);
   }
   var Ms = [(e, t) => 'ObjectExpression' === e.type && 'properties' === t, (e, t) => 'CallExpression' === e.type && 'Identifier' === e.callee.type && 'Component' === e.callee.name && 'arguments' === t, (e, t) => 'Decorator' === e.type && 'expression' === t];
   function js(e, t) {
    return et(e, Qe.Block | Qe.Leading, ({ value: e }) => e === ` ${t} `);
   }
   function _s({ node: e, parent: t }, r) {
    return (
     js(e, r) ||
     ((function (e) {
      return 'AsConstExpression' === e.type || ('TSAsExpression' === e.type && 'TSTypeReference' === e.typeAnnotation.type && 'Identifier' === e.typeAnnotation.typeName.type && 'const' === e.typeAnnotation.typeName.name);
     })(t) &&
      js(t, r)) ||
     ('ExpressionStatement' === t.type && js(t, r))
    );
   }
   async function Rs(e, t, r) {
    let { node: s } = r,
     n = s.quasis.map((e) => e.value.raw),
     i = 0,
     a = n.reduce((e, t, r) => (0 === r ? t : e + '@prettier-placeholder-' + i++ + '-id' + t), ''),
     o = (function (e, t) {
      if (!w(t)) return e;
      let r = 0,
       s = Bt(Ut(e), (e) => ('string' == typeof e && e.includes('@prettier-placeholder') ? e.split(/@prettier-placeholder-(\d+)-id/u).map((e, s) => (s % 2 == 0 ? $t(e) : (r++, t[e]))) : e));
      return t.length === r ? s : null;
     })(await e(a, { parser: 'scss' }), Bs(r, t));
    if (!o) throw new Error("Couldn't insert all the expressions");
    return ['`', Xt([pr, o]), lr, '`'];
   }
   function Us(e) {
    return 'Identifier' === e.type && 'styled' === e.name;
   }
   function $s(e) {
    return /^[A-Z]/u.test(e.object.name) && 'extend' === e.property.name;
   }
   var qs = function (e) {
    if (
     (function ({ node: e, parent: t, grandparent: r }) {
      return (r && e.quasis && 'JSXExpressionContainer' === t.type && 'JSXElement' === r.type && 'style' === r.openingElement.name.name && r.openingElement.attributes.some((e) => 'JSXAttribute' === e.type && 'jsx' === e.name.name)) || ('TaggedTemplateExpression' === (null == t ? void 0 : t.type) && 'Identifier' === t.tag.type && 'css' === t.tag.name) || ('TaggedTemplateExpression' === (null == t ? void 0 : t.type) && 'MemberExpression' === t.tag.type && 'css' === t.tag.object.name && ('global' === t.tag.property.name || 'resolve' === t.tag.property.name));
     })(e) ||
     (function ({ parent: e }) {
      if (!e || 'TaggedTemplateExpression' !== e.type) return !1;
      let t = 'ParenthesizedExpression' === e.tag.type ? e.tag.expression : e.tag;
      switch (t.type) {
       case 'MemberExpression':
        return Us(t.object) || $s(t);
       case 'CallExpression':
        return Us(t.callee) || ('MemberExpression' === t.callee.type && (('MemberExpression' === t.callee.object.type && (Us(t.callee.object.object) || $s(t.callee.object))) || ('CallExpression' === t.callee.object.type && Us(t.callee.object.callee))));
       case 'Identifier':
        return 'css' === t.name;
       default:
        return !1;
      }
     })(e) ||
     (function ({ parent: e, grandparent: t }) {
      return 'JSXAttribute' === (null == t ? void 0 : t.type) && 'JSXExpressionContainer' === e.type && 'JSXIdentifier' === t.name.type && 'css' === t.name.name;
     })(e) ||
     (function (e) {
      let t = (e) => 'TemplateLiteral' === e.type,
       r = (e, t) => nt(e) && !e.computed && 'Identifier' === e.key.type && 'styles' === e.key.name && 'value' === t;
      return e.match(t, (e, t) => Z(e) && 'elements' === t, r, ...Ms) || e.match(t, r, ...Ms);
     })(e)
    )
     return Rs;
   };
   async function Js(e, t, r) {
    let { node: s } = r,
     n = s.quasis.length,
     i = Bs(r, t),
     a = [];
    for (let o = 0; o < n; o++) {
     let t = 0 === o,
      r = o === n - 1,
      u = s.quasis[o].value.cooked,
      l = u.split('\n'),
      p = l.length,
      c = i[o],
      h = p > 2 && '' === l[0].trim() && '' === l[1].trim(),
      d = p > 2 && '' === l[p - 1].trim() && '' === l[p - 2].trim(),
      f = l.every((e) => /^\s*(?:#[^\n\r]*)?$/u.test(e));
     if (!r && /#[^\n\r]*$/u.test(l[p - 1])) return null;
     let m = null;
     (m = f ? Ws(l) : await e(u, { parser: 'graphql' })), m ? ((m = Os(m, !1)), !t && h && a.push(''), a.push(m), !r && d && a.push('')) : !t && !r && h && a.push(''), c && a.push(c);
    }
    return ['`', Xt([pr, dr(pr, a)]), pr, '`'];
   }
   function Ws(e) {
    let t = [],
     r = !1,
     s = e.map((e) => e.trim());
    for (let [n, i] of s.entries()) '' !== i && ('' === s[n - 1] && r ? t.push([pr, i]) : t.push(i), (r = !0));
    return 0 === t.length ? null : dr(pr, t);
   }
   var zs = function (e) {
     if (
      (function ({ node: e, parent: t }) {
       return _s({ node: e, parent: t }, 'GraphQL') || (t && (('TaggedTemplateExpression' === t.type && (('MemberExpression' === t.tag.type && 'graphql' === t.tag.object.name && 'experimental' === t.tag.property.name) || ('Identifier' === t.tag.type && ('gql' === t.tag.name || 'graphql' === t.tag.name)))) || ('CallExpression' === t.type && 'Identifier' === t.callee.type && 'graphql' === t.callee.name)));
      })(e)
     )
      return Js;
    },
    Vs = 0;
   async function Hs(e, t, r, s, n) {
    let { node: i } = s,
     a = Vs;
    Vs = (Vs + 1) >>> 0;
    let o = (e) => `PRETTIER_HTML_PLACEHOLDER_${e}_${a}_IN_JS`,
     u = i.quasis.map((e, t, r) => (t === r.length - 1 ? e.value.cooked : e.value.cooked + o(t))).join(''),
     l = Bs(s, r),
     c = new RegExp(o(String.raw`(\d+)`), 'gu'),
     h = 0,
     d = Bt(
      await t(u, {
       parser: e,
       __onHtmlRoot(e) {
        h = e.children.length;
       },
      }),
      (e) => {
       if ('string' != typeof e) return e;
       let t = [],
        r = e.split(c);
       for (let s = 0; s < r.length; s++) {
        let e = r[s];
        if (s % 2 == 0) {
         e && ((e = Ls(e)), n.__embeddedInHtml && (e = p(!1, e, /<\/(?=script\b)/giu, String.raw`<\/`)), t.push(e));
         continue;
        }
        let i = Number(e);
        t.push(l[i]);
       }
       return t;
      },
     ),
     f = /^\s/u.test(u) ? ' ' : '',
     m = /\s$/u.test(u) ? ' ' : '',
     y = 'ignore' === n.htmlWhitespaceSensitivity ? pr : f && m ? ur : null;
    return y ? Yt(['`', Xt([y, Yt(d)]), y, '`']) : fr({ hug: !1 }, Yt(['`', f, h > 1 ? Xt(Yt(d)) : Yt(d), m, '`']));
   }
   var Ks = Hs.bind(void 0, 'html'),
    Xs = Hs.bind(void 0, 'angular');
   var Gs = function (e) {
    return (function (e) {
     return (
      _s(e, 'HTML') ||
      e.match(
       (e) => 'TemplateLiteral' === e.type,
       (e, t) => 'TaggedTemplateExpression' === e.type && 'Identifier' === e.tag.type && 'html' === e.tag.name && 'quasi' === t,
      )
     );
    })(e)
     ? Ks
     : (function (e) {
          return e.match(
           (e) => 'TemplateLiteral' === e.type,
           (e, t) => nt(e) && !e.computed && 'Identifier' === e.key.type && 'template' === e.key.name && 'value' === t,
           ...Ms,
          );
         })(e)
       ? Xs
       : void 0;
   };
   async function Ys(e, t, r) {
    let { node: s } = r,
     n = p(!1, s.quasis[0].value.raw, /((?:\\\\)*)\\`/gu, (e, t) => '\\'.repeat(t.length / 2) + '`'),
     i = (function (e) {
      let t = e.match(/^([^\S\n]*)\S/mu);
      return null === t ? '' : t[1];
     })(n),
     a = '' !== i;
    a && (n = p(!1, n, new RegExp(`^${i}`, 'gmu'), ''));
    let o = Os(await e(n, { parser: 'markdown', __inJsTemplate: !0 }), !0);
    return ['`', a ? Xt([lr, o]) : [cr, Qt(o)], lr, '`'];
   }
   var Qs = function (e) {
    if (
     (function ({ node: e, parent: t }) {
      return 'TaggedTemplateExpression' === (null == t ? void 0 : t.type) && 1 === e.quasis.length && 'Identifier' === t.tag.type && ('md' === t.tag.name || 'markdown' === t.tag.name);
     })(e)
    )
     return Ys;
   };
   var Zs = function (e) {
     let t,
      { node: r } = e;
     if (
      'TemplateLiteral' === r.type &&
      !(function ({ quasis: e }) {
       return e.some(({ value: { cooked: e } }) => null === e);
      })(r)
     )
      for (let s of [qs, zs, Gs, Qs])
       if (((t = s(e)), t))
        return 1 === r.quasis.length && '' === r.quasis[0].value.raw.trim()
         ? '``'
         : async (...e) => {
            let r = await t(...e);
            return r && fr({ embed: !0, ...r.label }, r);
           };
    },
    en = /\*\/$/,
    tn = /^\/\*\*?/,
    rn = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/,
    sn = /(^|\s+)\/\/([^\n\r]*)/g,
    nn = /^(\r?\n)+/,
    an = /(?:^|\r?\n) *(@[^\n\r]*?) *\r?\n *(?![^\n\r@]*\/\/[^]*)([^\s@][^\n\r@]+?) *\r?\n/g,
    on = /(?:^|\r?\n) *@(\S+) *([^\n\r]*)/g,
    un = /(\r?\n|^) *\* ?/g,
    ln = [];
   function pn(e, t) {
    return [...ln, ...(Array.isArray(t) ? t : [t])].map((t) => `@${e} ${t}`.trim());
   }
   var cn = function (e) {
    if (!e.startsWith('#!')) return '';
    let t = e.indexOf('\n');
    return -1 === t ? e : e.slice(0, t);
   };
   function hn(e) {
    let t = cn(e);
    t && (e = e.slice(t.length + 1));
    let r = (function (e) {
      let t = e.match(rn);
      return t ? t[0].trimStart() : '';
     })(e),
     { pragmas: s, comments: n } = (function (e) {
      e = p(!1, e.replace(tn, '').replace(en, ''), un, '$1');
      let t = '';
      for (; t !== e; ) (t = e), (e = p(!1, e, an, '\n$1 $2\n'));
      e = e.replace(nn, '').trimEnd();
      let r,
       s = Object.create(null),
       n = p(!1, e, on, '').replace(nn, '').trimEnd();
      for (; (r = on.exec(e)); ) {
       let e = p(!1, r[2], sn, '');
       if ('string' == typeof s[r[1]] || Array.isArray(s[r[1]])) {
        let t = s[r[1]];
        s[r[1]] = [...ln, ...(Array.isArray(t) ? t : [t]), e];
       } else s[r[1]] = e;
      }
      return { comments: n, pragmas: s };
     })(r);
    return { shebang: t, text: e, pragmas: s, comments: n };
   }
   function dn(e) {
    let { shebang: t, text: r, pragmas: s, comments: n } = hn(e),
     i = (function (e) {
      let t = e.match(rn),
       r = null == t ? void 0 : t[0];
      return null == r ? e : e.slice(r.length);
     })(r),
     a = (function ({ comments: e = '', pragmas: t = {} }) {
      let r = '\n',
       s = ' *',
       n = Object.keys(t),
       i = n
        .flatMap((e) => pn(e, t[e]))
        .map((e) => `${s} ${e}${r}`)
        .join('');
      if (!e) {
       if (0 === n.length) return '';
       if (1 === n.length && !Array.isArray(t[n[0]])) {
        let e = t[n[0]];
        return `/** ${pn(n[0], e)[0]} */`;
       }
      }
      let a =
       e
        .split(r)
        .map((e) => `${s} ${e}`)
        .join(r) + r;
      return '/**\n' + (e ? a : '') + (e && n.length > 0 ? s + r : '') + i + ' */';
     })({ pragmas: { format: '', ...s }, comments: n.trimStart() });
    return (t ? `${t}\n` : '') + a + (i.startsWith('\n') ? '\n' : '\n\n') + i;
   }
   var fn = function (e, t) {
    let { originalText: r, [Symbol.for('comments')]: s, locStart: n, locEnd: i, [Symbol.for('printedComments')]: a } = t,
     { node: o } = e,
     u = n(o),
     l = i(o);
    for (let p of s) n(p) >= u && i(p) <= l && a.add(p);
    return r.slice(u, l);
   };
   function mn(e, t) {
    var r, s, n, i, a, o, u, l, p;
    if (e.isRoot) return !1;
    let { node: c, key: h, parent: d } = e;
    if (
     t.__isInHtmlInterpolation &&
     !t.bracketSpacing &&
     (function (e) {
      return ee(e);
     })(c) &&
     Dn(e)
    )
     return !0;
    if (yn(c)) return !1;
    if ('Identifier' === c.type) {
     if ((null != (r = c.extra) && r.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/u.test(c.name)) || ('left' === h && (('async' === c.name && !d.await) || 'let' === c.name) && 'ForOfStatement' === d.type)) return !0;
     if ('let' === c.name) {
      let t = null == (s = e.findAncestor((e) => 'ForOfStatement' === e.type)) ? void 0 : s.left;
      if (t && Me(t, (e) => e === c)) return !0;
     }
     if ('object' === h && 'let' === c.name && 'MemberExpression' === d.type && d.computed && !d.optional) {
      let t = e.findAncestor((e) => 'ExpressionStatement' === e.type || 'ForStatement' === e.type || 'ForInStatement' === e.type),
       r = t ? ('ExpressionStatement' === t.type ? t.expression : 'ForStatement' === t.type ? t.init : t.left) : void 0;
      if (r && Me(r, (e) => e === c)) return !0;
     }
     if ('expression' === h)
      switch (c.name) {
       case 'await':
       case 'interface':
       case 'module':
       case 'using':
       case 'yield':
       case 'let':
       case 'component':
       case 'hook':
       case 'type': {
        let t = e.findAncestor((e) => !it(e));
        if (t !== d && 'ExpressionStatement' === t.type) return !0;
       }
      }
     return !1;
    }
    if ('ObjectExpression' === c.type || 'FunctionExpression' === c.type || 'ClassExpression' === c.type || 'DoExpression' === c.type) {
     let t = null == (n = e.findAncestor((e) => 'ExpressionStatement' === e.type)) ? void 0 : n.expression;
     if (t && Me(t, (e) => e === c)) return !0;
    }
    if ('ObjectExpression' === c.type) {
     let t = null == (i = e.findAncestor((e) => 'ArrowFunctionExpression' === e.type)) ? void 0 : i.body;
     if (t && 'SequenceExpression' !== t.type && 'AssignmentExpression' !== t.type && Me(t, (e) => e === c)) return !0;
    }
    switch (d.type) {
     case 'ParenthesizedExpression':
      return !1;
     case 'ClassDeclaration':
     case 'ClassExpression':
      if ('superClass' === h && ('ArrowFunctionExpression' === c.type || 'AssignmentExpression' === c.type || 'AwaitExpression' === c.type || 'BinaryExpression' === c.type || 'ConditionalExpression' === c.type || 'LogicalExpression' === c.type || 'NewExpression' === c.type || 'ObjectExpression' === c.type || 'SequenceExpression' === c.type || 'TaggedTemplateExpression' === c.type || 'UnaryExpression' === c.type || 'UpdateExpression' === c.type || 'YieldExpression' === c.type || 'TSNonNullExpression' === c.type || ('ClassExpression' === c.type && w(c.decorators)))) return !0;
      break;
     case 'ExportDefaultDeclaration':
      return gn(e, t) || 'SequenceExpression' === c.type;
     case 'Decorator':
      if (
       'expression' === h &&
       !(function (e) {
        return 'ChainExpression' === e.type && (e = e.expression), xn(e) || (Ee(e) && !e.optional && xn(e.callee));
       })(c)
      )
       return !0;
      break;
     case 'TypeAnnotation':
      if (
       e.match(void 0, void 0, (e, t) => 'returnType' === t && 'ArrowFunctionExpression' === e.type) &&
       (function (e) {
        return H(e, (e) => 'ObjectTypeAnnotation' === e.type && H(e, (e) => 'FunctionTypeAnnotation' === e.type));
       })(c)
      )
       return !0;
      break;
     case 'BinaryExpression':
      if ('left' === h && ('in' === d.operator || 'instanceof' === d.operator) && 'UnaryExpression' === c.type) return !0;
      break;
     case 'VariableDeclarator':
      if (
       'init' === h &&
       e.match(
        void 0,
        void 0,
        (e, t) => 'declarations' === t && 'VariableDeclaration' === e.type,
        (e, t) => 'left' === t && 'ForInStatement' === e.type,
       )
      )
       return !0;
    }
    switch (c.type) {
     case 'UpdateExpression':
      if ('UnaryExpression' === d.type) return c.prefix && (('++' === c.operator && '+' === d.operator) || ('--' === c.operator && '-' === d.operator));
     case 'UnaryExpression':
      switch (d.type) {
       case 'UnaryExpression':
        return c.operator === d.operator && ('+' === c.operator || '-' === c.operator);
       case 'BindExpression':
       case 'TaggedTemplateExpression':
       case 'TSNonNullExpression':
        return !0;
       case 'MemberExpression':
       case 'OptionalMemberExpression':
        return 'object' === h;
       case 'NewExpression':
       case 'CallExpression':
       case 'OptionalCallExpression':
        return 'callee' === h;
       case 'BinaryExpression':
        return 'left' === h && '**' === d.operator;
       default:
        return !1;
      }
     case 'BinaryExpression':
      if (
       'UpdateExpression' === d.type ||
       ('in' === c.operator &&
        (function (e) {
         let t = 0,
          { node: r } = e;
         for (; r; ) {
          let s = e.getParentNode(t++);
          if ('ForStatement' === (null == s ? void 0 : s.type) && s.init === r) return !0;
          r = s;
         }
         return !1;
        })(e))
      )
       return !0;
      if ('|>' === c.operator && null != (a = c.extra) && a.parenthesized) {
       let t = e.grandparent;
       if ('BinaryExpression' === t.type && '|>' === t.operator) return !0;
      }
     case 'TSTypeAssertion':
     case 'TSAsExpression':
     case 'TSSatisfiesExpression':
     case 'AsExpression':
     case 'AsConstExpression':
     case 'SatisfiesExpression':
     case 'LogicalExpression':
      switch (d.type) {
       case 'TSAsExpression':
       case 'TSSatisfiesExpression':
       case 'AsExpression':
       case 'AsConstExpression':
       case 'SatisfiesExpression':
        return !it(c);
       case 'ConditionalExpression':
        return (
         it(c) ||
         (function (e) {
          return 'LogicalExpression' === e.type && '??' === e.operator;
         })(c)
        );
       case 'CallExpression':
       case 'NewExpression':
       case 'OptionalCallExpression':
        return 'callee' === h;
       case 'ClassExpression':
       case 'ClassDeclaration':
        return 'superClass' === h;
       case 'TSTypeAssertion':
       case 'TaggedTemplateExpression':
       case 'UnaryExpression':
       case 'JSXSpreadAttribute':
       case 'SpreadElement':
       case 'BindExpression':
       case 'AwaitExpression':
       case 'TSNonNullExpression':
       case 'UpdateExpression':
        return !0;
       case 'MemberExpression':
       case 'OptionalMemberExpression':
        return 'object' === h;
       case 'AssignmentExpression':
       case 'AssignmentPattern':
        return 'left' === h && ('TSTypeAssertion' === c.type || it(c));
       case 'LogicalExpression':
        if ('LogicalExpression' === c.type) return d.operator !== c.operator;
       case 'BinaryExpression': {
        let { operator: e, type: t } = c;
        if (!e && 'TSTypeAssertion' !== t) return !0;
        let r = qe(e),
         s = d.operator,
         n = qe(s);
        return (
         n > r ||
         ('right' === h && n === r) ||
         (n === r && !Ue(s, e)) ||
         (n < r && '%' === e
          ? '+' === s || '-' === s
          : !!(function (e) {
             return !!Re[e] || '|' === e || '^' === e || '&' === e;
            })(s))
        );
       }
       default:
        return !1;
      }
     case 'SequenceExpression':
      switch (d.type) {
       case 'ReturnStatement':
       case 'ForStatement':
        return !1;
       case 'ExpressionStatement':
        return 'expression' !== h;
       case 'ArrowFunctionExpression':
        return 'body' !== h;
       default:
        return !0;
      }
     case 'YieldExpression':
      if ('AwaitExpression' === d.type || 'TSTypeAssertion' === d.type) return !0;
     case 'AwaitExpression':
      switch (d.type) {
       case 'TaggedTemplateExpression':
       case 'UnaryExpression':
       case 'LogicalExpression':
       case 'SpreadElement':
       case 'TSAsExpression':
       case 'TSSatisfiesExpression':
       case 'TSNonNullExpression':
       case 'AsExpression':
       case 'AsConstExpression':
       case 'SatisfiesExpression':
       case 'BindExpression':
        return !0;
       case 'MemberExpression':
       case 'OptionalMemberExpression':
        return 'object' === h;
       case 'NewExpression':
       case 'CallExpression':
       case 'OptionalCallExpression':
        return 'callee' === h;
       case 'ConditionalExpression':
        return 'test' === h;
       case 'BinaryExpression':
        return !(!c.argument && '|>' === d.operator);
       default:
        return !1;
      }
     case 'TSFunctionType':
      if (
       e.match(
        (e) => 'TSFunctionType' === e.type,
        (e, t) => 'typeAnnotation' === t && 'TSTypeAnnotation' === e.type,
        (e, t) => 'returnType' === t && 'ArrowFunctionExpression' === e.type,
       )
      )
       return !0;
     case 'TSConditionalType':
     case 'TSConstructorType':
      if ('extendsType' === h && 'TSConditionalType' === d.type) {
       if ('TSConditionalType' === c.type) return !0;
       let { typeAnnotation: e } = c.returnType || c.typeAnnotation;
       if (('TSTypePredicate' === e.type && e.typeAnnotation && (e = e.typeAnnotation.typeAnnotation), 'TSInferType' === e.type && e.typeParameter.constraint)) return !0;
      }
      if ('checkType' === h && 'TSConditionalType' === d.type) return !0;
     case 'TSUnionType':
     case 'TSIntersectionType':
      if (('TSUnionType' === d.type || 'TSIntersectionType' === d.type) && d.types.length > 1 && (!c.types || c.types.length > 1)) return !0;
     case 'TSInferType':
      if ('TSInferType' === c.type) {
       if ('TSRestType' === d.type) return !1;
       if ('types' === h && ('TSUnionType' === d.type || 'TSIntersectionType' === d.type) && 'TSTypeParameter' === c.typeParameter.type && c.typeParameter.constraint) return !0;
      }
     case 'TSTypeOperator':
      return 'TSArrayType' === d.type || 'TSOptionalType' === d.type || 'TSRestType' === d.type || ('objectType' === h && 'TSIndexedAccessType' === d.type) || 'TSTypeOperator' === d.type || ('TSTypeAnnotation' === d.type && e.grandparent.type.startsWith('TSJSDoc'));
     case 'TSTypeQuery':
      return ('objectType' === h && 'TSIndexedAccessType' === d.type) || ('elementType' === h && 'TSArrayType' === d.type);
     case 'TypeOperator':
      return 'ArrayTypeAnnotation' === d.type || 'NullableTypeAnnotation' === d.type || ('objectType' === h && ('IndexedAccessType' === d.type || 'OptionalIndexedAccessType' === d.type)) || 'TypeOperator' === d.type;
     case 'TypeofTypeAnnotation':
      return ('objectType' === h && ('IndexedAccessType' === d.type || 'OptionalIndexedAccessType' === d.type)) || ('elementType' === h && 'ArrayTypeAnnotation' === d.type);
     case 'ArrayTypeAnnotation':
      return 'NullableTypeAnnotation' === d.type;
     case 'IntersectionTypeAnnotation':
     case 'UnionTypeAnnotation':
      return 'TypeOperator' === d.type || 'ArrayTypeAnnotation' === d.type || 'NullableTypeAnnotation' === d.type || 'IntersectionTypeAnnotation' === d.type || 'UnionTypeAnnotation' === d.type || ('objectType' === h && ('IndexedAccessType' === d.type || 'OptionalIndexedAccessType' === d.type));
     case 'InferTypeAnnotation':
     case 'NullableTypeAnnotation':
      return 'ArrayTypeAnnotation' === d.type || ('objectType' === h && ('IndexedAccessType' === d.type || 'OptionalIndexedAccessType' === d.type));
     case 'ComponentTypeAnnotation':
     case 'FunctionTypeAnnotation': {
      if ('ComponentTypeAnnotation' === c.type && (null === c.rendersType || void 0 === c.rendersType)) return !1;
      if (
       e.match(
        void 0,
        (e, t) => 'typeAnnotation' === t && 'TypeAnnotation' === e.type,
        (e, t) => 'returnType' === t && 'ArrowFunctionExpression' === e.type,
       ) ||
       e.match(
        void 0,
        (e, t) => 'typeAnnotation' === t && 'TypePredicate' === e.type,
        (e, t) => 'typeAnnotation' === t && 'TypeAnnotation' === e.type,
        (e, t) => 'returnType' === t && 'ArrowFunctionExpression' === e.type,
       )
      )
       return !0;
      let t = 'NullableTypeAnnotation' === d.type ? e.grandparent : d;
      return (
       'UnionTypeAnnotation' === t.type ||
       'IntersectionTypeAnnotation' === t.type ||
       'ArrayTypeAnnotation' === t.type ||
       ('objectType' === h && ('IndexedAccessType' === t.type || 'OptionalIndexedAccessType' === t.type)) ||
       ('checkType' === h && 'ConditionalTypeAnnotation' === d.type) ||
       ('extendsType' === h && 'ConditionalTypeAnnotation' === d.type && 'InferTypeAnnotation' === (null == (o = c.returnType) ? void 0 : o.type) && (null == (u = c.returnType) ? void 0 : u.typeParameter.bound)) ||
       'NullableTypeAnnotation' === t.type ||
       ('FunctionTypeParam' === d.type &&
        null === d.name &&
        ze(c).some((e) => {
         var t;
         return 'NullableTypeAnnotation' === (null == (t = e.typeAnnotation) ? void 0 : t.type);
        }))
      );
     }
     case 'ConditionalTypeAnnotation':
      if (('extendsType' === h && 'ConditionalTypeAnnotation' === d.type && 'ConditionalTypeAnnotation' === c.type) || ('checkType' === h && 'ConditionalTypeAnnotation' === d.type)) return !0;
     case 'OptionalIndexedAccessType':
      return 'objectType' === h && 'IndexedAccessType' === d.type;
     case 'StringLiteral':
     case 'NumericLiteral':
     case 'Literal':
      if ('string' == typeof c.value && 'ExpressionStatement' === d.type && !d.directive) {
       let t = e.grandparent;
       return 'Program' === t.type || 'BlockStatement' === t.type;
      }
      return 'object' === h && 'MemberExpression' === d.type && 'number' == typeof c.value;
     case 'AssignmentExpression': {
      let t = e.grandparent;
      return ('body' === h && 'ArrowFunctionExpression' === d.type) || (('key' !== h || ('ClassProperty' !== d.type && 'PropertyDefinition' !== d.type) || !d.computed) && (('init' !== h && 'update' !== h) || 'ForStatement' !== d.type) && ('ExpressionStatement' === d.type ? 'ObjectPattern' === c.left.type : !(('key' === h && 'TSPropertySignature' === d.type) || 'AssignmentExpression' === d.type || ('SequenceExpression' === d.type && 'ForStatement' === t.type && (t.init === d || t.update === d)) || ('value' === h && 'Property' === d.type && 'ObjectPattern' === t.type && t.properties.includes(d)) || 'NGChainedExpression' === d.type || ('node' === h && 'JsExpressionRoot' === d.type))));
     }
     case 'ConditionalExpression':
      switch (d.type) {
       case 'TaggedTemplateExpression':
       case 'UnaryExpression':
       case 'SpreadElement':
       case 'BinaryExpression':
       case 'LogicalExpression':
       case 'NGPipeExpression':
       case 'ExportDefaultDeclaration':
       case 'AwaitExpression':
       case 'JSXSpreadAttribute':
       case 'TSTypeAssertion':
       case 'TypeCastExpression':
       case 'TSAsExpression':
       case 'TSSatisfiesExpression':
       case 'AsExpression':
       case 'AsConstExpression':
       case 'SatisfiesExpression':
       case 'TSNonNullExpression':
        return !0;
       case 'NewExpression':
       case 'CallExpression':
       case 'OptionalCallExpression':
        return 'callee' === h;
       case 'ConditionalExpression':
        return !t.experimentalTernaries && 'test' === h;
       case 'MemberExpression':
       case 'OptionalMemberExpression':
        return 'object' === h;
       default:
        return !1;
      }
     case 'FunctionExpression':
      switch (d.type) {
       case 'NewExpression':
       case 'CallExpression':
       case 'OptionalCallExpression':
        return 'callee' === h;
       case 'TaggedTemplateExpression':
        return !0;
       default:
        return !1;
      }
     case 'ArrowFunctionExpression':
      switch (d.type) {
       case 'BinaryExpression':
        return '|>' !== d.operator || (null == (l = c.extra) ? void 0 : l.parenthesized);
       case 'NewExpression':
       case 'CallExpression':
       case 'OptionalCallExpression':
        return 'callee' === h;
       case 'MemberExpression':
       case 'OptionalMemberExpression':
        return 'object' === h;
       case 'TSAsExpression':
       case 'TSSatisfiesExpression':
       case 'AsExpression':
       case 'AsConstExpression':
       case 'SatisfiesExpression':
       case 'TSNonNullExpression':
       case 'BindExpression':
       case 'TaggedTemplateExpression':
       case 'UnaryExpression':
       case 'LogicalExpression':
       case 'AwaitExpression':
       case 'TSTypeAssertion':
        return !0;
       case 'ConditionalExpression':
        return 'test' === h;
       default:
        return !1;
      }
     case 'ClassExpression':
      return 'NewExpression' === d.type && 'callee' === h;
     case 'OptionalMemberExpression':
     case 'OptionalCallExpression':
     case 'CallExpression':
     case 'MemberExpression':
      if (
       (function (e) {
        return !!(
         e.match(
          void 0,
          (e, t) => 'expression' === t && 'ChainExpression' === e.type,
          (e, t) => 'tag' === t && 'TaggedTemplateExpression' === e.type,
         ) ||
         e.match(
          (e) => 'OptionalCallExpression' === e.type || 'OptionalMemberExpression' === e.type,
          (e, t) => 'tag' === t && 'TaggedTemplateExpression' === e.type,
         ) ||
         e.match(
          (e) => 'OptionalCallExpression' === e.type || 'OptionalMemberExpression' === e.type,
          (e, t) => 'expression' === t && 'TSNonNullExpression' === e.type,
          (e, t) => 'tag' === t && 'TaggedTemplateExpression' === e.type,
         ) ||
         e.match(
          void 0,
          (e, t) => 'expression' === t && 'ChainExpression' === e.type,
          (e, t) => 'expression' === t && 'TSNonNullExpression' === e.type,
          (e, t) => 'tag' === t && 'TaggedTemplateExpression' === e.type,
         ) ||
         e.match(
          void 0,
          (e, t) => 'expression' === t && 'TSNonNullExpression' === e.type,
          (e, t) => 'expression' === t && 'ChainExpression' === e.type,
          (e, t) => 'tag' === t && 'TaggedTemplateExpression' === e.type,
         ) ||
         e.match(
          (e) => 'OptionalMemberExpression' === e.type || 'OptionalCallExpression' === e.type,
          (e, t) => ('object' === t && 'MemberExpression' === e.type) || ('callee' === t && ('CallExpression' === e.type || 'NewExpression' === e.type)),
         ) ||
         e.match(
          (e) => 'OptionalMemberExpression' === e.type || 'OptionalCallExpression' === e.type,
          (e, t) => 'expression' === t && 'TSNonNullExpression' === e.type,
          (e, t) => ('object' === t && 'MemberExpression' === e.type) || ('callee' === t && 'CallExpression' === e.type),
         ) ||
         (e.match(
          (e) => 'CallExpression' === e.type || 'MemberExpression' === e.type,
          (e, t) => 'expression' === t && 'ChainExpression' === e.type,
         ) &&
          (e.match(void 0, void 0, (e, t) => ('callee' === t && (('CallExpression' === e.type && !e.optional) || 'NewExpression' === e.type)) || ('object' === t && 'MemberExpression' === e.type && !e.optional)) ||
           e.match(
            void 0,
            void 0,
            (e, t) => 'expression' === t && 'TSNonNullExpression' === e.type,
            (e, t) => ('object' === t && 'MemberExpression' === e.type) || ('callee' === t && 'CallExpression' === e.type),
           ))) ||
         e.match(
          (e) => 'CallExpression' === e.type || 'MemberExpression' === e.type,
          (e, t) => 'expression' === t && 'TSNonNullExpression' === e.type,
          (e, t) => 'expression' === t && 'ChainExpression' === e.type,
          (e, t) => ('object' === t && 'MemberExpression' === e.type) || ('callee' === t && 'CallExpression' === e.type),
         )
        );
       })(e)
      )
       return !0;
     case 'TaggedTemplateExpression':
     case 'TSNonNullExpression':
      if ('callee' === h && ('BindExpression' === d.type || 'NewExpression' === d.type)) {
       let e = c;
       for (; e; )
        switch (e.type) {
         case 'CallExpression':
         case 'OptionalCallExpression':
          return !0;
         case 'MemberExpression':
         case 'OptionalMemberExpression':
         case 'BindExpression':
          e = e.object;
          break;
         case 'TaggedTemplateExpression':
          e = e.tag;
          break;
         case 'TSNonNullExpression':
          e = e.expression;
          break;
         default:
          return !1;
        }
      }
      return !1;
     case 'BindExpression':
      return ('callee' === h && ('BindExpression' === d.type || 'NewExpression' === d.type)) || ('object' === h && be(d));
     case 'NGPipeExpression':
      return !('NGRoot' === d.type || 'NGMicrosyntaxExpression' === d.type || ('ObjectProperty' === d.type && (null == (p = c.extra) || !p.parenthesized)) || Z(d) || ('arguments' === h && Ee(d)) || ('right' === h && 'NGPipeExpression' === d.type) || ('property' === h && 'MemberExpression' === d.type) || 'AssignmentExpression' === d.type);
     case 'JSXFragment':
     case 'JSXElement':
      return 'callee' === h || ('left' === h && 'BinaryExpression' === d.type && '<' === d.operator) || (!Z(d) && 'ArrowFunctionExpression' !== d.type && 'AssignmentExpression' !== d.type && 'AssignmentPattern' !== d.type && 'BinaryExpression' !== d.type && 'NewExpression' !== d.type && 'ConditionalExpression' !== d.type && 'ExpressionStatement' !== d.type && 'JsExpressionRoot' !== d.type && 'JSXAttribute' !== d.type && 'JSXElement' !== d.type && 'JSXExpressionContainer' !== d.type && 'JSXFragment' !== d.type && 'LogicalExpression' !== d.type && !Ee(d) && !nt(d) && 'ReturnStatement' !== d.type && 'ThrowStatement' !== d.type && 'TypeCastExpression' !== d.type && 'VariableDeclarator' !== d.type && 'YieldExpression' !== d.type);
     case 'TSInstantiationExpression':
      return 'object' === h && be(d);
    }
    return !1;
   }
   var yn = q(['BlockStatement', 'BreakStatement', 'ComponentDeclaration', 'ClassBody', 'ClassDeclaration', 'ClassMethod', 'ClassProperty', 'PropertyDefinition', 'ClassPrivateProperty', 'ContinueStatement', 'DebuggerStatement', 'DeclareComponent', 'DeclareClass', 'DeclareExportAllDeclaration', 'DeclareExportDeclaration', 'DeclareFunction', 'DeclareHook', 'DeclareInterface', 'DeclareModule', 'DeclareModuleExports', 'DeclareNamespace', 'DeclareVariable', 'DeclareEnum', 'DoWhileStatement', 'EnumDeclaration', 'ExportAllDeclaration', 'ExportDefaultDeclaration', 'ExportNamedDeclaration', 'ExpressionStatement', 'ForInStatement', 'ForOfStatement', 'ForStatement', 'FunctionDeclaration', 'HookDeclaration', 'IfStatement', 'ImportDeclaration', 'InterfaceDeclaration', 'LabeledStatement', 'MethodDefinition', 'ReturnStatement', 'SwitchStatement', 'ThrowStatement', 'TryStatement', 'TSDeclareFunction', 'TSEnumDeclaration', 'TSImportEqualsDeclaration', 'TSInterfaceDeclaration', 'TSModuleDeclaration', 'TSNamespaceExportDeclaration', 'TypeAlias', 'VariableDeclaration', 'WhileStatement', 'WithStatement']);
   function Dn(e) {
    let { parent: t, key: r } = e;
    switch (t.type) {
     case 'NGPipeExpression':
      if ('arguments' === r && e.isLast) return e.callParent(Dn);
      break;
     case 'ObjectProperty':
      if ('value' === r) return e.callParent(() => 'properties' === e.key && e.isLast);
      break;
     case 'BinaryExpression':
     case 'LogicalExpression':
      if ('right' === r) return e.callParent(Dn);
      break;
     case 'ConditionalExpression':
      if ('alternate' === r) return e.callParent(Dn);
      break;
     case 'UnaryExpression':
      if (t.prefix) return e.callParent(Dn);
    }
    return !1;
   }
   function gn(e, t) {
    let { node: r, parent: s } = e;
    return 'FunctionExpression' === r.type || 'ClassExpression' === r.type ? 'ExportDefaultDeclaration' === s.type || !mn(e, t) : !(!K(r) || ('ExportDefaultDeclaration' !== s.type && mn(e, t))) && e.call(() => gn(e, t), ...G(r));
   }
   function xn(e) {
    return 'Identifier' === e.type || (!!be(e) && !e.computed && !e.optional && 'Identifier' === e.property.type && xn(e.object));
   }
   var En = mn;
   var bn = function (e, t) {
     let r = t - 1;
     return (r = x(e, r, { backwards: !0 })), (r = T(e, r, { backwards: !0 })), (r = x(e, r, { backwards: !0 })), r !== T(e, r, { backwards: !0 });
    },
    Tn = () => !0;
   function An(e, t) {
    return (e.node.printed = !0), t.printer.printComment(e, t);
   }
   function Cn(e, t, r = {}) {
    let { node: s } = e;
    if (!w(null == s ? void 0 : s.comments)) return '';
    let { indent: n = !1, marker: i, filter: a = Tn } = r,
     o = [];
    if (
     (e.each(({ node: r }) => {
      r.leading || r.trailing || r.marker !== i || !a(r) || o.push(An(e, t));
     }, 'comments'),
     0 === o.length)
    )
     return '';
    let u = dr(pr, o);
    return n ? Xt([pr, u]) : u;
   }
   function vn(e, t) {
    let r = e.node;
    if (!r) return {};
    let s = t[Symbol.for('printedComments')];
    if (0 === (r.comments || []).filter((e) => !s.has(e)).length) return { leading: '', trailing: '' };
    let n,
     i = [],
     a = [];
    return (
     e.each(() => {
      let r = e.node;
      if (null != s && s.has(r)) return;
      let { leading: o, trailing: u } = r;
      o
       ? i.push(
          (function (e, t) {
           var r;
           let s = e.node,
            n = [An(e, t)],
            { printer: i, originalText: a, locStart: o, locEnd: u } = t;
           if (null == (r = i.isBlockComment) ? void 0 : r.call(i, s)) {
            let e = A(a, u(s)) ? (A(a, o(s), { backwards: !0 }) ? pr : ur) : ' ';
            n.push(e);
           } else n.push(pr);
           let l = T(a, x(a, u(s)));
           return !1 !== l && A(a, l) && n.push(pr), n;
          })(e, t),
         )
       : u &&
         ((n = (function (e, t, r) {
          var s;
          let n = e.node,
           i = An(e, t),
           { printer: a, originalText: o, locStart: u } = t,
           l = null == (s = a.isBlockComment) ? void 0 : s.call(a, n);
          if ((null != r && r.hasLineSuffix && (null == r || !r.isBlock)) || A(o, u(n), { backwards: !0 })) {
           let e = bn(o, u(n));
           return { doc: nr([pr, e ? pr : '', i]), isBlock: l, hasLineSuffix: !0 };
          }
          return !l || (null != r && r.hasLineSuffix) ? { doc: [nr([' ', i]), ar], isBlock: l, hasLineSuffix: !0 } : { doc: [' ', i], isBlock: l, hasLineSuffix: !1 };
         })(e, t, n)),
         a.push(n.doc));
     }, 'comments'),
     { leading: i, trailing: a }
    );
   }
   function Fn(e, t, r) {
    let { leading: s, trailing: n } = vn(e, r);
    return s || n ? Jt(t, (e) => [s, e, n]) : t;
   }
   var wn = class extends Error {
    name = 'UnexpectedNodeError';
    constructor(e, t, r = 'type') {
     super(`Unexpected ${t} node ${r}: ${JSON.stringify(e[r])}.`), (this.node = e);
    }
   };
   var Sn;
   Sn = new WeakMap();
   var Pn = new (class {
     constructor(e) {
      ((e, t, r) => {
       t.has(e) ? n('Cannot add the same private member more than once') : t instanceof WeakSet ? t.add(e) : t.set(e, r);
      })(this, Sn),
       ((e, t, r, s) => {
        a(e, t, 'write to private field'), s ? s.call(e, r) : t.set(e, r);
       })(this, Sn, new Set(e));
     }
     getLeadingWhitespaceCount(e) {
      let t = o(this, Sn),
       r = 0;
      for (let s = 0; s < e.length && t.has(e.charAt(s)); s++) r++;
      return r;
     }
     getTrailingWhitespaceCount(e) {
      let t = o(this, Sn),
       r = 0;
      for (let s = e.length - 1; s >= 0 && t.has(e.charAt(s)); s--) r++;
      return r;
     }
     getLeadingWhitespace(e) {
      let t = this.getLeadingWhitespaceCount(e);
      return e.slice(0, t);
     }
     getTrailingWhitespace(e) {
      let t = this.getTrailingWhitespaceCount(e);
      return e.slice(e.length - t);
     }
     hasLeadingWhitespace(e) {
      return o(this, Sn).has(e.charAt(0));
     }
     hasTrailingWhitespace(e) {
      return o(this, Sn).has(c(!1, e, -1));
     }
     trimStart(e) {
      let t = this.getLeadingWhitespaceCount(e);
      return e.slice(t);
     }
     trimEnd(e) {
      let t = this.getTrailingWhitespaceCount(e);
      return e.slice(0, e.length - t);
     }
     trim(e) {
      return this.trimEnd(this.trimStart(e));
     }
     split(e, t = !1) {
      let r = `[${(function (e) {
        if ('string' != typeof e) throw new TypeError('Expected a string');
        return e.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&').replace(/-/g, '\\x2d');
       })([...o(this, Sn)].join(''))}]+`,
       s = new RegExp(t ? `(${r})` : r, 'u');
      return e.split(s);
     }
     hasWhitespaceCharacter(e) {
      let t = o(this, Sn);
      return Array.prototype.some.call(e, (e) => t.has(e));
     }
     hasNonWhitespaceCharacter(e) {
      let t = o(this, Sn);
      return Array.prototype.some.call(e, (e) => !t.has(e));
     }
     isWhitespaceOnly(e) {
      let t = o(this, Sn);
      return Array.prototype.every.call(e, (e) => t.has(e));
     }
    })(' \n\r\t'),
    kn = (e) => '' === e || e === ur || e === pr || e === lr;
   function In(e, t, r) {
    var s, n, i, a, o;
    let { node: u } = e;
    if (
     'JSXElement' === u.type &&
     (function (e) {
      if (0 === e.children.length) return !0;
      if (e.children.length > 1) return !1;
      let t = e.children[0];
      return 'JSXText' === t.type && !_n(t);
     })(u)
    )
     return [r('openingElement'), r('closingElement')];
    let l = 'JSXElement' === u.type ? r('openingElement') : r('openingFragment'),
     p = 'JSXElement' === u.type ? r('closingElement') : r('closingFragment');
    if (1 === u.children.length && 'JSXExpressionContainer' === u.children[0].type && ('TemplateLiteral' === u.children[0].expression.type || 'TaggedTemplateExpression' === u.children[0].expression.type)) return [l, ...e.map(r, 'children'), p];
    u.children = u.children.map((e) =>
     (function (e) {
      return 'JSXExpressionContainer' === e.type && se(e.expression) && ' ' === e.expression.value && !et(e.expression);
     })(e)
      ? { type: 'JSXText', value: ' ', raw: ' ' }
      : e,
    );
    let h = u.children.some(pe),
     d = u.children.filter((e) => 'JSXExpressionContainer' === e.type).length > 1,
     f = 'JSXElement' === u.type && u.openingElement.attributes.length > 1,
     m = Mt(l) || h || f || d,
     y = 'mdx' === e.parent.rootMarker,
     D = t.singleQuote ? "{' '}" : '{" "}',
     g = y ? ur : rr([D, lr], ' '),
     x = (function (e, t, r, s, n) {
      let i = '',
       a = [i];
      function o(e) {
       (i = e), a.push([a.pop(), e]);
      }
      function u(e) {
       '' !== e && ((i = e), a.push(e, ''));
      }
      return (
       e.each(({ node: e, next: t }) => {
        if ('JSXText' === e.type) {
         let r = Be(e);
         if (_n(e)) {
          let a,
           l = Pn.split(r, !0);
          if (('' === l[0] && (l.shift(), /\n/u.test(l[0]) ? u(Bn(n, l[1], e, t)) : u(s), l.shift()), '' === c(!1, l, -1) && (l.pop(), (a = l.pop())), 0 === l.length)) return;
          for (let [e, t] of l.entries()) e % 2 == 1 ? u(ur) : o(t);
          void 0 !== a ? (/\n/u.test(a) ? u(Bn(n, i, e, t)) : u(s)) : u(Nn(n, i, e, t));
         } else /\n/u.test(r) ? r.match(/\n/gu).length > 1 && u(pr) : u(s);
        } else {
         if ((o(r()), t && _n(t))) {
          let r = Pn.trim(Be(t)),
           [s] = Pn.split(r);
          u(Nn(n, s, e, t));
         } else u(pr);
        }
       }, 'children'),
       a
      );
     })(e, 0, r, g, 'fbt' === (null == (n = null == (s = u.openingElement) ? void 0 : s.name) ? void 0 : n.name)),
     E = u.children.some((e) => _n(e));
    for (let c = x.length - 2; c >= 0; c--) {
     let e = '' === x[c] && '' === x[c + 1],
      t = x[c] === pr && '' === x[c + 1] && x[c + 2] === pr,
      r = (x[c] === lr || x[c] === pr) && '' === x[c + 1] && x[c + 2] === g,
      s = x[c] === g && '' === x[c + 1] && (x[c + 2] === lr || x[c + 2] === pr),
      n = x[c] === g && '' === x[c + 1] && x[c + 2] === g,
      i = (x[c] === lr && '' === x[c + 1] && x[c + 2] === pr) || (x[c] === pr && '' === x[c + 1] && x[c + 2] === lr);
     (t && E) || e || r || n || i ? x.splice(c, 2) : s && x.splice(c + 1, 2);
    }
    for (; x.length > 0 && kn(c(!1, x, -1)); ) x.pop();
    for (; x.length > 1 && kn(x[0]) && kn(x[1]); ) x.shift(), x.shift();
    let b = [''];
    for (let [c, C] of x.entries()) {
     if (C === g) {
      if (1 === c && Wt(x[c - 1])) {
       if (2 === x.length) {
        b.push([b.pop(), D]);
        continue;
       }
       b.push([D, pr], '');
       continue;
      }
      if (c === x.length - 1) {
       b.push([b.pop(), D]);
       continue;
      }
      if ('' === x[c - 1] && x[c - 2] === pr) {
       b.push([b.pop(), D]);
       continue;
      }
     }
     c % 2 == 0 ? b.push([b.pop(), C]) : b.push(C, ''), Mt(C) && (m = !0);
    }
    let T = E ? tr(b) : Yt(b, { shouldBreak: !0 });
    if (('JSXText' === (null == (i = t.cursorNode) ? void 0 : i.type) && u.children.includes(t.cursorNode) ? (T = [hr, T, hr]) : 'JSXText' === (null == (a = t.nodeBeforeCursor) ? void 0 : a.type) && u.children.includes(t.nodeBeforeCursor) ? (T = [hr, T]) : 'JSXText' === (null == (o = t.nodeAfterCursor) ? void 0 : o.type) && u.children.includes(t.nodeAfterCursor) && (T = [T, hr]), y)) return T;
    let A = Yt([l, Xt([pr, T]), pr, p]);
    return m ? A : er([Yt([l, ...x, p]), A]);
   }
   function Nn(e, t, r, s) {
    return e ? '' : ('JSXElement' === r.type && !r.closingElement) || ('JSXElement' === (null == s ? void 0 : s.type) && !s.closingElement) ? (1 === t.length ? lr : pr) : lr;
   }
   function Bn(e, t, r, s) {
    return e ? pr : 1 === t.length ? (('JSXElement' === r.type && !r.closingElement) || ('JSXElement' === (null == s ? void 0 : s.type) && !s.closingElement) ? pr : lr) : pr;
   }
   var On = new Set(['ArrayExpression', 'TupleExpression', 'JSXAttribute', 'JSXElement', 'JSXExpressionContainer', 'JSXFragment', 'ExpressionStatement', 'CallExpression', 'OptionalCallExpression', 'ConditionalExpression', 'JsExpressionRoot']);
   function Ln(e, t, r) {
    return e.selfClosing
     ? [ur, '/>']
     : (function (e, t, r) {
          let s = e.attributes.length > 0 && et(c(!1, e.attributes, -1), Qe.Trailing);
          return (0 === e.attributes.length && !r) || ((t.bracketSameLine || t.jsxBracketSameLine) && (!r || e.attributes.length > 0) && !s);
         })(e, t, r)
       ? ['>']
       : [lr, '>'];
   }
   function Mn(e, t, r) {
    return (function (e, t, r) {
     let { parent: s } = e;
     if (On.has(s.type)) return t;
     let n = e.match(
       void 0,
       (e) => 'ArrowFunctionExpression' === e.type,
       Ee,
       (e) => 'JSXExpressionContainer' === e.type,
      ),
      i = En(e, r);
     return Yt([i ? '' : rr('('), Xt([lr, t]), lr, i ? '' : rr(')')], { shouldBreak: n });
    })(e, Fn(e, In(e, t, r), t), t);
   }
   function jn(e, t, r) {
    let { node: s } = e;
    if (s.type.startsWith('JSX'))
     switch (s.type) {
      case 'JSXAttribute':
       return (function (e, t, r) {
        let { node: s } = e,
         n = [];
        if ((n.push(r('name')), s.value)) {
         let i;
         if (se(s.value)) {
          let r = Be(s.value),
           n = p(!1, p(!1, r.slice(1, -1), '&apos;', "'"), '&quot;', '"'),
           a = I(n, t.jsxSingleQuote);
          (n = '"' === a ? p(!1, n, '"', '&quot;') : p(!1, n, "'", '&apos;')), (i = e.call(() => Fn(e, $t(a + n + a), t), 'value'));
         } else i = r('value');
         n.push('=', i);
        }
        return n;
       })(e, t, r);
      case 'JSXIdentifier':
       return s.name;
      case 'JSXNamespacedName':
       return dr(':', [r('namespace'), r('name')]);
      case 'JSXMemberExpression':
       return dr('.', [r('object'), r('property')]);
      case 'JSXSpreadAttribute':
      case 'JSXSpreadChild':
       return (function (e, t, r) {
        let { node: s } = e;
        return [
         '{',
         e.call(
          ({ node: s }) => {
           let n = ['...', r()];
           return et(s) && gs(e) ? [Xt([lr, Fn(e, n, t)]), lr] : n;
          },
          'JSXSpreadAttribute' === s.type ? 'argument' : 'expression',
         ),
         '}',
        ];
       })(e, t, r);
      case 'JSXExpressionContainer':
       return (function (e, t, r) {
        let { node: s } = e,
         n = (e, t) => 'JSXEmptyExpression' === e.type || (!et(e) && (Z(e) || ee(e) || 'ArrowFunctionExpression' === e.type || ('AwaitExpression' === e.type && (n(e.argument, e) || 'JSXElement' === e.argument.type)) || Ee(e) || ('ChainExpression' === e.type && Ee(e.expression)) || 'FunctionExpression' === e.type || 'TemplateLiteral' === e.type || 'TaggedTemplateExpression' === e.type || 'DoExpression' === e.type || (pe(t) && ('ConditionalExpression' === e.type || de(e)))));
        return n(s.expression, e.parent) ? Yt(['{', r('expression'), ir, '}']) : Yt(['{', Xt([lr, r('expression')]), lr, ir, '}']);
       })(e, 0, r);
      case 'JSXFragment':
      case 'JSXElement':
       return Mn(e, t, r);
      case 'JSXOpeningElement':
       return (function (e, t, r) {
        var s, n;
        let { node: i } = e,
         a = et(i.name) || et(i.typeParameters) || et(i.typeArguments);
        if (i.selfClosing && 0 === i.attributes.length && !a) return ['<', r('name'), i.typeArguments ? r('typeArguments') : r('typeParameters'), ' />'];
        if (1 === (null == (s = i.attributes) ? void 0 : s.length) && se(i.attributes[0].value) && !i.attributes[0].value.value.includes('\n') && !a && !et(i.attributes[0])) return Yt(['<', r('name'), i.typeArguments ? r('typeArguments') : r('typeParameters'), ' ', ...e.map(r, 'attributes'), i.selfClosing ? ' />' : '>']);
        let o = null == (n = i.attributes) ? void 0 : n.some((e) => se(e.value) && e.value.value.includes('\n')),
         u = t.singleAttributePerLine && i.attributes.length > 1 ? pr : ur;
        return Yt(['<', r('name'), i.typeArguments ? r('typeArguments') : r('typeParameters'), Xt(e.map(() => [u, r()], 'attributes')), ...Ln(i, t, a)], { shouldBreak: o });
       })(e, t, r);
      case 'JSXClosingElement':
       return (function (e, t, r) {
        let { node: s } = e,
         n = [];
        n.push('</');
        let i = r('name');
        return et(s.name, Qe.Leading | Qe.Line) ? n.push(Xt([pr, i]), pr) : et(s.name, Qe.Leading | Qe.Block) ? n.push(' ', i) : n.push(i), n.push('>'), n;
       })(e, 0, r);
      case 'JSXOpeningFragment':
      case 'JSXClosingFragment':
       return (function (e, t) {
        let { node: r } = e,
         s = et(r),
         n = et(r, Qe.Line),
         i = 'JSXOpeningFragment' === r.type;
        return [i ? '<' : '</', Xt([n ? pr : s && !i ? ' ' : '', Cn(e, t)]), n ? pr : '', '>'];
       })(e, t);
      case 'JSXEmptyExpression':
       return (function (e, t) {
        let { node: r } = e,
         s = et(r, Qe.Line);
        return [Cn(e, t, { indent: s }), s ? pr : ''];
       })(e, t);
      case 'JSXText':
       throw new Error('JSXText should be handled by JSXElement');
      default:
       throw new wn(s, 'JSX');
     }
   }
   function _n(e) {
    return 'JSXText' === e.type && (Pn.hasNonWhitespaceCharacter(Be(e)) || !/\n/u.test(Be(e)));
   }
   var Rn = function (e) {
     return (
      Ye(e.node) ||
      (function (e) {
       let { node: t, parent: r } = e;
       if (!pe(t) || !pe(r)) return !1;
       let s,
        { index: n, siblings: i } = e;
       for (let a = n; a > 0; a--) {
        let e = i[a - 1];
        if ('JSXText' !== e.type || _n(e)) {
         s = e;
         break;
        }
       }
       return 'JSXExpressionContainer' === (null == s ? void 0 : s.type) && 'JSXEmptyExpression' === s.expression.type && Ye(s.expression);
      })(e)
     );
    },
    Un = 0;
   function $n(e, t, r) {
    var s;
    let { node: n, parent: i, grandparent: a, key: o } = e,
     u = 'body' !== o && ('IfStatement' === i.type || 'WhileStatement' === i.type || 'SwitchStatement' === i.type || 'DoWhileStatement' === i.type),
     l = '|>' === n.operator && (null == (s = e.root.extra) ? void 0 : s.__isUsingHackPipeline),
     p = qn(e, r, t, !1, u);
    if (u) return p;
    if (l) return Yt(p);
    if ((Ee(i) && i.callee === n) || 'UnaryExpression' === i.type || (be(i) && !i.computed)) return Yt([Xt([lr, ...p]), lr]);
    let h = 'ReturnStatement' === i.type || 'ThrowStatement' === i.type || ('JSXExpressionContainer' === i.type && 'JSXAttribute' === a.type) || ('|' !== n.operator && 'JsExpressionRoot' === i.type) || ('NGPipeExpression' !== n.type && (('NGRoot' === i.type && '__ng_binding' === t.parser) || ('NGMicrosyntaxExpression' === i.type && 'NGMicrosyntax' === a.type && 1 === a.body.length))) || (n === i.body && 'ArrowFunctionExpression' === i.type) || (n !== i.body && 'ForStatement' === i.type) || ('ConditionalExpression' === i.type && 'ReturnStatement' !== a.type && 'ThrowStatement' !== a.type && !Ee(a)) || 'TemplateLiteral' === i.type,
     d = 'AssignmentExpression' === i.type || 'VariableDeclarator' === i.type || 'ClassProperty' === i.type || 'PropertyDefinition' === i.type || 'TSAbstractPropertyDefinition' === i.type || 'ClassPrivateProperty' === i.type || nt(i),
     f = de(n.left) && Ue(n.operator, n.left.operator);
    if (h || (Jn(n) && !f) || (!Jn(n) && d)) return Yt(p);
    if (0 === p.length) return '';
    let m = pe(n.right),
     y = p.findIndex((e) => 'string' != typeof e && !Array.isArray(e) && e.type === gt),
     D = p.slice(0, -1 === y ? 1 : y + 1),
     g = p.slice(D.length, m ? -1 : void 0),
     x = Symbol('logicalChain-' + ++Un),
     E = Yt([...D, Xt(g)], { id: x });
    return m ? Yt([E, sr(c(!1, p, -1), { groupId: x })]) : E;
   }
   function qn(e, t, r, s, n) {
    var i;
    let { node: a } = e;
    if (!de(a)) return [Yt(t())];
    let o = [];
    Ue(a.operator, a.left.operator) ? (o = e.call((e) => qn(e, t, r, !0, n), 'left')) : o.push(Yt(t('left')));
    let u,
     l = Jn(a),
     p =
      ('|>' === a.operator ||
       'NGPipeExpression' === a.type ||
       (function (e, t) {
        return ('__vue_expression' === t.parser || '__vue_ts_expression' === t.parser) && Wn(e.node) && !e.hasAncestor((e) => !Wn(e) && 'JsExpressionRoot' !== e.type);
       })(e, r)) &&
      !Fe(r.originalText, a.right),
     c = !et(a.right, Qe.Leading, vr) && Fe(r.originalText, a.right),
     h = 'NGPipeExpression' === a.type ? '|' : a.operator,
     d =
      'NGPipeExpression' === a.type && a.arguments.length > 0
       ? Yt(
          Xt([
           lr,
           ': ',
           dr(
            [ur, ': '],
            e.map(() => Gt(2, Yt(t())), 'arguments'),
           ),
          ]),
         )
       : '';
    if (l) u = [h, ' ', t('right'), d];
    else {
     let s = '|>' === h && (null == (i = e.root.extra) ? void 0 : i.__isUsingHackPipeline) ? e.call((e) => qn(e, t, r, !0, n), 'right') : t('right');
     if ('start' === r.experimentalOperatorPosition) {
      let e = '';
      if (c)
       switch (St(s)) {
        case dt:
         e = s.splice(0, 1)[0];
         break;
        case vt:
         e = s.contents.splice(0, 1)[0];
       }
      u = [ur, e, h, ' ', s, d];
     } else u = [p ? ur : '', h, p ? ' ' : ur, s, d];
    }
    let { parent: f } = e,
     m = et(a.left, Qe.Trailing | Qe.Line);
    if (((m || (!(n && 'LogicalExpression' === a.type) && f.type !== a.type && a.left.type !== a.type && a.right.type !== a.type)) && (u = Yt(u, { shouldBreak: m })), 'start' === r.experimentalOperatorPosition ? o.push(l || c ? ' ' : '', u) : o.push(p ? '' : ' ', u), s && et(a))) {
     let t = Ut(Fn(e, o, r));
     return t.type === xt ? t.parts : Array.isArray(t) ? t : [t];
    }
    return o;
   }
   function Jn(e) {
    return 'LogicalExpression' === e.type && !!((ee(e.right) && e.right.properties.length > 0) || (Z(e.right) && e.right.elements.length > 0) || pe(e.right));
   }
   var Wn = (e) => 'BinaryExpression' === e.type && '|' === e.operator;
   function zn(e, t, r) {
    let { node: s } = e;
    if (s.type.startsWith('NG'))
     switch (s.type) {
      case 'NGRoot':
       return [r('node'), et(s.node) ? ' //' + tt(s.node)[0].value.trimEnd() : ''];
      case 'NGPipeExpression':
       return $n(e, t, r);
      case 'NGChainedExpression':
       return Yt(
        dr(
         [';', ur],
         e.map(
          () =>
           (function ({ node: e }) {
            return H(e, Hn);
           })(e)
            ? r()
            : ['(', r(), ')'],
          'expressions',
         ),
        ),
       );
      case 'NGEmptyExpression':
       return '';
      case 'NGMicrosyntax':
       return e.map(() => [e.isFirst ? '' : Vn(e) ? ' ' : [';', ur], r()], 'body');
      case 'NGMicrosyntaxKey':
       return /^[$_a-z][\w$]*(?:-[$_a-z][\w$])*$/iu.test(s.name) ? s.name : JSON.stringify(s.name);
      case 'NGMicrosyntaxExpression':
       return [r('expression'), null === s.alias ? '' : [' as ', r('alias')]];
      case 'NGMicrosyntaxKeyedExpression': {
       let { index: t, parent: n } = e,
        i = Vn(e) || (((1 === t && ('then' === s.key.name || 'else' === s.key.name || 'as' === s.key.name)) || ((2 === t || 3 === t) && (('else' === s.key.name && 'NGMicrosyntaxKeyedExpression' === n.body[t - 1].type && 'then' === n.body[t - 1].key.name) || 'track' === s.key.name))) && 'NGMicrosyntaxExpression' === n.body[0].type);
       return [r('key'), i ? ' ' : ': ', r('expression')];
      }
      case 'NGMicrosyntaxLet':
       return ['let ', r('key'), null === s.value ? '' : [' = ', r('value')]];
      case 'NGMicrosyntaxAs':
       return [r('key'), ' as ', r('alias')];
      default:
       throw new wn(s, 'Angular');
     }
   }
   function Vn({ node: e, index: t }) {
    return 'NGMicrosyntaxKeyedExpression' === e.type && 'of' === e.key.name && 1 === t;
   }
   var Hn = q(['CallExpression', 'OptionalCallExpression', 'AssignmentExpression']);
   function Kn(e, t, r) {
    let { node: s } = e;
    return Yt([dr(ur, e.map(r, 'decorators')), Gn(s, t) ? pr : ur]);
   }
   function Xn(e, t, r) {
    return Yn(e.node) ? [dr(pr, e.map(r, 'declaration', 'decorators')), pr] : '';
   }
   function Gn(e, t) {
    return e.decorators.some((e) => A(t.originalText, L(e)));
   }
   function Yn(e) {
    var t;
    if ('ExportDefaultDeclaration' !== e.type && 'ExportNamedDeclaration' !== e.type && 'DeclareExportDeclaration' !== e.type) return !1;
    let r = null == (t = e.declaration) ? void 0 : t.decorators;
    return w(r) && M(e, r[0]);
   }
   var Qn = class extends Error {
    name = 'ArgExpansionBailout';
   };
   function Zn(e, t = !1) {
    return (
     (ee(e) && (e.properties.length > 0 || et(e))) ||
     (Z(e) && (e.elements.length > 0 || et(e))) ||
     ('TSTypeAssertion' === e.type && Zn(e.expression)) ||
     (it(e) && Zn(e.expression)) ||
     'FunctionExpression' === e.type ||
     ('ArrowFunctionExpression' === e.type &&
      (!e.returnType ||
       !e.returnType.typeAnnotation ||
       'TSTypeReference' !== e.returnType.typeAnnotation.type ||
       (function (e) {
        return 'BlockStatement' === e.type && (e.body.some((e) => 'EmptyStatement' !== e.type) || et(e, Qe.Dangling));
       })(e.body)) &&
      ('BlockStatement' === e.body.type || ('ArrowFunctionExpression' === e.body.type && Zn(e.body, !0)) || ee(e.body) || Z(e.body) || (!t && (Ee(e.body) || 'ConditionalExpression' === e.body.type)) || pe(e.body))) ||
     'DoExpression' === e.type ||
     'ModuleExpression' === e.type
    );
   }
   function ei(e) {
    if ('ParenthesizedExpression' === e.type) return ei(e.expression);
    if (it(e) || 'TypeCastExpression' === e.type) {
     let { typeAnnotation: t } = e;
     if (('TypeAnnotation' === t.type && (t = t.typeAnnotation), 'TSArrayType' === t.type && ((t = t.elementType), 'TSArrayType' === t.type && (t = t.elementType)), 'GenericTypeAnnotation' === t.type || 'TSTypeReference' === t.type)) {
      let e = t.typeArguments ?? t.typeParameters;
      1 === (null == e ? void 0 : e.params.length) && (t = e.params[0]);
     }
     return ye(t) && Ne(e.expression, 1);
    }
    return !(st(e) && He(e).length > 1) && (de(e) ? Ne(e.left, 1) && Ne(e.right, 1) : ne(e) || Ne(e));
   }
   function ti(e, t) {
    let r = e[t],
     s = e[t + 1];
    return 'ArrowFunctionExpression' === r.type && 0 === ze(r).length && 'BlockStatement' === r.body.type && 'ArrayExpression' === s.type && !e.some((e) => et(e));
   }
   var ri = function (e, t, r) {
     let { node: s } = e,
      n = He(s);
     if (0 === n.length) return ['(', Cn(e, t), ')'];
     let i = n.length - 1;
     if (
      (function (e) {
       return 2 === e.length ? ti(e, 0) : 3 === e.length && 'Identifier' === e[0].type && ti(e, 1);
      })(n)
     ) {
      let t = ['('];
      return (
       Ke(e, (e, s) => {
        t.push(r()), s !== i && t.push(', ');
       }),
       t.push(')'),
       t
      );
     }
     let a = !1,
      o = [];
     Ke(e, ({ node: e }, s) => {
      let n = r();
      s === i || (rt(e, t) ? ((a = !0), (n = [n, ',', pr, pr])) : (n = [n, ',', ur])), o.push(n);
     });
     let u = !t.parser.startsWith('__ng_') && 'ImportExpression' !== s.type && Le(t, 'all') ? ',' : '';
     function l() {
      return Yt(['(', Xt([ur, ...o]), u, ur, ')'], { shouldBreak: !0 });
     }
     if (
      a ||
      ('Decorator' !== e.parent.type &&
       (function (e) {
        if (e.length <= 1) return !1;
        let t = 0;
        for (let r of e)
         if (ue(r)) {
          if (((t += 1), t > 1)) return !0;
         } else if (Ee(r)) for (let e of He(r)) if (ue(e)) return !0;
        return !1;
       })(n))
     )
      return l();
     if (
      (function (e) {
       if (2 !== e.length) return !1;
       let [t, r] = e;
       return (
        !(
         'ModuleExpression' !== t.type ||
         !(function (e) {
          return 'ObjectExpression' === e.type && 1 === e.properties.length && nt(e.properties[0]) && 'Identifier' === e.properties[0].key.type && 'type' === e.properties[0].key.name && se(e.properties[0].value) && 'module' === e.properties[0].value.value;
         })(r)
        ) ||
        (!et(t) && ('FunctionExpression' === t.type || ('ArrowFunctionExpression' === t.type && 'BlockStatement' === t.body.type)) && 'FunctionExpression' !== r.type && 'ArrowFunctionExpression' !== r.type && 'ConditionalExpression' !== r.type && ei(r) && !Zn(r))
       );
      })(n)
     ) {
      let e,
       t = o.slice(1);
      if (t.some(Mt)) return l();
      try {
       e = r(Xe(s, 0), { expandFirstArg: !0 });
      } catch (h) {
       if (h instanceof Qn) return l();
       throw h;
      }
      return Mt(e) ? [ar, er([['(', Yt(e, { shouldBreak: !0 }), ', ', ...t, ')'], l()])] : er([['(', e, ', ', ...t, ')'], ['(', Yt(e, { shouldBreak: !0 }), ', ', ...t, ')'], l()]);
     }
     if (
      (function (e, t, r) {
       var s, n;
       let i = c(!1, e, -1);
       if (1 === e.length) {
        let e = c(!1, t, -1);
        if (null != (s = e.label) && s.embed && !1 !== (null == (n = e.label) ? void 0 : n.hug)) return !0;
       }
       let a = c(!1, e, -2);
       return !et(i, Qe.Leading) && !et(i, Qe.Trailing) && Zn(i) && (!a || a.type !== i.type) && (2 !== e.length || 'ArrowFunctionExpression' !== a.type || !Z(i)) && !(e.length > 1 && Gi(i, r));
      })(n, o, t)
     ) {
      let e,
       t = o.slice(0, -1);
      if (t.some(Mt)) return l();
      try {
       e = r(Xe(s, -1), { expandLastArg: !0 });
      } catch (h) {
       if (h instanceof Qn) return l();
       throw h;
      }
      return Mt(e) ? [ar, er([['(', ...t, Yt(e, { shouldBreak: !0 }), ')'], l()])] : er([['(', ...t, e, ')'], ['(', ...t, Yt(e, { shouldBreak: !0 }), ')'], l()]);
     }
     let p = ['(', Xt([lr, ...o]), rr(u), lr, ')'];
     return ke(e) ? p : Yt(p, { shouldBreak: o.some(Mt) || a });
    },
    si = (e) => (('ChainExpression' === e.type || 'TSNonNullExpression' === e.type) && (e = e.expression), Ee(e) && He(e).length > 0);
   function ni(e, t, r) {
    let s = r('property'),
     { node: n } = e,
     i = _i(e);
    return n.computed ? (!n.property || te(n.property) ? [i, '[', s, ']'] : Yt([i, '[', Xt([lr, s]), lr, ']'])) : [i, '.', s];
   }
   var ii = function e(t, r, s) {
    if ('ChainExpression' === t.node.type) return t.call(() => e(t, r, s), 'expression');
    let { parent: n } = t,
     i = !n || 'ExpressionStatement' === n.type,
     a = [];
    function o(e) {
     let { originalText: t } = r,
      s = Tr(t, L(e));
     return ')' === t.charAt(s) ? !1 !== s && F(t, s + 1) : rt(e, r);
    }
    let { node: u } = t;
    a.unshift({ node: u, printed: [_i(t), Wi(t, r, s), ri(t, r, s)] }),
     u.callee &&
      t.call(function e() {
       let { node: n } = t;
       if ('ChainExpression' === n.type) return t.call(e, 'expression');
       if (Ee(n) && (fe(n.callee) || Ee(n.callee))) {
        let i = o(n);
        a.unshift({ node: n, hasTrailingEmptyLine: i, printed: [Fn(t, [_i(t), Wi(t, r, s), ri(t, r, s)], r), i ? pr : ''] }), t.call(e, 'callee');
       } else fe(n) ? (a.unshift({ node: n, needsParens: En(t, r), printed: Fn(t, be(n) ? ni(t, 0, s) : zi(t, r, s), r) }), t.call(e, 'object')) : 'TSNonNullExpression' === n.type ? (a.unshift({ node: n, printed: Fn(t, '!', r) }), t.call(e, 'expression')) : a.unshift({ node: n, printed: s() });
      }, 'callee');
    let l = [],
     p = [a[0]],
     h = 1;
    for (; h < a.length && ('TSNonNullExpression' === a[h].node.type || Ee(a[h].node) || (be(a[h].node) && a[h].node.computed && te(a[h].node.property))); ++h) p.push(a[h]);
    if (!Ee(a[0].node)) for (; h + 1 < a.length && fe(a[h].node) && fe(a[h + 1].node); ++h) p.push(a[h]);
    l.push(p), (p = []);
    let d = !1;
    for (; h < a.length; ++h) {
     if (d && fe(a[h].node)) {
      if (a[h].node.computed && te(a[h].node.property)) {
       p.push(a[h]);
       continue;
      }
      l.push(p), (p = []), (d = !1);
     }
     (Ee(a[h].node) || 'ImportExpression' === a[h].node.type) && (d = !0), p.push(a[h]), et(a[h].node, Qe.Trailing) && (l.push(p), (p = []), (d = !1));
    }
    function f(e) {
     return /^[A-Z]|^[$_]+$/u.test(e);
    }
    p.length > 0 && l.push(p);
    let m =
     l.length >= 2 &&
     !et(l[1][0].node) &&
     (function (e) {
      var t;
      let s = null == (t = e[1][0]) ? void 0 : t.node.computed;
      if (1 === e[0].length) {
       let t = e[0][0].node;
       return (
        'ThisExpression' === t.type ||
        ('Identifier' === t.type &&
         (f(t.name) ||
          (i &&
           (function (e) {
            return e.length <= r.tabWidth;
           })(t.name)) ||
          s))
       );
      }
      let n = c(!1, e[0], -1).node;
      return be(n) && 'Identifier' === n.property.type && (f(n.property.name) || s);
     })(l);
    function y(e) {
     let t = e.map((e) => e.printed);
     return e.length > 0 && c(!1, e, -1).needsParens ? ['(', ...t, ')'] : t;
    }
    let D = l.map(y),
     g = D,
     x = m ? 3 : 2,
     E = l.flat(),
     b = E.slice(1, -1).some((e) => et(e.node, Qe.Leading)) || E.slice(0, -1).some((e) => et(e.node, Qe.Trailing)) || (l[x] && et(l[x][0].node, Qe.Leading));
    if (l.length <= x && !b && !l.some((e) => c(!1, e, -1).hasTrailingEmptyLine)) return ke(t) ? g : Yt(g);
    let T = c(!1, l[m ? 1 : 0], -1).node,
     A = !Ee(T) && o(T),
     C = [y(l[0]), m ? l.slice(1, 2).map(y) : '', A ? pr : '', ((w = l.slice(m ? 2 : 1)), 0 === w.length ? '' : Xt([pr, dr(pr, w.map(y))]))],
     v = a.map(({ node: e }) => e).filter(Ee);
    var w;
    let S;
    return (
     (S =
      b ||
      (v.length > 2 && v.some((e) => !e.arguments.every((e) => Ne(e)))) ||
      D.slice(0, -1).some(Mt) ||
      (function () {
       let e = c(!1, c(!1, l, -1), -1).node,
        t = c(!1, D, -1);
       return Ee(e) && Mt(t) && v.slice(0, -1).some((e) => e.arguments.some(ue));
      })()
       ? Yt(C)
       : [Mt(g) || A ? ar : '', er([g, C])]),
     fr({ memberChain: !0 }, S)
    );
   };
   function ai(e, t, r) {
    var s;
    let { node: n } = e,
     i = 'NewExpression' === n.type,
     a = 'ImportExpression' === n.type,
     o = _i(e),
     u = He(n),
     l = 1 === u.length && Se(u[0], t.originalText);
    if (
     l ||
     (function (e) {
      let { node: t } = e;
      if ('CallExpression' !== t.type || t.optional || 'Identifier' !== t.callee.type) return !1;
      let r = He(t);
      return 'require' === t.callee.name ? (1 === r.length && se(r[0])) || r.length > 1 : 'define' === t.callee.name && 'ExpressionStatement' === e.parent.type && (1 === r.length || (2 === r.length && 'ArrayExpression' === r[0].type) || (3 === r.length && se(r[0]) && 'ArrayExpression' === r[1].type));
     })(e) ||
     ge(n, e.parent)
    ) {
     let n = [];
     if (
      (Ke(e, () => {
       n.push(r());
      }),
      !l || null == (s = n[0].label) || !s.embed)
     )
      return [i ? 'new ' : '', oi(e, r), o, Wi(e, t, r), '(', dr(', ', n), ')'];
    }
    if (!a && !i && fe(n.callee) && !e.call((e) => En(e, t), 'callee', ...('ChainExpression' === n.callee.type ? ['expression'] : []))) return ii(e, t, r);
    let p = [i ? 'new ' : '', oi(e, r), o, Wi(e, t, r), ri(e, t, r)];
    return a || Ee(n.callee) ? Yt(p) : p;
   }
   function oi(e, t) {
    let { node: r } = e;
    return 'ImportExpression' === r.type ? 'import' + (r.phase ? `.${r.phase}` : '') : t('callee');
   }
   function ui(e, t, r, s, n, i) {
    let a = (function (e, t, r, s, n) {
      let { node: i } = e,
       a = i[n];
      if (!a) return 'only-left';
      let o = !li(a);
      if (e.match(li, pi, (e) => !o || ('ExpressionStatement' !== e.type && 'VariableDeclaration' !== e.type))) return o ? ('ArrowFunctionExpression' === a.type && 'ArrowFunctionExpression' === a.body.type ? 'chain-tail-arrow-chain' : 'chain-tail') : 'chain';
      if ((!o && li(a.right)) || Fe(t.originalText, a)) return 'break-after-operator';
      if ('ImportAttribute' === i.type || ('CallExpression' === a.type && 'require' === a.callee.name) || 'json5' === t.parser || 'jsonc' === t.parser || 'json' === t.parser) return 'never-break-after-operator';
      let u = (function (e) {
       return Ot(e, qt, !1);
      })(s);
      if (
       (function (e) {
        if (pi(e)) {
         let t = e.left || e.id;
         return (
          'ObjectPattern' === t.type &&
          t.properties.length > 2 &&
          t.properties.some((e) => {
           var t;
           return nt(e) && (!e.shorthand || 'AssignmentPattern' === (null == (t = e.value) ? void 0 : t.type));
          })
         );
        }
        return !1;
       })(i) ||
       (function (e) {
        if ('VariableDeclarator' !== e.type) return !1;
        let { typeAnnotation: t } = e.id;
        if (!t || !t.typeAnnotation) return !1;
        let r = fi(t.typeAnnotation);
        return w(r) && r.length > 1 && r.some((e) => w(fi(e)) || 'TSConditionalType' === e.type);
       })(i) ||
       (hi(i) && u)
      )
       return 'break-lhs';
      let l = (function (e, t, r) {
       return !!nt(e) && ((t = Ut(t)), 'string' == typeof t && D(t) < r.tabWidth + 3);
      })(i, s, t);
      return e.call(
       () =>
        (function (e, t, r, s) {
         let n = e.node;
         if (de(n) && !Jn(n)) return !0;
         switch (n.type) {
          case 'StringLiteralTypeAnnotation':
          case 'SequenceExpression':
           return !0;
          case 'TSConditionalType':
          case 'ConditionalTypeAnnotation':
           if (
            !t.experimentalTernaries &&
            !(function (e) {
             function t(e) {
              switch (e.type) {
               case 'FunctionTypeAnnotation':
               case 'GenericTypeAnnotation':
               case 'TSFunctionType':
                return !!e.typeParameters;
               case 'TSTypeReference':
                return !!(e.typeArguments ?? e.typeParameters);
               default:
                return !1;
              }
             }
             return t(e.checkType) || t(e.extendsType);
            })(n)
           )
            break;
           return !0;
          case 'ConditionalExpression': {
           if (!t.experimentalTernaries) {
            let { test: e } = n;
            return de(e) && !Jn(e);
           }
           let { consequent: e, alternate: r } = n;
           return 'ConditionalExpression' === e.type || 'ConditionalExpression' === r.type;
          }
          case 'ClassExpression':
           return w(n.decorators);
         }
         if (s) return !1;
         let i = n,
          a = [];
         for (;;)
          if ('UnaryExpression' === i.type || 'AwaitExpression' === i.type || ('YieldExpression' === i.type && null !== i.argument)) (i = i.argument), a.push('argument');
          else {
           if ('TSNonNullExpression' !== i.type) break;
           (i = i.expression), a.push('expression');
          }
         return !(!se(i) && !e.call(() => mi(e, t, r), ...a));
        })(e, t, r, l),
       n,
      )
       ? 'break-after-operator'
       : (function (e) {
            let t = (function (e) {
             var t;
             if (ci(e)) return null == (t = e.typeParameters) ? void 0 : t.params;
            })(e);
            if (w(t)) {
             let r = 'TSTypeAliasDeclaration' === e.type ? 'constraint' : 'bound';
             if (t.length > 1 && t.some((e) => e[r] || e.default)) return !0;
            }
            return !1;
           })(i)
         ? 'break-lhs'
         : u || (!l && 'TemplateLiteral' !== a.type && 'TaggedTemplateExpression' !== a.type && 'BooleanLiteral' !== a.type && !te(a) && 'ClassExpression' !== a.type)
           ? 'fluid'
           : 'never-break-after-operator';
     })(e, t, r, s, i),
     o = i ? r(i, { assignmentLayout: a }) : '';
    switch (a) {
     case 'break-after-operator':
      return Yt([Yt(s), n, Yt(Xt([ur, o]))]);
     case 'never-break-after-operator':
      return Yt([Yt(s), n, ' ', o]);
     case 'fluid': {
      let e = Symbol('assignment');
      return Yt([Yt(s), n, Yt(Xt(ur), { id: e }), ir, sr(o, { groupId: e })]);
     }
     case 'break-lhs':
      return Yt([s, n, ' ', Yt(o)]);
     case 'chain':
      return [Yt(s), n, ur, o];
     case 'chain-tail':
      return [Yt(s), n, Xt([ur, o])];
     case 'chain-tail-arrow-chain':
      return [Yt(s), n, o];
     case 'only-left':
      return s;
    }
   }
   function li(e) {
    return 'AssignmentExpression' === e.type;
   }
   function pi(e) {
    return li(e) || 'VariableDeclarator' === e.type;
   }
   var ci = q(['TSTypeAliasDeclaration', 'TypeAlias']);
   function hi(e) {
    var t;
    return 'VariableDeclarator' === e.type && 'ArrowFunctionExpression' === (null == (t = e.init) ? void 0 : t.type);
   }
   var di = q(['TSTypeReference', 'GenericTypeAnnotation']);
   function fi(e) {
    var t;
    if (di(e)) return null == (t = e.typeArguments ?? e.typeParameters) ? void 0 : t.params;
   }
   function mi(e, t, r, s = !1) {
    var n;
    let { node: i } = e,
     a = () => mi(e, t, r, !0);
    if ('ChainExpression' === i.type || 'TSNonNullExpression' === i.type) return e.call(a, 'expression');
    if (Ee(i)) {
     if (null != (n = ai(e, t, r).label) && n.memberChain) return !1;
     let s = He(i);
     return (
      !(
       !(0 === s.length || (1 === s.length && ve(s[0], t))) ||
       (function (e, t) {
        let r = (function (e) {
         var t;
         return null == (t = e.typeParameters ?? e.typeArguments) ? void 0 : t.params;
        })(e);
        if (w(r)) {
         if (r.length > 1) return !0;
         if (1 === r.length) {
          let e = r[0];
          if (at(e) || ot(e) || 'TSTypeLiteral' === e.type || 'ObjectTypeAnnotation' === e.type) return !0;
         }
         if (Mt(t(e.typeParameters ? 'typeParameters' : 'typeArguments'))) return !0;
        }
        return !1;
       })(i, r)
      ) && e.call(a, 'callee')
     );
    }
    return be(i) ? e.call(a, 'object') : s && ('Identifier' === i.type || 'ThisExpression' === i.type);
   }
   function yi(e, t, r, s, n) {
    let i = e.node,
     a = ze(i),
     o = n ? Wi(e, r, t) : '';
    if (0 === a.length) return [o, '(', Cn(e, r, { filter: (e) => ')' === Ar(r.originalText, L(e)) }), ')'];
    let { parent: u } = e,
     l = ge(u),
     p = Di(i),
     c = [];
    if (
     ((function (e, t) {
      let { node: r } = e,
       s = 0,
       n = (e) => t(e, s++);
      r.this && e.call(n, 'this'), Array.isArray(r.parameters) ? e.each(n, 'parameters') : Array.isArray(r.params) && e.each(n, 'params'), r.rest && e.call(n, 'rest');
     })(e, (e, s) => {
      let n = s === a.length - 1;
      n && i.rest && c.push('...'), c.push(t()), !n && (c.push(','), l || p ? c.push(' ') : rt(a[s], r) ? c.push(pr, pr) : c.push(ur));
     }),
     s &&
      !(function (e) {
       return e.match(
        (e) => 'ArrowFunctionExpression' === e.type && 'BlockStatement' === e.body.type,
        (e, t) => {
         if ('CallExpression' === e.type && 'arguments' === t && 1 === e.arguments.length && 'CallExpression' === e.callee.type) {
          let t = e.callee.callee;
          return 'Identifier' === t.type || ('MemberExpression' === t.type && !t.computed && 'Identifier' === t.object.type && 'Identifier' === t.property.type);
         }
         return !1;
        },
        (e, t) => ('VariableDeclarator' === e.type && 'init' === t) || ('ExportDefaultDeclaration' === e.type && 'declaration' === t) || ('TSExportAssignment' === e.type && 'expression' === t) || ('AssignmentExpression' === e.type && 'right' === t && 'MemberExpression' === e.left.type && 'Identifier' === e.left.object.type && 'module' === e.left.object.name && 'Identifier' === e.left.property.type && 'exports' === e.left.property.name),
        (e) => 'VariableDeclaration' !== e.type || ('const' === e.kind && 1 === e.declarations.length),
       );
      })(e))
    ) {
     if (Mt(o) || Mt(c)) throw new Qn();
     return Yt([Rt(o), '(', Rt(c), ')']);
    }
    let h = a.every((e) => !w(e.decorators));
    return (p && h) || l
     ? [o, '(', ...c, ')']
     : (he(u) ||
          (function (e) {
           return !(('TypeAnnotation' !== e.type && 'TSTypeAnnotation' !== e.type) || 'FunctionTypeAnnotation' !== e.typeAnnotation.type || e.static || M(e, e.typeAnnotation));
          })(u) ||
          'TypeAlias' === u.type ||
          'UnionTypeAnnotation' === u.type ||
          'IntersectionTypeAnnotation' === u.type ||
          ('FunctionTypeAnnotation' === u.type && u.returnType === i)) &&
         1 === a.length &&
         null === a[0].name &&
         i.this !== a[0] &&
         a[0].typeAnnotation &&
         null === i.typeParameters &&
         ye(a[0].typeAnnotation) &&
         !i.rest
       ? 'always' === r.arrowParens || 'HookTypeAnnotation' === i.type
         ? ['(', ...c, ')']
         : c
       : [o, '(', Xt([lr, ...c]), rr(!Je(i) && Le(r, 'all') ? ',' : ''), lr, ')'];
   }
   function Di(e) {
    if (!e) return !1;
    let t = ze(e);
    if (1 !== t.length) return !1;
    let [r] = t;
    return !et(r) && ('ObjectPattern' === r.type || 'ArrayPattern' === r.type || ('Identifier' === r.type && r.typeAnnotation && ('TypeAnnotation' === r.typeAnnotation.type || 'TSTypeAnnotation' === r.typeAnnotation.type) && oe(r.typeAnnotation.typeAnnotation)) || ('FunctionTypeParam' === r.type && oe(r.typeAnnotation) && r !== e.rest) || ('AssignmentPattern' === r.type && ('ObjectPattern' === r.left.type || 'ArrayPattern' === r.left.type) && ('Identifier' === r.right.type || (ee(r.right) && 0 === r.right.properties.length) || (Z(r.right) && 0 === r.right.elements.length))));
   }
   function gi(e, t) {
    var r;
    let s = (function (e) {
     let t;
     return e.returnType ? ((t = e.returnType), t.typeAnnotation && (t = t.typeAnnotation)) : e.typeAnnotation && (t = e.typeAnnotation), t;
    })(e);
    if (!s) return !1;
    let n = null == (r = e.typeParameters) ? void 0 : r.params;
    if (n) {
     if (n.length > 1) return !1;
     if (1 === n.length) {
      let e = n[0];
      if (e.constraint || e.default) return !1;
     }
    }
    return 1 === ze(e).length && (oe(s) || Mt(t));
   }
   var xi = q(['VoidTypeAnnotation', 'TSVoidKeyword', 'NullLiteralTypeAnnotation', 'TSNullKeyword']),
    Ei = q(['ObjectTypeAnnotation', 'TSTypeLiteral', 'GenericTypeAnnotation', 'TSTypeReference']);
   function bi(e) {
    return (
     !(!ye(e) && !oe(e)) ||
     (!!at(e) &&
      (function (e) {
       let { types: t } = e;
       if (t.some((e) => et(e))) return !1;
       let r = t.find((e) => Ei(e));
       return !!r && t.every((e) => e === r || xi(e));
      })(e))
    );
   }
   function Ti(e, t, r) {
    let s = t.semi ? ';' : '',
     { node: n } = e,
     i = [$i(e)];
    return i.push('type ', r('id'), r('typeParameters')), [ui(e, t, r, i, ' =', 'TSTypeAliasDeclaration' === n.type ? 'typeAnnotation' : 'right'), s];
   }
   function Ai(e, t, r) {
    let s = !1;
    return Yt(
     e.map(({ isFirst: e, previous: n, node: i, index: a }) => {
      let o = r();
      if (e) return o;
      let u = oe(i),
       l = oe(n);
      return l && u ? [' & ', s ? Xt(o) : o] : l || u ? (a > 1 && (s = !0), [' & ', a > 1 ? Xt(o) : o]) : 'start' === t.experimentalOperatorPosition ? Xt([ur, '& ', o]) : Xt([' &', ur, o]);
     }, 'types'),
    );
   }
   function Ci(e, t, r) {
    let { node: s } = e,
     { parent: n } = e,
     i = !('TypeParameterInstantiation' === n.type || ('TSConditionalType' === n.type && t.experimentalTernaries) || ('ConditionalTypeAnnotation' === n.type && t.experimentalTernaries) || 'TSTypeParameterInstantiation' === n.type || 'GenericTypeAnnotation' === n.type || 'TSTypeReference' === n.type || 'TSTypeAssertion' === n.type || 'TupleTypeAnnotation' === n.type || 'TSTupleType' === n.type || ('FunctionTypeParam' === n.type && !n.name && e.grandparent.this !== n) || (('TypeAlias' === n.type || 'VariableDeclarator' === n.type || 'TSTypeAliasDeclaration' === n.type) && Fe(t.originalText, s))),
     a = bi(s),
     o = e.map((e) => {
      let s = r();
      return a || (s = Gt(2, s)), Fn(e, s, t);
     }, 'types');
    if (a) return dr(' | ', o);
    let u = [rr([i && !Fe(t.originalText, s) ? ur : '', '| ']), dr([ur, '| '], o)];
    return En(e, t) ? Yt([Xt(u), lr]) : ('TupleTypeAnnotation' === n.type || 'TSTupleType' === n.type) && n['TupleTypeAnnotation' === n.type && n.types ? 'types' : 'elementTypes'].length > 1 ? Yt([Xt([rr(['(', lr]), u]), lr, rr(')')]) : Yt(i ? Xt(u) : u);
   }
   function vi(e, t, r) {
    let { node: s } = e,
     n = [Ji(e)];
    ('TSConstructorType' === s.type || 'TSConstructSignatureDeclaration' === s.type) && n.push('new ');
    let i = yi(e, r, t, !1, !0),
     a = [];
    return (
     'FunctionTypeAnnotation' === s.type
      ? a.push(
         (function (e) {
          var t;
          let { node: r, parent: s } = e;
          return 'FunctionTypeAnnotation' === r.type && (he(s) || !((('ObjectTypeProperty' === s.type || 'ObjectTypeInternalSlot' === s.type) && !s.variance && !s.optional && M(s, r)) || 'ObjectTypeCallProperty' === s.type || 'DeclareFunction' === (null == (t = e.getParentNode(2)) ? void 0 : t.type)));
         })(e)
          ? ' => '
          : ': ',
         r('returnType'),
        )
      : a.push(Ni(e, r, s.returnType ? 'returnType' : 'typeAnnotation')),
     gi(s, a) && (i = Yt(i)),
     n.push(i, a),
     Yt(n)
    );
   }
   function Fi(e, t, r) {
    return [r('objectType'), _i(e), '[', r('indexType'), ']'];
   }
   function wi(e, t, r) {
    return ['infer ', r('typeParameter')];
   }
   function Si(e, t, r) {
    let { node: s } = e;
    return [s.postfix ? '' : r, Ni(e, t), s.postfix ? r : ''];
   }
   function Pi(e, t, r) {
    let { node: s } = e;
    return ['...', ...('TupleTypeSpreadElement' === s.type && s.label ? [r('label'), ': '] : []), r('typeAnnotation')];
   }
   function ki(e, t, r) {
    let { node: s } = e;
    return [s.variance ? r('variance') : '', r('label'), s.optional ? '?' : '', ': ', r('elementType')];
   }
   var Ii = new WeakSet();
   function Ni(e, t, r = 'typeAnnotation') {
    let {
     node: { [r]: s },
    } = e;
    if (!s) return '';
    let n = !1;
    if ('TSTypeAnnotation' === s.type || 'TypeAnnotation' === s.type) {
     let t = e.call(Bi, r);
     ('=>' === t || (':' === t && et(s, Qe.Leading))) && (n = !0), Ii.add(s);
    }
    return n ? [' ', t(r)] : t(r);
   }
   var Bi = (e) =>
    e.match(
     (e) => 'TSTypeAnnotation' === e.type,
     (e, t) => !(('returnType' !== t && 'typeAnnotation' !== t) || ('TSFunctionType' !== e.type && 'TSConstructorType' !== e.type)),
    )
     ? '=>'
     : e.match(
          (e) => 'TSTypeAnnotation' === e.type,
          (e, t) => 'typeAnnotation' === t && ('TSJSDocNullableType' === e.type || 'TSJSDocNonNullableType' === e.type || 'TSTypePredicate' === e.type),
         ) ||
         e.match(
          (e) => 'TypeAnnotation' === e.type,
          (e, t) => 'typeAnnotation' === t && 'Identifier' === e.type,
          (e, t) => 'id' === t && 'DeclareFunction' === e.type,
         ) ||
         e.match(
          (e) => 'TypeAnnotation' === e.type,
          (e, t) => 'typeAnnotation' === t && 'Identifier' === e.type,
          (e, t) => 'id' === t && 'DeclareHook' === e.type,
         ) ||
         e.match(
          (e) => 'TypeAnnotation' === e.type,
          (e, t) => 'bound' === t && 'TypeParameter' === e.type && e.usesExtendsBound,
         )
       ? ''
       : ':';
   function Oi(e, t, r) {
    let s = Bi(e);
    return s ? [s, ' ', r('typeAnnotation')] : r('typeAnnotation');
   }
   function Li(e) {
    return [e('elementType'), '[]'];
   }
   function Mi({ node: e }, t) {
    let r = 'TSTypeQuery' === e.type ? 'exprName' : 'argument',
     s = 'TypeofTypeAnnotation' === e.type || e.typeArguments ? 'typeArguments' : 'typeParameters';
    return ['typeof ', t(r), t(s)];
   }
   function ji(e, t) {
    let { node: r } = e;
    return ['TSTypePredicate' === r.type && r.asserts ? 'asserts ' : 'TypePredicate' === r.type && r.kind ? `${r.kind} ` : '', t('parameterName'), r.typeAnnotation ? [' is ', Ni(e, t)] : ''];
   }
   function _i(e) {
    let { node: t } = e;
    return !t.optional || ('Identifier' === t.type && t === e.parent.key) ? '' : Ee(t) || (be(t) && t.computed) || 'OptionalIndexedAccessType' === t.type ? '?.' : '?';
   }
   function Ri(e) {
    return e.node.definite || e.match(void 0, (e, t) => 'id' === t && 'VariableDeclarator' === e.type && e.definite) ? '!' : '';
   }
   var Ui = new Set(['DeclareClass', 'DeclareComponent', 'DeclareFunction', 'DeclareHook', 'DeclareVariable', 'DeclareExportDeclaration', 'DeclareExportAllDeclaration', 'DeclareOpaqueType', 'DeclareTypeAlias', 'DeclareEnum', 'DeclareInterface']);
   function $i(e) {
    let { node: t } = e;
    return t.declare || (Ui.has(t.type) && 'DeclareExportDeclaration' !== e.parent.type) ? 'declare ' : '';
   }
   var qi = new Set(['TSAbstractMethodDefinition', 'TSAbstractPropertyDefinition', 'TSAbstractAccessorProperty']);
   function Ji({ node: e }) {
    return e.abstract || qi.has(e.type) ? 'abstract ' : '';
   }
   function Wi(e, t, r) {
    let s = e.node;
    return s.typeArguments ? r('typeArguments') : s.typeParameters ? r('typeParameters') : '';
   }
   function zi(e, t, r) {
    return ['::', r('callee')];
   }
   function Vi(e, t, r) {
    return 'EmptyStatement' === e.type ? ';' : 'BlockStatement' === e.type || r ? [' ', t] : Xt([ur, t]);
   }
   function Hi(e, t) {
    return ['...', t('argument'), Ni(e, t)];
   }
   function Ki(e) {
    return e.accessibility ? e.accessibility + ' ' : '';
   }
   function Xi(e, t, r) {
    let { node: s } = e,
     n = [],
     i = 'TupleExpression' === s.type ? '#[' : '[',
     a = 'TupleTypeAnnotation' === s.type && s.types ? 'types' : 'TSTupleType' === s.type || 'TupleTypeAnnotation' === s.type ? 'elementTypes' : 'elements',
     o = s[a];
    if (0 === o.length)
     n.push(
      (function (e, t, r, s) {
       let { node: n } = e,
        i = n.inexact ? '...' : '';
       return et(n, Qe.Dangling) ? Yt([r, i, Cn(e, t, { indent: !0 }), lr, s]) : [r, i, s];
      })(e, t, i, ']'),
     );
    else {
     let u = c(!1, o, -1),
      l = 'RestElement' !== (null == u ? void 0 : u.type) && !s.inexact,
      p = null === u,
      h = Symbol('array'),
      d =
       !t.__inJestEach &&
       o.length > 1 &&
       o.every((e, t, r) => {
        let s = null == e ? void 0 : e.type;
        if (!Z(e) && !ee(e)) return !1;
        let n = r[t + 1];
        if (n && s !== n.type) return !1;
        let i = Z(e) ? 'elements' : 'properties';
        return e[i] && e[i].length > 1;
       }),
      f = Gi(s, t),
      m = l ? (p ? ',' : Le(t) ? (f ? rr(',', '', { groupId: h }) : rr(',')) : '') : '';
     n.push(Yt([i, Xt([lr, f ? Zi(e, t, r, m) : [Qi(e, t, a, s.inexact, r), m], Cn(e, t)]), lr, ']'], { shouldBreak: d, id: h }));
    }
    return n.push(_i(e), Ni(e, r)), n;
   }
   function Gi(e, t) {
    return Z(e) && e.elements.length > 1 && e.elements.every((e) => e && (te(e) || (re(e) && !et(e.argument))) && !et(e, Qe.Trailing | Qe.Line, (e) => !A(t.originalText, O(e), { backwards: !0 })));
   }
   function Yi({ node: e }, { originalText: t }) {
    let r = (e) => (',' === t[e] ? e : r(((e) => C(t, v(t, e)))(e + 1)));
    return F(t, r(L(e)));
   }
   function Qi(e, t, r, s, n) {
    let i = [];
    return (
     e.each(({ node: r, isLast: a }) => {
      i.push(r ? Yt(n()) : ''), (!a || s) && i.push([',', ur, r && Yi(e, t) ? lr : '']);
     }, r),
     s && i.push('...'),
     i
    );
   }
   function Zi(e, t, r, s) {
    let n = [];
    return (
     e.each(({ isLast: i, next: a }) => {
      n.push([r(), i ? s : ',']), i || n.push(Yi(e, t) ? [pr, pr] : et(a, Qe.Leading | Qe.Line) ? pr : ur);
     }, 'elements'),
     tr(n)
    );
   }
   var ea = /^[\$A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC][\$0-9A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]*$/,
    ta = (e) => ea.test(e);
   var ra = function (e) {
     return 1 === e.length
      ? e
      : e
         .toLowerCase()
         .replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(?=\d)/u, '$1$2')
         .replace(/^([+-]?[\d.]+)e[+-]?0+$/u, '$1')
         .replace(/^([+-])?\./u, '$10.')
         .replace(/(\.\d+?)0+(?=e|$)/u, '$1')
         .replace(/\.(?=e|$)/u, '');
    },
    sa = new WeakMap();
   function na(e) {
    return /^(?:\d+|\d+\.\d+)$/u.test(e);
   }
   function ia(e, t) {
    return !('json' === t.parser || 'jsonc' === t.parser || !se(e.key) || B(Be(e.key), t).slice(1, -1) !== e.key.value) && !!((ta(e.key.value) && !(('babel-ts' === t.parser && 'ClassProperty' === e.type) || ('typescript' === t.parser && 'PropertyDefinition' === e.type))) || (na(e.key.value) && String(Number(e.key.value)) === e.key.value && 'ImportAttribute' !== e.type && ('babel' === t.parser || 'acorn' === t.parser || 'espree' === t.parser || 'meriyah' === t.parser || '__babel_estree' === t.parser)));
   }
   function aa(e, t, r) {
    let { node: s } = e;
    if (s.computed) return ['[', r('key'), ']'];
    let { parent: n } = e,
     { key: i } = s;
    if ('consistent' === t.quoteProps && !sa.has(n)) {
     let r = e.siblings.some((e) => !e.computed && se(e.key) && !ia(e, t));
     sa.set(n, r);
    }
    if (
     (function (e, t) {
      let { key: r } = e.node;
      return ('Identifier' === r.type || (te(r) && na(ra(Be(r))) && String(r.value) === ra(Be(r)) && !('typescript' === t.parser || 'babel-ts' === t.parser))) && ('json' === t.parser || 'jsonc' === t.parser || ('consistent' === t.quoteProps && sa.get(e.parent)));
     })(e, t)
    ) {
     let r = B(JSON.stringify('Identifier' === i.type ? i.name : i.value.toString()), t);
     return e.call((e) => Fn(e, r, t), 'key');
    }
    return ia(s, t) && ('as-needed' === t.quoteProps || ('consistent' === t.quoteProps && !sa.get(n))) ? e.call((e) => Fn(e, /^\d/u.test(i.value) ? ra(i.value) : i.value, t), 'key') : r('key');
   }
   function oa(e, t, r) {
    let { node: s } = e;
    return s.shorthand ? r('value') : ui(e, t, r, aa(e, t, r), ':', 'value');
   }
   var ua = ({ node: e, key: t, parent: r }) => 'value' === t && 'FunctionExpression' === e.type && ('ObjectMethod' === r.type || 'ClassMethod' === r.type || 'ClassPrivateMethod' === r.type || 'MethodDefinition' === r.type || 'TSAbstractMethodDefinition' === r.type || 'TSDeclareMethod' === r.type || ('Property' === r.type && ce(r)));
   function la(e, t, r, s) {
    if (ua(e)) return ca(e, r, t);
    let { node: n } = e,
     i = !1;
    if (('FunctionDeclaration' === n.type || 'FunctionExpression' === n.type) && null != s && s.expandLastArg) {
     let { parent: t } = e;
     Ee(t) && (He(t).length > 1 || ze(n).every((e) => 'Identifier' === e.type && !e.typeAnnotation)) && (i = !0);
    }
    let a = [$i(e), n.async ? 'async ' : '', `function${n.generator ? '*' : ''} `, n.id ? t('id') : ''],
     o = yi(e, t, r, i),
     u = da(e, t),
     l = gi(n, u);
    return a.push(Wi(e, 0, t), Yt([l ? Yt(o) : o, u]), n.body ? ' ' : '', t('body')), r.semi && (n.declare || !n.body) && a.push(';'), a;
   }
   function pa(e, t, r) {
    let { node: s } = e,
     { kind: n } = s,
     i = s.value || s,
     a = [];
    return n && 'init' !== n && 'method' !== n && 'constructor' !== n ? (P.ok('get' === n || 'set' === n), a.push(n, ' ')) : i.async && a.push('async '), i.generator && a.push('*'), a.push(aa(e, t, r), s.optional || s.key.optional ? '?' : '', s === i ? ca(e, t, r) : r('value')), a;
   }
   function ca(e, t, r) {
    let { node: s } = e,
     n = yi(e, r, t),
     i = da(e, r),
     a = (function (e) {
      let t = ze(e);
      return t.length > 1 && t.some((e) => 'TSParameterProperty' === e.type);
     })(s),
     o = gi(s, i),
     u = [Wi(e, 0, r), Yt([a ? Yt(n, { shouldBreak: !0 }) : o ? Yt(n) : n, i])];
    return s.body ? u.push(' ', r('body')) : u.push(t.semi ? ';' : ''), u;
   }
   function ha(e, t) {
    if ('always' === t.arrowParens) return !1;
    if ('avoid' === t.arrowParens) {
     let { node: t } = e;
     return (function (e) {
      let t = ze(e);
      return !(1 !== t.length || e.typeParameters || et(e, Qe.Dangling) || 'Identifier' !== t[0].type || t[0].typeAnnotation || et(t[0]) || t[0].optional || e.predicate || e.returnType);
     })(t);
    }
    return !1;
   }
   function da(e, t) {
    let { node: r } = e,
     s = [Ni(e, t, 'returnType')];
    return r.predicate && s.push(t('predicate')), s;
   }
   function fa(e, t, r) {
    let { node: s } = e,
     n = t.semi ? ';' : '',
     i = [];
    if (s.argument) {
     let e = r('argument');
     !(function (e, t) {
      if (Fe(e.originalText, t) || (et(t, Qe.Leading, (t) => Cr(e.originalText, O(t), L(t))) && !pe(t))) return !0;
      if (K(t)) {
       let r,
        s = t;
       for (; (r = X(s)); ) if (((s = r), Fe(e.originalText, s))) return !0;
      }
      return !1;
     })(t, s.argument)
      ? (de(s.argument) || 'SequenceExpression' === s.argument.type || (t.experimentalTernaries && 'ConditionalExpression' === s.argument.type && ('ConditionalExpression' === s.argument.consequent.type || 'ConditionalExpression' === s.argument.alternate.type))) && (e = Yt([rr('('), Xt([lr, e]), lr, rr(')')]))
      : (e = ['(', Xt([pr, e]), pr, ')']),
      i.push(' ', e);
    }
    let a = et(s, Qe.Dangling),
     o = n && a && et(s, Qe.Last | Qe.Line);
    return o && i.push(n), a && i.push(' ', Cn(e, t)), o || i.push(n), i;
   }
   var ma = new WeakMap();
   function ya(e) {
    return ma.has(e) || ma.set(e, 'ConditionalExpression' === e.type && !Me(e, (e) => 'ObjectExpression' === e.type)), ma.get(e);
   }
   var Da = (e) => 'SequenceExpression' === e.type;
   function ga(e, t, r, s = {}) {
    let n,
     i,
     a = [],
     o = [],
     u = !1,
     l = !s.expandLastArg && 'ArrowFunctionExpression' === e.node.body.type;
    !(function p() {
     let { node: c } = e,
      h = (function (e, t, r, s) {
       let { node: n } = e,
        i = [];
       if ((n.async && i.push('async '), ha(e, t))) i.push(r(['params', 0]));
       else {
        let n = s.expandLastArg || s.expandFirstArg,
         a = da(e, r);
        if (n) {
         if (Mt(a)) throw new Qn();
         a = Yt(Rt(a));
        }
        i.push(Yt([yi(e, r, t, n, !0), a]));
       }
       let a = Cn(e, t, {
        filter(e) {
         let r = Tr(t.originalText, L(e));
         return !1 !== r && '=>' === t.originalText.slice(r, r + 2);
        },
       });
       return a && i.push(' ', a), i;
      })(e, t, r, s);
     if (0 === a.length) a.push(h);
     else {
      let { leading: r, trailing: s } = vn(e, t);
      a.push([r, h]), o.unshift(s);
     }
     l && (u || (u = (c.returnType && ze(c).length > 0) || c.typeParameters || ze(c).some((e) => 'Identifier' !== e.type))), l && 'ArrowFunctionExpression' === c.body.type ? e.call(p, 'body') : ((n = r('body', s)), (i = c.body));
    })();
    let p =
      !Fe(t.originalText, i) &&
      (Da(i) ||
       (function (e, t, r) {
        var s, n;
        return Z(e) || ee(e) || 'ArrowFunctionExpression' === e.type || 'DoExpression' === e.type || 'BlockStatement' === e.type || pe(e) || (!1 !== (null == (s = t.label) ? void 0 : s.hug) && ((null == (n = t.label) ? void 0 : n.embed) || Se(e, r.originalText)));
       })(i, n, t) ||
       (!u && ya(i))),
     c = 'callee' === e.key && st(e.parent),
     h = Symbol('arrow-chain'),
     d = (function (e, t, { signatureDocs: r, shouldBreak: s }) {
      if (1 === r.length) return r[0];
      let { parent: n, key: i } = e;
      return ('callee' !== i && st(n)) || de(n) ? Yt([r[0], ' =>', Xt([ur, dr([' =>', ur], r.slice(1))])], { shouldBreak: s }) : ('callee' === i && st(n)) || t.assignmentLayout ? Yt(dr([' =>', ur], r), { shouldBreak: s }) : Yt(Xt(dr([' =>', ur], r)), { shouldBreak: s });
     })(e, s, { signatureDocs: a, shouldBreak: u }),
     f = !1,
     m = !1,
     y = !1;
    return (
     l && (c || s.assignmentLayout) && ((m = !0), (y = !et(e.node, Qe.Leading & Qe.Line)), (f = 'chain-tail-arrow-chain' === s.assignmentLayout || (c && !p))),
     (n = (function (e, t, r, { bodyDoc: s, bodyComments: n, functionBody: i, shouldPutBodyOnSameLine: a }) {
      let { node: o, parent: u } = e,
       l = r.expandLastArg && Le(t, 'all') ? rr(',') : '',
       p = (!r.expandLastArg && 'JSXExpressionContainer' !== u.type) || et(o) ? '' : lr;
      return a && ya(i) ? [' ', Yt([rr('', '('), Xt([lr, s]), rr('', ')'), l, p]), n] : (Da(i) && (s = Yt(['(', Xt([lr, s]), lr, ')'])), a ? [' ', s, n] : [Xt([ur, s, n]), l, p]);
     })(e, t, s, { bodyDoc: n, bodyComments: o, functionBody: i, shouldPutBodyOnSameLine: p })),
     Yt([Yt(m ? Xt([y ? lr : '', d]) : d, { shouldBreak: f, id: h }), ' =>', l ? sr(n, { groupId: h }) : Yt(n), l && c ? rr(lr, '', { groupId: h }) : ''])
    );
   }
   var xa = (e, t, r) => {
    if (!e || null != t) {
     if (t.findLast) return t.findLast(r);
     for (let e = t.length - 1; e >= 0; e--) {
      let s = t[e];
      if (r(s, e, t)) return s;
     }
    }
   };
   function Ea(e, t, r, s) {
    let { node: n } = e,
     i = [],
     a = xa(!1, n[s], (e) => 'EmptyStatement' !== e.type);
    return (
     e.each(({ node: e }) => {
      'EmptyStatement' !== e.type && (i.push(r()), e !== a && (i.push(pr), rt(e, t) && i.push(pr)));
     }, s),
     i
    );
   }
   function ba(e, t, r) {
    let s = (function (e, t, r) {
      let { node: s } = e,
       n = w(s.directives),
       i = s.body.some((e) => 'EmptyStatement' !== e.type),
       a = et(s, Qe.Dangling);
      if (!n && !i && !a) return '';
      let o = [];
      return n && (o.push(Ea(e, t, r, 'directives')), (i || a) && (o.push(pr), rt(c(!1, s.directives, -1), t) && o.push(pr))), i && o.push(Ea(e, t, r, 'body')), a && o.push(Cn(e, t)), o;
     })(e, t, r),
     { node: n, parent: i } = e;
    if ('Program' === n.type && 'ModuleExpression' !== (null == i ? void 0 : i.type)) return s ? [s, pr] : '';
    let a = [];
    if (('StaticBlock' === n.type && a.push('static '), a.push('{'), s)) a.push(Xt([pr, s]), pr);
    else {
     let t = e.grandparent;
     'ArrowFunctionExpression' === i.type || 'FunctionExpression' === i.type || 'FunctionDeclaration' === i.type || 'ComponentDeclaration' === i.type || 'HookDeclaration' === i.type || 'ObjectMethod' === i.type || 'ClassMethod' === i.type || 'ClassPrivateMethod' === i.type || 'ForStatement' === i.type || 'WhileStatement' === i.type || 'DoWhileStatement' === i.type || 'DoExpression' === i.type || 'ModuleExpression' === i.type || ('CatchClause' === i.type && !t.finalizer) || 'TSModuleDeclaration' === i.type || 'StaticBlock' === n.type || a.push(pr);
    }
    return a.push('}'), a;
   }
   var Ta = function (e) {
    let t = new WeakMap();
    return function (r) {
     return t.has(r) || t.set(r, Symbol(e)), t.get(r);
    };
   };
   function Aa(e) {
    switch (e) {
     case null:
      return '';
     case 'PlusOptional':
      return '+?';
     case 'MinusOptional':
      return '-?';
     case 'Optional':
      return '?';
    }
   }
   function Ca(e, t) {
    return '+' === e || '-' === e ? e + t : t;
   }
   var va = Ta('typeParameters');
   function Fa(e, t, r, s) {
    let { node: n } = e;
    if (!n[s]) return '';
    if (!Array.isArray(n[s])) return r(s);
    let i = ge(e.grandparent),
     a = e.match(
      (e) => !(1 === e[s].length && oe(e[s][0])),
      void 0,
      (e, t) => 'typeAnnotation' === t,
      (e) => 'Identifier' === e.type,
      hi,
     );
    if (0 === n[s].length || (!a && (i || (1 === n[s].length && ('NullableTypeAnnotation' === n[s][0].type || bi(n[s][0])))))) return ['<', dr(', ', e.map(r, s)), wa(e, t), '>'];
    let o =
     'TSTypeParameterInstantiation' === n.type
      ? ''
      : (function (e, t, r) {
           let { node: s } = e;
           return 1 === ze(s).length && s.type.startsWith('TS') && !s[r][0].constraint && 'ArrowFunctionExpression' === e.parent.type && !(t.filepath && /\.ts$/u.test(t.filepath));
          })(e, t, s)
        ? ','
        : Le(t)
          ? rr(',')
          : '';
    return Yt(['<', Xt([lr, dr([',', ur], e.map(r, s))]), o, lr, '>'], { id: va(n) });
   }
   function wa(e, t) {
    let { node: r } = e;
    if (!et(r, Qe.Dangling)) return '';
    let s = !et(r, Qe.Line),
     n = Cn(e, t, { indent: !s });
    return s ? n : [n, pr];
   }
   function Sa(e, t, r) {
    let { node: s, parent: n } = e,
     i = [s.const ? 'const ' : ''],
     a = 'TSTypeParameter' === s.type ? r('name') : s.name;
    if ('TSMappedType' === n.type)
     return (
      n.readonly && i.push(Ca(n.readonly, 'readonly'), ' '),
      i.push('[', a),
      s.constraint && i.push(' in ', r('constraint')),
      n.nameType &&
       i.push(
        ' as ',
        e.callParent(() => r('nameType')),
       ),
      i.push(']'),
      i
     );
    if ((s.variance && i.push(r('variance')), s.in && i.push('in '), s.out && i.push('out '), i.push(a), s.bound && (s.usesExtendsBound && i.push(' extends '), i.push(Ni(e, r, 'bound'))), s.constraint)) {
     let e = Symbol('constraint');
     i.push(' extends', Yt(Xt(ur), { id: e }), ir, sr(r('constraint'), { groupId: e }));
    }
    return s.default && i.push(' = ', r('default')), Yt(i);
   }
   var Pa = q(['ClassProperty', 'PropertyDefinition', 'ClassPrivateProperty', 'ClassAccessorProperty', 'AccessorProperty', 'TSAbstractPropertyDefinition', 'TSAbstractAccessorProperty']);
   function ka(e, t, r) {
    let s,
     { node: n } = e,
     i = [$i(e), Ji(e), 'class'],
     a = et(n.id, Qe.Trailing) || et(n.typeParameters, Qe.Trailing) || et(n.superClass) || w(n.extends) || w(n.mixins) || w(n.implements),
     o = [],
     u = [];
    if ((n.id && o.push(' ', r('id')), o.push(r('typeParameters')), n.superClass)) {
     let s = [La(e, t, r), r(n.superTypeArguments ? 'superTypeArguments' : 'superTypeParameters')],
      i = e.call((e) => ['extends ', Fn(e, s, t)], 'superClass');
     a ? u.push(ur, Yt(i)) : u.push(' ', i);
    } else u.push(Oa(e, t, r, 'extends'));
    if ((u.push(Oa(e, t, r, 'mixins'), Oa(e, t, r, 'implements')), a)) {
     let e;
     (e = Ba(n) ? [...o, Xt(u)] : Xt([...o, u])), (s = Ia(n)), i.push(Yt(e, { id: s }));
    } else i.push(...o, ...u);
    let l = n.body;
    return a && w(l.body) ? i.push(rr(pr, ' ', { groupId: s })) : i.push(' '), i.push(r('body')), i;
   }
   var Ia = Ta('heritageGroup');
   function Na(e) {
    return rr(pr, '', { groupId: Ia(e) });
   }
   function Ba(e) {
    return (
     e.typeParameters &&
     !et(e.typeParameters, Qe.Trailing | Qe.Line) &&
     !(function (e) {
      return ['extends', 'mixins', 'implements'].reduce((t, r) => t + (Array.isArray(e[r]) ? e[r].length : 0), e.superClass ? 1 : 0) > 1;
     })(e)
    );
   }
   function Oa(e, t, r, s) {
    let { node: n } = e;
    if (!w(n[s])) return '';
    let i = Cn(e, t, { marker: s });
    return [Ba(n) ? rr(' ', ur, { groupId: va(n.typeParameters) }) : ur, i, i && pr, s, Yt(Xt([ur, dr([',', ur], e.map(r, s))]))];
   }
   function La(e, t, r) {
    let s = r('superClass'),
     { parent: n } = e;
    return 'AssignmentExpression' === n.type ? Yt(rr(['(', Xt([lr, s]), lr, ')'], s)) : s;
   }
   function Ma(e, t, r) {
    let { node: s } = e,
     n = [];
    return w(s.decorators) && n.push(Kn(e, t, r)), n.push(Ki(s)), s.static && n.push('static '), n.push(Ji(e)), s.override && n.push('override '), n.push(pa(e, t, r)), n;
   }
   function ja(e, t, r) {
    let { node: s } = e,
     n = [],
     i = t.semi ? ';' : '';
    return w(s.decorators) && n.push(Kn(e, t, r)), n.push($i(e), Ki(s)), s.static && n.push('static '), n.push(Ji(e)), s.override && n.push('override '), s.readonly && n.push('readonly '), s.variance && n.push(r('variance')), ('ClassAccessorProperty' === s.type || 'AccessorProperty' === s.type || 'TSAbstractAccessorProperty' === s.type) && n.push('accessor '), n.push(aa(e, t, r), _i(e), Ri(e), Ni(e, r)), [ui(e, t, r, n, ' =', 'TSAbstractPropertyDefinition' === s.type || 'TSAbstractAccessorProperty' === s.type ? void 0 : 'value'), i];
   }
   function _a(e, t, r) {
    let { node: s } = e,
     n = [];
    return (
     e.each(({ node: e, next: s, isLast: i }) => {
      n.push(r()),
       !t.semi &&
        Pa(e) &&
        (function (e, t) {
         var r;
         let { type: s, name: n } = e.key;
         if (!(e.computed || 'Identifier' !== s || ('static' !== n && 'get' !== n && 'set' !== n) || e.value || e.typeAnnotation)) return !0;
         if (!t || t.static || t.accessibility || t.readonly) return !1;
         if (!t.computed) {
          let e = null == (r = t.key) ? void 0 : r.name;
          if ('in' === e || 'instanceof' === e) return !0;
         }
         if (Pa(t) && t.variance && !t.static && !t.declare) return !0;
         switch (t.type) {
          case 'ClassProperty':
          case 'PropertyDefinition':
          case 'TSAbstractPropertyDefinition':
           return t.computed;
          case 'MethodDefinition':
          case 'TSAbstractMethodDefinition':
          case 'ClassMethod':
          case 'ClassPrivateMethod': {
           if ((t.value ? t.value.async : t.async) || 'get' === t.kind || 'set' === t.kind) return !1;
           let e = t.value ? t.value.generator : t.generator;
           return !(!t.computed && !e);
          }
          case 'TSIndexSignature':
           return !0;
         }
         return !1;
        })(e, s) &&
        n.push(';'),
       i || (n.push(pr), rt(e, t) && n.push(pr));
     }, 'body'),
     et(s, Qe.Dangling) && n.push(Cn(e, t)),
     ['{', n.length > 0 ? [Xt([pr, n]), pr] : '', '}']
    );
   }
   var Ra = q(['TSAsExpression', 'TSTypeAssertion', 'TSNonNullExpression', 'TSInstantiationExpression', 'TSSatisfiesExpression']);
   function Ua(e) {
    return Ra(e) ? Ua(e.expression) : e;
   }
   var $a = q(['FunctionExpression', 'ArrowFunctionExpression']);
   function qa(e, t) {
    if (t.semi || Wa(e, t) || za(e, t)) return !1;
    let { node: r, key: s, parent: n } = e;
    return !('ExpressionStatement' !== r.type || (('body' !== s || ('Program' !== n.type && 'BlockStatement' !== n.type && 'StaticBlock' !== n.type && 'TSModuleBlock' !== n.type)) && ('consequent' !== s || 'SwitchCase' !== n.type)) || !e.call(() => Ja(e, t), 'expression'));
   }
   function Ja(e, t) {
    let { node: r } = e;
    switch (r.type) {
     case 'ParenthesizedExpression':
     case 'TypeCastExpression':
     case 'ArrayExpression':
     case 'ArrayPattern':
     case 'TemplateLiteral':
     case 'TemplateElement':
     case 'RegExpLiteral':
      return !0;
     case 'ArrowFunctionExpression':
      if (!ha(e, t)) return !0;
      break;
     case 'UnaryExpression': {
      let { prefix: e, operator: t } = r;
      if (e && ('+' === t || '-' === t)) return !0;
      break;
     }
     case 'BindExpression':
      if (!r.object) return !0;
      break;
     case 'Literal':
      if (r.regex) return !0;
      break;
     default:
      if (pe(r)) return !0;
    }
    return !!En(e, t) || (!!K(r) && e.call(() => Ja(e, t), ...G(r)));
   }
   function Wa({ node: e, parent: t }, r) {
    return ('markdown' === r.parentParser || 'mdx' === r.parentParser) && 'ExpressionStatement' === e.type && pe(e.expression) && 'Program' === t.type && 1 === t.body.length;
   }
   function za({ node: e, parent: t }, r) {
    return ('__vue_event_binding' === r.parser || '__vue_ts_event_binding' === r.parser) && 'ExpressionStatement' === e.type && 'Program' === t.type && 1 === t.body.length;
   }
   function Va(e, t, r) {
    let s = [r('expression')];
    if (za(e, t)) {
     let t = Ua(e.node.expression);
     ($a(t) ||
      (function (e) {
       return 'MemberExpression' === e.type || 'OptionalMemberExpression' === e.type || ('Identifier' === e.type && 'undefined' !== e.name);
      })(t)) &&
      s.push(';');
    } else Wa(e, t) || (t.semi && s.push(';'));
    return s;
   }
   function Ha(e) {
    return e.toLowerCase();
   }
   function Ka({ pattern: e, flags: t }) {
    return `/${e}/${(t = [...t].sort().join(''))}`;
   }
   function Xa(e, t) {
    let r = e.slice(1, -1);
    if (r.includes('"') || r.includes("'")) return e;
    let s = t.singleQuote ? "'" : '"';
    return s + r + s;
   }
   var Ga = function (e, t, r) {
    let s = e.originalText.slice(t, r);
    for (let n of e[Symbol.for('comments')]) {
     let e = O(n);
     if (e > r) break;
     let i = L(n);
     if (i < t) continue;
     let a = i - e;
     s = s.slice(0, e - t) + ' '.repeat(a) + s.slice(i - t);
    }
    return s;
   };
   var Ya = (e) => 'ExportDefaultDeclaration' === e.type || ('DeclareExportDeclaration' === e.type && e.default);
   function Qa(e, t, r) {
    let { node: s } = e,
     n = [Xn(e, 0, r), $i(e), 'export', Ya(s) ? ' default' : ''],
     { declaration: i, exported: a } = s;
    return (
     et(s, Qe.Dangling) && (n.push(' ', Cn(e, t)), Pe(s) && n.push(pr)),
     i
      ? n.push(' ', r('declaration'))
      : (n.push(
         (function (e) {
          return eo(e.exportKind);
         })(s),
        ),
        'ExportAllDeclaration' === s.type || 'DeclareExportAllDeclaration' === s.type ? (n.push(' *'), a && n.push(' as ', r('exported'))) : n.push(so(e, t, r)),
        n.push(ro(e, t, r), io(e, t, r))),
     n.push(
      (function (e, t) {
       return t.semi && (!e.declaration || (Ya(e) && !Za(e.declaration))) ? ';' : '';
      })(s, t),
     ),
     n
    );
   }
   var Za = q(['ClassDeclaration', 'ComponentDeclaration', 'FunctionDeclaration', 'TSInterfaceDeclaration', 'DeclareClass', 'DeclareComponent', 'DeclareFunction', 'DeclareHook', 'HookDeclaration', 'TSDeclareFunction', 'EnumDeclaration']);
   function eo(e, t = !0) {
    return e && 'value' !== e ? `${t ? ' ' : ''}${e}${t ? '' : ' '}` : '';
   }
   function to(e, t) {
    return eo(e.importKind, t);
   }
   function ro(e, t, r) {
    let { node: s } = e;
    if (!s.source) return '';
    let n = [];
    return no(s, t) && n.push(' from'), n.push(' ', r('source')), n;
   }
   function so(e, t, r) {
    let { node: s } = e;
    if (!no(s, t)) return '';
    let n = [' '];
    if (w(s.specifiers)) {
     let i = [],
      a = [];
     e.each(() => {
      let t = e.node.type;
      if ('ExportNamespaceSpecifier' === t || 'ExportDefaultSpecifier' === t || 'ImportNamespaceSpecifier' === t || 'ImportDefaultSpecifier' === t) i.push(r());
      else {
       if ('ExportSpecifier' !== t && 'ImportSpecifier' !== t) throw new wn(s, 'specifier');
       a.push(r());
      }
     }, 'specifiers'),
      n.push(dr(', ', i)),
      a.length > 0 && (i.length > 0 && n.push(', '), a.length > 1 || i.length > 0 || s.specifiers.some((e) => et(e)) ? n.push(Yt(['{', Xt([t.bracketSpacing ? ur : lr, dr([',', ur], a)]), rr(Le(t) ? ',' : ''), t.bracketSpacing ? ur : lr, '}'])) : n.push(['{', t.bracketSpacing ? ' ' : '', ...a, t.bracketSpacing ? ' ' : '', '}']));
    } else n.push('{}');
    return n;
   }
   function no(e, t) {
    return !('ImportDeclaration' === e.type && !w(e.specifiers) && 'type' !== e.importKind) || Ga(t, O(e), O(e.source)).trimEnd().endsWith('from');
   }
   function io(e, t, r) {
    let { node: s } = e;
    if (!s.source) return '';
    let n = (function (e, t) {
     var r, s;
     if (null != (r = e.extra) && r.deprecatedAssertSyntax) return 'assert';
     let n = Ga(t, L(e.source), null != (s = e.attributes) && s[0] ? O(e.attributes[0]) : L(e)).trimStart();
     return n.startsWith('assert') ? 'assert' : n.startsWith('with') || w(e.attributes) ? 'with' : void 0;
    })(s, t);
    if (!n) return '';
    let i = [` ${n} {`];
    return w(s.attributes) && (t.bracketSpacing && i.push(' '), i.push(dr(', ', e.map(r, 'attributes'))), t.bracketSpacing && i.push(' ')), i.push('}'), i;
   }
   function ao(e, t, r) {
    let { node: s } = e,
     { type: n } = s,
     i = n.startsWith('Import'),
     a = i ? 'imported' : 'local',
     o = i ? 'local' : 'exported',
     u = s[a],
     l = s[o],
     p = '',
     c = '';
    return (
     'ExportNamespaceSpecifier' === n || 'ImportNamespaceSpecifier' === n ? (p = '*') : u && (p = r(a)),
     l &&
      !(function (e) {
       if ('ImportSpecifier' !== e.type && 'ExportSpecifier' !== e.type) return !1;
       let { local: t, ['ImportSpecifier' === e.type ? 'imported' : 'exported']: r } = e;
       if (t.type !== r.type || !j(t, r)) return !1;
       if (se(t)) return t.value === r.value && Be(t) === Be(r);
       if ('Identifier' === t.type) return t.name === r.name;
       return !1;
      })(s) &&
      (c = r(o)),
     [eo('ImportSpecifier' === n ? s.importKind : s.exportKind, !1), p, p && c ? ' as ' : '', c]
    );
   }
   function oo(e, t, r) {
    var s;
    let n = t.semi ? ';' : '',
     { node: i } = e,
     a = 'ObjectTypeAnnotation' === i.type,
     o = 'TSEnumDeclaration' === i.type || 'EnumBooleanBody' === i.type || 'EnumNumberBody' === i.type || 'EnumBigIntBody' === i.type || 'EnumStringBody' === i.type || 'EnumSymbolBody' === i.type,
     u = ['TSTypeLiteral' === i.type || o ? 'members' : 'TSInterfaceBody' === i.type ? 'body' : 'properties'];
    a && u.push('indexers', 'callProperties', 'internalSlots');
    let l = u.flatMap((t) => e.map(({ node: e }) => ({ node: e, printed: r(), loc: O(e) }), t));
    u.length > 1 && l.sort((e, t) => e.loc - t.loc);
    let { parent: p, key: h } = e,
     d = a && 'body' === h && ('InterfaceDeclaration' === p.type || 'DeclareInterface' === p.type || 'DeclareClass' === p.type),
     f = 'TSInterfaceBody' === i.type || o || d || ('ObjectPattern' === i.type && 'FunctionDeclaration' !== p.type && 'FunctionExpression' !== p.type && 'ArrowFunctionExpression' !== p.type && 'ObjectMethod' !== p.type && 'ClassMethod' !== p.type && 'ClassPrivateMethod' !== p.type && 'AssignmentPattern' !== p.type && 'CatchClause' !== p.type && i.properties.some((e) => e.value && ('ObjectPattern' === e.value.type || 'ArrayPattern' === e.value.type))) || ('ObjectPattern' !== i.type && 'preserve' === t.objectWrap && l.length > 0 && Cr(t.originalText, O(i), l[0].loc)),
     m = d ? ';' : 'TSInterfaceBody' === i.type || 'TSTypeLiteral' === i.type ? rr(n, ';') : ',',
     y = 'RecordExpression' === i.type ? '#{' : i.exact ? '{|' : '{',
     D = i.exact ? '|}' : '}',
     g = [],
     x = l.map((e) => {
      let r = [...g, Yt(e.printed)];
      return (g = [m, ur]), ('TSPropertySignature' === e.node.type || 'TSMethodSignature' === e.node.type || 'TSConstructSignatureDeclaration' === e.node.type || 'TSCallSignatureDeclaration' === e.node.type) && et(e.node, Qe.PrettierIgnore) && g.shift(), rt(e.node, t) && g.push(pr), r;
     });
    if (i.inexact || i.hasUnknownMembers) {
     let r;
     if (et(i, Qe.Dangling)) {
      let s = et(i, Qe.Line);
      r = [Cn(e, t), s || A(t.originalText, L(c(!1, tt(i), -1))) ? pr : ur, '...'];
     } else r = ['...'];
     x.push([...g, ...r]);
    }
    let E,
     b = null == (s = c(!1, l, -1)) ? void 0 : s.node,
     T = !(i.inexact || i.hasUnknownMembers || (b && ('RestElement' === b.type || (('TSPropertySignature' === b.type || 'TSCallSignatureDeclaration' === b.type || 'TSMethodSignature' === b.type || 'TSConstructSignatureDeclaration' === b.type) && et(b, Qe.PrettierIgnore)))));
    if (0 === x.length) {
     if (!et(i, Qe.Dangling)) return [y, D, Ni(e, r)];
     E = Yt([y, Cn(e, t, { indent: !0 }), lr, D, _i(e), Ni(e, r)]);
    } else E = [d && w(i.properties) ? Na(p) : '', y, Xt([t.bracketSpacing ? ur : lr, ...x]), rr(T && (',' !== m || Le(t)) ? m : ''), t.bracketSpacing ? ur : lr, D, _i(e), Ni(e, r)];
    return e.match((e) => 'ObjectPattern' === e.type && !w(e.decorators), uo) ||
     (oe(i) &&
      (e.match(
       void 0,
       (e, t) => 'typeAnnotation' === t,
       (e, t) => 'typeAnnotation' === t,
       uo,
      ) ||
       e.match(void 0, (e, t) => 'FunctionTypeParam' === e.type && 'typeAnnotation' === t, uo))) ||
     (!f &&
      e.match(
       (e) => 'ObjectPattern' === e.type,
       (e) => 'AssignmentExpression' === e.type || 'VariableDeclarator' === e.type,
      ))
     ? E
     : Yt(E, { shouldBreak: f });
   }
   function uo(e, t) {
    return ('params' === t || 'parameters' === t || 'this' === t || 'rest' === t) && Di(e);
   }
   function lo(e, t, r) {
    let { node: s } = e,
     n = 'ConditionalExpression' === s.type,
     i = n ? 'alternate' : 'falseType',
     { parent: a } = e,
     o = n ? r('test') : [r('checkType'), ' ', 'extends', ' ', r('extendsType')];
    return a.type === s.type && a[i] === s ? Gt(2, o) : o;
   }
   var po = new Map([
    ['AssignmentExpression', 'right'],
    ['VariableDeclarator', 'init'],
    ['ReturnStatement', 'argument'],
    ['ThrowStatement', 'argument'],
    ['UnaryExpression', 'argument'],
    ['YieldExpression', 'argument'],
    ['AwaitExpression', 'argument'],
   ]);
   function co(e, t, r) {
    let s,
     n,
     { node: i } = e,
     a = 'ConditionalExpression' === i.type,
     o = a ? 'consequent' : 'trueType',
     u = a ? 'alternate' : 'falseType',
     l = a ? ['test'] : ['checkType', 'extendsType'],
     p = i[o],
     c = i[u],
     h = [],
     d = !1,
     { parent: f } = e,
     m = f.type === i.type && l.some((e) => f[e] === i),
     y = f.type === i.type && !m,
     D = 0;
    do {
     (n = s || i), (s = e.getParentNode(D)), D++;
    } while (s && s.type === i.type && l.every((e) => s[e] !== n));
    let g = s || f,
     x = n;
    if (
     a &&
     (pe(i[l[0]]) ||
      pe(p) ||
      pe(c) ||
      (function (e) {
       let t = [e];
       for (let r = 0; r < t.length; r++) {
        let e = t[r];
        for (let r of ['test', 'consequent', 'alternate']) {
         let s = e[r];
         if (pe(s)) return !0;
         'ConditionalExpression' === s.type && t.push(s);
        }
       }
       return !1;
      })(x))
    ) {
     (d = !0), (y = !0);
     let e = (e) => [rr('('), Xt([lr, e]), lr, rr(')')],
      t = (e) => 'NullLiteral' === e.type || ('Literal' === e.type && null === e.value) || ('Identifier' === e.type && 'undefined' === e.name);
     h.push(' ? ', t(p) ? r(o) : e(r(o)), ' : ', c.type === i.type || t(c) ? r(u) : e(r(u)));
    } else {
     let e = (e) => (t.useTabs ? Xt(r(e)) : Gt(2, r(e))),
      s = [ur, '? ', p.type === i.type ? rr('', '(') : '', e(o), p.type === i.type ? rr('', ')') : '', ur, ': ', e(u)];
     h.push(f.type !== i.type || f[u] === i || m ? s : t.useTabs ? Zt(Xt(s)) : Gt(Math.max(0, t.tabWidth - 2), s));
    }
    let E = [o, u, ...l].some((e) => et(i[e], (e) => J(e) && Cr(t.originalText, O(e), L(e)))),
     b = !d && (be(f) || ('NGPipeExpression' === f.type && f.left === i)) && !f.computed,
     T = (function (e) {
      let { node: t } = e;
      if ('ConditionalExpression' !== t.type) return !1;
      let r,
       s = t;
      for (let n = 0; !r; n++) {
       let t = e.getParentNode(n);
       ('ChainExpression' === t.type && t.expression === s) || (Ee(t) && t.callee === s) || (be(t) && t.object === s) || ('TSNonNullExpression' === t.type && t.expression === s) ? (s = t) : ('NewExpression' === t.type && t.callee === s) || (it(t) && t.expression === s) ? ((r = e.getParentNode(n + 1)), (s = t)) : (r = t);
      }
      return s !== t && r[po.get(r.type)] === s;
     })(e),
     A = ((C = [lo(e, 0, r), y ? h : Xt(h), a && b && !T ? lr : '']), f === g ? Yt(C, { shouldBreak: E }) : E ? [C, ar] : C);
    var C;
    return m || T ? Yt([Xt([lr, A]), lr]) : A;
   }
   var ho = new Map([
    ['AssignmentExpression', 'right'],
    ['VariableDeclarator', 'init'],
    ['ReturnStatement', 'argument'],
    ['ThrowStatement', 'argument'],
    ['UnaryExpression', 'argument'],
    ['YieldExpression', 'argument'],
    ['AwaitExpression', 'argument'],
   ]);
   var fo = (e) => [rr('('), Xt([lr, e]), lr, rr(')')];
   function mo(e, t, r, s) {
    if (!t.experimentalTernaries) return co(e, t, r);
    let n,
     i,
     { node: a } = e,
     o = 'ConditionalExpression' === a.type,
     u = 'TSConditionalType' === a.type || 'ConditionalTypeAnnotation' === a.type,
     l = o ? 'consequent' : 'trueType',
     p = o ? 'alternate' : 'falseType',
     c = o ? ['test'] : ['checkType', 'extendsType'],
     h = a[l],
     d = a[p],
     f = c.map((e) => a[e]),
     { parent: m } = e,
     y = m.type === a.type,
     D = y && c.some((e) => m[e] === a),
     g = y && m[p] === a,
     x = h.type === a.type,
     E = d.type === a.type,
     b = E || g,
     T = t.tabWidth > 2 || t.useTabs,
     A = 0;
    do {
     (i = n || a), (n = e.getParentNode(A)), A++;
    } while (n && n.type === a.type && c.every((e) => n[e] !== i));
    let C = n || m,
     v = s && s.assignmentLayout && 'break-after-operator' !== s.assignmentLayout && ('AssignmentExpression' === m.type || 'VariableDeclarator' === m.type || 'ClassProperty' === m.type || 'PropertyDefinition' === m.type || 'ClassPrivateProperty' === m.type || 'ObjectProperty' === m.type || 'Property' === m.type),
     F = ('ReturnStatement' === m.type || 'ThrowStatement' === m.type) && !(x || E),
     w = o && 'JSXExpressionContainer' === C.type && 'JSXAttribute' !== e.grandparent.type,
     S = (function (e) {
      let { node: t } = e;
      if ('ConditionalExpression' !== t.type) return !1;
      let r,
       s = t;
      for (let n = 0; !r; n++) {
       let t = e.getParentNode(n);
       ('ChainExpression' === t.type && t.expression === s) || (Ee(t) && t.callee === s) || (be(t) && t.object === s) || ('TSNonNullExpression' === t.type && t.expression === s) ? (s = t) : ('NewExpression' === t.type && t.callee === s) || (it(t) && t.expression === s) ? ((r = e.getParentNode(n + 1)), (s = t)) : (r = t);
      }
      return s !== t && r[ho.get(r.type)] === s;
     })(e),
     P = (function (e, t) {
      return (be(t) || ('NGPipeExpression' === t.type && t.left === e)) && !t.computed;
     })(a, m),
     k = u && En(e, t),
     I = T ? (t.useTabs ? '\t' : ' '.repeat(t.tabWidth - 1)) : '',
     N =
      (function (e, t, r, s) {
       return [...e.map((e) => tt(e)), tt(t), tt(r)].flat().some((e) => J(e) && Cr(s.originalText, O(e), L(e)));
      })(f, h, d, t) ||
      x ||
      E,
     B = !b && !y && !u && (w ? 'NullLiteral' === h.type || ('Literal' === h.type && null === h.value) : ve(h, t) && Te(a.test, 3)),
     M = b || g || (u && !y) || (y && o && Te(a.test, 1)) || B,
     j = [];
    !x &&
     et(h, Qe.Dangling) &&
     e.call((e) => {
      j.push(Cn(e, t), pr);
     }, 'consequent');
    let _ = [];
    et(a.test, Qe.Dangling) &&
     e.call((e) => {
      _.push(Cn(e, t));
     }, 'test'),
     !E &&
      et(d, Qe.Dangling) &&
      e.call((e) => {
       _.push(Cn(e, t));
      }, 'alternate'),
     et(a, Qe.Dangling) && _.push(Cn(e, t));
    let R = Symbol('test'),
     U = Symbol('consequent'),
     $ = Symbol('test-and-consequent'),
     q = o ? [fo(r('test')), 'ConditionalExpression' === a.test.type ? ar : ''] : [r('checkType'), ' ', 'extends', ' ', 'TSConditionalType' === a.extendsType.type || 'ConditionalTypeAnnotation' === a.extendsType.type || 'TSMappedType' === a.extendsType.type ? r('extendsType') : Yt(fo(r('extendsType')))],
     W = Yt([q, ' ?'], { id: R }),
     z = r(l),
     V = Xt([x || (w && (pe(h) || y || b)) ? pr : ur, j, z]),
     H = M ? Yt([W, b ? V : rr(V, Yt(V, { id: U }), { groupId: R })], { id: $ }) : [W, V],
     K = r(p),
     X = B ? rr(K, Zt(fo(K)), { groupId: $ }) : K,
     G = [H, _.length > 0 ? [Xt([pr, _]), pr] : E ? pr : B ? rr(ur, ' ', { groupId: $ }) : ur, ':', E ? ' ' : T ? (M ? rr(I, rr(b || B ? ' ' : I, ' '), { groupId: $ }) : rr(I, ' ')) : ' ', E ? X : Yt([Xt(X), w && !B ? lr : '']), P && !S ? lr : '', N ? ar : ''];
    return v && !N ? Yt(Xt([lr, Yt(G)])) : v || F ? Yt(Xt(G)) : S || (u && D) ? Yt([Xt([lr, G]), k ? lr : '']) : m === C ? Yt(G) : G;
   }
   function yo(e, t, r, s) {
    let { node: n } = e;
    if (ie(n))
     return (function (e, t) {
      let { node: r } = e;
      switch (r.type) {
       case 'RegExpLiteral':
        return Ka(r);
       case 'BigIntLiteral':
        return Ha(r.extra.raw);
       case 'NumericLiteral':
        return ra(r.extra.raw);
       case 'StringLiteral':
        return $t(B(r.extra.raw, t));
       case 'NullLiteral':
        return 'null';
       case 'BooleanLiteral':
        return String(r.value);
       case 'DirectiveLiteral':
        return Xa(r.extra.raw, t);
       case 'Literal': {
        if (r.regex) return Ka(r.regex);
        if (r.bigint) return Ha(r.raw);
        let { value: s } = r;
        return 'number' == typeof s
         ? ra(r.raw)
         : 'string' == typeof s
           ? (function (e) {
              if ('expression' !== e.key) return;
              let { parent: t } = e;
              return 'ExpressionStatement' === t.type && t.directive;
             })(e)
             ? Xa(r.raw, t)
             : $t(B(r.raw, t))
           : String(s);
       }
      }
     })(e, t);
    let i = t.semi ? ';' : '',
     a = [];
    switch (n.type) {
     case 'JsExpressionRoot':
      return r('node');
     case 'JsonRoot':
      return [r('node'), pr];
     case 'File':
      return (
       (function (e, t, r) {
        if (t.__isVueBindings || t.__isVueForBindingLeft) {
         let s = e.map(r, 'program', 'body', 0, 'params');
         if (1 === s.length) return s[0];
         let n = dr([',', ur], s);
         return t.__isVueForBindingLeft ? ['(', Xt([lr, Yt(n)]), lr, ')'] : n;
        }
        if (t.__isEmbeddedTypescriptGenericParameters) {
         let t = e.map(r, 'program', 'body', 0, 'typeParameters', 'params');
         return dr([',', ur], t);
        }
       })(e, t, r) ?? r('program')
      );
     case 'EmptyStatement':
      return '';
     case 'ExpressionStatement':
      return Va(e, t, r);
     case 'ChainExpression':
      return r('expression');
     case 'ParenthesizedExpression':
      return et(n.expression) || (!ee(n.expression) && !Z(n.expression)) ? Yt(['(', Xt([lr, r('expression')]), lr, ')']) : ['(', r('expression'), ')'];
     case 'AssignmentExpression':
      return (function (e, t, r) {
       let { node: s } = e;
       return ui(e, t, r, r('left'), [' ', s.operator], 'right');
      })(e, t, r);
     case 'VariableDeclarator':
      return (function (e, t, r) {
       return ui(e, t, r, r('id'), ' =', 'init');
      })(e, t, r);
     case 'BinaryExpression':
     case 'LogicalExpression':
      return $n(e, t, r);
     case 'AssignmentPattern':
      return [r('left'), ' = ', r('right')];
     case 'OptionalMemberExpression':
     case 'MemberExpression':
      return (function (e, t, r) {
       var s;
       let n = r('object'),
        i = ni(e, 0, r),
        { node: a } = e,
        o = e.findAncestor((e) => !(be(e) || 'TSNonNullExpression' === e.type)),
        u = e.findAncestor((e) => !('ChainExpression' === e.type || 'TSNonNullExpression' === e.type)),
        l = (o && ('NewExpression' === o.type || 'BindExpression' === o.type || ('AssignmentExpression' === o.type && 'Identifier' !== o.left.type))) || a.computed || ('Identifier' === a.object.type && 'Identifier' === a.property.type && !be(u)) || (('AssignmentExpression' === u.type || 'VariableDeclarator' === u.type) && (si(a.object) || (null == (s = n.label) ? void 0 : s.memberChain)));
       return fr(n.label, [n, l ? i : Yt(Xt([lr, i]))]);
      })(e, 0, r);
     case 'MetaProperty':
      return [r('meta'), '.', r('property')];
     case 'BindExpression':
      return n.object && a.push(r('object')), a.push(Yt(Xt([lr, zi(0, 0, r)]))), a;
     case 'Identifier':
      return [n.name, _i(e), Ri(e), Ni(e, r)];
     case 'V8IntrinsicIdentifier':
      return ['%', n.name];
     case 'SpreadElement':
     case 'SpreadElementPattern':
     case 'SpreadPropertyPattern':
     case 'RestElement':
      return Hi(e, r);
     case 'FunctionDeclaration':
     case 'FunctionExpression':
      return la(e, r, t, s);
     case 'ArrowFunctionExpression':
      return ga(e, t, r, s);
     case 'YieldExpression':
      return a.push('yield'), n.delegate && a.push('*'), n.argument && a.push(' ', r('argument')), a;
     case 'AwaitExpression':
      if ((a.push('await'), n.argument)) {
       a.push(' ', r('argument'));
       let { parent: t } = e;
       if ((Ee(t) && t.callee === n) || (be(t) && t.object === n)) {
        a = [Xt([lr, ...a]), lr];
        let t = e.findAncestor((e) => 'AwaitExpression' === e.type || 'BlockStatement' === e.type);
        if ('AwaitExpression' !== (null == t ? void 0 : t.type) || !Me(t.argument, (e) => e === n)) return Yt(a);
       }
      }
      return a;
     case 'ExportDefaultDeclaration':
     case 'ExportNamedDeclaration':
     case 'ExportAllDeclaration':
      return Qa(e, t, r);
     case 'ImportDeclaration':
      return (function (e, t, r) {
       let { node: s } = e;
       return ['import', s.phase ? ` ${s.phase}` : '', to(s), so(e, t, r), ro(e, t, r), io(e, t, r), t.semi ? ';' : ''];
      })(e, t, r);
     case 'ImportSpecifier':
     case 'ExportSpecifier':
     case 'ImportNamespaceSpecifier':
     case 'ExportNamespaceSpecifier':
     case 'ImportDefaultSpecifier':
     case 'ExportDefaultSpecifier':
      return ao(e, 0, r);
     case 'ImportAttribute':
     case 'ObjectProperty':
      return oa(e, t, r);
     case 'Program':
     case 'BlockStatement':
     case 'StaticBlock':
      return ba(e, t, r);
     case 'ClassBody':
      return _a(e, t, r);
     case 'ThrowStatement':
      return (function (e, t, r) {
       return ['throw', fa(e, t, r)];
      })(e, t, r);
     case 'ReturnStatement':
      return (function (e, t, r) {
       return ['return', fa(e, t, r)];
      })(e, t, r);
     case 'NewExpression':
     case 'ImportExpression':
     case 'OptionalCallExpression':
     case 'CallExpression':
      return ai(e, t, r);
     case 'ObjectExpression':
     case 'ObjectPattern':
     case 'RecordExpression':
      return oo(e, t, r);
     case 'Property':
      return ce(n) ? pa(e, t, r) : oa(e, t, r);
     case 'ObjectMethod':
      return pa(e, t, r);
     case 'Decorator':
      return ['@', r('expression')];
     case 'ArrayExpression':
     case 'ArrayPattern':
     case 'TupleExpression':
      return Xi(e, t, r);
     case 'SequenceExpression': {
      let { parent: t } = e;
      if ('ExpressionStatement' === t.type || 'ForStatement' === t.type) {
       let t = [];
       return (
        e.each(({ isFirst: e }) => {
         e ? t.push(r()) : t.push(',', Xt([ur, r()]));
        }, 'expressions'),
        Yt(t)
       );
      }
      return Yt(dr([',', ur], e.map(r, 'expressions')));
     }
     case 'ThisExpression':
      return 'this';
     case 'Super':
      return 'super';
     case 'Directive':
      return [r('value'), i];
     case 'UnaryExpression':
      return a.push(n.operator), /[a-z]$/u.test(n.operator) && a.push(' '), et(n.argument) ? a.push(Yt(['(', Xt([lr, r('argument')]), lr, ')'])) : a.push(r('argument')), a;
     case 'UpdateExpression':
      return [n.prefix ? n.operator : '', r('argument'), n.prefix ? '' : n.operator];
     case 'ConditionalExpression':
      return mo(e, t, r, s);
     case 'VariableDeclaration': {
      let t,
       s = e.map(r, 'declarations'),
       o = e.parent,
       u = 'ForStatement' === o.type || 'ForInStatement' === o.type || 'ForOfStatement' === o.type,
       l = n.declarations.some((e) => e.init);
      return 1 !== s.length || et(n.declarations[0]) ? s.length > 0 && (t = Xt(s[0])) : (t = s[0]), (a = [$i(e), n.kind, t ? [' ', t] : '', Xt(s.slice(1).map((e) => [',', l && !u ? pr : ur, e]))]), (u && o.body !== n) || a.push(i), Yt(a);
     }
     case 'WithStatement':
      return Yt(['with (', r('object'), ')', Vi(n.body, r('body'))]);
     case 'IfStatement': {
      let s = Vi(n.consequent, r('consequent')),
       i = Yt(['if (', Yt([Xt([lr, r('test')]), lr]), ')', s]);
      if ((a.push(i), n.alternate)) {
       let s = et(n.consequent, Qe.Trailing | Qe.Line) || Pe(n),
        i = 'BlockStatement' === n.consequent.type && !s;
       a.push(i ? ' ' : pr), et(n, Qe.Dangling) && a.push(Cn(e, t), s ? pr : ' '), a.push('else', Yt(Vi(n.alternate, r('alternate'), 'IfStatement' === n.alternate.type)));
      }
      return a;
     }
     case 'ForStatement': {
      let s = Vi(n.body, r('body')),
       i = Cn(e, t),
       a = i ? [i, lr] : '';
      return n.init || n.test || n.update ? [a, Yt(['for (', Yt([Xt([lr, r('init'), ';', ur, r('test'), ';', ur, r('update')]), lr]), ')', s])] : [a, Yt(['for (;;)', s])];
     }
     case 'WhileStatement':
      return Yt(['while (', Yt([Xt([lr, r('test')]), lr]), ')', Vi(n.body, r('body'))]);
     case 'ForInStatement':
      return Yt(['for (', r('left'), ' in ', r('right'), ')', Vi(n.body, r('body'))]);
     case 'ForOfStatement':
      return Yt(['for', n.await ? ' await' : '', ' (', r('left'), ' of ', r('right'), ')', Vi(n.body, r('body'))]);
     case 'DoWhileStatement':
      return (a = [Yt(['do', Vi(n.body, r('body'))])]), 'BlockStatement' === n.body.type ? a.push(' ') : a.push(pr), a.push('while (', Yt([Xt([lr, r('test')]), lr]), ')', i), a;
     case 'DoExpression':
      return [n.async ? 'async ' : '', 'do ', r('body')];
     case 'BreakStatement':
     case 'ContinueStatement':
      return a.push('BreakStatement' === n.type ? 'break' : 'continue'), n.label && a.push(' ', r('label')), a.push(i), a;
     case 'LabeledStatement':
      return 'EmptyStatement' === n.body.type ? [r('label'), ':;'] : [r('label'), ': ', r('body')];
     case 'TryStatement':
      return ['try ', r('block'), n.handler ? [' ', r('handler')] : '', n.finalizer ? [' finally ', r('finalizer')] : ''];
     case 'CatchClause':
      if (n.param) {
       let e = et(n.param, (e) => !J(e) || (e.leading && A(t.originalText, L(e))) || (e.trailing && A(t.originalText, O(e), { backwards: !0 }))),
        s = r('param');
       return ['catch ', e ? ['(', Xt([lr, s]), lr, ') '] : ['(', s, ') '], r('body')];
      }
      return ['catch ', r('body')];
     case 'SwitchStatement':
      return [
       Yt(['switch (', Xt([lr, r('discriminant')]), lr, ')']),
       ' {',
       n.cases.length > 0
        ? Xt([
           pr,
           dr(
            pr,
            e.map(({ node: e, isLast: s }) => [r(), !s && rt(e, t) ? pr : ''], 'cases'),
           ),
          ])
        : '',
       pr,
       '}',
      ];
     case 'SwitchCase': {
      n.test ? a.push('case ', r('test'), ':') : a.push('default:'), et(n, Qe.Dangling) && a.push(' ', Cn(e, t));
      let s = n.consequent.filter((e) => 'EmptyStatement' !== e.type);
      if (s.length > 0) {
       let n = Ea(e, t, r, 'consequent');
       a.push(1 === s.length && 'BlockStatement' === s[0].type ? [' ', n] : Xt([pr, n]));
      }
      return a;
     }
     case 'DebuggerStatement':
      return ['debugger', i];
     case 'ClassDeclaration':
     case 'ClassExpression':
      return ka(e, t, r);
     case 'ClassMethod':
     case 'ClassPrivateMethod':
     case 'MethodDefinition':
      return Ma(e, t, r);
     case 'ClassProperty':
     case 'PropertyDefinition':
     case 'ClassPrivateProperty':
     case 'ClassAccessorProperty':
     case 'AccessorProperty':
      return ja(e, t, r);
     case 'TemplateElement':
      return $t(n.value.raw);
     case 'TemplateLiteral':
      return Ns(e, r, t);
     case 'TaggedTemplateExpression':
      return (function (e, t) {
       let r = t('quasi');
       return fr(r.label && { tagged: !0, ...r.label }, [t('tag'), t(e.node.typeArguments ? 'typeArguments' : 'typeParameters'), ir, r]);
      })(e, r);
     case 'PrivateIdentifier':
      return ['#', n.name];
     case 'PrivateName':
      return ['#', r('id')];
     case 'TopicReference':
      return '%';
     case 'ArgumentPlaceholder':
      return '?';
     case 'ModuleExpression':
      return ['module ', r('body')];
     default:
      throw new wn(n, 'ESTree');
    }
   }
   function Do(e, t, r) {
    let { parent: s, node: n, key: i } = e,
     a = [r('expression')];
    switch (n.type) {
     case 'AsConstExpression':
      a.push(' as const');
      break;
     case 'AsExpression':
     case 'TSAsExpression':
      a.push(' as ', r('typeAnnotation'));
      break;
     case 'SatisfiesExpression':
     case 'TSSatisfiesExpression':
      a.push(' satisfies ', r('typeAnnotation'));
    }
    return ('callee' === i && Ee(s)) || ('object' === i && be(s)) ? Yt([Xt([lr, ...a]), lr]) : a;
   }
   function go(e, t, r) {
    let { node: s } = e,
     n = [$i(e), 'component'];
    s.id && n.push(' ', r('id')), n.push(r('typeParameters'));
    let i = (function (e, t, r) {
     let { node: s } = e,
      n = s.params;
     if ((s.rest && (n = [...n, s.rest]), 0 === n.length)) return ['(', Cn(e, r, { filter: (e) => ')' === Ar(r.originalText, L(e)) }), ')'];
     let i = [];
     return (
      (function (e, t) {
       let { node: r } = e,
        s = 0,
        n = (e) => t(e, s++);
       e.each(n, 'params'), r.rest && e.call(n, 'rest');
      })(e, (e, a) => {
       let o = a === n.length - 1;
       o && s.rest && i.push('...'), i.push(t()), !o && (i.push(','), rt(n[a], r) ? i.push(pr, pr) : i.push(ur));
      }),
      ['(', Xt([lr, ...i]), rr(Le(r, 'all') && !xo(s, n) ? ',' : ''), lr, ')']
     );
    })(e, r, t);
    return s.rendersType ? n.push(Yt([i, ' ', r('rendersType')])) : n.push(Yt([i])), s.body && n.push(' ', r('body')), t.semi && 'DeclareComponent' === s.type && n.push(';'), n;
   }
   function xo(e, t) {
    var r;
    return e.rest || 'RestElement' === (null == (r = c(!1, t, -1)) ? void 0 : r.type);
   }
   function Eo(e, t, r) {
    return oo(e, r, t);
   }
   function bo(e, t) {
    let { node: r } = e,
     s = t('id');
    r.computed && (s = ['[', s, ']']);
    let n = '';
    return r.initializer && (n = t('initializer')), r.init && (n = t('init')), n ? [s, ' = ', n] : s;
   }
   function To(e, t, r) {
    let { node: s } = e;
    return [$i(e), s.const ? 'const ' : '', 'enum ', t('id'), ' ', 'TSEnumDeclaration' === s.type ? Eo(e, t, r) : t('body')];
   }
   function Ao(e) {
    var t;
    let { node: r } = e;
    return 'HookTypeAnnotation' === r.type && 'DeclareHook' === (null == (t = e.getParentNode(2)) ? void 0 : t.type);
   }
   function Co(e, t, r) {
    let { node: s } = e,
     n = [$i(e), 'interface'],
     i = [],
     a = [];
    'InterfaceTypeAnnotation' !== s.type && i.push(' ', r('id'), r('typeParameters'));
    let o = s.typeParameters && !et(s.typeParameters, Qe.Trailing | Qe.Line);
    return w(s.extends) && a.push(o ? rr(' ', ur, { groupId: va(s.typeParameters) }) : ur, 'extends ', (1 === s.extends.length ? Oe : Xt)(dr([',', ur], e.map(r, 'extends')))), et(s.id, Qe.Trailing) || w(s.extends) ? (o ? n.push(Yt([...i, Xt(a)])) : n.push(Yt(Xt([...i, ...a])))) : n.push(...i, ...a), n.push(' ', r('body')), Yt(n);
   }
   function vo(e, t, r) {
    let { node: s } = e;
    if (W(s)) return s.type.slice(0, -14).toLowerCase();
    let n = t.semi ? ';' : '';
    switch (s.type) {
     case 'ComponentDeclaration':
     case 'DeclareComponent':
     case 'ComponentTypeAnnotation':
      return go(e, t, r);
     case 'ComponentParameter':
      return (function (e, t, r) {
       let { node: s } = e;
       return s.shorthand ? r('local') : [r('name'), ' as ', r('local')];
      })(e, 0, r);
     case 'ComponentTypeParameter':
      return (function (e, t, r) {
       let { node: s } = e,
        n = [];
       return s.name && n.push(r('name'), s.optional ? '?: ' : ': '), n.push(r('typeAnnotation')), n;
      })(e, 0, r);
     case 'HookDeclaration':
      return (function (e, t, r) {
       let { node: s } = e,
        n = ['hook'];
       s.id && n.push(' ', r('id'));
       let i = yi(e, r, t, !1, !0),
        a = da(e, r),
        o = gi(s, a);
       return n.push(Yt([o ? Yt(i) : i, a]), s.body ? ' ' : '', r('body')), n;
      })(e, t, r);
     case 'DeclareHook':
      return (function (e, t, r) {
       let { node: s } = e,
        n = [$i(e), 'hook'];
       return s.id && n.push(' ', r('id')), t.semi && n.push(';'), n;
      })(e, t, r);
     case 'HookTypeAnnotation':
      return (function (e, t, r) {
       let { node: s } = e,
        n = [];
       n.push(Ao(e) ? '' : 'hook ');
       let i = yi(e, r, t, !1, !0),
        a = [];
       return a.push(Ao(e) ? ': ' : ' => ', r('returnType')), gi(s, a) && (i = Yt(i)), n.push(i, a), Yt(n);
      })(e, t, r);
     case 'DeclareClass':
      return ka(e, t, r);
     case 'DeclareFunction':
      return [$i(e), 'function ', r('id'), r('predicate'), n];
     case 'DeclareModule':
      return ['declare module ', r('id'), ' ', r('body')];
     case 'DeclareModuleExports':
      return ['declare module.exports', Ni(e, r), n];
     case 'DeclareNamespace':
      return ['declare namespace ', r('id'), ' ', r('body')];
     case 'DeclareVariable':
      return [$i(e), s.kind ?? 'var', ' ', r('id'), n];
     case 'DeclareExportDeclaration':
     case 'DeclareExportAllDeclaration':
      return Qa(e, t, r);
     case 'DeclareOpaqueType':
     case 'OpaqueType':
      return (function (e, t, r) {
       let s = t.semi ? ';' : '',
        { node: n } = e,
        i = [$i(e), 'opaque type ', r('id'), r('typeParameters')];
       return n.supertype && i.push(': ', r('supertype')), n.impltype && i.push(' = ', r('impltype')), i.push(s), i;
      })(e, t, r);
     case 'DeclareTypeAlias':
     case 'TypeAlias':
      return Ti(e, t, r);
     case 'IntersectionTypeAnnotation':
      return Ai(e, t, r);
     case 'UnionTypeAnnotation':
      return Ci(e, t, r);
     case 'ConditionalTypeAnnotation':
      return mo(e, t, r);
     case 'InferTypeAnnotation':
      return wi(0, 0, r);
     case 'FunctionTypeAnnotation':
      return vi(e, t, r);
     case 'TupleTypeAnnotation':
      return Xi(e, t, r);
     case 'TupleTypeLabeledElement':
      return ki(e, 0, r);
     case 'TupleTypeSpreadElement':
      return Pi(e, 0, r);
     case 'GenericTypeAnnotation':
      return [r('id'), Fa(e, t, r, 'typeParameters')];
     case 'IndexedAccessType':
     case 'OptionalIndexedAccessType':
      return Fi(e, 0, r);
     case 'TypeAnnotation':
      return Oi(e, 0, r);
     case 'TypeParameter':
      return Sa(e, 0, r);
     case 'TypeofTypeAnnotation':
      return Mi(e, r);
     case 'ExistsTypeAnnotation':
      return '*';
     case 'ArrayTypeAnnotation':
      return Li(r);
     case 'DeclareEnum':
     case 'EnumDeclaration':
      return To(e, r, t);
     case 'EnumBooleanBody':
     case 'EnumNumberBody':
     case 'EnumBigIntBody':
     case 'EnumStringBody':
     case 'EnumSymbolBody':
      return (function (e, t, r) {
       let s,
        { node: n } = e;
       if ('EnumSymbolBody' === n.type || n.explicitType)
        switch (n.type) {
         case 'EnumBooleanBody':
          s = 'boolean';
          break;
         case 'EnumNumberBody':
          s = 'number';
          break;
         case 'EnumBigIntBody':
          s = 'bigint';
          break;
         case 'EnumStringBody':
          s = 'string';
          break;
         case 'EnumSymbolBody':
          s = 'symbol';
        }
       return [s ? `of ${s} ` : '', Eo(e, t, r)];
      })(e, r, t);
     case 'EnumBooleanMember':
     case 'EnumNumberMember':
     case 'EnumBigIntMember':
     case 'EnumStringMember':
     case 'EnumDefaultedMember':
      return bo(e, r);
     case 'FunctionTypeParam': {
      let t = s.name ? r('name') : e.parent.this === s ? 'this' : '';
      return [t, _i(e), t ? ': ' : '', r('typeAnnotation')];
     }
     case 'DeclareInterface':
     case 'InterfaceDeclaration':
     case 'InterfaceTypeAnnotation':
      return Co(e, 0, r);
     case 'ClassImplements':
     case 'InterfaceExtends':
      return [r('id'), r('typeParameters')];
     case 'NullableTypeAnnotation':
      return ['?', r('typeAnnotation')];
     case 'Variance': {
      let { kind: e } = s;
      return P.ok('plus' === e || 'minus' === e), 'plus' === e ? '+' : '-';
     }
     case 'KeyofTypeAnnotation':
      return ['keyof ', r('argument')];
     case 'ObjectTypeCallProperty':
      return [s.static ? 'static ' : '', r('value')];
     case 'ObjectTypeMappedTypeProperty':
      return (function (e, t, r) {
       let { node: s } = e;
       return Yt([s.variance ? r('variance') : '', '[', Xt([r('keyTparam'), ' in ', r('sourceType')]), ']', Aa(s.optional), ': ', r('propType')]);
      })(e, 0, r);
     case 'ObjectTypeIndexer':
      return [s.static ? 'static ' : '', s.variance ? r('variance') : '', '[', r('id'), s.id ? ': ' : '', r('key'), ']: ', r('value')];
     case 'ObjectTypeProperty': {
      let n = '';
      return s.proto ? (n = 'proto ') : s.static && (n = 'static '), [n, 'init' !== s.kind ? s.kind + ' ' : '', s.variance ? r('variance') : '', aa(e, t, r), _i(e), ce(s) ? '' : ': ', r('value')];
     }
     case 'ObjectTypeAnnotation':
      return oo(e, t, r);
     case 'ObjectTypeInternalSlot':
      return [s.static ? 'static ' : '', '[[', r('id'), ']]', _i(e), s.method ? '' : ': ', r('value')];
     case 'ObjectTypeSpreadProperty':
      return Hi(e, r);
     case 'QualifiedTypeofIdentifier':
     case 'QualifiedTypeIdentifier':
      return [r('qualification'), '.', r('id')];
     case 'NullLiteralTypeAnnotation':
      return 'null';
     case 'BooleanLiteralTypeAnnotation':
      return String(s.value);
     case 'StringLiteralTypeAnnotation':
      return $t(B(Be(s), t));
     case 'NumberLiteralTypeAnnotation':
      return ra(s.raw ?? s.extra.raw);
     case 'BigIntLiteralTypeAnnotation':
      return Ha(s.raw ?? s.extra.raw);
     case 'TypeCastExpression':
      return ['(', r('expression'), Ni(e, r), ')'];
     case 'TypePredicate':
      return ji(e, r);
     case 'TypeOperator':
      return [s.operator, ' ', r('typeAnnotation')];
     case 'TypeParameterDeclaration':
     case 'TypeParameterInstantiation':
      return Fa(e, t, r, 'params');
     case 'InferredPredicate':
     case 'DeclaredPredicate':
      return ['predicate' !== e.key || 'DeclareFunction' === e.parent.type || e.parent.returnType ? ' ' : ': ', '%checks', ...('DeclaredPredicate' === s.type ? ['(', r('value'), ')'] : [])];
     case 'AsExpression':
     case 'AsConstExpression':
     case 'SatisfiesExpression':
      return Do(e, 0, r);
    }
   }
   function Fo(e, t, r) {
    var s;
    let { node: n } = e;
    if (!n.type.startsWith('TS')) return;
    if (V(n)) return n.type.slice(2, -7).toLowerCase();
    let i = t.semi ? ';' : '',
     a = [];
    switch (n.type) {
     case 'TSThisType':
      return 'this';
     case 'TSTypeAssertion': {
      let e = !(Z(n.expression) || ee(n.expression)),
       t = Yt(['<', Xt([lr, r('typeAnnotation')]), lr, '>']),
       s = [rr('('), Xt([lr, r('expression')]), lr, rr(')')];
      return e
       ? er([
          [t, r('expression')],
          [t, Yt(s, { shouldBreak: !0 })],
          [t, r('expression')],
         ])
       : Yt([t, r('expression')]);
     }
     case 'TSDeclareFunction':
      return la(e, r, t);
     case 'TSExportAssignment':
      return ['export = ', r('expression'), i];
     case 'TSModuleBlock':
      return ba(e, t, r);
     case 'TSInterfaceBody':
     case 'TSTypeLiteral':
      return oo(e, t, r);
     case 'TSTypeAliasDeclaration':
      return Ti(e, t, r);
     case 'TSQualifiedName':
      return [r('left'), '.', r('right')];
     case 'TSAbstractMethodDefinition':
     case 'TSDeclareMethod':
      return Ma(e, t, r);
     case 'TSAbstractAccessorProperty':
     case 'TSAbstractPropertyDefinition':
      return ja(e, t, r);
     case 'TSInterfaceHeritage':
     case 'TSClassImplements':
     case 'TSExpressionWithTypeArguments':
     case 'TSInstantiationExpression':
      return [r('expression'), r(n.typeArguments ? 'typeArguments' : 'typeParameters')];
     case 'TSTemplateLiteralType':
      return Ns(e, r, t);
     case 'TSNamedTupleMember':
      return ki(e, 0, r);
     case 'TSRestType':
      return Pi(e, 0, r);
     case 'TSOptionalType':
      return [r('typeAnnotation'), '?'];
     case 'TSInterfaceDeclaration':
      return Co(e, 0, r);
     case 'TSTypeParameterDeclaration':
     case 'TSTypeParameterInstantiation':
      return Fa(e, t, r, 'params');
     case 'TSTypeParameter':
      return Sa(e, 0, r);
     case 'TSAsExpression':
     case 'TSSatisfiesExpression':
      return Do(e, 0, r);
     case 'TSArrayType':
      return Li(r);
     case 'TSPropertySignature':
      return [n.readonly ? 'readonly ' : '', aa(e, t, r), _i(e), Ni(e, r)];
     case 'TSParameterProperty':
      return [Ki(n), n.static ? 'static ' : '', n.override ? 'override ' : '', n.readonly ? 'readonly ' : '', r('parameter')];
     case 'TSTypeQuery':
      return Mi(e, r);
     case 'TSIndexSignature': {
      let s = n.parameters.length > 1 ? rr(Le(t) ? ',' : '') : '',
       a = Yt([Xt([lr, dr([', ', lr], e.map(r, 'parameters'))]), s, lr]),
       o = 'ClassBody' === e.parent.type && 'body' === e.key;
      return [o && n.static ? 'static ' : '', n.readonly ? 'readonly ' : '', '[', n.parameters ? a : '', ']', Ni(e, r), o ? i : ''];
     }
     case 'TSTypePredicate':
      return ji(e, r);
     case 'TSNonNullExpression':
      return [r('expression'), '!'];
     case 'TSImportType':
      return ['import(', r('argument'), ')', n.qualifier ? ['.', r('qualifier')] : '', Fa(e, t, r, n.typeArguments ? 'typeArguments' : 'typeParameters')];
     case 'TSLiteralType':
      return r('literal');
     case 'TSIndexedAccessType':
      return Fi(e, 0, r);
     case 'TSTypeOperator':
      return [n.operator, ' ', r('typeAnnotation')];
     case 'TSMappedType':
      return (function (e, t, r) {
       let { node: s } = e,
        n = 'preserve' === t.objectWrap && Cr(t.originalText, O(s), O(s.typeParameter));
       return Yt(['{', Xt([t.bracketSpacing ? ur : lr, Yt([r('typeParameter'), s.optional ? Ca(s.optional, '?') : '', s.typeAnnotation ? ': ' : '', r('typeAnnotation')]), t.semi ? rr(';') : '']), Cn(e, t), t.bracketSpacing ? ur : lr, '}'], { shouldBreak: n });
      })(e, t, r);
     case 'TSMethodSignature': {
      let s = n.kind && 'method' !== n.kind ? `${n.kind} ` : '';
      a.push(Ki(n), s, n.computed ? '[' : '', r('key'), n.computed ? ']' : '', _i(e));
      let i = yi(e, r, t, !1, !0),
       o = n.returnType ? 'returnType' : 'typeAnnotation',
       u = n[o],
       l = u ? Ni(e, r, o) : '',
       p = gi(n, l);
      return a.push(p ? Yt(i) : i), u && a.push(Yt(l)), Yt(a);
     }
     case 'TSNamespaceExportDeclaration':
      return ['export as namespace ', r('id'), t.semi ? ';' : ''];
     case 'TSEnumDeclaration':
      return To(e, r, t);
     case 'TSEnumMember':
      return bo(e, r);
     case 'TSImportEqualsDeclaration':
      return [n.isExport ? 'export ' : '', 'import ', to(n, !1), r('id'), ' = ', r('moduleReference'), t.semi ? ';' : ''];
     case 'TSExternalModuleReference':
      return ['require(', r('expression'), ')'];
     case 'TSModuleDeclaration': {
      let { parent: t } = e,
       o = 'TSModuleDeclaration' === t.type,
       u = 'TSModuleDeclaration' === (null == (s = n.body) ? void 0 : s.type);
      return o ? a.push('.') : (a.push($i(e)), 'global' !== n.kind && a.push(n.kind, ' ')), a.push(r('id')), u ? a.push(r('body')) : n.body ? a.push(' ', Yt(r('body'))) : a.push(i), a;
     }
     case 'TSConditionalType':
      return mo(e, t, r);
     case 'TSInferType':
      return wi(0, 0, r);
     case 'TSIntersectionType':
      return Ai(e, t, r);
     case 'TSUnionType':
      return Ci(e, t, r);
     case 'TSFunctionType':
     case 'TSCallSignatureDeclaration':
     case 'TSConstructorType':
     case 'TSConstructSignatureDeclaration':
      return vi(e, t, r);
     case 'TSTupleType':
      return Xi(e, t, r);
     case 'TSTypeReference':
      return [r('typeName'), Fa(e, t, r, n.typeArguments ? 'typeArguments' : 'typeParameters')];
     case 'TSTypeAnnotation':
      return Oi(e, 0, r);
     case 'TSEmptyBodyFunctionExpression':
      return ca(e, t, r);
     case 'TSJSDocAllType':
      return '*';
     case 'TSJSDocUnknownType':
      return '?';
     case 'TSJSDocNullableType':
      return Si(e, r, '?');
     case 'TSJSDocNonNullableType':
      return Si(e, r, '!');
     default:
      throw new wn(n, 'TypeScript');
    }
   }
   var wo = q(['ClassMethod', 'ClassPrivateMethod', 'ClassProperty', 'ClassAccessorProperty', 'AccessorProperty', 'TSAbstractAccessorProperty', 'PropertyDefinition', 'TSAbstractPropertyDefinition', 'ClassPrivateProperty', 'MethodDefinition', 'TSAbstractMethodDefinition', 'TSDeclareMethod']);
   var So = function (e, t, r, s) {
     var n;
     e.isRoot && (null == (n = t.__onHtmlBindingRoot) || n.call(t, e.node, t));
     let i = (function (e, t, r, s) {
      if (Rn(e)) return fn(e, t);
      for (let n of [zn, jn, vo, Fo, yo]) {
       let i = n(e, t, r, s);
       if (void 0 !== i) return i;
      }
     })(e, t, r, s);
     if (!i) return '';
     let { node: a } = e;
     if (wo(a)) return i;
     let o = w(a.decorators),
      u = (function (e, t, r) {
       let { node: s, parent: n } = e,
        { decorators: i } = s;
       if (!w(i) || Yn(n) || Rn(e)) return '';
       let a = 'ClassExpression' === s.type || 'ClassDeclaration' === s.type || Gn(s, t);
       return ['declaration' === e.key && Q(n) ? pr : a ? ar : '', dr(ur, e.map(r, 'decorators')), ur];
      })(e, t, r),
      l = 'ClassExpression' === a.type;
     if (o && !l) return Jt(i, (e) => Yt([u, e]));
     let p = En(e, t),
      c = qa(e, t);
     return u || p || c ? Jt(i, (e) => [c ? ';' : '', p ? '(' : '', p && l && o ? [Xt([ur, u, e]), ur] : [u, e], p ? ')' : '']) : i;
    },
    Po = { avoidAstMutation: !0 },
    ko = {};
   i(ko, { getVisitorKeys: () => Io, massageAstNode: () => Lo, print: () => No });
   var Io = U({ JsonRoot: ['node'], ArrayExpression: ['elements'], ObjectExpression: ['properties'], ObjectProperty: ['key', 'value'], UnaryExpression: ['argument'], NullLiteral: [], BooleanLiteral: [], StringLiteral: [], NumericLiteral: [], Identifier: [], TemplateLiteral: ['quasis'], TemplateElement: [] });
   function No(e, t, r) {
    let { node: s } = e;
    switch (s.type) {
     case 'JsonRoot':
      return [r('node'), pr];
     case 'ArrayExpression': {
      if (0 === s.elements.length) return '[]';
      let t = e.map(() => (null === e.node ? 'null' : r()), 'elements');
      return ['[', Xt([pr, dr([',', pr], t)]), pr, ']'];
     }
     case 'ObjectExpression':
      return 0 === s.properties.length ? '{}' : ['{', Xt([pr, dr([',', pr], e.map(r, 'properties'))]), pr, '}'];
     case 'ObjectProperty':
      return [r('key'), ': ', r('value')];
     case 'UnaryExpression':
      return ['+' === s.operator ? '' : s.operator, r('argument')];
     case 'NullLiteral':
      return 'null';
     case 'BooleanLiteral':
      return s.value ? 'true' : 'false';
     case 'StringLiteral':
      return JSON.stringify(s.value);
     case 'NumericLiteral':
      return Bo(e) ? JSON.stringify(String(s.value)) : JSON.stringify(s.value);
     case 'Identifier':
      return Bo(e) ? JSON.stringify(s.name) : s.name;
     case 'TemplateLiteral':
      return r(['quasis', 0]);
     case 'TemplateElement':
      return JSON.stringify(s.value.cooked);
     default:
      throw new wn(s, 'JSON');
    }
   }
   function Bo(e) {
    return 'key' === e.key && 'ObjectProperty' === e.parent.type;
   }
   var Oo = new Set(['start', 'end', 'extra', 'loc', 'comments', 'leadingComments', 'trailingComments', 'innerComments', 'errors', 'range', 'tokens']);
   function Lo(e, t) {
    let { type: r } = e;
    if ('ObjectProperty' !== r) {
     if ('UnaryExpression' === r && '+' === e.operator) return t.argument;
     if ('ArrayExpression' !== r) return 'TemplateLiteral' === r ? { type: 'StringLiteral', value: e.quasis[0].value.cooked } : void 0;
     for (let [r, s] of e.elements.entries()) null === s && t.elements.splice(r, 0, { type: 'NullLiteral' });
    } else {
     let { key: r } = e;
     'Identifier' === r.type ? (t.key = { type: 'StringLiteral', value: r.name }) : 'NumericLiteral' === r.type && (t.key = { type: 'StringLiteral', value: String(r.value) });
    }
   }
   Lo.ignoredProperties = Oo;
   var Mo = {
     bracketSpacing: { category: 'Common', type: 'boolean', default: !0, description: 'Print spaces between brackets.', oppositeDescription: 'Do not print spaces between brackets.' },
     objectWrap: {
      category: 'Common',
      type: 'choice',
      default: 'preserve',
      description: 'How to wrap object literals.',
      choices: [
       { value: 'preserve', description: 'Keep as multi-line, if there is a newline between the opening brace and first property.' },
       { value: 'collapse', description: 'Fit to a single line when possible.' },
      ],
     },
     singleQuote: { category: 'Common', type: 'boolean', default: !1, description: 'Use single quotes instead of double quotes.' },
     proseWrap: {
      category: 'Common',
      type: 'choice',
      default: 'preserve',
      description: 'How to wrap prose.',
      choices: [
       { value: 'always', description: 'Wrap prose if it exceeds the print width.' },
       { value: 'never', description: 'Do not wrap prose.' },
       { value: 'preserve', description: 'Wrap prose as-is.' },
      ],
     },
     bracketSameLine: { category: 'Common', type: 'boolean', default: !1, description: 'Put > of opening tags on the last line instead of on a new line.' },
     singleAttributePerLine: { category: 'Common', type: 'boolean', default: !1, description: 'Enforce single attribute per line in HTML, Vue and JSX.' },
    },
    jo = 'JavaScript',
    _o = {
     arrowParens: {
      category: jo,
      type: 'choice',
      default: 'always',
      description: 'Include parentheses around a sole arrow function parameter.',
      choices: [
       { value: 'always', description: 'Always include parens. Example: `(x) => x`' },
       { value: 'avoid', description: 'Omit parens when possible. Example: `x => x`' },
      ],
     },
     bracketSameLine: Mo.bracketSameLine,
     objectWrap: Mo.objectWrap,
     bracketSpacing: Mo.bracketSpacing,
     jsxBracketSameLine: { category: jo, type: 'boolean', description: 'Put > on the last line instead of at a new line.', deprecated: '2.4.0' },
     semi: { category: jo, type: 'boolean', default: !0, description: 'Print semicolons.', oppositeDescription: 'Do not print semicolons, except at the beginning of lines which may need them.' },
     experimentalOperatorPosition: {
      category: jo,
      type: 'choice',
      default: 'end',
      description: 'Where to print operators when binary expressions wrap lines.',
      choices: [
       { value: 'start', description: 'Print operators at the start of new lines.' },
       { value: 'end', description: 'Print operators at the end of previous lines.' },
      ],
     },
     experimentalTernaries: { category: jo, type: 'boolean', default: !1, description: 'Use curious ternaries, with the question mark after the condition.', oppositeDescription: 'Default behavior of ternaries; keep question marks on the same line as the consequent.' },
     singleQuote: Mo.singleQuote,
     jsxSingleQuote: { category: jo, type: 'boolean', default: !1, description: 'Use single quotes in JSX.' },
     quoteProps: {
      category: jo,
      type: 'choice',
      default: 'as-needed',
      description: 'Change when properties in objects are quoted.',
      choices: [
       { value: 'as-needed', description: 'Only add quotes around object properties where required.' },
       { value: 'consistent', description: 'If at least one property in an object requires quotes, quote all properties.' },
       { value: 'preserve', description: 'Respect the input use of quotes in object properties.' },
      ],
     },
     trailingComma: {
      category: jo,
      type: 'choice',
      default: 'all',
      description: 'Print trailing commas wherever possible when multi-line.',
      choices: [
       { value: 'all', description: 'Trailing commas wherever possible (including function arguments).' },
       { value: 'es5', description: 'Trailing commas where valid in ES5 (objects, arrays, etc.)' },
       { value: 'none', description: 'No trailing commas.' },
      ],
     },
     singleAttributePerLine: Mo.singleAttributePerLine,
    },
    Ro = { estree: l, 'estree-json': ko },
    Uo = [
     { linguistLanguageId: 183, name: 'JavaScript', type: 'programming', tmScope: 'source.js', aceMode: 'javascript', codemirrorMode: 'javascript', codemirrorMimeType: 'text/javascript', color: '#f1e05a', aliases: ['js', 'node'], extensions: ['.js', '._js', '.bones', '.cjs', '.es', '.es6', '.frag', '.gs', '.jake', '.javascript', '.jsb', '.jscad', '.jsfl', '.jslib', '.jsm', '.jspre', '.jss', '.mjs', '.njs', '.pac', '.sjs', '.ssjs', '.xsjs', '.xsjslib', '.wxs'], filenames: ['Jakefile'], interpreters: ['chakra', 'd8', 'gjs', 'js', 'node', 'nodejs', 'qjs', 'rhino', 'v8', 'v8-shell', 'zx'], parsers: ['babel', 'acorn', 'espree', 'meriyah', 'babel-flow', 'babel-ts', 'flow', 'typescript'], vscodeLanguageIds: ['javascript', 'mongo'] },
     { linguistLanguageId: 183, name: 'Flow', type: 'programming', tmScope: 'source.js', aceMode: 'javascript', codemirrorMode: 'javascript', codemirrorMimeType: 'text/javascript', color: '#f1e05a', aliases: [], extensions: ['.js.flow'], filenames: [], interpreters: ['chakra', 'd8', 'gjs', 'js', 'node', 'nodejs', 'qjs', 'rhino', 'v8', 'v8-shell'], parsers: ['flow', 'babel-flow'], vscodeLanguageIds: ['javascript'] },
     { linguistLanguageId: 183, name: 'JSX', type: 'programming', tmScope: 'source.js.jsx', aceMode: 'javascript', codemirrorMode: 'jsx', codemirrorMimeType: 'text/jsx', color: void 0, aliases: void 0, extensions: ['.jsx'], filenames: void 0, interpreters: void 0, parsers: ['babel', 'babel-flow', 'babel-ts', 'flow', 'typescript', 'espree', 'meriyah'], vscodeLanguageIds: ['javascriptreact'], group: 'JavaScript' },
     { linguistLanguageId: 378, name: 'TypeScript', type: 'programming', color: '#3178c6', aliases: ['ts'], interpreters: ['deno', 'ts-node'], extensions: ['.ts', '.cts', '.mts'], tmScope: 'source.ts', aceMode: 'typescript', codemirrorMode: 'javascript', codemirrorMimeType: 'application/typescript', parsers: ['typescript', 'babel-ts'], vscodeLanguageIds: ['typescript'] },
     { linguistLanguageId: 94901924, name: 'TSX', type: 'programming', color: '#3178c6', group: 'TypeScript', extensions: ['.tsx'], tmScope: 'source.tsx', aceMode: 'javascript', codemirrorMode: 'jsx', codemirrorMimeType: 'text/jsx', parsers: ['typescript', 'babel-ts'], vscodeLanguageIds: ['typescriptreact'] },
     { linguistLanguageId: 174, name: 'JSON.stringify', type: 'data', color: '#292929', tmScope: 'source.json', aceMode: 'json', codemirrorMode: 'javascript', codemirrorMimeType: 'application/json', aliases: ['geojson', 'jsonl', 'topojson'], extensions: ['.importmap'], filenames: ['package.json', 'package-lock.json', 'composer.json'], parsers: ['json-stringify'], vscodeLanguageIds: ['json'] },
     { linguistLanguageId: 174, name: 'JSON', type: 'data', color: '#292929', tmScope: 'source.json', aceMode: 'json', codemirrorMode: 'javascript', codemirrorMimeType: 'application/json', aliases: ['geojson', 'jsonl', 'topojson'], extensions: ['.json', '.4DForm', '.4DProject', '.avsc', '.geojson', '.gltf', '.har', '.ice', '.JSON-tmLanguage', '.mcmeta', '.tfstate', '.tfstate.backup', '.topojson', '.webapp', '.webmanifest', '.yy', '.yyp'], filenames: ['.all-contributorsrc', '.arcconfig', '.auto-changelog', '.c8rc', '.htmlhintrc', '.imgbotconfig', '.nycrc', '.tern-config', '.tern-project', '.watchmanconfig', 'Pipfile.lock', 'composer.lock', 'flake.lock', 'mcmod.info', '.babelrc', '.jscsrc', '.jshintrc', '.jslintrc', '.swcrc'], parsers: ['json'], vscodeLanguageIds: ['json'] },
     { linguistLanguageId: 423, name: 'JSON with Comments', type: 'data', color: '#292929', group: 'JSON', tmScope: 'source.js', aceMode: 'javascript', codemirrorMode: 'javascript', codemirrorMimeType: 'text/javascript', aliases: ['jsonc'], extensions: ['.jsonc', '.code-snippets', '.code-workspace', '.sublime-build', '.sublime-commands', '.sublime-completions', '.sublime-keymap', '.sublime-macro', '.sublime-menu', '.sublime-mousemap', '.sublime-project', '.sublime-settings', '.sublime-theme', '.sublime-workspace', '.sublime_metrics', '.sublime_session'], filenames: [], parsers: ['jsonc'], vscodeLanguageIds: ['jsonc'] },
     { linguistLanguageId: 175, name: 'JSON5', type: 'data', color: '#267CB9', extensions: ['.json5'], tmScope: 'source.js', aceMode: 'javascript', codemirrorMode: 'javascript', codemirrorMimeType: 'application/json', parsers: ['json5'], vscodeLanguageIds: ['json5'] },
    ],
    $o = u;
  },
  48231: (e, t, r) => {
   r.d(t, { ZP: () => yn });
   var s = Object.create,
    n = Object.defineProperty,
    i = Object.getOwnPropertyDescriptor,
    a = Object.getOwnPropertyNames,
    o = Object.getPrototypeOf,
    u = Object.prototype.hasOwnProperty,
    l = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports),
    p = (e, t) => {
     for (var r in t) n(e, r, { get: t[r], enumerable: !0 });
    },
    c = (e, t, r) => (
     (r = null != e ? s(o(e)) : {}),
     ((e, t, r, s) => {
      if ((t && 'object' == typeof t) || 'function' == typeof t) for (let o of a(t)) !u.call(e, o) && o !== r && n(e, o, { get: () => t[o], enumerable: !(s = i(t, o)) || s.enumerable });
      return e;
     })(!t && e && e.__esModule ? r : n(r, 'default', { value: e, enumerable: !0 }), e)
    ),
    h = l((e, t) => {
     var r = String,
      s = function () {
       return { isColorSupported: !1, reset: r, bold: r, dim: r, italic: r, underline: r, inverse: r, hidden: r, strikethrough: r, black: r, red: r, green: r, yellow: r, blue: r, magenta: r, cyan: r, white: r, gray: r, bgBlack: r, bgRed: r, bgGreen: r, bgYellow: r, bgBlue: r, bgMagenta: r, bgCyan: r, bgWhite: r, blackBright: r, redBright: r, greenBright: r, yellowBright: r, blueBright: r, magentaBright: r, cyanBright: r, whiteBright: r, bgBlackBright: r, bgRedBright: r, bgGreenBright: r, bgYellowBright: r, bgBlueBright: r, bgMagentaBright: r, bgCyanBright: r, bgWhiteBright: r };
      };
     (t.exports = s()), (t.exports.createColors = s);
    }),
    d = l(() => {}),
    f = l((e, t) => {
     var r = h(),
      s = d(),
      n = class e extends Error {
       constructor(t, r, s, n, i, a) {
        super(t), (this.name = 'CssSyntaxError'), (this.reason = t), i && (this.file = i), n && (this.source = n), a && (this.plugin = a), typeof r < 'u' && typeof s < 'u' && ('number' == typeof r ? ((this.line = r), (this.column = s)) : ((this.line = r.line), (this.column = r.column), (this.endLine = s.line), (this.endColumn = s.column))), this.setMessage(), Error.captureStackTrace && Error.captureStackTrace(this, e);
       }
       setMessage() {
        (this.message = this.plugin ? this.plugin + ': ' : ''), (this.message += this.file ? this.file : '<css input>'), typeof this.line < 'u' && (this.message += ':' + this.line + ':' + this.column), (this.message += ': ' + this.reason);
       }
       showSourceCode(e) {
        if (!this.source) return '';
        let t = this.source;
        null == e && (e = r.isColorSupported);
        let n = (e) => e,
         i = (e) => e,
         a = (e) => e;
        if (e) {
         let { bold: e, gray: t, red: o } = r.createColors(!0);
         (i = (t) => e(o(t))), (n = (e) => t(e)), s && (a = (e) => s(e));
        }
        let o = t.split(/\r?\n/),
         u = Math.max(this.line - 3, 0),
         l = Math.min(this.line + 2, o.length),
         p = String(l).length;
        return o
         .slice(u, l)
         .map((e, t) => {
          let r = u + 1 + t,
           s = ' ' + (' ' + r).slice(-p) + ' | ';
          if (r === this.line) {
           if (e.length > 160) {
            let t = 20,
             r = Math.max(0, this.column - t),
             o = Math.max(this.column + t, this.endColumn + t),
             u = e.slice(r, o),
             l = n(s.replace(/\d/g, ' ')) + e.slice(0, Math.min(this.column - 1, t - 1)).replace(/[^\t]/g, ' ');
            return i('>') + n(s) + a(u) + '\n ' + l + i('^');
           }
           let t = n(s.replace(/\d/g, ' ')) + e.slice(0, this.column - 1).replace(/[^\t]/g, ' ');
           return i('>') + n(s) + a(e) + '\n ' + t + i('^');
          }
          return ' ' + n(s) + a(e);
         })
         .join('\n');
       }
       toString() {
        let e = this.showSourceCode();
        return e && (e = '\n\n' + e + '\n'), this.name + ': ' + this.message + e;
       }
      };
     (t.exports = n), (n.default = n);
    }),
    m = l((e, t) => {
     var r = { after: '\n', beforeClose: '\n', beforeComment: '\n', beforeDecl: '\n', beforeOpen: ' ', beforeRule: '\n', colon: ': ', commentLeft: ' ', commentRight: ' ', emptyBody: '', indent: '    ', semicolon: !1 };
     var s = class {
      constructor(e) {
       this.builder = e;
      }
      atrule(e, t) {
       let r = '@' + e.name,
        s = e.params ? this.rawValue(e, 'params') : '';
       if ((typeof e.raws.afterName < 'u' ? (r += e.raws.afterName) : s && (r += ' '), e.nodes)) this.block(e, r + s);
       else {
        let n = (e.raws.between || '') + (t ? ';' : '');
        this.builder(r + s + n, e);
       }
      }
      beforeAfter(e, t) {
       let r;
       r = 'decl' === e.type ? this.raw(e, null, 'beforeDecl') : 'comment' === e.type ? this.raw(e, null, 'beforeComment') : 'before' === t ? this.raw(e, null, 'beforeRule') : this.raw(e, null, 'beforeClose');
       let s = e.parent,
        n = 0;
       for (; s && 'root' !== s.type; ) (n += 1), (s = s.parent);
       if (r.includes('\n')) {
        let t = this.raw(e, null, 'indent');
        if (t.length) for (let e = 0; e < n; e++) r += t;
       }
       return r;
      }
      block(e, t) {
       let r,
        s = this.raw(e, 'between', 'beforeOpen');
       this.builder(t + s + '{', e, 'start'), e.nodes && e.nodes.length ? (this.body(e), (r = this.raw(e, 'after'))) : (r = this.raw(e, 'after', 'emptyBody')), r && this.builder(r), this.builder('}', e, 'end');
      }
      body(e) {
       let t = e.nodes.length - 1;
       for (; t > 0 && 'comment' === e.nodes[t].type; ) t -= 1;
       let r = this.raw(e, 'semicolon');
       for (let s = 0; s < e.nodes.length; s++) {
        let n = e.nodes[s],
         i = this.raw(n, 'before');
        i && this.builder(i), this.stringify(n, t !== s || r);
       }
      }
      comment(e) {
       let t = this.raw(e, 'left', 'commentLeft'),
        r = this.raw(e, 'right', 'commentRight');
       this.builder('/*' + t + e.text + r + '*/', e);
      }
      decl(e, t) {
       let r = this.raw(e, 'between', 'colon'),
        s = e.prop + r + this.rawValue(e, 'value');
       e.important && (s += e.raws.important || ' !important'), t && (s += ';'), this.builder(s, e);
      }
      document(e) {
       this.body(e);
      }
      raw(e, t, s) {
       let n;
       if ((s || (s = t), t && ((n = e.raws[t]), typeof n < 'u'))) return n;
       let i = e.parent;
       if ('before' === s && (!i || ('root' === i.type && i.first === e) || (i && 'document' === i.type))) return '';
       if (!i) return r[s];
       let a = e.root();
       if ((a.rawCache || (a.rawCache = {}), typeof a.rawCache[s] < 'u')) return a.rawCache[s];
       if ('before' === s || 'after' === s) return this.beforeAfter(e, s);
       {
        let r = 'raw' + ((o = s)[0].toUpperCase() + o.slice(1));
        this[r]
         ? (n = this[r](a, e))
         : a.walk((e) => {
            if (((n = e.raws[t]), typeof n < 'u')) return !1;
           });
       }
       var o;
       return typeof n > 'u' && (n = r[s]), (a.rawCache[s] = n), n;
      }
      rawBeforeClose(e) {
       let t;
       return (
        e.walk((e) => {
         if (e.nodes && e.nodes.length > 0 && typeof e.raws.after < 'u') return (t = e.raws.after), t.includes('\n') && (t = t.replace(/[^\n]+$/, '')), !1;
        }),
        t && (t = t.replace(/\S/g, '')),
        t
       );
      }
      rawBeforeComment(e, t) {
       let r;
       return (
        e.walkComments((e) => {
         if (typeof e.raws.before < 'u') return (r = e.raws.before), r.includes('\n') && (r = r.replace(/[^\n]+$/, '')), !1;
        }),
        typeof r > 'u' ? (r = this.raw(t, null, 'beforeDecl')) : r && (r = r.replace(/\S/g, '')),
        r
       );
      }
      rawBeforeDecl(e, t) {
       let r;
       return (
        e.walkDecls((e) => {
         if (typeof e.raws.before < 'u') return (r = e.raws.before), r.includes('\n') && (r = r.replace(/[^\n]+$/, '')), !1;
        }),
        typeof r > 'u' ? (r = this.raw(t, null, 'beforeRule')) : r && (r = r.replace(/\S/g, '')),
        r
       );
      }
      rawBeforeOpen(e) {
       let t;
       return (
        e.walk((e) => {
         if ('decl' !== e.type && ((t = e.raws.between), typeof t < 'u')) return !1;
        }),
        t
       );
      }
      rawBeforeRule(e) {
       let t;
       return (
        e.walk((r) => {
         if (r.nodes && (r.parent !== e || e.first !== r) && typeof r.raws.before < 'u') return (t = r.raws.before), t.includes('\n') && (t = t.replace(/[^\n]+$/, '')), !1;
        }),
        t && (t = t.replace(/\S/g, '')),
        t
       );
      }
      rawColon(e) {
       let t;
       return (
        e.walkDecls((e) => {
         if (typeof e.raws.between < 'u') return (t = e.raws.between.replace(/[^\s:]/g, '')), !1;
        }),
        t
       );
      }
      rawEmptyBody(e) {
       let t;
       return (
        e.walk((e) => {
         if (e.nodes && 0 === e.nodes.length && ((t = e.raws.after), typeof t < 'u')) return !1;
        }),
        t
       );
      }
      rawIndent(e) {
       if (e.raws.indent) return e.raws.indent;
       let t;
       return (
        e.walk((r) => {
         let s = r.parent;
         if (s && s !== e && s.parent && s.parent === e && typeof r.raws.before < 'u') {
          let e = r.raws.before.split('\n');
          return (t = e[e.length - 1]), (t = t.replace(/\S/g, '')), !1;
         }
        }),
        t
       );
      }
      rawSemicolon(e) {
       let t;
       return (
        e.walk((e) => {
         if (e.nodes && e.nodes.length && 'decl' === e.last.type && ((t = e.raws.semicolon), typeof t < 'u')) return !1;
        }),
        t
       );
      }
      rawValue(e, t) {
       let r = e[t],
        s = e.raws[t];
       return s && s.value === r ? s.raw : r;
      }
      root(e) {
       this.body(e), e.raws.after && this.builder(e.raws.after);
      }
      rule(e) {
       this.block(e, this.rawValue(e, 'selector')), e.raws.ownSemicolon && this.builder(e.raws.ownSemicolon, e, 'end');
      }
      stringify(e, t) {
       if (!this[e.type]) throw new Error('Unknown AST node type ' + e.type + '. Maybe you need to change PostCSS stringifier.');
       this[e.type](e, t);
      }
     };
     (t.exports = s), (s.default = s);
    }),
    y = l((e, t) => {
     var r = m();
     function s(e, t) {
      new r(t).stringify(e);
     }
     (t.exports = s), (s.default = s);
    }),
    D = l((e, t) => {
     (t.exports.isClean = Symbol('isClean')), (t.exports.my = Symbol('my'));
    }),
    g = l((e, t) => {
     var r = f(),
      s = m(),
      n = y(),
      { isClean: i, my: a } = D();
     function o(e, t) {
      let r = new e.constructor();
      for (let s in e) {
       if (!Object.prototype.hasOwnProperty.call(e, s) || 'proxyCache' === s) continue;
       let n = e[s],
        i = typeof n;
       'parent' === s && 'object' === i ? t && (r[s] = t) : 'source' === s ? (r[s] = n) : Array.isArray(n) ? (r[s] = n.map((e) => o(e, r))) : ('object' === i && null !== n && (n = o(n)), (r[s] = n));
      }
      return r;
     }
     function u(e, t) {
      if (t && typeof t.offset < 'u') return t.offset;
      let r = 1,
       s = 1,
       n = 0;
      for (let i = 0; i < e.length; i++) {
       if (s === t.line && r === t.column) {
        n = i;
        break;
       }
       '\n' === e[i] ? ((r = 1), (s += 1)) : (r += 1);
      }
      return n;
     }
     var l = class {
      constructor(e = {}) {
       (this.raws = {}), (this[i] = !1), (this[a] = !0);
       for (let t in e)
        if ('nodes' === t) {
         this.nodes = [];
         for (let r of e[t]) 'function' == typeof r.clone ? this.append(r.clone()) : this.append(r);
        } else this[t] = e[t];
      }
      addToError(e) {
       if (((e.postcssNode = this), e.stack && this.source && /\n\s{4}at /.test(e.stack))) {
        let t = this.source;
        e.stack = e.stack.replace(/\n\s{4}at /, `$&${t.input.from}:${t.start.line}:${t.start.column}$&`);
       }
       return e;
      }
      after(e) {
       return this.parent.insertAfter(this, e), this;
      }
      assign(e = {}) {
       for (let t in e) this[t] = e[t];
       return this;
      }
      before(e) {
       return this.parent.insertBefore(this, e), this;
      }
      cleanRaws(e) {
       delete this.raws.before, delete this.raws.after, e || delete this.raws.between;
      }
      clone(e = {}) {
       let t = o(this);
       for (let r in e) t[r] = e[r];
       return t;
      }
      cloneAfter(e = {}) {
       let t = this.clone(e);
       return this.parent.insertAfter(this, t), t;
      }
      cloneBefore(e = {}) {
       let t = this.clone(e);
       return this.parent.insertBefore(this, t), t;
      }
      error(e, t = {}) {
       if (this.source) {
        let { end: r, start: s } = this.rangeBy(t);
        return this.source.input.error(e, { column: s.column, line: s.line }, { column: r.column, line: r.line }, t);
       }
       return new r(e);
      }
      getProxyProcessor() {
       return { get: (e, t) => ('proxyOf' === t ? e : 'root' === t ? () => e.root().toProxy() : e[t]), set: (e, t, r) => (e[t] === r || ((e[t] = r), ('prop' === t || 'value' === t || 'name' === t || 'params' === t || 'important' === t || 'text' === t) && e.markDirty()), !0) };
      }
      markClean() {
       this[i] = !0;
      }
      markDirty() {
       if (this[i]) {
        this[i] = !1;
        let e = this;
        for (; (e = e.parent); ) e[i] = !1;
       }
      }
      next() {
       if (!this.parent) return;
       let e = this.parent.index(this);
       return this.parent.nodes[e + 1];
      }
      positionBy(e) {
       let t = this.source.start;
       if (e.index) t = this.positionInside(e.index);
       else if (e.word) {
        let r = 'document' in this.source.input ? this.source.input.document : this.source.input.css,
         s = r.slice(u(r, this.source.start), u(r, this.source.end)).indexOf(e.word);
        -1 !== s && (t = this.positionInside(s));
       }
       return t;
      }
      positionInside(e) {
       let t = this.source.start.column,
        r = this.source.start.line,
        s = 'document' in this.source.input ? this.source.input.document : this.source.input.css,
        n = u(s, this.source.start),
        i = n + e;
       for (let a = n; a < i; a++) '\n' === s[a] ? ((t = 1), (r += 1)) : (t += 1);
       return { column: t, line: r };
      }
      prev() {
       if (!this.parent) return;
       let e = this.parent.index(this);
       return this.parent.nodes[e - 1];
      }
      rangeBy(e) {
       let t = { column: this.source.start.column, line: this.source.start.line },
        r = this.source.end ? { column: this.source.end.column + 1, line: this.source.end.line } : { column: t.column + 1, line: t.line };
       if (e.word) {
        let s = 'document' in this.source.input ? this.source.input.document : this.source.input.css,
         n = s.slice(u(s, this.source.start), u(s, this.source.end)).indexOf(e.word);
        -1 !== n && ((t = this.positionInside(n)), (r = this.positionInside(n + e.word.length)));
       } else e.start ? (t = { column: e.start.column, line: e.start.line }) : e.index && (t = this.positionInside(e.index)), e.end ? (r = { column: e.end.column, line: e.end.line }) : 'number' == typeof e.endIndex ? (r = this.positionInside(e.endIndex)) : e.index && (r = this.positionInside(e.index + 1));
       return (r.line < t.line || (r.line === t.line && r.column <= t.column)) && (r = { column: t.column + 1, line: t.line }), { end: r, start: t };
      }
      raw(e, t) {
       return new s().raw(this, e, t);
      }
      remove() {
       return this.parent && this.parent.removeChild(this), (this.parent = void 0), this;
      }
      replaceWith(...e) {
       if (this.parent) {
        let t = this,
         r = !1;
        for (let s of e) s === this ? (r = !0) : r ? (this.parent.insertAfter(t, s), (t = s)) : this.parent.insertBefore(t, s);
        r || this.remove();
       }
       return this;
      }
      root() {
       let e = this;
       for (; e.parent && 'document' !== e.parent.type; ) e = e.parent;
       return e;
      }
      toJSON(e, t) {
       let r = {},
        s = null == t;
       t = t || new Map();
       let n = 0;
       for (let i in this) {
        if (!Object.prototype.hasOwnProperty.call(this, i) || 'parent' === i || 'proxyCache' === i) continue;
        let e = this[i];
        if (Array.isArray(e)) r[i] = e.map((e) => ('object' == typeof e && e.toJSON ? e.toJSON(null, t) : e));
        else if ('object' == typeof e && e.toJSON) r[i] = e.toJSON(null, t);
        else if ('source' === i) {
         let s = t.get(e.input);
         null == s && ((s = n), t.set(e.input, n), n++), (r[i] = { end: e.end, inputId: s, start: e.start });
        } else r[i] = e;
       }
       return s && (r.inputs = [...t.keys()].map((e) => e.toJSON())), r;
      }
      toProxy() {
       return this.proxyCache || (this.proxyCache = new Proxy(this, this.getProxyProcessor())), this.proxyCache;
      }
      toString(e = n) {
       e.stringify && (e = e.stringify);
       let t = '';
       return (
        e(this, (e) => {
         t += e;
        }),
        t
       );
      }
      warn(e, t, r) {
       let s = { node: this };
       for (let n in r) s[n] = r[n];
       return e.warn(t, s);
      }
      get proxyOf() {
       return this;
      }
     };
     (t.exports = l), (l.default = l);
    }),
    x = l((e, t) => {
     var r = g(),
      s = class extends r {
       constructor(e) {
        super(e), (this.type = 'comment');
       }
      };
     (t.exports = s), (s.default = s);
    }),
    E = l((e, t) => {
     var r = g(),
      s = class extends r {
       constructor(e) {
        e && typeof e.value < 'u' && 'string' != typeof e.value && (e = { ...e, value: String(e.value) }), super(e), (this.type = 'decl');
       }
       get variable() {
        return this.prop.startsWith('--') || '$' === this.prop[0];
       }
      };
     (t.exports = s), (s.default = s);
    }),
    b = l((e, t) => {
     var r,
      s,
      n,
      i,
      a = x(),
      o = E(),
      u = g(),
      { isClean: l, my: p } = D();
     function c(e) {
      return e.map((e) => (e.nodes && (e.nodes = c(e.nodes)), delete e.source, e));
     }
     function h(e) {
      if (((e[l] = !1), e.proxyOf.nodes)) for (let t of e.proxyOf.nodes) h(t);
     }
     var d = class e extends u {
      append(...e) {
       for (let t of e) {
        let e = this.normalize(t, this.last);
        for (let t of e) this.proxyOf.nodes.push(t);
       }
       return this.markDirty(), this;
      }
      cleanRaws(e) {
       if ((super.cleanRaws(e), this.nodes)) for (let t of this.nodes) t.cleanRaws(e);
      }
      each(e) {
       if (!this.proxyOf.nodes) return;
       let t,
        r,
        s = this.getIterator();
       for (; this.indexes[s] < this.proxyOf.nodes.length && ((t = this.indexes[s]), (r = e(this.proxyOf.nodes[t], t)), !1 !== r); ) this.indexes[s] += 1;
       return delete this.indexes[s], r;
      }
      every(e) {
       return this.nodes.every(e);
      }
      getIterator() {
       this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), (this.lastEach += 1);
       let e = this.lastEach;
       return (this.indexes[e] = 0), e;
      }
      getProxyProcessor() {
       return { get: (e, t) => ('proxyOf' === t ? e : e[t] ? ('each' === t || ('string' == typeof t && t.startsWith('walk')) ? (...r) => e[t](...r.map((e) => ('function' == typeof e ? (t, r) => e(t.toProxy(), r) : e))) : 'every' === t || 'some' === t ? (r) => e[t]((e, ...t) => r(e.toProxy(), ...t)) : 'root' === t ? () => e.root().toProxy() : 'nodes' === t ? e.nodes.map((e) => e.toProxy()) : 'first' === t || 'last' === t ? e[t].toProxy() : e[t]) : e[t]), set: (e, t, r) => (e[t] === r || ((e[t] = r), ('name' === t || 'params' === t || 'selector' === t) && e.markDirty()), !0) };
      }
      index(e) {
       return 'number' == typeof e ? e : (e.proxyOf && (e = e.proxyOf), this.proxyOf.nodes.indexOf(e));
      }
      insertAfter(e, t) {
       let r,
        s = this.index(e),
        n = this.normalize(t, this.proxyOf.nodes[s]).reverse();
       s = this.index(e);
       for (let i of n) this.proxyOf.nodes.splice(s + 1, 0, i);
       for (let i in this.indexes) (r = this.indexes[i]), s < r && (this.indexes[i] = r + n.length);
       return this.markDirty(), this;
      }
      insertBefore(e, t) {
       let r,
        s = this.index(e),
        n = 0 === s && 'prepend',
        i = this.normalize(t, this.proxyOf.nodes[s], n).reverse();
       s = this.index(e);
       for (let a of i) this.proxyOf.nodes.splice(s, 0, a);
       for (let a in this.indexes) (r = this.indexes[a]), s <= r && (this.indexes[a] = r + i.length);
       return this.markDirty(), this;
      }
      normalize(t, n) {
       if ('string' == typeof t) t = c(s(t).nodes);
       else if (typeof t > 'u') t = [];
       else if (Array.isArray(t)) {
        t = t.slice(0);
        for (let e of t) e.parent && e.parent.removeChild(e, 'ignore');
       } else if ('root' === t.type && 'document' !== this.type) {
        t = t.nodes.slice(0);
        for (let e of t) e.parent && e.parent.removeChild(e, 'ignore');
       } else if (t.type) t = [t];
       else if (t.prop) {
        if (typeof t.value > 'u') throw new Error('Value field is missed in node creation');
        'string' != typeof t.value && (t.value = String(t.value)), (t = [new o(t)]);
       } else if (t.selector || t.selectors) t = [new i(t)];
       else if (t.name) t = [new r(t)];
       else {
        if (!t.text) throw new Error('Unknown node type in node creation');
        t = [new a(t)];
       }
       return t.map((t) => (t[p] || e.rebuild(t), (t = t.proxyOf).parent && t.parent.removeChild(t), t[l] && h(t), t.raws || (t.raws = {}), typeof t.raws.before > 'u' && n && typeof n.raws.before < 'u' && (t.raws.before = n.raws.before.replace(/\S/g, '')), (t.parent = this.proxyOf), t));
      }
      prepend(...e) {
       e = e.reverse();
       for (let t of e) {
        let e = this.normalize(t, this.first, 'prepend').reverse();
        for (let t of e) this.proxyOf.nodes.unshift(t);
        for (let t in this.indexes) this.indexes[t] = this.indexes[t] + e.length;
       }
       return this.markDirty(), this;
      }
      push(e) {
       return (e.parent = this), this.proxyOf.nodes.push(e), this;
      }
      removeAll() {
       for (let e of this.proxyOf.nodes) e.parent = void 0;
       return (this.proxyOf.nodes = []), this.markDirty(), this;
      }
      removeChild(e) {
       let t;
       (e = this.index(e)), (this.proxyOf.nodes[e].parent = void 0), this.proxyOf.nodes.splice(e, 1);
       for (let r in this.indexes) (t = this.indexes[r]), t >= e && (this.indexes[r] = t - 1);
       return this.markDirty(), this;
      }
      replaceValues(e, t, r) {
       return (
        r || ((r = t), (t = {})),
        this.walkDecls((s) => {
         (t.props && !t.props.includes(s.prop)) || (t.fast && !s.value.includes(t.fast)) || (s.value = s.value.replace(e, r));
        }),
        this.markDirty(),
        this
       );
      }
      some(e) {
       return this.nodes.some(e);
      }
      walk(e) {
       return this.each((t, r) => {
        let s;
        try {
         s = e(t, r);
        } catch (n) {
         throw t.addToError(n);
        }
        return !1 !== s && t.walk && (s = t.walk(e)), s;
       });
      }
      walkAtRules(e, t) {
       return t
        ? e instanceof RegExp
          ? this.walk((r, s) => {
             if ('atrule' === r.type && e.test(r.name)) return t(r, s);
            })
          : this.walk((r, s) => {
             if ('atrule' === r.type && r.name === e) return t(r, s);
            })
        : ((t = e),
          this.walk((e, r) => {
           if ('atrule' === e.type) return t(e, r);
          }));
      }
      walkComments(e) {
       return this.walk((t, r) => {
        if ('comment' === t.type) return e(t, r);
       });
      }
      walkDecls(e, t) {
       return t
        ? e instanceof RegExp
          ? this.walk((r, s) => {
             if ('decl' === r.type && e.test(r.prop)) return t(r, s);
            })
          : this.walk((r, s) => {
             if ('decl' === r.type && r.prop === e) return t(r, s);
            })
        : ((t = e),
          this.walk((e, r) => {
           if ('decl' === e.type) return t(e, r);
          }));
      }
      walkRules(e, t) {
       return t
        ? e instanceof RegExp
          ? this.walk((r, s) => {
             if ('rule' === r.type && e.test(r.selector)) return t(r, s);
            })
          : this.walk((r, s) => {
             if ('rule' === r.type && r.selector === e) return t(r, s);
            })
        : ((t = e),
          this.walk((e, r) => {
           if ('rule' === e.type) return t(e, r);
          }));
      }
      get first() {
       if (this.proxyOf.nodes) return this.proxyOf.nodes[0];
      }
      get last() {
       if (this.proxyOf.nodes) return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
      }
     };
     (d.registerParse = (e) => {
      s = e;
     }),
      (d.registerRule = (e) => {
       i = e;
      }),
      (d.registerAtRule = (e) => {
       r = e;
      }),
      (d.registerRoot = (e) => {
       n = e;
      }),
      (t.exports = d),
      (d.default = d),
      (d.rebuild = (e) => {
       'atrule' === e.type ? Object.setPrototypeOf(e, r.prototype) : 'rule' === e.type ? Object.setPrototypeOf(e, i.prototype) : 'decl' === e.type ? Object.setPrototypeOf(e, o.prototype) : 'comment' === e.type ? Object.setPrototypeOf(e, a.prototype) : 'root' === e.type && Object.setPrototypeOf(e, n.prototype),
        (e[p] = !0),
        e.nodes &&
         e.nodes.forEach((e) => {
          d.rebuild(e);
         });
      });
    }),
    T = l((e, t) => {
     t.exports = {
      nanoid: (e = 21) => {
       let t = '',
        r = 0 | e;
       for (; r--; ) t += 'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'[(64 * Math.random()) | 0];
       return t;
      },
      customAlphabet:
       (e, t = 21) =>
       (r = t) => {
        let s = '',
         n = 0 | r;
        for (; n--; ) s += e[(Math.random() * e.length) | 0];
        return s;
       },
     };
    }),
    A = l(() => {}),
    C = l((e, t) => {
     t.exports = class {};
    }),
    v = l((e, t) => {
     var { nanoid: r } = T(),
      { isAbsolute: s, resolve: n } = {},
      { SourceMapConsumer: i, SourceMapGenerator: a } = A(),
      { fileURLToPath: o, pathToFileURL: u } = {},
      l = f(),
      p = C(),
      c = d(),
      h = Symbol('fromOffsetCache'),
      m = !(!i || !a),
      y = !(!n || !s),
      D = class {
       constructor(e, t = {}) {
        if (null === e || typeof e > 'u' || ('object' == typeof e && !e.toString)) throw new Error(`PostCSS received ${e} instead of CSS string`);
        if (((this.css = e.toString()), '\ufeff' === this.css[0] || '\ufffe' === this.css[0] ? ((this.hasBOM = !0), (this.css = this.css.slice(1))) : (this.hasBOM = !1), (this.document = this.css), t.document && (this.document = t.document.toString()), t.from && (!y || /^\w+:\/\//.test(t.from) || s(t.from) ? (this.file = t.from) : (this.file = n(t.from))), y && m)) {
         let e = new p(this.css, t);
         if (e.text) {
          this.map = e;
          let t = e.consumer().file;
          !this.file && t && (this.file = this.mapResolve(t));
         }
        }
        this.file || (this.id = '<input css ' + r(6) + '>'), this.map && (this.map.file = this.from);
       }
       error(e, t, r, s = {}) {
        let n, i, a;
        if (t && 'object' == typeof t) {
         let e = t,
          s = r;
         if ('number' == typeof e.offset) {
          let s = this.fromOffset(e.offset);
          (t = s.line), (r = s.col);
         } else (t = e.line), (r = e.column);
         if ('number' == typeof s.offset) {
          let e = this.fromOffset(s.offset);
          (i = e.line), (n = e.col);
         } else (i = s.line), (n = s.column);
        } else if (!r) {
         let e = this.fromOffset(t);
         (t = e.line), (r = e.col);
        }
        let o = this.origin(t, r, i, n);
        return (a = o ? new l(e, void 0 === o.endLine ? o.line : { column: o.column, line: o.line }, void 0 === o.endLine ? o.column : { column: o.endColumn, line: o.endLine }, o.source, o.file, s.plugin) : new l(e, void 0 === i ? t : { column: r, line: t }, void 0 === i ? r : { column: n, line: i }, this.css, this.file, s.plugin)), (a.input = { column: r, endColumn: n, endLine: i, line: t, source: this.css }), this.file && (u && (a.input.url = u(this.file).toString()), (a.input.file = this.file)), a;
       }
       fromOffset(e) {
        let t, r;
        if (this[h]) r = this[h];
        else {
         let e = this.css.split('\n');
         r = new Array(e.length);
         let t = 0;
         for (let s = 0, n = e.length; s < n; s++) (r[s] = t), (t += e[s].length + 1);
         this[h] = r;
        }
        t = r[r.length - 1];
        let s = 0;
        if (e >= t) s = r.length - 1;
        else {
         let t,
          n = r.length - 2;
         for (; s < n; )
          if (((t = s + ((n - s) >> 1)), e < r[t])) n = t - 1;
          else {
           if (!(e >= r[t + 1])) {
            s = t;
            break;
           }
           s = t + 1;
          }
        }
        return { col: e - r[s] + 1, line: s + 1 };
       }
       mapResolve(e) {
        return /^\w+:\/\//.test(e) ? e : n(this.map.consumer().sourceRoot || this.map.root || '.', e);
       }
       origin(e, t, r, n) {
        if (!this.map) return !1;
        let i,
         a,
         l = this.map.consumer(),
         p = l.originalPositionFor({ column: t, line: e });
        if (!p.source) return !1;
        'number' == typeof r && (i = l.originalPositionFor({ column: n, line: r })), (a = s(p.source) ? u(p.source) : new URL(p.source, this.map.consumer().sourceRoot || u(this.map.mapFile)));
        let c = { column: p.column, endColumn: i && i.column, endLine: i && i.line, line: p.line, url: a.toString() };
        if ('file:' === a.protocol) {
         if (!o) throw new Error('file: protocol is not available in this PostCSS build');
         c.file = o(a);
        }
        let h = l.sourceContentFor(p.source);
        return h && (c.source = h), c;
       }
       toJSON() {
        let e = {};
        for (let t of ['hasBOM', 'css', 'file', 'id']) null != this[t] && (e[t] = this[t]);
        return this.map && ((e.map = { ...this.map }), e.map.consumerCache && (e.map.consumerCache = void 0)), e;
       }
       get from() {
        return this.file || this.id;
       }
      };
     (t.exports = D), (D.default = D), c && c.registerInput && c.registerInput(D);
    }),
    F = l((e, t) => {
     var r = b(),
      s = class extends r {
       constructor(e) {
        super(e), (this.type = 'atrule');
       }
       append(...e) {
        return this.proxyOf.nodes || (this.nodes = []), super.append(...e);
       }
       prepend(...e) {
        return this.proxyOf.nodes || (this.nodes = []), super.prepend(...e);
       }
      };
     (t.exports = s), (s.default = s), r.registerAtRule(s);
    }),
    w = l((e, t) => {
     var r,
      s,
      n = b(),
      i = class extends n {
       constructor(e) {
        super(e), (this.type = 'root'), this.nodes || (this.nodes = []);
       }
       normalize(e, t, r) {
        let s = super.normalize(e);
        if (t)
         if ('prepend' === r) this.nodes.length > 1 ? (t.raws.before = this.nodes[1].raws.before) : delete t.raws.before;
         else if (this.first !== t) for (let n of s) n.raws.before = t.raws.before;
        return s;
       }
       removeChild(e, t) {
        let r = this.index(e);
        return !t && 0 === r && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[r].raws.before), super.removeChild(e);
       }
       toResult(e = {}) {
        return new r(new s(), this, e).stringify();
       }
      };
     (i.registerLazyResult = (e) => {
      r = e;
     }),
      (i.registerProcessor = (e) => {
       s = e;
      }),
      (t.exports = i),
      (i.default = i),
      n.registerRoot(i);
    }),
    S = l((e, t) => {
     var r = {
      comma: (e) => r.split(e, [','], !0),
      space(e) {
       let t = [' ', '\n', '\t'];
       return r.split(e, t);
      },
      split(e, t, r) {
       let s = [],
        n = '',
        i = !1,
        a = 0,
        o = !1,
        u = '',
        l = !1;
       for (let p of e) l ? (l = !1) : '\\' === p ? (l = !0) : o ? p === u && (o = !1) : '"' === p || "'" === p ? ((o = !0), (u = p)) : '(' === p ? (a += 1) : ')' === p ? a > 0 && (a -= 1) : 0 === a && t.includes(p) && (i = !0), i ? ('' !== n && s.push(n.trim()), (n = ''), (i = !1)) : (n += p);
       return (r || '' !== n) && s.push(n.trim()), s;
      },
     };
     (t.exports = r), (r.default = r);
    }),
    P = l((e, t) => {
     var r = b(),
      s = S(),
      n = class extends r {
       constructor(e) {
        super(e), (this.type = 'rule'), this.nodes || (this.nodes = []);
       }
       get selectors() {
        return s.comma(this.selector);
       }
       set selectors(e) {
        let t = this.selector ? this.selector.match(/,\s*/) : null,
         r = t ? t[0] : ',' + this.raw('between', 'beforeOpen');
        this.selector = e.join(r);
       }
      };
     (t.exports = n), (n.default = n), r.registerRule(n);
    }),
    k = l((e, t) => {
     var r = /[\t\n\f\r "#'()/;[\\\]{}]/g,
      s = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g,
      n = /.[\r\n"'(/\\]/,
      i = /[\da-f]/i;
     t.exports = function (e, t = {}) {
      let a,
       o,
       u,
       l,
       p,
       c,
       h,
       d,
       f,
       m,
       y = e.css.valueOf(),
       D = t.ignoreErrors,
       g = y.length,
       x = 0,
       E = [],
       b = [];
      function T(t) {
       throw e.error('Unclosed ' + t, x);
      }
      return {
       back: function (e) {
        b.push(e);
       },
       endOfFile: function () {
        return 0 === b.length && x >= g;
       },
       nextToken: function (e) {
        if (b.length) return b.pop();
        if (x >= g) return;
        let t = !!e && e.ignoreUnclosed;
        switch (((a = y.charCodeAt(x)), a)) {
         case 10:
         case 32:
         case 9:
         case 13:
         case 12:
          l = x;
          do {
           (l += 1), (a = y.charCodeAt(l));
          } while (32 === a || 10 === a || 9 === a || 13 === a || 12 === a);
          (c = ['space', y.slice(x, l)]), (x = l - 1);
          break;
         case 91:
         case 93:
         case 123:
         case 125:
         case 58:
         case 59:
         case 41: {
          let e = String.fromCharCode(a);
          c = [e, e, x];
          break;
         }
         case 40:
          if (((m = E.length ? E.pop()[1] : ''), (f = y.charCodeAt(x + 1)), 'url' === m && 39 !== f && 34 !== f && 32 !== f && 10 !== f && 9 !== f && 12 !== f && 13 !== f)) {
           l = x;
           do {
            if (((h = !1), (l = y.indexOf(')', l + 1)), -1 === l)) {
             if (D || t) {
              l = x;
              break;
             }
             T('bracket');
            }
            for (d = l; 92 === y.charCodeAt(d - 1); ) (d -= 1), (h = !h);
           } while (h);
           (c = ['brackets', y.slice(x, l + 1), x, l]), (x = l);
          } else (l = y.indexOf(')', x + 1)), (o = y.slice(x, l + 1)), -1 === l || n.test(o) ? (c = ['(', '(', x]) : ((c = ['brackets', o, x, l]), (x = l));
          break;
         case 39:
         case 34:
          (p = 39 === a ? "'" : '"'), (l = x);
          do {
           if (((h = !1), (l = y.indexOf(p, l + 1)), -1 === l)) {
            if (D || t) {
             l = x + 1;
             break;
            }
            T('string');
           }
           for (d = l; 92 === y.charCodeAt(d - 1); ) (d -= 1), (h = !h);
          } while (h);
          (c = ['string', y.slice(x, l + 1), x, l]), (x = l);
          break;
         case 64:
          (r.lastIndex = x + 1), r.test(y), (l = 0 === r.lastIndex ? y.length - 1 : r.lastIndex - 2), (c = ['at-word', y.slice(x, l + 1), x, l]), (x = l);
          break;
         case 92:
          for (l = x, u = !0; 92 === y.charCodeAt(l + 1); ) (l += 1), (u = !u);
          if (((a = y.charCodeAt(l + 1)), u && 47 !== a && 32 !== a && 10 !== a && 9 !== a && 13 !== a && 12 !== a && ((l += 1), i.test(y.charAt(l))))) {
           for (; i.test(y.charAt(l + 1)); ) l += 1;
           32 === y.charCodeAt(l + 1) && (l += 1);
          }
          (c = ['word', y.slice(x, l + 1), x, l]), (x = l);
          break;
         default:
          47 === a && 42 === y.charCodeAt(x + 1) ? ((l = y.indexOf('*/', x + 2) + 1), 0 === l && (D || t ? (l = y.length) : T('comment')), (c = ['comment', y.slice(x, l + 1), x, l]), (x = l)) : ((s.lastIndex = x + 1), s.test(y), (l = 0 === s.lastIndex ? y.length - 1 : s.lastIndex - 2), (c = ['word', y.slice(x, l + 1), x, l]), E.push(c), (x = l));
        }
        return x++, c;
       },
       position: function () {
        return x;
       },
      };
     };
    }),
    I = l((e, t) => {
     var r = F(),
      s = x(),
      n = E(),
      i = w(),
      a = P(),
      o = k(),
      u = { empty: !0, space: !0 };
     t.exports = class {
      constructor(e) {
       (this.input = e), (this.root = new i()), (this.current = this.root), (this.spaces = ''), (this.semicolon = !1), this.createTokenizer(), (this.root.source = { input: e, start: { column: 1, line: 1, offset: 0 } });
      }
      atrule(e) {
       let t = new r();
       (t.name = e[1].slice(1)), '' === t.name && this.unnamedAtrule(t, e), this.init(t, e[2]);
       let s,
        n,
        i,
        a = !1,
        o = !1,
        u = [],
        l = [];
       for (; !this.tokenizer.endOfFile(); ) {
        if (((s = (e = this.tokenizer.nextToken())[0]), '(' === s || '[' === s ? l.push('(' === s ? ')' : ']') : '{' === s && l.length > 0 ? l.push('}') : s === l[l.length - 1] && l.pop(), 0 === l.length)) {
         if (';' === s) {
          (t.source.end = this.getPosition(e[2])), t.source.end.offset++, (this.semicolon = !0);
          break;
         }
         if ('{' === s) {
          o = !0;
          break;
         }
         if ('}' === s) {
          if (u.length > 0) {
           for (i = u.length - 1, n = u[i]; n && 'space' === n[0]; ) n = u[--i];
           n && ((t.source.end = this.getPosition(n[3] || n[2])), t.source.end.offset++);
          }
          this.end(e);
          break;
         }
         u.push(e);
        } else u.push(e);
        if (this.tokenizer.endOfFile()) {
         a = !0;
         break;
        }
       }
       (t.raws.between = this.spacesAndCommentsFromEnd(u)), u.length ? ((t.raws.afterName = this.spacesAndCommentsFromStart(u)), this.raw(t, 'params', u), a && ((e = u[u.length - 1]), (t.source.end = this.getPosition(e[3] || e[2])), t.source.end.offset++, (this.spaces = t.raws.between), (t.raws.between = ''))) : ((t.raws.afterName = ''), (t.params = '')), o && ((t.nodes = []), (this.current = t));
      }
      checkMissedSemicolon(e) {
       let t = this.colon(e);
       if (!1 === t) return;
       let r,
        s = 0;
       for (let n = t - 1; n >= 0 && ((r = e[n]), 'space' === r[0] || ((s += 1), 2 !== s)); n--);
       throw this.input.error('Missed semicolon', 'word' === r[0] ? r[3] + 1 : r[2]);
      }
      colon(e) {
       let t,
        r,
        s,
        n = 0;
       for (let [i, a] of e.entries()) {
        if (((r = a), (s = r[0]), '(' === s && (n += 1), ')' === s && (n -= 1), 0 === n && ':' === s)) {
         if (t) {
          if ('word' === t[0] && 'progid' === t[1]) continue;
          return i;
         }
         this.doubleColon(r);
        }
        t = r;
       }
       return !1;
      }
      comment(e) {
       let t = new s();
       this.init(t, e[2]), (t.source.end = this.getPosition(e[3] || e[2])), t.source.end.offset++;
       let r = e[1].slice(2, -2);
       if (/^\s*$/.test(r)) (t.text = ''), (t.raws.left = r), (t.raws.right = '');
       else {
        let e = r.match(/^(\s*)([^]*\S)(\s*)$/);
        (t.text = e[2]), (t.raws.left = e[1]), (t.raws.right = e[3]);
       }
      }
      createTokenizer() {
       this.tokenizer = o(this.input);
      }
      decl(e, t) {
       let r = new n();
       this.init(r, e[0][2]);
       let s,
        i = e[e.length - 1];
       for (
        ';' === i[0] && ((this.semicolon = !0), e.pop()),
         r.source.end = this.getPosition(
          i[3] ||
           i[2] ||
           (function (e) {
            for (let t = e.length - 1; t >= 0; t--) {
             let r = e[t],
              s = r[3] || r[2];
             if (s) return s;
            }
           })(e),
         ),
         r.source.end.offset++;
        'word' !== e[0][0];

       )
        1 === e.length && this.unknownWord(e), (r.raws.before += e.shift()[1]);
       for (r.source.start = this.getPosition(e[0][2]), r.prop = ''; e.length; ) {
        let t = e[0][0];
        if (':' === t || 'space' === t || 'comment' === t) break;
        r.prop += e.shift()[1];
       }
       for (r.raws.between = ''; e.length; ) {
        if (((s = e.shift()), ':' === s[0])) {
         r.raws.between += s[1];
         break;
        }
        'word' === s[0] && /\w/.test(s[1]) && this.unknownWord([s]), (r.raws.between += s[1]);
       }
       ('_' === r.prop[0] || '*' === r.prop[0]) && ((r.raws.before += r.prop[0]), (r.prop = r.prop.slice(1)));
       let a,
        o = [];
       for (; e.length && ((a = e[0][0]), 'space' === a || 'comment' === a); ) o.push(e.shift());
       this.precheckMissedSemicolon(e);
       for (let n = e.length - 1; n >= 0; n--) {
        if (((s = e[n]), '!important' === s[1].toLowerCase())) {
         r.important = !0;
         let t = this.stringFrom(e, n);
         (t = this.spacesFromEnd(e) + t), ' !important' !== t && (r.raws.important = t);
         break;
        }
        if ('important' === s[1].toLowerCase()) {
         let t = e.slice(0),
          s = '';
         for (let e = n; e > 0; e--) {
          let r = t[e][0];
          if (s.trim().startsWith('!') && 'space' !== r) break;
          s = t.pop()[1] + s;
         }
         s.trim().startsWith('!') && ((r.important = !0), (r.raws.important = s), (e = t));
        }
        if ('space' !== s[0] && 'comment' !== s[0]) break;
       }
       e.some((e) => 'space' !== e[0] && 'comment' !== e[0]) && ((r.raws.between += o.map((e) => e[1]).join('')), (o = [])), this.raw(r, 'value', o.concat(e), t), r.value.includes(':') && !t && this.checkMissedSemicolon(e);
      }
      doubleColon(e) {
       throw this.input.error('Double colon', { offset: e[2] }, { offset: e[2] + e[1].length });
      }
      emptyRule(e) {
       let t = new a();
       this.init(t, e[2]), (t.selector = ''), (t.raws.between = ''), (this.current = t);
      }
      end(e) {
       this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), (this.semicolon = !1), (this.current.raws.after = (this.current.raws.after || '') + this.spaces), (this.spaces = ''), this.current.parent ? ((this.current.source.end = this.getPosition(e[2])), this.current.source.end.offset++, (this.current = this.current.parent)) : this.unexpectedClose(e);
      }
      endFile() {
       this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), (this.current.raws.after = (this.current.raws.after || '') + this.spaces), (this.root.source.end = this.getPosition(this.tokenizer.position()));
      }
      freeSemicolon(e) {
       if (((this.spaces += e[1]), this.current.nodes)) {
        let e = this.current.nodes[this.current.nodes.length - 1];
        e && 'rule' === e.type && !e.raws.ownSemicolon && ((e.raws.ownSemicolon = this.spaces), (this.spaces = ''));
       }
      }
      getPosition(e) {
       let t = this.input.fromOffset(e);
       return { column: t.col, line: t.line, offset: e };
      }
      init(e, t) {
       this.current.push(e), (e.source = { input: this.input, start: this.getPosition(t) }), (e.raws.before = this.spaces), (this.spaces = ''), 'comment' !== e.type && (this.semicolon = !1);
      }
      other(e) {
       let t = !1,
        r = null,
        s = !1,
        n = null,
        i = [],
        a = e[1].startsWith('--'),
        o = [],
        u = e;
       for (; u; ) {
        if (((r = u[0]), o.push(u), '(' === r || '[' === r)) n || (n = u), i.push('(' === r ? ')' : ']');
        else if (a && s && '{' === r) n || (n = u), i.push('}');
        else if (0 === i.length) {
         if (';' === r) {
          if (s) return void this.decl(o, a);
          break;
         }
         if ('{' === r) return void this.rule(o);
         if ('}' === r) {
          this.tokenizer.back(o.pop()), (t = !0);
          break;
         }
         ':' === r && (s = !0);
        } else r === i[i.length - 1] && (i.pop(), 0 === i.length && (n = null));
        u = this.tokenizer.nextToken();
       }
       if ((this.tokenizer.endOfFile() && (t = !0), i.length > 0 && this.unclosedBracket(n), t && s)) {
        if (!a) for (; o.length && ((u = o[o.length - 1][0]), 'space' === u || 'comment' === u); ) this.tokenizer.back(o.pop());
        this.decl(o, a);
       } else this.unknownWord(o);
      }
      parse() {
       let e;
       for (; !this.tokenizer.endOfFile(); )
        switch (((e = this.tokenizer.nextToken()), e[0])) {
         case 'space':
          this.spaces += e[1];
          break;
         case ';':
          this.freeSemicolon(e);
          break;
         case '}':
          this.end(e);
          break;
         case 'comment':
          this.comment(e);
          break;
         case 'at-word':
          this.atrule(e);
          break;
         case '{':
          this.emptyRule(e);
          break;
         default:
          this.other(e);
        }
       this.endFile();
      }
      precheckMissedSemicolon() {}
      raw(e, t, r, s) {
       let n,
        i,
        a,
        o,
        l = r.length,
        p = '',
        c = !0;
       for (let h = 0; h < l; h += 1) (n = r[h]), (i = n[0]), 'space' !== i || h !== l - 1 || s ? ('comment' === i ? ((o = r[h - 1] ? r[h - 1][0] : 'empty'), (a = r[h + 1] ? r[h + 1][0] : 'empty'), u[o] || u[a] || ',' === p.slice(-1) ? (c = !1) : (p += n[1])) : (p += n[1])) : (c = !1);
       if (!c) {
        let s = r.reduce((e, t) => e + t[1], '');
        e.raws[t] = { raw: s, value: p };
       }
       e[t] = p;
      }
      rule(e) {
       e.pop();
       let t = new a();
       this.init(t, e[0][2]), (t.raws.between = this.spacesAndCommentsFromEnd(e)), this.raw(t, 'selector', e), (this.current = t);
      }
      spacesAndCommentsFromEnd(e) {
       let t,
        r = '';
       for (; e.length && ((t = e[e.length - 1][0]), 'space' === t || 'comment' === t); ) r = e.pop()[1] + r;
       return r;
      }
      spacesAndCommentsFromStart(e) {
       let t,
        r = '';
       for (; e.length && ((t = e[0][0]), 'space' === t || 'comment' === t); ) r += e.shift()[1];
       return r;
      }
      spacesFromEnd(e) {
       let t,
        r = '';
       for (; e.length && ((t = e[e.length - 1][0]), 'space' === t); ) r = e.pop()[1] + r;
       return r;
      }
      stringFrom(e, t) {
       let r = '';
       for (let s = t; s < e.length; s++) r += e[s][1];
       return e.splice(t, e.length - t), r;
      }
      unclosedBlock() {
       let e = this.current.source.start;
       throw this.input.error('Unclosed block', e.line, e.column);
      }
      unclosedBracket(e) {
       throw this.input.error('Unclosed bracket', { offset: e[2] }, { offset: e[2] + 1 });
      }
      unexpectedClose(e) {
       throw this.input.error('Unexpected }', { offset: e[2] }, { offset: e[2] + 1 });
      }
      unknownWord(e) {
       throw this.input.error('Unknown word', { offset: e[0][2] }, { offset: e[0][2] + e[0][1].length });
      }
      unnamedAtrule(e, t) {
       throw this.input.error('At-rule without name', { offset: t[2] }, { offset: t[2] + t[1].length });
      }
     };
    }),
    N = l((e, t) => {
     var r = b(),
      s = v(),
      n = I();
     function i(e, t) {
      let r = new s(e, t),
       i = new n(r);
      try {
       i.parse();
      } catch (a) {
       throw a;
      }
      return i.root;
     }
     (t.exports = i), (i.default = i), r.registerParse(i);
    }),
    B = l((e, t) => {
     var r = k(),
      s = v();
     t.exports = {
      isInlineComment(e) {
       if ('word' === e[0] && '//' === e[1].slice(0, 2)) {
        let t,
         n,
         i = e,
         a = [];
        for (; e; ) {
         if (/\r?\n/.test(e[1])) {
          if (/['"].*\r?\n/.test(e[1])) {
           a.push(e[1].substring(0, e[1].indexOf('\n'))), (n = e[1].substring(e[1].indexOf('\n')));
           let r = this.input.css.valueOf().substring(this.tokenizer.position());
           (n += r), (t = e[3] + r.length - n.length);
          } else this.tokenizer.back(e);
          break;
         }
         a.push(e[1]), (t = e[2]), (e = this.tokenizer.nextToken({ ignoreUnclosed: !0 }));
        }
        let o = ['comment', a.join(''), i[2], t];
        return this.inlineComment(o), n && ((this.input = new s(n)), (this.tokenizer = r(this.input))), !0;
       }
       if ('/' === e[1]) {
        let r = this.tokenizer.nextToken({ ignoreUnclosed: !0 });
        if ('comment' === r[0] && /^\/\*/.test(r[1])) return (r[0] = 'word'), (r[1] = r[1].slice(1)), (e[1] = '//'), this.tokenizer.back(r), t.exports.isInlineComment.bind(this)(e);
       }
       return !1;
      },
     };
    }),
    O = l((e, t) => {
     t.exports = {
      interpolation(e) {
       let t = [e, this.tokenizer.nextToken()],
        r = ['word', '}'];
       if (t[0][1].length > 1 || '{' !== t[1][0]) return this.tokenizer.back(t[1]), !1;
       for (e = this.tokenizer.nextToken(); e && r.includes(e[0]); ) t.push(e), (e = this.tokenizer.nextToken());
       let s = t.map((e) => e[1]),
        [n] = t,
        i = t.pop(),
        a = ['word', s.join(''), n[2], i[2]];
       return this.tokenizer.back(e), this.tokenizer.back(a), !0;
      },
     };
    }),
    L = l((e, t) => {
     var r = /^#[0-9a-fA-F]{6}$|^#[0-9a-fA-F]{3}$/,
      s = /\.[0-9]/;
     t.exports = {
      isMixinToken: (e) => {
       let [, t] = e,
        [n] = t;
       return ('.' === n || '#' === n) && !1 === r.test(t) && !1 === s.test(t);
      },
     };
    }),
    M = l((e, t) => {
     var r = k(),
      s = /^url\((.+)\)/;
     t.exports = (e) => {
      let { name: t, params: n = '' } = e;
      if ('import' === t && n.length) {
       e.import = !0;
       let t = r({ css: n });
       for (e.filename = n.replace(s, '$1'); !t.endOfFile(); ) {
        let [r, s] = t.nextToken();
        if ('word' === r && 'url' === s) return;
        if ('brackets' === r) {
         (e.options = s), (e.filename = n.replace(s, '').trim());
         break;
        }
       }
      }
     };
    }),
    j = l((e, t) => {
     var r = /:$/,
      s = /^:(\s+)?/;
     t.exports = (e) => {
      let { name: t, params: n = '' } = e;
      if (':' === e.name.slice(-1)) {
       if (r.test(t)) {
        let [s] = t.match(r);
        (e.name = t.replace(s, '')), (e.raws.afterName = s + (e.raws.afterName || '')), (e.variable = !0), (e.value = e.params);
       }
       if (s.test(n)) {
        let [t] = n.match(s);
        (e.value = n.replace(t, '')), (e.raws.afterName = (e.raws.afterName || '') + t), (e.variable = !0);
       }
      }
     };
    }),
    _ = l((e, t) => {
     var r = x(),
      s = I(),
      { isInlineComment: n } = B(),
      { interpolation: i } = O(),
      { isMixinToken: a } = L(),
      o = M(),
      u = j(),
      l = /(!\s*important)$/i;
     t.exports = class extends s {
      constructor(...e) {
       super(...e), (this.lastNode = null);
      }
      atrule(e) {
       i.bind(this)(e) || (super.atrule(e), o(this.lastNode), u(this.lastNode));
      }
      decl(...e) {
       super.decl(...e), /extend\(.+\)/i.test(this.lastNode.value) && (this.lastNode.extend = !0);
      }
      each(e) {
       e[0][1] = ` ${e[0][1]}`;
       let t = e.findIndex((e) => '(' === e[0]),
        r = e.reverse().find((e) => ')' === e[0]),
        s = e.reverse().indexOf(r),
        n = e
         .splice(t, s)
         .map((e) => e[1])
         .join('');
       for (let i of e.reverse()) this.tokenizer.back(i);
       this.atrule(this.tokenizer.nextToken()), (this.lastNode.function = !0), (this.lastNode.params = n);
      }
      init(e, t, r) {
       super.init(e, t, r), (this.lastNode = e);
      }
      inlineComment(e) {
       let t = new r(),
        s = e[1].slice(2);
       if ((this.init(t, e[2]), (t.source.end = this.getPosition(e[3] || e[2])), (t.inline = !0), (t.raws.begin = '//'), /^\s*$/.test(s))) (t.text = ''), (t.raws.left = s), (t.raws.right = '');
       else {
        let e = s.match(/^(\s*)([^]*[^\s])(\s*)$/);
        [, t.raws.left, t.text, t.raws.right] = e;
       }
      }
      mixin(e) {
       let [t] = e,
        r = t[1].slice(0, 1),
        s = e.findIndex((e) => 'brackets' === e[0]),
        n = e.findIndex((e) => '(' === e[0]),
        i = '';
       if ((s < 0 || s > 3) && n > 0) {
        let t = e.reduce((e, t, r) => (')' === t[0] ? r : e)),
         r = e
          .slice(n, t + n)
          .map((e) => e[1])
          .join(''),
         [s] = e.slice(n),
         i = [s[2], s[3]],
         [a] = e.slice(t, t + 1),
         o = [a[2], a[3]],
         u = ['brackets', r].concat(i, o),
         l = e.slice(0, n),
         p = e.slice(t + 1);
        (e = l).push(u), (e = e.concat(p));
       }
       let a = [];
       for (let u of e) if ((('!' === u[1] || a.length) && a.push(u), 'important' === u[1])) break;
       if (a.length) {
        let [t] = a,
         r = e.indexOf(t),
         s = a[a.length - 1],
         n = [t[2], t[3]],
         i = [s[4], s[5]],
         o = ['word', a.map((e) => e[1]).join('')].concat(n, i);
        e.splice(r, a.length, o);
       }
       let o = e.findIndex((e) => l.test(e[1]));
       o > 0 && (([, i] = e[o]), e.splice(o, 1));
       for (let u of e.reverse()) this.tokenizer.back(u);
       this.atrule(this.tokenizer.nextToken()), (this.lastNode.mixin = !0), (this.lastNode.raws.identifier = r), i && ((this.lastNode.important = !0), (this.lastNode.raws.important = i));
      }
      other(e) {
       n.bind(this)(e) || super.other(e);
      }
      rule(e) {
       let t = e[e.length - 1],
        r = e[e.length - 2];
       if ('at-word' === r[0] && '{' === t[0] && (this.tokenizer.back(t), i.bind(this)(r))) {
        let t = this.tokenizer.nextToken();
        e = e.slice(0, e.length - 2).concat([t]);
        for (let r of e.reverse()) this.tokenizer.back(r);
       } else super.rule(e), /:extend\(.+\)/i.test(this.lastNode.selector) && (this.lastNode.extend = !0);
      }
      unknownWord(e) {
       let [t] = e;
       'each' !== e[0][1] || '(' !== e[1][0] ? (a(t) ? this.mixin(e) : super.unknownWord(e)) : this.each(e);
      }
     };
    }),
    R = l((e, t) => {
     var r = m();
     t.exports = class extends r {
      atrule(e, t) {
       if (!e.mixin && !e.variable && !e.function) return void super.atrule(e, t);
       let r = `${e.function ? '' : e.raws.identifier || '@'}${e.name}`,
        s = e.params ? this.rawValue(e, 'params') : '',
        n = e.raws.important || '';
       if ((e.variable && (s = e.value), typeof e.raws.afterName < 'u' ? (r += e.raws.afterName) : s && (r += ' '), e.nodes)) this.block(e, r + s + n);
       else {
        let i = (e.raws.between || '') + n + (t ? ';' : '');
        this.builder(r + s + i, e);
       }
      }
      comment(e) {
       if (e.inline) {
        let t = this.raw(e, 'left', 'commentLeft'),
         r = this.raw(e, 'right', 'commentRight');
        this.builder(`//${t}${e.text}${r}`, e);
       } else super.comment(e);
      }
     };
    }),
    U = l((e, t) => {
     var r = v(),
      s = _(),
      n = R();
     t.exports = {
      parse(e, t) {
       let n = new r(e, t),
        i = new s(n);
       return (
        i.parse(),
        i.root.walk((e) => {
         let t = n.css.lastIndexOf(e.source.input.css);
         if (0 === t) return;
         if (t + e.source.input.css.length !== n.css.length) throw new Error('Invalid state detected in postcss-less');
         let r = t + e.source.start.offset,
          s = n.fromOffset(t + e.source.start.offset);
         if (((e.source.start = { offset: r, line: s.line, column: s.col }), e.source.end)) {
          let r = t + e.source.end.offset,
           s = n.fromOffset(t + e.source.end.offset);
          e.source.end = { offset: r, line: s.line, column: s.col };
         }
        }),
        i.root
       );
      },
      stringify(e, t) {
       new n(t).stringify(e);
      },
      nodeToString(e) {
       let r = '';
       return (
        t.exports.stringify(e, (e) => {
         r += e;
        }),
        r
       );
      },
     };
    }),
    $ = l((e, t) => {
     var r,
      s,
      n = b(),
      i = class extends n {
       constructor(e) {
        super({ type: 'document', ...e }), this.nodes || (this.nodes = []);
       }
       toResult(e = {}) {
        return new r(new s(), this, e).stringify();
       }
      };
     (i.registerLazyResult = (e) => {
      r = e;
     }),
      (i.registerProcessor = (e) => {
       s = e;
      }),
      (t.exports = i),
      (i.default = i);
    }),
    q = l((e, t) => {
     var r = F(),
      s = x(),
      n = E(),
      i = v(),
      a = C(),
      o = w(),
      u = P();
     function l(e, t) {
      if (Array.isArray(e)) return e.map((e) => l(e));
      let { inputs: p, ...c } = e;
      if (p) {
       t = [];
       for (let e of p) {
        let r = { ...e, __proto__: i.prototype };
        r.map && (r.map = { ...r.map, __proto__: a.prototype }), t.push(r);
       }
      }
      if ((c.nodes && (c.nodes = e.nodes.map((e) => l(e, t))), c.source)) {
       let { inputId: e, ...r } = c.source;
       (c.source = r), null != e && (c.source.input = t[e]);
      }
      if ('root' === c.type) return new o(c);
      if ('decl' === c.type) return new n(c);
      if ('rule' === c.type) return new u(c);
      if ('comment' === c.type) return new s(c);
      if ('atrule' === c.type) return new r(c);
      throw new Error('Unknown node type: ' + e.type);
     }
     (t.exports = l), (l.default = l);
    }),
    J = l((e, t) => {
     t.exports = class {
      generate() {}
     };
    }),
    W = l((e, t) => {
     var r = class {
      constructor(e, t = {}) {
       if (((this.type = 'warning'), (this.text = e), t.node && t.node.source)) {
        let e = t.node.rangeBy(t);
        (this.line = e.start.line), (this.column = e.start.column), (this.endLine = e.end.line), (this.endColumn = e.end.column);
       }
       for (let r in t) this[r] = t[r];
      }
      toString() {
       return this.node ? this.node.error(this.text, { index: this.index, plugin: this.plugin, word: this.word }).message : this.plugin ? this.plugin + ': ' + this.text : this.text;
      }
     };
     (t.exports = r), (r.default = r);
    }),
    z = l((e, t) => {
     var r = W(),
      s = class {
       constructor(e, t, r) {
        (this.processor = e), (this.messages = []), (this.root = t), (this.opts = r), (this.css = void 0), (this.map = void 0);
       }
       toString() {
        return this.css;
       }
       warn(e, t = {}) {
        t.plugin || (this.lastPlugin && this.lastPlugin.postcssPlugin && (t.plugin = this.lastPlugin.postcssPlugin));
        let s = new r(e, t);
        return this.messages.push(s), s;
       }
       warnings() {
        return this.messages.filter((e) => 'warning' === e.type);
       }
       get content() {
        return this.css;
       }
      };
     (t.exports = s), (s.default = s);
    }),
    V = l((e, t) => {
     var r = {};
     t.exports = function (e) {
      r[e] || ((r[e] = !0), typeof console < 'u' && console.warn && console.warn(e));
     };
    }),
    H = l((e, t) => {
     var r = b(),
      s = $(),
      n = J(),
      i = N(),
      a = z(),
      o = w(),
      u = y(),
      { isClean: l, my: p } = D(),
      c = (V(), { atrule: 'AtRule', comment: 'Comment', decl: 'Declaration', document: 'Document', root: 'Root', rule: 'Rule' }),
      h = { AtRule: !0, AtRuleExit: !0, Comment: !0, CommentExit: !0, Declaration: !0, DeclarationExit: !0, Document: !0, DocumentExit: !0, Once: !0, OnceExit: !0, postcssPlugin: !0, prepare: !0, Root: !0, RootExit: !0, Rule: !0, RuleExit: !0 },
      d = { Once: !0, postcssPlugin: !0, prepare: !0 },
      f = 0;
     function m(e) {
      return 'object' == typeof e && 'function' == typeof e.then;
     }
     function g(e) {
      let t = !1,
       r = c[e.type];
      return 'decl' === e.type ? (t = e.prop.toLowerCase()) : 'atrule' === e.type && (t = e.name.toLowerCase()), t && e.append ? [r, r + '-' + t, f, r + 'Exit', r + 'Exit-' + t] : t ? [r, r + '-' + t, r + 'Exit', r + 'Exit-' + t] : e.append ? [r, f, r + 'Exit'] : [r, r + 'Exit'];
     }
     function x(e) {
      let t;
      return (t = 'document' === e.type ? ['Document', f, 'DocumentExit'] : 'root' === e.type ? ['Root', f, 'RootExit'] : g(e)), { eventIndex: 0, events: t, iterator: 0, node: e, visitorIndex: 0, visitors: [] };
     }
     function E(e) {
      return (e[l] = !1), e.nodes && e.nodes.forEach((e) => E(e)), e;
     }
     var T = {},
      A = class e {
       constructor(t, s, n) {
        let o;
        if (((this.stringified = !1), (this.processed = !1), 'object' != typeof s || null === s || ('root' !== s.type && 'document' !== s.type)))
         if (s instanceof e || s instanceof a) (o = E(s.root)), s.map && (typeof n.map > 'u' && (n.map = {}), n.map.inline || (n.map.inline = !1), (n.map.prev = s.map));
         else {
          let e = i;
          n.syntax && (e = n.syntax.parse), n.parser && (e = n.parser), e.parse && (e = e.parse);
          try {
           o = e(s, n);
          } catch (u) {
           (this.processed = !0), (this.error = u);
          }
          o && !o[p] && r.rebuild(o);
         }
        else o = E(s);
        (this.result = new a(t, o, n)), (this.helpers = { ...T, postcss: T, result: this.result }), (this.plugins = this.processor.plugins.map((e) => ('object' == typeof e && e.prepare ? { ...e, ...e.prepare(this.result) } : e)));
       }
       async() {
        return this.error ? Promise.reject(this.error) : this.processed ? Promise.resolve(this.result) : (this.processing || (this.processing = this.runAsync()), this.processing);
       }
       catch(e) {
        return this.async().catch(e);
       }
       finally(e) {
        return this.async().then(e, e);
       }
       getAsyncError() {
        throw new Error('Use process(css).then(cb) to work with async plugins');
       }
       handleError(e, t) {
        let r = this.result.lastPlugin;
        try {
         t && t.addToError(e), (this.error = e), 'CssSyntaxError' !== e.name || e.plugin ? r.postcssVersion : ((e.plugin = r.postcssPlugin), e.setMessage());
        } catch (s) {
         console && console.error && console.error(s);
        }
        return e;
       }
       prepareVisitors() {
        this.listeners = {};
        let e = (e, t, r) => {
         this.listeners[t] || (this.listeners[t] = []), this.listeners[t].push([e, r]);
        };
        for (let t of this.plugins)
         if ('object' == typeof t)
          for (let r in t) {
           if (!h[r] && /^[A-Z]/.test(r)) throw new Error(`Unknown event ${r} in ${t.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`);
           if (!d[r])
            if ('object' == typeof t[r]) for (let s in t[r]) e(t, '*' === s ? r : r + '-' + s.toLowerCase(), t[r][s]);
            else 'function' == typeof t[r] && e(t, r, t[r]);
          }
        this.hasListener = Object.keys(this.listeners).length > 0;
       }
       async runAsync() {
        this.plugin = 0;
        for (let t = 0; t < this.plugins.length; t++) {
         let r = this.plugins[t],
          s = this.runOnRoot(r);
         if (m(s))
          try {
           await s;
          } catch (e) {
           throw this.handleError(e);
          }
        }
        if ((this.prepareVisitors(), this.hasListener)) {
         let t = this.result.root;
         for (; !t[l]; ) {
          t[l] = !0;
          let r = [x(t)];
          for (; r.length > 0; ) {
           let t = this.visitTick(r);
           if (m(t))
            try {
             await t;
            } catch (e) {
             let t = r[r.length - 1].node;
             throw this.handleError(e, t);
            }
          }
         }
         if (this.listeners.OnceExit)
          for (let [r, s] of this.listeners.OnceExit) {
           this.result.lastPlugin = r;
           try {
            if ('document' === t.type) {
             let e = t.nodes.map((e) => s(e, this.helpers));
             await Promise.all(e);
            } else await s(t, this.helpers);
           } catch (e) {
            throw this.handleError(e);
           }
          }
        }
        return (this.processed = !0), this.stringify();
       }
       runOnRoot(e) {
        this.result.lastPlugin = e;
        try {
         if ('object' == typeof e && e.Once) {
          if ('document' === this.result.root.type) {
           let t = this.result.root.nodes.map((t) => e.Once(t, this.helpers));
           return m(t[0]) ? Promise.all(t) : t;
          }
          return e.Once(this.result.root, this.helpers);
         }
         if ('function' == typeof e) return e(this.result.root, this.result);
        } catch (t) {
         throw this.handleError(t);
        }
       }
       stringify() {
        if (this.error) throw this.error;
        if (this.stringified) return this.result;
        (this.stringified = !0), this.sync();
        let e = this.result.opts,
         t = u;
        e.syntax && (t = e.syntax.stringify), e.stringifier && (t = e.stringifier), t.stringify && (t = t.stringify);
        let r = new n(t, this.result.root, this.result.opts).generate();
        return (this.result.css = r[0]), (this.result.map = r[1]), this.result;
       }
       sync() {
        if (this.error) throw this.error;
        if (this.processed) return this.result;
        if (((this.processed = !0), this.processing)) throw this.getAsyncError();
        for (let e of this.plugins) {
         if (m(this.runOnRoot(e))) throw this.getAsyncError();
        }
        if ((this.prepareVisitors(), this.hasListener)) {
         let e = this.result.root;
         for (; !e[l]; ) (e[l] = !0), this.walkSync(e);
         if (this.listeners.OnceExit)
          if ('document' === e.type) for (let t of e.nodes) this.visitSync(this.listeners.OnceExit, t);
          else this.visitSync(this.listeners.OnceExit, e);
        }
        return this.result;
       }
       then(e, t) {
        return this.async().then(e, t);
       }
       toString() {
        return this.css;
       }
       visitSync(e, t) {
        for (let [s, n] of e) {
         let e;
         this.result.lastPlugin = s;
         try {
          e = n(t, this.helpers);
         } catch (r) {
          throw this.handleError(r, t.proxyOf);
         }
         if ('root' !== t.type && 'document' !== t.type && !t.parent) return !0;
         if (m(e)) throw this.getAsyncError();
        }
       }
       visitTick(e) {
        let t = e[e.length - 1],
         { node: r, visitors: s } = t;
        if ('root' !== r.type && 'document' !== r.type && !r.parent) return void e.pop();
        if (s.length > 0 && t.visitorIndex < s.length) {
         let [e, n] = s[t.visitorIndex];
         (t.visitorIndex += 1), t.visitorIndex === s.length && ((t.visitors = []), (t.visitorIndex = 0)), (this.result.lastPlugin = e);
         try {
          return n(r.toProxy(), this.helpers);
         } catch (i) {
          throw this.handleError(i, r);
         }
        }
        if (0 !== t.iterator) {
         let s,
          n = t.iterator;
         for (; (s = r.nodes[r.indexes[n]]); ) if (((r.indexes[n] += 1), !s[l])) return (s[l] = !0), void e.push(x(s));
         (t.iterator = 0), delete r.indexes[n];
        }
        let n = t.events;
        for (; t.eventIndex < n.length; ) {
         let e = n[t.eventIndex];
         if (((t.eventIndex += 1), e === f)) return void (r.nodes && r.nodes.length && ((r[l] = !0), (t.iterator = r.getIterator())));
         if (this.listeners[e]) return void (t.visitors = this.listeners[e]);
        }
        e.pop();
       }
       walkSync(e) {
        e[l] = !0;
        let t = g(e);
        for (let r of t)
         if (r === f)
          e.nodes &&
           e.each((e) => {
            e[l] || this.walkSync(e);
           });
         else {
          let t = this.listeners[r];
          if (t && this.visitSync(t, e.toProxy())) return;
         }
       }
       warnings() {
        return this.sync().warnings();
       }
       get content() {
        return this.stringify().content;
       }
       get css() {
        return this.stringify().css;
       }
       get map() {
        return this.stringify().map;
       }
       get messages() {
        return this.sync().messages;
       }
       get opts() {
        return this.result.opts;
       }
       get processor() {
        return this.result.processor;
       }
       get root() {
        return this.sync().root;
       }
       get [Symbol.toStringTag]() {
        return 'LazyResult';
       }
      };
     (A.registerPostcss = (e) => {
      T = e;
     }),
      (t.exports = A),
      (A.default = A),
      o.registerLazyResult(A),
      s.registerLazyResult(A);
    }),
    K = l((e, t) => {
     var r = J(),
      s = N(),
      n = z(),
      i = y(),
      a =
       (V(),
       class {
        constructor(e, t, s) {
         (t = t.toString()), (this.stringified = !1), (this._processor = e), (this._css = t), (this._opts = s), (this._map = void 0);
         let a,
          o = i;
         (this.result = new n(this._processor, a, this._opts)), (this.result.css = t);
         let u = this;
         Object.defineProperty(this.result, 'root', { get: () => u.root });
         let l = new r(o, a, this._opts, t);
         if (l.isMap()) {
          let [e, t] = l.generate();
          e && (this.result.css = e), t && (this.result.map = t);
         } else l.clearAnnotation(), (this.result.css = l.css);
        }
        async() {
         return this.error ? Promise.reject(this.error) : Promise.resolve(this.result);
        }
        catch(e) {
         return this.async().catch(e);
        }
        finally(e) {
         return this.async().then(e, e);
        }
        sync() {
         if (this.error) throw this.error;
         return this.result;
        }
        then(e, t) {
         return this.async().then(e, t);
        }
        toString() {
         return this._css;
        }
        warnings() {
         return [];
        }
        get content() {
         return this.result.css;
        }
        get css() {
         return this.result.css;
        }
        get map() {
         return this.result.map;
        }
        get messages() {
         return [];
        }
        get opts() {
         return this.result.opts;
        }
        get processor() {
         return this.result.processor;
        }
        get root() {
         if (this._root) return this._root;
         let e,
          t = s;
         try {
          e = t(this._css, this._opts);
         } catch (r) {
          this.error = r;
         }
         if (this.error) throw this.error;
         return (this._root = e), e;
        }
        get [Symbol.toStringTag]() {
         return 'NoWorkResult';
        }
       });
     (t.exports = a), (a.default = a);
    }),
    X = l((e, t) => {
     var r = $(),
      s = H(),
      n = K(),
      i = w(),
      a = class {
       constructor(e = []) {
        (this.version = '8.5.1'), (this.plugins = this.normalize(e));
       }
       normalize(e) {
        let t = [];
        for (let r of e)
         if ((!0 === r.postcss ? (r = r()) : r.postcss && (r = r.postcss), 'object' == typeof r && Array.isArray(r.plugins))) t = t.concat(r.plugins);
         else if ('object' == typeof r && r.postcssPlugin) t.push(r);
         else if ('function' == typeof r) t.push(r);
         else if ('object' != typeof r || (!r.parse && !r.stringify)) throw new Error(r + ' is not a PostCSS plugin');
        return t;
       }
       process(e, t = {}) {
        return this.plugins.length || t.parser || t.stringifier || t.syntax ? new s(this, e, t) : new n(this, e, t);
       }
       use(e) {
        return (this.plugins = this.plugins.concat(this.normalize([e]))), this;
       }
      };
     (t.exports = a), (a.default = a), i.registerProcessor(a), r.registerProcessor(a);
    }),
    G = l((e, t) => {
     var r = F(),
      s = x(),
      n = b(),
      i = f(),
      a = E(),
      o = $(),
      u = q(),
      l = v(),
      p = H(),
      c = S(),
      h = g(),
      d = N(),
      m = X(),
      D = z(),
      T = w(),
      A = P(),
      C = y(),
      k = W();
     function I(...e) {
      return 1 === e.length && Array.isArray(e[0]) && (e = e[0]), new m(e);
     }
     (I.plugin = function (e, t) {
      let r,
       s = !1;
      function n(...r) {
       console && console.warn && !s && ((s = !0), console.warn(e + ': postcss.plugin was deprecated. Migration guide:\nhttps://evilmartians.com/chronicles/postcss-8-plugin-migration'));
       let n = t(...r);
       return (n.postcssPlugin = e), (n.postcssVersion = new m().version), n;
      }
      return (
       Object.defineProperty(n, 'postcss', { get: () => (r || (r = n()), r) }),
       (n.process = function (e, t, r) {
        return I([n(r)]).process(e, t);
       }),
       n
      );
     }),
      (I.stringify = C),
      (I.parse = d),
      (I.fromJSON = u),
      (I.list = c),
      (I.comment = (e) => new s(e)),
      (I.atRule = (e) => new r(e)),
      (I.decl = (e) => new a(e)),
      (I.rule = (e) => new A(e)),
      (I.root = (e) => new T(e)),
      (I.document = (e) => new o(e)),
      (I.CssSyntaxError = i),
      (I.Declaration = a),
      (I.Container = n),
      (I.Processor = m),
      (I.Document = o),
      (I.Comment = s),
      (I.Warning = k),
      (I.AtRule = r),
      (I.Result = D),
      (I.Input = l),
      (I.Rule = A),
      (I.Root = T),
      (I.Node = h),
      p.registerPostcss(I),
      (t.exports = I),
      (I.default = I);
    }),
    Y = l((e, t) => {
     var { Container: r } = G();
     t.exports = class extends r {
      constructor(e) {
       super(e), (this.type = 'decl'), (this.isNested = !0), this.nodes || (this.nodes = []);
      }
     };
    }),
    Q = l((e, t) => {
     var r = /[\t\n\f\r "#'()/;[\\\]{}]/g,
      s = /[,\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g,
      n = /.[\r\n"'(/\\]/,
      i = /[\da-f]/i,
      a = /[\n\f\r]/g;
     t.exports = function (e, t = {}) {
      let o,
       u,
       l,
       p,
       c,
       h,
       d,
       f,
       m,
       y,
       D = e.css.valueOf(),
       g = t.ignoreErrors,
       x = D.length,
       E = 0,
       b = [],
       T = [];
      function A(t) {
       throw e.error('Unclosed ' + t, E);
      }
      function C() {
       let e = 1,
        t = !1,
        r = !1;
       for (; e > 0; ) (u += 1), D.length <= u && A('interpolation'), (o = D.charCodeAt(u)), (f = D.charCodeAt(u + 1)), t ? (r || o !== t ? (92 === o ? (r = !r) : r && (r = !1)) : ((t = !1), (r = !1))) : 39 === o || 34 === o ? (t = o) : 125 === o ? (e -= 1) : 35 === o && 123 === f && (e += 1);
      }
      return {
       back: function (e) {
        T.push(e);
       },
       endOfFile: function () {
        return 0 === T.length && E >= x;
       },
       nextToken: function (e) {
        if (T.length) return T.pop();
        if (E >= x) return;
        let t = !!e && e.ignoreUnclosed;
        switch (((o = D.charCodeAt(E)), o)) {
         case 10:
         case 32:
         case 9:
         case 13:
         case 12:
          u = E;
          do {
           (u += 1), (o = D.charCodeAt(u));
          } while (32 === o || 10 === o || 9 === o || 13 === o || 12 === o);
          (m = ['space', D.slice(E, u)]), (E = u - 1);
          break;
         case 91:
         case 93:
         case 123:
         case 125:
         case 58:
         case 59:
         case 41: {
          let e = String.fromCharCode(o);
          m = [e, e, E];
          break;
         }
         case 44:
          m = ['word', ',', E, E + 1];
          break;
         case 40:
          if (((d = b.length ? b.pop()[1] : ''), (f = D.charCodeAt(E + 1)), 'url' === d && 39 !== f && 34 !== f)) {
           for (y = 1, h = !1, u = E + 1; u <= D.length - 1; ) {
            if (((f = D.charCodeAt(u)), 92 === f)) h = !h;
            else if (40 === f) y += 1;
            else if (41 === f && ((y -= 1), 0 === y)) break;
            u += 1;
           }
           (p = D.slice(E, u + 1)), (m = ['brackets', p, E, u]), (E = u);
          } else (u = D.indexOf(')', E + 1)), (p = D.slice(E, u + 1)), -1 === u || n.test(p) ? (m = ['(', '(', E]) : ((m = ['brackets', p, E, u]), (E = u));
          break;
         case 39:
         case 34:
          for (l = o, u = E, h = !1; u < x && (u++, u === x && A('string'), (o = D.charCodeAt(u)), (f = D.charCodeAt(u + 1)), h || o !== l); ) 92 === o ? (h = !h) : h ? (h = !1) : 35 === o && 123 === f && C();
          (m = ['string', D.slice(E, u + 1), E, u]), (E = u);
          break;
         case 64:
          (r.lastIndex = E + 1), r.test(D), (u = 0 === r.lastIndex ? D.length - 1 : r.lastIndex - 2), (m = ['at-word', D.slice(E, u + 1), E, u]), (E = u);
          break;
         case 92:
          for (u = E, c = !0; 92 === D.charCodeAt(u + 1); ) (u += 1), (c = !c);
          if (((o = D.charCodeAt(u + 1)), c && 47 !== o && 32 !== o && 10 !== o && 9 !== o && 13 !== o && 12 !== o && ((u += 1), i.test(D.charAt(u))))) {
           for (; i.test(D.charAt(u + 1)); ) u += 1;
           32 === D.charCodeAt(u + 1) && (u += 1);
          }
          (m = ['word', D.slice(E, u + 1), E, u]), (E = u);
          break;
         default:
          (f = D.charCodeAt(E + 1)), 35 === o && 123 === f ? ((u = E), C(), (p = D.slice(E, u + 1)), (m = ['word', p, E, u]), (E = u)) : 47 === o && 42 === f ? ((u = D.indexOf('*/', E + 2) + 1), 0 === u && (g || t ? (u = D.length) : A('comment')), (m = ['comment', D.slice(E, u + 1), E, u]), (E = u)) : 47 === o && 47 === f ? ((a.lastIndex = E + 1), a.test(D), (u = 0 === a.lastIndex ? D.length - 1 : a.lastIndex - 2), (p = D.slice(E, u + 1)), (m = ['comment', p, E, u, 'inline']), (E = u)) : ((s.lastIndex = E + 1), s.test(D), (u = 0 === s.lastIndex ? D.length - 1 : s.lastIndex - 2), (m = ['word', D.slice(E, u + 1), E, u]), b.push(m), (E = u));
        }
        return E++, m;
       },
       position: function () {
        return E;
       },
      };
     };
    }),
    Z = l((e, t) => {
     var { Comment: r } = G(),
      s = I(),
      n = Y(),
      i = Q();
     t.exports = class extends s {
      atrule(e) {
       let t = e[1],
        r = e;
       for (; !this.tokenizer.endOfFile(); ) {
        let e = this.tokenizer.nextToken();
        if ('word' !== e[0] || e[2] !== r[3] + 1) {
         this.tokenizer.back(e);
         break;
        }
        (t += e[1]), (r = e);
       }
       super.atrule(['at-word', t, e[2], r[3]]);
      }
      comment(e) {
       if ('inline' === e[4]) {
        let t = new r();
        this.init(t, e[2]), (t.raws.inline = !0);
        let s = this.input.fromOffset(e[3]);
        t.source.end = { column: s.col, line: s.line, offset: e[3] + 1 };
        let n = e[1].slice(2);
        if (/^\s*$/.test(n)) (t.text = ''), (t.raws.left = n), (t.raws.right = '');
        else {
         let e = n.match(/^(\s*)([^]*\S)(\s*)$/),
          r = e[2].replace(/(\*\/|\/\*)/g, '*//*');
         (t.text = r), (t.raws.left = e[1]), (t.raws.right = e[3]), (t.raws.text = e[2]);
        }
       } else super.comment(e);
      }
      createTokenizer() {
       this.tokenizer = i(this.input);
      }
      raw(e, t, r, s) {
       if ((super.raw(e, t, r, s), e.raws[t])) {
        let s = e.raws[t].raw;
        (e.raws[t].raw = r.reduce((e, t) => {
         if ('comment' === t[0] && 'inline' === t[4]) {
          return e + '/*' + t[1].slice(2).replace(/(\*\/|\/\*)/g, '*//*') + '*/';
         }
         return e + t[1];
        }, '')),
         s !== e.raws[t].raw && (e.raws[t].scss = s);
       }
      }
      rule(e) {
       let t = !1,
        r = 0,
        s = '';
       for (let n of e)
        if (t) 'comment' !== n[0] && '{' !== n[0] && (s += n[1]);
        else {
         if ('space' === n[0] && n[1].includes('\n')) break;
         '(' === n[0] ? (r += 1) : ')' === n[0] ? (r -= 1) : 0 === r && ':' === n[0] && (t = !0);
        }
       if (!t || '' === s.trim() || /^[#:A-Za-z-]/.test(s)) super.rule(e);
       else {
        e.pop();
        let t,
         r,
         s = new n();
        this.init(s, e[0][2]);
        for (let n = e.length - 1; n >= 0; n--)
         if ('space' !== e[n][0]) {
          t = e[n];
          break;
         }
        if (t[3]) {
         let e = this.input.fromOffset(t[3]);
         s.source.end = { column: e.col, line: e.line, offset: t[3] + 1 };
        } else {
         let e = this.input.fromOffset(t[2]);
         s.source.end = { column: e.col, line: e.line, offset: t[2] + 1 };
        }
        for (; 'word' !== e[0][0]; ) s.raws.before += e.shift()[1];
        if (e[0][2]) {
         let t = this.input.fromOffset(e[0][2]);
         s.source.start = { column: t.col, line: t.line, offset: e[0][2] };
        }
        for (s.prop = ''; e.length; ) {
         let t = e[0][0];
         if (':' === t || 'space' === t || 'comment' === t) break;
         s.prop += e.shift()[1];
        }
        for (s.raws.between = ''; e.length; ) {
         if (((r = e.shift()), ':' === r[0])) {
          s.raws.between += r[1];
          break;
         }
         s.raws.between += r[1];
        }
        ('_' === s.prop[0] || '*' === s.prop[0]) && ((s.raws.before += s.prop[0]), (s.prop = s.prop.slice(1))), (s.raws.between += this.spacesAndCommentsFromStart(e)), this.precheckMissedSemicolon(e);
        for (let n = e.length - 1; n > 0; n--) {
         if (((r = e[n]), '!important' === r[1])) {
          s.important = !0;
          let t = this.stringFrom(e, n);
          (t = this.spacesFromEnd(e) + t), ' !important' !== t && (s.raws.important = t);
          break;
         }
         if ('important' === r[1]) {
          let t = e.slice(0),
           r = '';
          for (let e = n; e > 0; e--) {
           let s = t[e][0];
           if (0 === r.trim().indexOf('!') && 'space' !== s) break;
           r = t.pop()[1] + r;
          }
          0 === r.trim().indexOf('!') && ((s.important = !0), (s.raws.important = r), (e = t));
         }
         if ('space' !== r[0] && 'comment' !== r[0]) break;
        }
        this.raw(s, 'value', e), s.value.includes(':') && this.checkMissedSemicolon(e), (this.current = s);
       }
      }
     };
    }),
    ee = l((e, t) => {
     var { Input: r } = G(),
      s = Z();
     t.exports = function (e, t) {
      let n = new r(e, t),
       i = new s(n);
      return i.parse(), i.root;
     };
    }),
    te = l((e) => {
     Object.defineProperty(e, '__esModule', { value: !0 }),
      (e.default = function (e) {
       (this.after = e.after), (this.before = e.before), (this.type = e.type), (this.value = e.value), (this.sourceIndex = e.sourceIndex);
      });
    }),
    re = l((e) => {
     Object.defineProperty(e, '__esModule', { value: !0 });
     var t,
      r = te(),
      s = (t = r) && t.__esModule ? t : { default: t };
     function n(e) {
      var t = this;
      this.constructor(e),
       (this.nodes = e.nodes),
       void 0 === this.after && (this.after = this.nodes.length > 0 ? this.nodes[this.nodes.length - 1].after : ''),
       void 0 === this.before && (this.before = this.nodes.length > 0 ? this.nodes[0].before : ''),
       void 0 === this.sourceIndex && (this.sourceIndex = this.before.length),
       this.nodes.forEach(function (e) {
        e.parent = t;
       });
     }
     (n.prototype = Object.create(s.default.prototype)),
      (n.constructor = s.default),
      (n.prototype.walk = function (e, t) {
       for (var r = 'string' == typeof e || e instanceof RegExp, s = r ? t : e, n = 'string' == typeof e ? new RegExp(e) : e, i = 0; i < this.nodes.length; i++) {
        var a = this.nodes[i];
        if (((!r || n.test(a.type)) && s && !1 === s(a, i, this.nodes)) || (a.nodes && !1 === a.walk(e, t))) return !1;
       }
       return !0;
      }),
      (n.prototype.each = function () {
       for (var e = arguments.length <= 0 || void 0 === arguments[0] ? function () {} : arguments[0], t = 0; t < this.nodes.length; t++) {
        if (!1 === e(this.nodes[t], t, this.nodes)) return !1;
       }
       return !0;
      }),
      (e.default = n);
    }),
    se = l((e) => {
     Object.defineProperty(e, '__esModule', { value: !0 }),
      (e.parseMediaFeature = n),
      (e.parseMediaQuery = i),
      (e.parseMediaList = function (e) {
       var s = [],
        n = 0,
        a = 0,
        o = /^(\s*)url\s*\(/.exec(e);
       if (null !== o) {
        for (var u = o[0].length, l = 1; l > 0; ) {
         var p = e[u];
         '(' === p && l++, ')' === p && l--, u++;
        }
        s.unshift(new t.default({ type: 'url', value: e.substring(0, u).trim(), sourceIndex: o[1].length, before: o[1], after: /^(\s*)/.exec(e.substring(u))[1] })), (n = u);
       }
       for (var c = n; c < e.length; c++) {
        var h = e[c];
        if (('(' === h && a++, ')' === h && a--, 0 === a && ',' === h)) {
         var d = e.substring(n, c),
          f = /^(\s*)/.exec(d)[1];
         s.push(new r.default({ type: 'media-query', value: d.trim(), sourceIndex: n + f.length, nodes: i(d, n), before: f, after: /(\s*)$/.exec(d)[1] })), (n = c + 1);
        }
       }
       var m = e.substring(n),
        y = /^(\s*)/.exec(m)[1];
       return s.push(new r.default({ type: 'media-query', value: m.trim(), sourceIndex: n + y.length, nodes: i(m, n), before: y, after: /(\s*)$/.exec(m)[1] })), s;
      });
     var t = s(te()),
      r = s(re());
     function s(e) {
      return e && e.__esModule ? e : { default: e };
     }
     function n(e) {
      var t = [{ mode: 'normal', character: null }],
       r = [],
       s = 0,
       n = '',
       i = null,
       a = null,
       o = arguments.length <= 1 || void 0 === arguments[1] ? 0 : arguments[1],
       u = e;
      '(' === e[0] && ')' === e[e.length - 1] && ((u = e.substring(1, e.length - 1)), o++);
      for (var l = 0; l < u.length; l++) {
       var p = u[l];
       if ((("'" === p || '"' === p) && (!0 === t[s].isCalculationEnabled ? (t.push({ mode: 'string', isCalculationEnabled: !1, character: p }), s++) : 'string' === t[s].mode && t[s].character === p && '\\' !== u[l - 1] && (t.pop(), s--)), '{' === p ? (t.push({ mode: 'interpolation', isCalculationEnabled: !0 }), s++) : '}' === p && (t.pop(), s--), 'normal' === t[s].mode && ':' === p)) {
        var c = u.substring(l + 1);
        ((a = { type: 'value', before: /^(\s*)/.exec(c)[1], after: /(\s*)$/.exec(c)[1], value: c.trim() }).sourceIndex = a.before.length + l + 1 + o), (i = { type: 'colon', sourceIndex: l + o, after: a.before, value: ':' });
        break;
       }
       n += p;
      }
      return ((n = { type: 'media-feature', before: /^(\s*)/.exec(n)[1], after: /(\s*)$/.exec(n)[1], value: n.trim() }).sourceIndex = n.before.length + o), r.push(n), null !== i && ((i.before = n.after), r.push(i)), null !== a && r.push(a), r;
     }
     function i(e) {
      var s = arguments.length <= 1 || void 0 === arguments[1] ? 0 : arguments[1],
       i = [],
       a = 0,
       o = !1,
       u = void 0;
      u = { before: '', after: '', value: '' };
      for (var l = 0; l < e.length; l++) {
       var p = e[l];
       o ? ((u.value += p), ('{' === p || '(' === p) && a++, (')' === p || '}' === p) && a--) : -1 !== p.search(/\s/) ? (u.before += p) : ('(' === p && ((u.type = 'media-feature-expression'), a++), (u.value = p), (u.sourceIndex = s + l), (o = !0)), o && 0 === a && (')' === p || l === e.length - 1 || -1 !== e[l + 1].search(/\s/)) && (-1 !== ['not', 'only', 'and'].indexOf(u.value) && (u.type = 'keyword'), 'media-feature-expression' === u.type && (u.nodes = n(u.value, u.sourceIndex)), i.push(Array.isArray(u.nodes) ? new r.default(u) : new t.default(u)), (u = { before: '', after: '', value: '' }), (o = !1));
      }
      for (var c = 0; c < i.length; c++)
       if (((u = i[c]), c > 0 && (i[c - 1].after = u.before), void 0 === u.type)) {
        if (c > 0) {
         if ('media-feature-expression' === i[c - 1].type) {
          u.type = 'keyword';
          continue;
         }
         if ('not' === i[c - 1].value || 'only' === i[c - 1].value) {
          u.type = 'media-type';
          continue;
         }
         if ('and' === i[c - 1].value) {
          u.type = 'media-feature-expression';
          continue;
         }
         'media-type' === i[c - 1].type && (i[c + 1] ? (u.type = 'media-feature-expression' === i[c + 1].type ? 'keyword' : 'media-feature-expression') : (u.type = 'media-feature-expression'));
        }
        if (0 === c) {
         if (!i[c + 1]) {
          u.type = 'media-type';
          continue;
         }
         if (i[c + 1] && ('media-feature-expression' === i[c + 1].type || 'keyword' === i[c + 1].type)) {
          u.type = 'media-type';
          continue;
         }
         if (i[c + 2]) {
          if ('media-feature-expression' === i[c + 2].type) {
           (u.type = 'media-type'), (i[c + 1].type = 'keyword');
           continue;
          }
          if ('keyword' === i[c + 2].type) {
           (u.type = 'keyword'), (i[c + 1].type = 'media-type');
           continue;
          }
         }
         if (i[c + 3] && 'media-feature-expression' === i[c + 3].type) {
          (u.type = 'keyword'), (i[c + 1].type = 'media-type'), (i[c + 2].type = 'keyword');
          continue;
         }
        }
       }
      return i;
     }
    }),
    ne = l((e) => {
     Object.defineProperty(e, '__esModule', { value: !0 }),
      (e.default = function (e) {
       return new s.default({ nodes: (0, n.parseMediaList)(e), type: 'media-query-list', value: e.trim() });
      });
     var t,
      r = re(),
      s = (t = r) && t.__esModule ? t : { default: t },
      n = se();
    }),
    ie = l((e, t) => {
     t.exports = function (e, t) {
      return (t = 'number' == typeof t ? t : 1 / 0)
       ? (function e(r, s) {
          return r.reduce(function (r, n) {
           return Array.isArray(n) && s < t ? r.concat(e(n, s + 1)) : r.concat(n);
          }, []);
         })(e, 1)
       : Array.isArray(e)
         ? e.map(function (e) {
            return e;
           })
         : e;
     };
    }),
    ae = l((e, t) => {
     t.exports = function (e, t) {
      for (var r = -1, s = []; -1 !== (r = e.indexOf(t, r + 1)); ) s.push(r);
      return s;
     };
    }),
    oe = l((e, t) => {
     t.exports = function (e, t, r) {
      return 0 === e.length
       ? e
       : t
         ? (r || e.sort(t),
           (function (e, t) {
            for (var r = 1, s = e.length, n = e[0], i = e[0], a = 1; a < s; ++a)
             if (((i = n), t((n = e[a]), i))) {
              if (a === r) {
               r++;
               continue;
              }
              e[r++] = n;
             }
            return (e.length = r), e;
           })(e, t))
         : (r || e.sort(),
           (function (e) {
            for (var t = 1, r = e.length, s = e[0], n = e[0], i = 1; i < r; ++i, n = s)
             if (((n = s), (s = e[i]) !== n)) {
              if (i === t) {
               t++;
               continue;
              }
              e[t++] = s;
             }
            return (e.length = t), e;
           })(e));
     };
    }),
    ue = l((e, t) => {
     e.__esModule = !0;
     var r =
      'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
       ? function (e) {
          return typeof e;
         }
       : function (e) {
          return e && 'function' == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e;
         };
     var s = function e(t, s) {
       if ('object' !== (typeof t > 'u' ? 'undefined' : r(t))) return t;
       var n = new t.constructor();
       for (var i in t)
        if (t.hasOwnProperty(i)) {
         var a = t[i],
          o = typeof a > 'u' ? 'undefined' : r(a);
         'parent' === i && 'object' === o
          ? s && (n[i] = s)
          : (n[i] =
             a instanceof Array
              ? a.map(function (t) {
                 return e(t, n);
                })
              : e(a, n));
        }
       return n;
      },
      n = (function () {
       function e() {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        for (var r in ((function (e, t) {
         if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
        })(this, e),
        t))
         this[r] = t[r];
        var s = t.spaces,
         n = (s = void 0 === s ? {} : s).before,
         i = void 0 === n ? '' : n,
         a = s.after,
         o = void 0 === a ? '' : a;
        this.spaces = { before: i, after: o };
       }
       return (
        (e.prototype.remove = function () {
         return this.parent && this.parent.removeChild(this), (this.parent = void 0), this;
        }),
        (e.prototype.replaceWith = function () {
         if (this.parent) {
          for (var e in arguments) this.parent.insertBefore(this, arguments[e]);
          this.remove();
         }
         return this;
        }),
        (e.prototype.next = function () {
         return this.parent.at(this.parent.index(this) + 1);
        }),
        (e.prototype.prev = function () {
         return this.parent.at(this.parent.index(this) - 1);
        }),
        (e.prototype.clone = function () {
         var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
          t = s(this);
         for (var r in e) t[r] = e[r];
         return t;
        }),
        (e.prototype.toString = function () {
         return [this.spaces.before, String(this.value), this.spaces.after].join('');
        }),
        e
       );
      })();
     (e.default = n), (t.exports = e.default);
    }),
    le = l((e) => {
     e.__esModule = !0;
     (e.TAG = 'tag'), (e.STRING = 'string'), (e.SELECTOR = 'selector'), (e.ROOT = 'root'), (e.PSEUDO = 'pseudo'), (e.NESTING = 'nesting'), (e.ID = 'id'), (e.COMMENT = 'comment'), (e.COMBINATOR = 'combinator'), (e.CLASS = 'class'), (e.ATTRIBUTE = 'attribute'), (e.UNIVERSAL = 'universal');
    }),
    pe = l((e, t) => {
     e.__esModule = !0;
     var r,
      s = (function () {
       function e(e, t) {
        for (var r = 0; r < t.length; r++) {
         var s = t[r];
         (s.enumerable = s.enumerable || !1), (s.configurable = !0), 'value' in s && (s.writable = !0), Object.defineProperty(e, s.key, s);
        }
       }
       return function (t, r, s) {
        return r && e(t.prototype, r), s && e(t, s), t;
       };
      })(),
      n = ue(),
      i = (r = n) && r.__esModule ? r : { default: r },
      a = (function (e) {
       if (e && e.__esModule) return e;
       var t = {};
       if (null != e) for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
       return (t.default = e), t;
      })(le());
     var o = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, t);
       var s = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
       })(this, e.call(this, r));
       return s.nodes || (s.nodes = []), s;
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       (t.prototype.append = function (e) {
        return (e.parent = this), this.nodes.push(e), this;
       }),
       (t.prototype.prepend = function (e) {
        return (e.parent = this), this.nodes.unshift(e), this;
       }),
       (t.prototype.at = function (e) {
        return this.nodes[e];
       }),
       (t.prototype.index = function (e) {
        return 'number' == typeof e ? e : this.nodes.indexOf(e);
       }),
       (t.prototype.removeChild = function (e) {
        (e = this.index(e)), (this.at(e).parent = void 0), this.nodes.splice(e, 1);
        var t = void 0;
        for (var r in this.indexes) (t = this.indexes[r]) >= e && (this.indexes[r] = t - 1);
        return this;
       }),
       (t.prototype.removeAll = function () {
        var e = this.nodes,
         t = Array.isArray(e),
         r = 0;
        for (e = t ? e : e[Symbol.iterator](); ; ) {
         var s;
         if (t) {
          if (r >= e.length) break;
          s = e[r++];
         } else {
          if ((r = e.next()).done) break;
          s = r.value;
         }
         s.parent = void 0;
        }
        return (this.nodes = []), this;
       }),
       (t.prototype.empty = function () {
        return this.removeAll();
       }),
       (t.prototype.insertAfter = function (e, t) {
        var r = this.index(e);
        this.nodes.splice(r + 1, 0, t);
        var s = void 0;
        for (var n in this.indexes) r <= (s = this.indexes[n]) && (this.indexes[n] = s + this.nodes.length);
        return this;
       }),
       (t.prototype.insertBefore = function (e, t) {
        var r = this.index(e);
        this.nodes.splice(r, 0, t);
        var s = void 0;
        for (var n in this.indexes) r <= (s = this.indexes[n]) && (this.indexes[n] = s + this.nodes.length);
        return this;
       }),
       (t.prototype.each = function (e) {
        this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach++;
        var t = this.lastEach;
        if (((this.indexes[t] = 0), this.length)) {
         for (var r = void 0, s = void 0; this.indexes[t] < this.length && ((r = this.indexes[t]), !1 !== (s = e(this.at(r), r))); ) this.indexes[t] += 1;
         if ((delete this.indexes[t], !1 === s)) return !1;
        }
       }),
       (t.prototype.walk = function (e) {
        return this.each(function (t, r) {
         var s = e(t, r);
         if ((!1 !== s && t.length && (s = t.walk(e)), !1 === s)) return !1;
        });
       }),
       (t.prototype.walkAttributes = function (e) {
        var t = this;
        return this.walk(function (r) {
         if (r.type === a.ATTRIBUTE) return e.call(t, r);
        });
       }),
       (t.prototype.walkClasses = function (e) {
        var t = this;
        return this.walk(function (r) {
         if (r.type === a.CLASS) return e.call(t, r);
        });
       }),
       (t.prototype.walkCombinators = function (e) {
        var t = this;
        return this.walk(function (r) {
         if (r.type === a.COMBINATOR) return e.call(t, r);
        });
       }),
       (t.prototype.walkComments = function (e) {
        var t = this;
        return this.walk(function (r) {
         if (r.type === a.COMMENT) return e.call(t, r);
        });
       }),
       (t.prototype.walkIds = function (e) {
        var t = this;
        return this.walk(function (r) {
         if (r.type === a.ID) return e.call(t, r);
        });
       }),
       (t.prototype.walkNesting = function (e) {
        var t = this;
        return this.walk(function (r) {
         if (r.type === a.NESTING) return e.call(t, r);
        });
       }),
       (t.prototype.walkPseudos = function (e) {
        var t = this;
        return this.walk(function (r) {
         if (r.type === a.PSEUDO) return e.call(t, r);
        });
       }),
       (t.prototype.walkTags = function (e) {
        var t = this;
        return this.walk(function (r) {
         if (r.type === a.TAG) return e.call(t, r);
        });
       }),
       (t.prototype.walkUniversals = function (e) {
        var t = this;
        return this.walk(function (r) {
         if (r.type === a.UNIVERSAL) return e.call(t, r);
        });
       }),
       (t.prototype.split = function (e) {
        var t = this,
         r = [];
        return this.reduce(function (s, n, i) {
         var a = e.call(t, n);
         return r.push(n), a ? (s.push(r), (r = [])) : i === t.length - 1 && s.push(r), s;
        }, []);
       }),
       (t.prototype.map = function (e) {
        return this.nodes.map(e);
       }),
       (t.prototype.reduce = function (e, t) {
        return this.nodes.reduce(e, t);
       }),
       (t.prototype.every = function (e) {
        return this.nodes.every(e);
       }),
       (t.prototype.some = function (e) {
        return this.nodes.some(e);
       }),
       (t.prototype.filter = function (e) {
        return this.nodes.filter(e);
       }),
       (t.prototype.sort = function (e) {
        return this.nodes.sort(e);
       }),
       (t.prototype.toString = function () {
        return this.map(String).join('');
       }),
       s(t, [
        {
         key: 'first',
         get: function () {
          return this.at(0);
         },
        },
        {
         key: 'last',
         get: function () {
          return this.at(this.length - 1);
         },
        },
        {
         key: 'length',
         get: function () {
          return this.nodes.length;
         },
        },
       ]),
       t
      );
     })(i.default);
     (e.default = o), (t.exports = e.default);
    }),
    ce = l((e, t) => {
     e.__esModule = !0;
     var r,
      s = pe(),
      n = (r = s) && r.__esModule ? r : { default: r },
      i = le();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, t);
       var s = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
       })(this, e.call(this, r));
       return (s.type = i.ROOT), s;
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       (t.prototype.toString = function () {
        var e = this.reduce(function (e, t) {
         var r = String(t);
         return r ? e + r + ',' : '';
        }, '').slice(0, -1);
        return this.trailingComma ? e + ',' : e;
       }),
       t
      );
     })(n.default);
     (e.default = a), (t.exports = e.default);
    }),
    he = l((e, t) => {
     e.__esModule = !0;
     var r,
      s = pe(),
      n = (r = s) && r.__esModule ? r : { default: r },
      i = le();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, t);
       var s = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
       })(this, e.call(this, r));
       return (s.type = i.SELECTOR), s;
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       t
      );
     })(n.default);
     (e.default = a), (t.exports = e.default);
    }),
    de = l((e, t) => {
     e.__esModule = !0;
     var r,
      s = (function () {
       function e(e, t) {
        for (var r = 0; r < t.length; r++) {
         var s = t[r];
         (s.enumerable = s.enumerable || !1), (s.configurable = !0), 'value' in s && (s.writable = !0), Object.defineProperty(e, s.key, s);
        }
       }
       return function (t, r, s) {
        return r && e(t.prototype, r), s && e(t, s), t;
       };
      })(),
      n = ue();
     var i = (function (e) {
      function t() {
       return (
        (function (e, t) {
         if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
        })(this, t),
        (function (e, t) {
         if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
         return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
        })(this, e.apply(this, arguments))
       );
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       (t.prototype.toString = function () {
        return [this.spaces.before, this.ns, String(this.value), this.spaces.after].join('');
       }),
       s(t, [
        {
         key: 'ns',
         get: function () {
          var e = this.namespace;
          return e ? ('string' == typeof e ? e : '') + '|' : '';
         },
        },
       ]),
       t
      );
     })(((r = n) && r.__esModule ? r : { default: r }).default);
     (e.default = i), (t.exports = e.default);
    }),
    fe = l((e, t) => {
     e.__esModule = !0;
     var r,
      s = de(),
      n = (r = s) && r.__esModule ? r : { default: r },
      i = le();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, t);
       var s = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
       })(this, e.call(this, r));
       return (s.type = i.CLASS), s;
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       (t.prototype.toString = function () {
        return [this.spaces.before, this.ns, '.' + this.value, this.spaces.after].join('');
       }),
       t
      );
     })(n.default);
     (e.default = a), (t.exports = e.default);
    }),
    me = l((e, t) => {
     e.__esModule = !0;
     var r,
      s = ue(),
      n = (r = s) && r.__esModule ? r : { default: r },
      i = le();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, t);
       var s = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
       })(this, e.call(this, r));
       return (s.type = i.COMMENT), s;
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       t
      );
     })(n.default);
     (e.default = a), (t.exports = e.default);
    }),
    ye = l((e, t) => {
     e.__esModule = !0;
     var r,
      s = de(),
      n = (r = s) && r.__esModule ? r : { default: r },
      i = le();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, t);
       var s = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
       })(this, e.call(this, r));
       return (s.type = i.ID), s;
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       (t.prototype.toString = function () {
        return [this.spaces.before, this.ns, '#' + this.value, this.spaces.after].join('');
       }),
       t
      );
     })(n.default);
     (e.default = a), (t.exports = e.default);
    }),
    De = l((e, t) => {
     e.__esModule = !0;
     var r,
      s = de(),
      n = (r = s) && r.__esModule ? r : { default: r },
      i = le();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, t);
       var s = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
       })(this, e.call(this, r));
       return (s.type = i.TAG), s;
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       t
      );
     })(n.default);
     (e.default = a), (t.exports = e.default);
    }),
    ge = l((e, t) => {
     e.__esModule = !0;
     var r,
      s = ue(),
      n = (r = s) && r.__esModule ? r : { default: r },
      i = le();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, t);
       var s = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
       })(this, e.call(this, r));
       return (s.type = i.STRING), s;
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       t
      );
     })(n.default);
     (e.default = a), (t.exports = e.default);
    }),
    xe = l((e, t) => {
     e.__esModule = !0;
     var r,
      s = pe(),
      n = (r = s) && r.__esModule ? r : { default: r },
      i = le();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, t);
       var s = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
       })(this, e.call(this, r));
       return (s.type = i.PSEUDO), s;
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       (t.prototype.toString = function () {
        var e = this.length ? '(' + this.map(String).join(',') + ')' : '';
        return [this.spaces.before, String(this.value), e, this.spaces.after].join('');
       }),
       t
      );
     })(n.default);
     (e.default = a), (t.exports = e.default);
    }),
    Ee = l((e, t) => {
     e.__esModule = !0;
     var r,
      s = de(),
      n = (r = s) && r.__esModule ? r : { default: r },
      i = le();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, t);
       var s = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
       })(this, e.call(this, r));
       return (s.type = i.ATTRIBUTE), (s.raws = {}), s;
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       (t.prototype.toString = function () {
        var e = [this.spaces.before, '[', this.ns, this.attribute];
        return this.operator && e.push(this.operator), this.value && e.push(this.value), this.raws.insensitive ? e.push(this.raws.insensitive) : this.insensitive && e.push(' i'), e.push(']'), e.concat(this.spaces.after).join('');
       }),
       t
      );
     })(n.default);
     (e.default = a), (t.exports = e.default);
    }),
    be = l((e, t) => {
     e.__esModule = !0;
     var r,
      s = de(),
      n = (r = s) && r.__esModule ? r : { default: r },
      i = le();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, t);
       var s = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
       })(this, e.call(this, r));
       return (s.type = i.UNIVERSAL), (s.value = '*'), s;
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       t
      );
     })(n.default);
     (e.default = a), (t.exports = e.default);
    }),
    Te = l((e, t) => {
     e.__esModule = !0;
     var r,
      s = ue(),
      n = (r = s) && r.__esModule ? r : { default: r },
      i = le();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, t);
       var s = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
       })(this, e.call(this, r));
       return (s.type = i.COMBINATOR), s;
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       t
      );
     })(n.default);
     (e.default = a), (t.exports = e.default);
    }),
    Ae = l((e, t) => {
     e.__esModule = !0;
     var r,
      s = ue(),
      n = (r = s) && r.__esModule ? r : { default: r },
      i = le();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, t);
       var s = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
       })(this, e.call(this, r));
       return (s.type = i.NESTING), (s.value = '&'), s;
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        (e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t));
       })(t, e),
       t
      );
     })(n.default);
     (e.default = a), (t.exports = e.default);
    }),
    Ce = l((e, t) => {
     (e.__esModule = !0),
      (e.default = function (e) {
       return e.sort(function (e, t) {
        return e - t;
       });
      }),
      (t.exports = e.default);
    }),
    ve = l((e, t) => {
     (e.__esModule = !0),
      (e.default = function (e) {
       for (
        var t = [],
         w = e.css.valueOf(),
         S = void 0,
         P = void 0,
         k = void 0,
         I = void 0,
         N = void 0,
         B = void 0,
         O = void 0,
         L = void 0,
         M = void 0,
         j = void 0,
         _ = void 0,
         R = w.length,
         U = -1,
         $ = 1,
         q = 0,
         J = function (t, r) {
          if (!e.safe) throw e.error('Unclosed ' + t, $, q - U, q);
          P = (w += r).length - 1;
         };
        q < R;

       ) {
        switch (((S = w.charCodeAt(q)) === a && ((U = q), ($ += 1)), S)) {
         case a:
         case o:
         case l:
         case p:
         case u:
          P = q;
          do {
           (P += 1), (S = w.charCodeAt(P)) === a && ((U = P), ($ += 1));
          } while (S === o || S === a || S === l || S === p || S === u);
          t.push(['space', w.slice(q, P), $, q - U, q]), (q = P - 1);
          break;
         case c:
         case h:
         case d:
         case f:
          P = q;
          do {
           (P += 1), (S = w.charCodeAt(P));
          } while (S === c || S === h || S === d || S === f);
          t.push(['combinator', w.slice(q, P), $, q - U, q]), (q = P - 1);
          break;
         case b:
          t.push(['*', '*', $, q - U, q]);
          break;
         case A:
          t.push(['&', '&', $, q - U, q]);
          break;
         case m:
          t.push([',', ',', $, q - U, q]);
          break;
         case g:
          t.push(['[', '[', $, q - U, q]);
          break;
         case x:
          t.push([']', ']', $, q - U, q]);
          break;
         case T:
          t.push([':', ':', $, q - U, q]);
          break;
         case E:
          t.push([';', ';', $, q - U, q]);
          break;
         case y:
          t.push(['(', '(', $, q - U, q]);
          break;
         case D:
          t.push([')', ')', $, q - U, q]);
          break;
         case r:
         case s:
          (k = S === r ? "'" : '"'), (P = q);
          do {
           for (j = !1, -1 === (P = w.indexOf(k, P + 1)) && J('quote', k), _ = P; w.charCodeAt(_ - 1) === n; ) (_ -= 1), (j = !j);
          } while (j);
          t.push(['string', w.slice(q, P + 1), $, q - U, $, P - U, q]), (q = P);
          break;
         case C:
          (v.lastIndex = q + 1), v.test(w), (P = 0 === v.lastIndex ? w.length - 1 : v.lastIndex - 2), t.push(['at-word', w.slice(q, P + 1), $, q - U, $, P - U, q]), (q = P);
          break;
         case n:
          for (P = q, O = !0; w.charCodeAt(P + 1) === n; ) (P += 1), (O = !O);
          (S = w.charCodeAt(P + 1)), O && S !== i && S !== o && S !== a && S !== l && S !== p && S !== u && (P += 1), t.push(['word', w.slice(q, P + 1), $, q - U, $, P - U, q]), (q = P);
          break;
         default:
          S === i && w.charCodeAt(q + 1) === b ? (0 === (P = w.indexOf('*/', q + 2) + 1) && J('comment', '*/'), (N = (I = (B = w.slice(q, P + 1)).split('\n')).length - 1) > 0 ? ((L = $ + N), (M = P - I[N].length)) : ((L = $), (M = U)), t.push(['comment', B, $, q - U, L, P - M, q]), (U = M), ($ = L), (q = P)) : ((F.lastIndex = q + 1), F.test(w), (P = 0 === F.lastIndex ? w.length - 1 : F.lastIndex - 2), t.push(['word', w.slice(q, P + 1), $, q - U, $, P - U, q]), (q = P));
        }
        q++;
       }
       return t;
      });
     var r = 39,
      s = 34,
      n = 92,
      i = 47,
      a = 10,
      o = 32,
      u = 12,
      l = 9,
      p = 13,
      c = 43,
      h = 62,
      d = 126,
      f = 124,
      m = 44,
      y = 40,
      D = 41,
      g = 91,
      x = 93,
      E = 59,
      b = 42,
      T = 58,
      A = 38,
      C = 64,
      v = /[ \n\t\r\{\(\)'"\\;/]/g,
      F = /[ \n\t\r\(\)\*:;@!&'"\+\|~>,\[\]\\]|\/(?=\*)/g;
     t.exports = e.default;
    }),
    Fe = l((e, t) => {
     e.__esModule = !0;
     var r = (function () {
       function e(e, t) {
        for (var r = 0; r < t.length; r++) {
         var s = t[r];
         (s.enumerable = s.enumerable || !1), (s.configurable = !0), 'value' in s && (s.writable = !0), Object.defineProperty(e, s.key, s);
        }
       }
       return function (t, r, s) {
        return r && e(t.prototype, r), s && e(t, s), t;
       };
      })(),
      s = b(ie()),
      n = b(ae()),
      i = b(oe()),
      a = b(ce()),
      o = b(he()),
      u = b(fe()),
      l = b(me()),
      p = b(ye()),
      c = b(De()),
      h = b(ge()),
      d = b(xe()),
      f = b(Ee()),
      m = b(be()),
      y = b(Te()),
      D = b(Ae()),
      g = b(Ce()),
      x = b(ve()),
      E = (function (e) {
       if (e && e.__esModule) return e;
       var t = {};
       if (null != e) for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
       return (t.default = e), t;
      })(le());
     function b(e) {
      return e && e.__esModule ? e : { default: e };
     }
     var T = (function () {
      function e(t) {
       (function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, e),
        (this.input = t),
        (this.lossy = !1 === t.options.lossless),
        (this.position = 0),
        (this.root = new a.default());
       var r = new o.default();
       return this.root.append(r), (this.current = r), this.lossy ? (this.tokens = (0, x.default)({ safe: t.safe, css: t.css.trim() })) : (this.tokens = (0, x.default)(t)), this.loop();
      }
      return (
       (e.prototype.attribute = function () {
        var e = '',
         t = void 0,
         r = this.currToken;
        for (this.position++; this.position < this.tokens.length && ']' !== this.currToken[0]; ) (e += this.tokens[this.position][1]), this.position++;
        this.position === this.tokens.length && !~e.indexOf(']') && this.error('Expected a closing square bracket.');
        var s = e.split(/((?:[*~^$|]?=))([^]*)/),
         n = s[0].split(/(\|)/g),
         i = { operator: s[1], value: s[2], source: { start: { line: r[2], column: r[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: r[4] };
        if ((n.length > 1 ? ('' === n[0] && (n[0] = !0), (i.attribute = this.parseValue(n[2])), (i.namespace = this.parseNamespace(n[0]))) : (i.attribute = this.parseValue(s[0])), (t = new f.default(i)), s[2])) {
         var a = s[2].split(/(\s+i\s*?)$/),
          o = a[0].trim();
         (t.value = this.lossy ? o : a[0]), a[1] && ((t.insensitive = !0), this.lossy || (t.raws.insensitive = a[1])), (t.quoted = "'" === o[0] || '"' === o[0]), (t.raws.unquoted = t.quoted ? o.slice(1, -1) : o);
        }
        this.newNode(t), this.position++;
       }),
       (e.prototype.combinator = function () {
        if ('|' === this.currToken[1]) return this.namespace();
        for (var e = new y.default({ value: '', source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] }); this.position < this.tokens.length && this.currToken && ('space' === this.currToken[0] || 'combinator' === this.currToken[0]); ) this.nextToken && 'combinator' === this.nextToken[0] ? ((e.spaces.before = this.parseSpace(this.currToken[1])), (e.source.start.line = this.nextToken[2]), (e.source.start.column = this.nextToken[3]), (e.source.end.column = this.nextToken[3]), (e.source.end.line = this.nextToken[2]), (e.sourceIndex = this.nextToken[4])) : this.prevToken && 'combinator' === this.prevToken[0] ? (e.spaces.after = this.parseSpace(this.currToken[1])) : 'combinator' === this.currToken[0] ? (e.value = this.currToken[1]) : 'space' === this.currToken[0] && (e.value = this.parseSpace(this.currToken[1], ' ')), this.position++;
        return this.newNode(e);
       }),
       (e.prototype.comma = function () {
        if (this.position === this.tokens.length - 1) return (this.root.trailingComma = !0), void this.position++;
        var e = new o.default();
        this.current.parent.append(e), (this.current = e), this.position++;
       }),
       (e.prototype.comment = function () {
        var e = new l.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] });
        this.newNode(e), this.position++;
       }),
       (e.prototype.error = function (e) {
        throw new this.input.error(e);
       }),
       (e.prototype.missingBackslash = function () {
        return this.error('Expected a backslash preceding the semicolon.');
       }),
       (e.prototype.missingParenthesis = function () {
        return this.error('Expected opening parenthesis.');
       }),
       (e.prototype.missingSquareBracket = function () {
        return this.error('Expected opening square bracket.');
       }),
       (e.prototype.namespace = function () {
        var e = (this.prevToken && this.prevToken[1]) || !0;
        return 'word' === this.nextToken[0] ? (this.position++, this.word(e)) : '*' === this.nextToken[0] ? (this.position++, this.universal(e)) : void 0;
       }),
       (e.prototype.nesting = function () {
        this.newNode(new D.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] })), this.position++;
       }),
       (e.prototype.parentheses = function () {
        var e = this.current.last;
        if (e && e.type === E.PSEUDO) {
         var t = new o.default(),
          r = this.current;
         e.append(t), (this.current = t);
         var s = 1;
         for (this.position++; this.position < this.tokens.length && s; ) '(' === this.currToken[0] && s++, ')' === this.currToken[0] && s--, s ? this.parse() : ((t.parent.source.end.line = this.currToken[2]), (t.parent.source.end.column = this.currToken[3]), this.position++);
         s && this.error('Expected closing parenthesis.'), (this.current = r);
        } else {
         var n = 1;
         for (this.position++, e.value += '('; this.position < this.tokens.length && n; ) '(' === this.currToken[0] && n++, ')' === this.currToken[0] && n--, (e.value += this.parseParenthesisToken(this.currToken)), this.position++;
         n && this.error('Expected closing parenthesis.');
        }
       }),
       (e.prototype.pseudo = function () {
        for (var e = this, t = '', r = this.currToken; this.currToken && ':' === this.currToken[0]; ) (t += this.currToken[1]), this.position++;
        if (!this.currToken) return this.error('Expected pseudo-class or pseudo-element');
        if ('word' === this.currToken[0]) {
         var s = void 0;
         this.splitWord(!1, function (n, i) {
          (t += n), (s = new d.default({ value: t, source: { start: { line: r[2], column: r[3] }, end: { line: e.currToken[4], column: e.currToken[5] } }, sourceIndex: r[4] })), e.newNode(s), i > 1 && e.nextToken && '(' === e.nextToken[0] && e.error('Misplaced parenthesis.');
         });
        } else this.error('Unexpected "' + this.currToken[0] + '" found.');
       }),
       (e.prototype.space = function () {
        var e = this.currToken;
        0 === this.position || ',' === this.prevToken[0] || '(' === this.prevToken[0] ? ((this.spaces = this.parseSpace(e[1])), this.position++) : this.position === this.tokens.length - 1 || ',' === this.nextToken[0] || ')' === this.nextToken[0] ? ((this.current.last.spaces.after = this.parseSpace(e[1])), this.position++) : this.combinator();
       }),
       (e.prototype.string = function () {
        var e = this.currToken;
        this.newNode(new h.default({ value: this.currToken[1], source: { start: { line: e[2], column: e[3] }, end: { line: e[4], column: e[5] } }, sourceIndex: e[6] })), this.position++;
       }),
       (e.prototype.universal = function (e) {
        var t = this.nextToken;
        if (t && '|' === t[1]) return this.position++, this.namespace();
        this.newNode(new m.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] }), e), this.position++;
       }),
       (e.prototype.splitWord = function (e, t) {
        for (var r = this, a = this.nextToken, o = this.currToken[1]; a && 'word' === a[0]; ) {
         this.position++;
         var l = this.currToken[1];
         if (((o += l), l.lastIndexOf('\\') === l.length - 1)) {
          var h = this.nextToken;
          h && 'space' === h[0] && ((o += this.parseSpace(h[1], ' ')), this.position++);
         }
         a = this.nextToken;
        }
        var d = (0, n.default)(o, '.'),
         f = (0, n.default)(o, '#'),
         m = (0, n.default)(o, '#{');
        m.length &&
         (f = f.filter(function (e) {
          return !~m.indexOf(e);
         }));
        var y = (0, g.default)((0, i.default)((0, s.default)([[0], d, f])));
        y.forEach(function (s, n) {
         var i = y[n + 1] || o.length,
          a = o.slice(s, i);
         if (0 === n && t) return t.call(r, a, y.length);
         var l = void 0;
         (l = ~d.indexOf(s) ? new u.default({ value: a.slice(1), source: { start: { line: r.currToken[2], column: r.currToken[3] + s }, end: { line: r.currToken[4], column: r.currToken[3] + (i - 1) } }, sourceIndex: r.currToken[6] + y[n] }) : ~f.indexOf(s) ? new p.default({ value: a.slice(1), source: { start: { line: r.currToken[2], column: r.currToken[3] + s }, end: { line: r.currToken[4], column: r.currToken[3] + (i - 1) } }, sourceIndex: r.currToken[6] + y[n] }) : new c.default({ value: a, source: { start: { line: r.currToken[2], column: r.currToken[3] + s }, end: { line: r.currToken[4], column: r.currToken[3] + (i - 1) } }, sourceIndex: r.currToken[6] + y[n] })), r.newNode(l, e);
        }),
         this.position++;
       }),
       (e.prototype.word = function (e) {
        var t = this.nextToken;
        return t && '|' === t[1] ? (this.position++, this.namespace()) : this.splitWord(e);
       }),
       (e.prototype.loop = function () {
        for (; this.position < this.tokens.length; ) this.parse(!0);
        return this.root;
       }),
       (e.prototype.parse = function (e) {
        switch (this.currToken[0]) {
         case 'space':
          this.space();
          break;
         case 'comment':
          this.comment();
          break;
         case '(':
          this.parentheses();
          break;
         case ')':
          e && this.missingParenthesis();
          break;
         case '[':
          this.attribute();
          break;
         case ']':
          this.missingSquareBracket();
          break;
         case 'at-word':
         case 'word':
          this.word();
          break;
         case ':':
          this.pseudo();
          break;
         case ';':
          this.missingBackslash();
          break;
         case ',':
          this.comma();
          break;
         case '*':
          this.universal();
          break;
         case '&':
          this.nesting();
          break;
         case 'combinator':
          this.combinator();
          break;
         case 'string':
          this.string();
        }
       }),
       (e.prototype.parseNamespace = function (e) {
        if (this.lossy && 'string' == typeof e) {
         var t = e.trim();
         return !t.length || t;
        }
        return e;
       }),
       (e.prototype.parseSpace = function (e, t) {
        return this.lossy ? t || '' : e;
       }),
       (e.prototype.parseValue = function (e) {
        return this.lossy && e && 'string' == typeof e ? e.trim() : e;
       }),
       (e.prototype.parseParenthesisToken = function (e) {
        return this.lossy ? ('space' === e[0] ? this.parseSpace(e[1], ' ') : this.parseValue(e[1])) : e[1];
       }),
       (e.prototype.newNode = function (e, t) {
        return t && (e.namespace = this.parseNamespace(t)), this.spaces && ((e.spaces.before = this.spaces), (this.spaces = '')), this.current.append(e);
       }),
       r(e, [
        {
         key: 'currToken',
         get: function () {
          return this.tokens[this.position];
         },
        },
        {
         key: 'nextToken',
         get: function () {
          return this.tokens[this.position + 1];
         },
        },
        {
         key: 'prevToken',
         get: function () {
          return this.tokens[this.position - 1];
         },
        },
       ]),
       e
      );
     })();
     (e.default = T), (t.exports = e.default);
    }),
    we = l((e, t) => {
     e.__esModule = !0;
     var r,
      s = (function () {
       function e(e, t) {
        for (var r = 0; r < t.length; r++) {
         var s = t[r];
         (s.enumerable = s.enumerable || !1), (s.configurable = !0), 'value' in s && (s.writable = !0), Object.defineProperty(e, s.key, s);
        }
       }
       return function (t, r, s) {
        return r && e(t.prototype, r), s && e(t, s), t;
       };
      })(),
      n = Fe(),
      i = (r = n) && r.__esModule ? r : { default: r };
     var a = (function () {
      function e(t) {
       return (
        (function (e, t) {
         if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
        })(this, e),
        (this.func = t || function () {}),
        this
       );
      }
      return (
       (e.prototype.process = function (e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
         r = new i.default({
          css: e,
          error: function (e) {
           throw new Error(e);
          },
          options: t,
         });
        return (this.res = r), this.func(r), this;
       }),
       s(e, [
        {
         key: 'result',
         get: function () {
          return String(this.res);
         },
        },
       ]),
       e
      );
     })();
     (e.default = a), (t.exports = e.default);
    }),
    Se = l((e, t) => {
     var r = function (e, t) {
      let s = new e.constructor();
      for (let n in e) {
       if (!e.hasOwnProperty(n)) continue;
       let i = e[n],
        a = typeof i;
       'parent' === n && 'object' === a ? t && (s[n] = t) : 'source' === n ? (s[n] = i) : i instanceof Array ? (s[n] = i.map((e) => r(e, s))) : 'before' !== n && 'after' !== n && 'between' !== n && 'semicolon' !== n && ('object' === a && null !== i && (i = r(i)), (s[n] = i));
      }
      return s;
     };
     t.exports = class {
      constructor(e) {
       (e = e || {}), (this.raws = { before: '', after: '' });
       for (let t in e) this[t] = e[t];
      }
      remove() {
       return this.parent && this.parent.removeChild(this), (this.parent = void 0), this;
      }
      toString() {
       return [this.raws.before, String(this.value), this.raws.after].join('');
      }
      clone(e) {
       e = e || {};
       let t = r(this);
       for (let r in e) t[r] = e[r];
       return t;
      }
      cloneBefore(e) {
       e = e || {};
       let t = this.clone(e);
       return this.parent.insertBefore(this, t), t;
      }
      cloneAfter(e) {
       e = e || {};
       let t = this.clone(e);
       return this.parent.insertAfter(this, t), t;
      }
      replaceWith() {
       let e = Array.prototype.slice.call(arguments);
       if (this.parent) {
        for (let t of e) this.parent.insertBefore(this, t);
        this.remove();
       }
       return this;
      }
      moveTo(e) {
       return this.cleanRaws(this.root() === e.root()), this.remove(), e.append(this), this;
      }
      moveBefore(e) {
       return this.cleanRaws(this.root() === e.root()), this.remove(), e.parent.insertBefore(e, this), this;
      }
      moveAfter(e) {
       return this.cleanRaws(this.root() === e.root()), this.remove(), e.parent.insertAfter(e, this), this;
      }
      next() {
       let e = this.parent.index(this);
       return this.parent.nodes[e + 1];
      }
      prev() {
       let e = this.parent.index(this);
       return this.parent.nodes[e - 1];
      }
      toJSON() {
       let e = {};
       for (let t in this) {
        if (!this.hasOwnProperty(t) || 'parent' === t) continue;
        let r = this[t];
        r instanceof Array ? (e[t] = r.map((e) => ('object' == typeof e && e.toJSON ? e.toJSON() : e))) : 'object' == typeof r && r.toJSON ? (e[t] = r.toJSON()) : (e[t] = r);
       }
       return e;
      }
      root() {
       let e = this;
       for (; e.parent; ) e = e.parent;
       return e;
      }
      cleanRaws(e) {
       delete this.raws.before, delete this.raws.after, e || delete this.raws.between;
      }
      positionInside(e) {
       let t = this.toString(),
        r = this.source.start.column,
        s = this.source.start.line;
       for (let n = 0; n < e; n++) '\n' === t[n] ? ((r = 1), (s += 1)) : (r += 1);
       return { line: s, column: r };
      }
      positionBy(e) {
       let t = this.source.start;
       if (Object(e).index) t = this.positionInside(e.index);
       else if (Object(e).word) {
        let r = this.toString().indexOf(e.word);
        -1 !== r && (t = this.positionInside(r));
       }
       return t;
      }
     };
    }),
    Pe = l((e, t) => {
     var r = Se(),
      s = class extends r {
       constructor(e) {
        super(e), this.nodes || (this.nodes = []);
       }
       push(e) {
        return (e.parent = this), this.nodes.push(e), this;
       }
       each(e) {
        this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), (this.lastEach += 1);
        let t,
         r,
         s = this.lastEach;
        if (((this.indexes[s] = 0), this.nodes)) {
         for (; this.indexes[s] < this.nodes.length && ((t = this.indexes[s]), (r = e(this.nodes[t], t)), !1 !== r); ) this.indexes[s] += 1;
         return delete this.indexes[s], r;
        }
       }
       walk(e) {
        return this.each((t, r) => {
         let s = e(t, r);
         return !1 !== s && t.walk && (s = t.walk(e)), s;
        });
       }
       walkType(e, t) {
        if (!e || !t) throw new Error('Parameters {type} and {callback} are required.');
        let r = 'function' == typeof e;
        return this.walk((s, n) => {
         if ((r && s instanceof e) || (!r && s.type === e)) return t.call(this, s, n);
        });
       }
       append(e) {
        return (e.parent = this), this.nodes.push(e), this;
       }
       prepend(e) {
        return (e.parent = this), this.nodes.unshift(e), this;
       }
       cleanRaws(e) {
        if ((super.cleanRaws(e), this.nodes)) for (let t of this.nodes) t.cleanRaws(e);
       }
       insertAfter(e, t) {
        let r,
         s = this.index(e);
        this.nodes.splice(s + 1, 0, t);
        for (let n in this.indexes) (r = this.indexes[n]), s <= r && (this.indexes[n] = r + this.nodes.length);
        return this;
       }
       insertBefore(e, t) {
        let r,
         s = this.index(e);
        this.nodes.splice(s, 0, t);
        for (let n in this.indexes) (r = this.indexes[n]), s <= r && (this.indexes[n] = r + this.nodes.length);
        return this;
       }
       removeChild(e) {
        let t;
        (e = this.index(e)), (this.nodes[e].parent = void 0), this.nodes.splice(e, 1);
        for (let r in this.indexes) (t = this.indexes[r]), t >= e && (this.indexes[r] = t - 1);
        return this;
       }
       removeAll() {
        for (let e of this.nodes) e.parent = void 0;
        return (this.nodes = []), this;
       }
       every(e) {
        return this.nodes.every(e);
       }
       some(e) {
        return this.nodes.some(e);
       }
       index(e) {
        return 'number' == typeof e ? e : this.nodes.indexOf(e);
       }
       get first() {
        if (this.nodes) return this.nodes[0];
       }
       get last() {
        if (this.nodes) return this.nodes[this.nodes.length - 1];
       }
       toString() {
        let e = this.nodes.map(String).join('');
        return this.value && (e = this.value + e), this.raws.before && (e = this.raws.before + e), this.raws.after && (e += this.raws.after), e;
       }
      };
     (s.registerWalker = (e) => {
      let t = 'walk' + e.name;
      t.lastIndexOf('s') !== t.length - 1 && (t += 's'),
       !s.prototype[t] &&
        (s.prototype[t] = function (t) {
         return this.walkType(e, t);
        });
     }),
      (t.exports = s);
    }),
    ke = l((e, t) => {
     var r = Pe();
     t.exports = class extends r {
      constructor(e) {
       super(e), (this.type = 'root');
      }
     };
    }),
    Ie = l((e, t) => {
     var r = Pe();
     t.exports = class extends r {
      constructor(e) {
       super(e), (this.type = 'value'), (this.unbalanced = 0);
      }
     };
    }),
    Ne = l((e, t) => {
     var r = Pe(),
      s = class extends r {
       constructor(e) {
        super(e), (this.type = 'atword');
       }
       toString() {
        this.quoted && this.raws.quote;
        return [this.raws.before, '@', String.prototype.toString.call(this.value), this.raws.after].join('');
       }
      };
     r.registerWalker(s), (t.exports = s);
    }),
    Be = l((e, t) => {
     var r = Pe(),
      s = Se(),
      n = class extends s {
       constructor(e) {
        super(e), (this.type = 'colon');
       }
      };
     r.registerWalker(n), (t.exports = n);
    }),
    Oe = l((e, t) => {
     var r = Pe(),
      s = Se(),
      n = class extends s {
       constructor(e) {
        super(e), (this.type = 'comma');
       }
      };
     r.registerWalker(n), (t.exports = n);
    }),
    Le = l((e, t) => {
     var r = Pe(),
      s = Se(),
      n = class extends s {
       constructor(e) {
        super(e), (this.type = 'comment'), (this.inline = Object(e).inline || !1);
       }
       toString() {
        return [this.raws.before, this.inline ? '//' : '/*', String(this.value), this.inline ? '' : '*/', this.raws.after].join('');
       }
      };
     r.registerWalker(n), (t.exports = n);
    }),
    Me = l((e, t) => {
     var r = Pe(),
      s = class extends r {
       constructor(e) {
        super(e), (this.type = 'func'), (this.unbalanced = -1);
       }
      };
     r.registerWalker(s), (t.exports = s);
    }),
    je = l((e, t) => {
     var r = Pe(),
      s = Se(),
      n = class extends s {
       constructor(e) {
        super(e), (this.type = 'number'), (this.unit = Object(e).unit || '');
       }
       toString() {
        return [this.raws.before, String(this.value), this.unit, this.raws.after].join('');
       }
      };
     r.registerWalker(n), (t.exports = n);
    }),
    _e = l((e, t) => {
     var r = Pe(),
      s = Se(),
      n = class extends s {
       constructor(e) {
        super(e), (this.type = 'operator');
       }
      };
     r.registerWalker(n), (t.exports = n);
    }),
    Re = l((e, t) => {
     var r = Pe(),
      s = Se(),
      n = class extends s {
       constructor(e) {
        super(e), (this.type = 'paren'), (this.parenType = '');
       }
      };
     r.registerWalker(n), (t.exports = n);
    }),
    Ue = l((e, t) => {
     var r = Pe(),
      s = Se(),
      n = class extends s {
       constructor(e) {
        super(e), (this.type = 'string');
       }
       toString() {
        let e = this.quoted ? this.raws.quote : '';
        return [this.raws.before, e, this.value + '', e, this.raws.after].join('');
       }
      };
     r.registerWalker(n), (t.exports = n);
    }),
    $e = l((e, t) => {
     var r = Pe(),
      s = Se(),
      n = class extends s {
       constructor(e) {
        super(e), (this.type = 'word');
       }
      };
     r.registerWalker(n), (t.exports = n);
    }),
    qe = l((e, t) => {
     var r = Pe(),
      s = Se(),
      n = class extends s {
       constructor(e) {
        super(e), (this.type = 'unicode-range');
       }
      };
     r.registerWalker(n), (t.exports = n);
    }),
    Je = l((e, t) => {
     var r = class extends Error {
      constructor(e) {
       super(e), (this.name = this.constructor.name), (this.message = e || 'An error ocurred while tokzenizing.'), 'function' == typeof Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : (this.stack = new Error(e).stack);
      }
     };
     t.exports = r;
    }),
    We = l((e, t) => {
     var r = /[ \n\t\r\{\(\)'"\\;,/]/g,
      s = /[ \n\t\r\(\)\{\}\*:;@!&'"\+\|~>,\[\]\\]|\/(?=\*)/g,
      n = /[ \n\t\r\(\)\{\}\*:;@!&'"\-\+\|~>,\[\]\\]|\//g,
      i = /^[a-z0-9]/i,
      a = /^[a-f0-9?\-]/i,
      o = Je();
     t.exports = function (e, t) {
      t = t || {};
      let u,
       l,
       p,
       c,
       h,
       d,
       f,
       m,
       y,
       D,
       g,
       x = [],
       E = e.valueOf(),
       b = E.length,
       T = -1,
       A = 1,
       C = 0,
       v = 0,
       F = null;
      function w(e) {
       throw new o(`Unclosed ${e} at line: ${A}, column: ${C - T}, token: ${C}`);
      }
      for (; C < b; ) {
       switch (((u = E.charCodeAt(C)), 10 === u && ((T = C), (A += 1)), u)) {
        case 10:
        case 32:
        case 9:
        case 13:
        case 12:
         l = C;
         do {
          (l += 1), (u = E.charCodeAt(l)), 10 === u && ((T = l), (A += 1));
         } while (32 === u || 10 === u || 9 === u || 13 === u || 12 === u);
         x.push(['space', E.slice(C, l), A, C - T, A, l - T, C]), (C = l - 1);
         break;
        case 58:
         (l = C + 1), x.push(['colon', E.slice(C, l), A, C - T, A, l - T, C]), (C = l - 1);
         break;
        case 44:
         (l = C + 1), x.push(['comma', E.slice(C, l), A, C - T, A, l - T, C]), (C = l - 1);
         break;
        case 123:
         x.push(['{', '{', A, C - T, A, l - T, C]);
         break;
        case 125:
         x.push(['}', '}', A, C - T, A, l - T, C]);
         break;
        case 40:
         v++, (F = !F && 1 === v && x.length > 0 && 'word' === x[x.length - 1][0] && 'url' === x[x.length - 1][1]), x.push(['(', '(', A, C - T, A, l - T, C]);
         break;
        case 41:
         v--, (F = F && v > 0), x.push([')', ')', A, C - T, A, l - T, C]);
         break;
        case 39:
        case 34:
         (p = 39 === u ? "'" : '"'), (l = C);
         do {
          for (y = !1, l = E.indexOf(p, l + 1), -1 === l && w('quote'), D = l; 92 === E.charCodeAt(D - 1); ) (D -= 1), (y = !y);
         } while (y);
         x.push(['string', E.slice(C, l + 1), A, C - T, A, l - T, C]), (C = l);
         break;
        case 64:
         (r.lastIndex = C + 1), r.test(E), (l = 0 === r.lastIndex ? E.length - 1 : r.lastIndex - 2), x.push(['atword', E.slice(C, l + 1), A, C - T, A, l - T, C]), (C = l);
         break;
        case 92:
         (l = C), (u = E.charCodeAt(l + 1)), x.push(['word', E.slice(C, l + 1), A, C - T, A, l - T, C]), (C = l);
         break;
        case 43:
        case 45:
        case 42:
         (l = C + 1), (g = E.slice(C + 1, l + 1));
         E.slice(C - 1, C);
         if (45 === u && 45 === g.charCodeAt(0)) {
          l++, x.push(['word', E.slice(C, l), A, C - T, A, l - T, C]), (C = l - 1);
          break;
         }
         x.push(['operator', E.slice(C, l), A, C - T, A, l - T, C]), (C = l - 1);
         break;
        default:
         if (47 === u && (42 === E.charCodeAt(C + 1) || (t.loose && !F && 47 === E.charCodeAt(C + 1)))) {
          if (42 === E.charCodeAt(C + 1)) (l = E.indexOf('*/', C + 2) + 1), 0 === l && w('comment');
          else {
           let e = E.indexOf('\n', C + 2);
           l = -1 !== e ? e - 1 : b;
          }
          (d = E.slice(C, l + 1)), (c = d.split('\n')), (h = c.length - 1), h > 0 ? ((f = A + h), (m = l - c[h].length)) : ((f = A), (m = T)), x.push(['comment', d, A, C - T, f, l - m, C]), (T = m), (A = f), (C = l);
         } else if (35 !== u || i.test(E.slice(C + 1, C + 2)))
          if ((117 !== u && 85 !== u) || 43 !== E.charCodeAt(C + 1))
           if (47 === u) (l = C + 1), x.push(['operator', E.slice(C, l), A, C - T, A, l - T, C]), (C = l - 1);
           else {
            let e = s;
            if ((u >= 48 && u <= 57 && (e = n), (e.lastIndex = C + 1), e.test(E), (l = 0 === e.lastIndex ? E.length - 1 : e.lastIndex - 2), e === n || 46 === u)) {
             let e = E.charCodeAt(l),
              t = E.charCodeAt(l + 1),
              r = E.charCodeAt(l + 2);
             (101 === e || 69 === e) && (45 === t || 43 === t) && r >= 48 && r <= 57 && ((n.lastIndex = l + 2), n.test(E), (l = 0 === n.lastIndex ? E.length - 1 : n.lastIndex - 2));
            }
            x.push(['word', E.slice(C, l + 1), A, C - T, A, l - T, C]), (C = l);
           }
          else {
           l = C + 2;
           do {
            (l += 1), (u = E.charCodeAt(l));
           } while (l < b && a.test(E.slice(l, l + 1)));
           x.push(['unicoderange', E.slice(C, l), A, C - T, A, l - T, C]), (C = l - 1);
          }
         else (l = C + 1), x.push(['#', E.slice(C, l), A, C - T, A, l - T, C]), (C = l - 1);
       }
       C++;
      }
      return x;
     };
    }),
    ze = l((e, t) => {
     var r = class extends Error {
      constructor(e) {
       super(e), (this.name = this.constructor.name), (this.message = e || 'An error ocurred while parsing.'), 'function' == typeof Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : (this.stack = new Error(e).stack);
      }
     };
     t.exports = r;
    }),
    Ve = l((e, t) => {
     var r = ke(),
      s = Ie(),
      n = Ne(),
      i = Be(),
      a = Oe(),
      o = Le(),
      u = Me(),
      l = je(),
      p = _e(),
      c = Re(),
      h = Ue(),
      d = $e(),
      f = qe(),
      m = We(),
      y = ie(),
      D = ae(),
      g = oe(),
      x = ze();
     t.exports = class {
      constructor(e, t) {
       (this.cache = []), (this.input = e), (this.options = Object.assign({}, { loose: !1 }, t)), (this.position = 0), (this.unbalanced = 0), (this.root = new r());
       let n = new s();
       this.root.append(n), (this.current = n), (this.tokens = m(e, this.options));
      }
      parse() {
       return this.loop();
      }
      colon() {
       let e = this.currToken;
       this.newNode(new i({ value: e[1], source: { start: { line: e[2], column: e[3] }, end: { line: e[4], column: e[5] } }, sourceIndex: e[6] })), this.position++;
      }
      comma() {
       let e = this.currToken;
       this.newNode(new a({ value: e[1], source: { start: { line: e[2], column: e[3] }, end: { line: e[4], column: e[5] } }, sourceIndex: e[6] })), this.position++;
      }
      comment() {
       let e,
        t = !1,
        r = this.currToken[1].replace(/\/\*|\*\//g, '');
       this.options.loose && r.startsWith('//') && ((r = r.substring(2)), (t = !0)), (e = new o({ value: r, inline: t, source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] })), this.newNode(e), this.position++;
      }
      error(e, t) {
       throw new x(e + ` at line: ${t[2]}, column ${t[3]}`);
      }
      loop() {
       for (; this.position < this.tokens.length; ) this.parseTokens();
       return !this.current.last && this.spaces ? (this.current.raws.before += this.spaces) : this.spaces && (this.current.last.raws.after += this.spaces), (this.spaces = ''), this.root;
      }
      operator() {
       let e,
        t = this.currToken[1];
       if ('+' === t || '-' === t)
        if ((this.options.loose || (this.position > 0 && ('func' === this.current.type && 'calc' === this.current.value ? (('space' !== this.prevToken[0] && '(' !== this.prevToken[0]) || ('space' !== this.nextToken[0] && 'word' !== this.nextToken[0]) || ('word' === this.nextToken[0] && 'operator' !== this.current.last.type && '(' !== this.current.last.value)) && this.error('Syntax Error', this.currToken) : ('space' === this.nextToken[0] || 'operator' === this.nextToken[0] || 'operator' === this.prevToken[0]) && this.error('Syntax Error', this.currToken))), this.options.loose)) {
         if ((!this.current.nodes.length || (this.current.last && 'operator' === this.current.last.type)) && 'word' === this.nextToken[0]) return this.word();
        } else if ('word' === this.nextToken[0]) return this.word();
       return (e = new p({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] })), this.position++, this.newNode(e);
      }
      parseTokens() {
       switch (this.currToken[0]) {
        case 'space':
         this.space();
         break;
        case 'colon':
         this.colon();
         break;
        case 'comma':
         this.comma();
         break;
        case 'comment':
         this.comment();
         break;
        case '(':
         this.parenOpen();
         break;
        case ')':
         this.parenClose();
         break;
        case 'atword':
        case 'word':
        default:
         this.word();
         break;
        case 'operator':
         this.operator();
         break;
        case 'string':
         this.string();
         break;
        case 'unicoderange':
         this.unicodeRange();
       }
      }
      parenOpen() {
       let e,
        t = 1,
        r = this.position + 1,
        s = this.currToken;
       for (; r < this.tokens.length && t; ) {
        let e = this.tokens[r];
        '(' === e[0] && t++, ')' === e[0] && t--, r++;
       }
       if ((t && this.error('Expected closing parenthesis', s), (e = this.current.last), e && 'func' === e.type && e.unbalanced < 0 && ((e.unbalanced = 0), (this.current = e)), this.current.unbalanced++, this.newNode(new c({ value: s[1], source: { start: { line: s[2], column: s[3] }, end: { line: s[4], column: s[5] } }, sourceIndex: s[6] })), this.position++, 'func' === this.current.type && this.current.unbalanced && 'url' === this.current.value && 'string' !== this.currToken[0] && ')' !== this.currToken[0] && !this.options.loose)) {
        let e = this.nextToken,
         t = this.currToken[1],
         r = { line: this.currToken[2], column: this.currToken[3] };
        for (; e && ')' !== e[0] && this.current.unbalanced; ) this.position++, (t += this.currToken[1]), (e = this.nextToken);
        this.position !== this.tokens.length - 1 && (this.position++, this.newNode(new d({ value: t, source: { start: r, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] })));
       }
      }
      parenClose() {
       let e = this.currToken;
       this.newNode(new c({ value: e[1], source: { start: { line: e[2], column: e[3] }, end: { line: e[4], column: e[5] } }, sourceIndex: e[6] })), this.position++, (!(this.position >= this.tokens.length - 1) || this.current.unbalanced) && (this.current.unbalanced--, this.current.unbalanced < 0 && this.error('Expected opening parenthesis', e), !this.current.unbalanced && this.cache.length && (this.current = this.cache.pop()));
      }
      space() {
       let e = this.currToken;
       this.position === this.tokens.length - 1 || ',' === this.nextToken[0] || ')' === this.nextToken[0] ? ((this.current.last.raws.after += e[1]), this.position++) : ((this.spaces = e[1]), this.position++);
      }
      unicodeRange() {
       let e = this.currToken;
       this.newNode(new f({ value: e[1], source: { start: { line: e[2], column: e[3] }, end: { line: e[4], column: e[5] } }, sourceIndex: e[6] })), this.position++;
      }
      splitWord() {
       let e,
        t,
        r = this.nextToken,
        s = this.currToken[1],
        i = /^[\+\-]?((\d+(\.\d*)?)|(\.\d+))([eE][\+\-]?\d+)?/;
       if (!/^(?!\#([a-z0-9]+))[\#\{\}]/gi.test(s))
        for (; r && 'word' === r[0]; ) {
         this.position++;
         let e = this.currToken[1];
         (s += e), (r = this.nextToken);
        }
       var a;
       (e = D(s, '@')),
        (a = g(y([[0], e]))),
        (t = a.sort((e, t) => e - t)),
        t.forEach((a, o) => {
         let p,
          c = t[o + 1] || s.length,
          h = s.slice(a, c);
         if (~e.indexOf(a)) p = new n({ value: h.slice(1), source: { start: { line: this.currToken[2], column: this.currToken[3] + a }, end: { line: this.currToken[4], column: this.currToken[3] + (c - 1) } }, sourceIndex: this.currToken[6] + t[o] });
         else if (i.test(this.currToken[1])) {
          let e = h.replace(i, '');
          p = new l({ value: h.replace(e, ''), source: { start: { line: this.currToken[2], column: this.currToken[3] + a }, end: { line: this.currToken[4], column: this.currToken[3] + (c - 1) } }, sourceIndex: this.currToken[6] + t[o], unit: e });
         } else (p = new (r && '(' === r[0] ? u : d)({ value: h, source: { start: { line: this.currToken[2], column: this.currToken[3] + a }, end: { line: this.currToken[4], column: this.currToken[3] + (c - 1) } }, sourceIndex: this.currToken[6] + t[o] })), 'word' === p.type ? ((p.isHex = /^#(.+)/.test(h)), (p.isColor = /^#([0-9a-f]{3}|[0-9a-f]{4}|[0-9a-f]{6}|[0-9a-f]{8})$/i.test(h))) : this.cache.push(this.current);
         this.newNode(p);
        }),
        this.position++;
      }
      string() {
       let e,
        t = this.currToken,
        r = this.currToken[1],
        s = /^(\"|\')/,
        n = s.test(r),
        i = '';
       n && ((i = r.match(s)[0]), (r = r.slice(1, r.length - 1))), (e = new h({ value: r, source: { start: { line: t[2], column: t[3] }, end: { line: t[4], column: t[5] } }, sourceIndex: t[6], quoted: n })), (e.raws.quote = i), this.newNode(e), this.position++;
      }
      word() {
       return this.splitWord();
      }
      newNode(e) {
       return this.spaces && ((e.raws.before += this.spaces), (this.spaces = '')), this.current.append(e);
      }
      get currToken() {
       return this.tokens[this.position];
      }
      get nextToken() {
       return this.tokens[this.position + 1];
      }
      get prevToken() {
       return this.tokens[this.position - 1];
      }
     };
    }),
    He = {};
   p(He, { languages: () => ks, options: () => Is, parsers: () => Ns, printers: () => mn });
   var Ke = (e, t, r, s) => {
     if (!e || null != t) return t.replaceAll ? t.replaceAll(r, s) : r.global ? t.replace(r, s) : t.split(r).join(s);
    },
    Xe = 'string',
    Ge = 'array',
    Ye = 'cursor',
    Qe = 'indent',
    Ze = 'align',
    et = 'trim',
    tt = 'group',
    rt = 'fill',
    st = 'if-break',
    nt = 'indent-if-break',
    it = 'line-suffix',
    at = 'line-suffix-boundary',
    ot = 'line',
    ut = 'label',
    lt = 'break-parent',
    pt = new Set([Ye, Qe, Ze, et, tt, rt, st, nt, it, at, ot, ut, lt]),
    ct = (e, t, r) => {
     if (!e || null != t) return Array.isArray(t) || 'string' == typeof t ? t[r < 0 ? t.length + r : r] : t.at(r);
    };
   var ht = function (e) {
    if ('string' == typeof e) return Xe;
    if (Array.isArray(e)) return Ge;
    if (!e) return;
    let { type: t } = e;
    return pt.has(t) ? t : void 0;
   };
   function dt(e) {
    let t = null === e ? 'null' : typeof e;
    if ('string' !== t && 'object' !== t) return `Unexpected doc '${t}', \nExpected it to be 'string' or 'object'.`;
    if (ht(e)) throw new Error('doc is valid.');
    let r = Object.prototype.toString.call(e);
    if ('[object Object]' !== r) return `Unexpected doc '${r}'.`;
    let s = ((e) => new Intl.ListFormat('en-US', { type: 'disjunction' }).format(e))([...pt].map((e) => `'${e}'`));
    return `Unexpected doc.type '${e.type}'.\nExpected it to be ${s}.`;
   }
   var ft = class extends Error {
    name = 'InvalidDocError';
    constructor(e) {
     super(dt(e)), (this.doc = e);
    }
   };
   function mt(e, t) {
    if ('string' == typeof e) return t(e);
    let r = new Map();
    return s(e);
    function s(e) {
     if (r.has(e)) return r.get(e);
     let n = (function (e) {
      switch (ht(e)) {
       case Ge:
        return t(e.map(s));
       case rt:
        return t({ ...e, parts: e.parts.map(s) });
       case st:
        return t({ ...e, breakContents: s(e.breakContents), flatContents: s(e.flatContents) });
       case tt: {
        let { expandedStates: r, contents: n } = e;
        return r ? ((r = r.map(s)), (n = r[0])) : (n = s(n)), t({ ...e, contents: n, expandedStates: r });
       }
       case Ze:
       case Qe:
       case nt:
       case ut:
       case it:
        return t({ ...e, contents: s(e.contents) });
       case Xe:
       case Ye:
       case et:
       case at:
       case ot:
       case lt:
        return t(e);
       default:
        throw new ft(e);
      }
     })(e);
     return r.set(e, n), n;
    }
   }
   function yt(e) {
    return e.type !== ot || e.hard ? (e.type === st ? e.flatContents : e) : e.soft ? '' : ' ';
   }
   var Dt = () => {},
    gt = Dt,
    xt = Dt,
    Et = Dt;
   function bt(e) {
    return gt(e), { type: Qe, contents: e };
   }
   function Tt(e, t) {
    return gt(t), { type: Ze, contents: t, n: e };
   }
   function At(e, t = {}) {
    return gt(e), xt(t.expandedStates, !0), { type: tt, id: t.id, contents: e, break: !!t.shouldBreak, expandedStates: t.expandedStates };
   }
   function Ct(e) {
    return Tt(-1, e);
   }
   function vt(e) {
    return Et(e), { type: rt, parts: e };
   }
   function Ft(e, t = '', r = {}) {
    return gt(e), '' !== t && gt(t), { type: st, breakContents: e, flatContents: t, groupId: r.groupId };
   }
   function wt(e) {
    return gt(e), { type: it, contents: e };
   }
   var St = { type: lt },
    Pt = { type: ot },
    kt = { type: ot, soft: !0 },
    It = [{ type: ot, hard: !0 }, St];
   function Nt(e, t) {
    gt(e), xt(t);
    let r = [];
    for (let s = 0; s < t.length; s++) 0 !== s && r.push(e), r.push(t[s]);
    return r;
   }
   var Bt = function (e) {
     return Array.isArray(e) && e.length > 0;
    },
    Ot = new Proxy(() => {}, { get: () => Ot }),
    Lt = Ot,
    Mt = "'";
   var jt = function (e, t) {
    let r = !0 === t || t === Mt ? Mt : '"',
     s = r === Mt ? '"' : Mt,
     n = 0,
     i = 0;
    for (let a of e) a === r ? n++ : a === s && i++;
    return n > i ? s : r;
   };
   var _t = function (e, t, r) {
    let s = '"' === t ? "'" : '"',
     n = Ke(!1, e, /\\(.)|(["'])/gsu, (e, n, i) => (n === s ? n : i === t ? '\\' + i : i || (r && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/u.test(n) ? n : '\\' + n)));
    return t + n + t;
   };
   var Rt = function (e, t) {
     Lt(/^(?<quote>["']).*\k<quote>$/su.test(e));
     let r = e.slice(1, -1),
      s = 'json' === t.parser || 'jsonc' === t.parser || ('json5' === t.parser && 'preserve' === t.quoteProps && !t.singleQuote) ? '"' : t.__isInHtmlAttribute ? "'" : jt(r, t.singleQuote);
     return e.charAt(0) === s ? e : _t(r, s, !1);
    },
    Ut = class extends Error {
     name = 'UnexpectedNodeError';
     constructor(e, t, r = 'type') {
      super(`Unexpected ${t} node ${r}: ${JSON.stringify(e[r])}.`), (this.node = e);
     }
    };
   var $t = function (e) {
     return 'front-matter' === (null == e ? void 0 : e.type);
    },
    qt = new Set(['raw', 'raws', 'sourceIndex', 'source', 'before', 'after', 'trailingComma', 'spaces']);
   function Jt(e, t, r) {
    if (($t(e) && 'yaml' === e.language && delete t.value, 'css-comment' === e.type && 'css-root' === r.type && r.nodes.length > 0 && (((r.nodes[0] === e || ($t(r.nodes[0]) && r.nodes[1] === e)) && (delete t.text, /^\*\s*@(?:format|prettier)\s*$/u.test(e.text))) || ('css-root' === r.type && ct(!1, r.nodes, -1) === e)))) return null;
    if (
     ('value-root' === e.type && delete t.text,
     ('media-query' === e.type || 'media-query-list' === e.type || 'media-feature-expression' === e.type) && delete t.value,
     'css-rule' === e.type && delete t.params,
     ('media-feature' === e.type || 'media-keyword' === e.type || 'media-type' === e.type || 'media-unknown' === e.type || 'media-url' === e.type || 'media-value' === e.type || 'selector-attribute' === e.type || 'selector-string' === e.type || 'selector-class' === e.type || 'selector-combinator' === e.type || 'value-string' === e.type) &&
      e.value &&
      (t.value = (function (e) {
       return Ke(!1, Ke(!1, e, "'", '"'), /\\([^\da-f])/giu, '$1');
      })(e.value)),
     'selector-combinator' === e.type && (t.value = Ke(!1, t.value, /\s+/gu, ' ')),
     'media-feature' === e.type && (t.value = Ke(!1, t.value, ' ', '')),
     (('value-word' === e.type && ((e.isColor && e.isHex) || ['initial', 'inherit', 'unset', 'revert'].includes(e.value.toLowerCase()))) || 'media-feature' === e.type || 'selector-root-invalid' === e.type || 'selector-pseudo' === e.type) && (t.value = t.value.toLowerCase()),
     'css-decl' === e.type && (t.prop = e.prop.toLowerCase()),
     ('css-atrule' === e.type || 'css-import' === e.type) && (t.name = e.name.toLowerCase()),
     'value-number' === e.type && (t.unit = e.unit.toLowerCase()),
     'value-unknown' === e.type && (t.value = Ke(!1, t.value, /;$/gu, '')),
     'selector-attribute' === e.type && ((t.attribute = e.attribute.trim()), e.namespace && 'string' == typeof e.namespace && (t.namespace = e.namespace.trim() || !0), e.value && ((t.value = Ke(!1, t.value.trim(), /^["']|["']$/gu, '')), delete t.quoted)),
     ('media-value' === e.type || 'media-type' === e.type || 'value-number' === e.type || 'selector-root-invalid' === e.type || 'selector-class' === e.type || 'selector-combinator' === e.type || 'selector-tag' === e.type) &&
      e.value &&
      (t.value = Ke(!1, t.value, /([\d+.e-]+)([a-z]*)/giu, (e, t, r) => {
       let s = Number(t);
       return Number.isNaN(s) ? e : s + r.toLowerCase();
      })),
     'selector-tag' === e.type)
    ) {
     let e = t.value.toLowerCase();
     ['from', 'to'].includes(e) && (t.value = e);
    }
    if (('css-atrule' === e.type && 'supports' === e.name.toLowerCase() && delete t.value, 'selector-unknown' === e.type && delete t.value, 'value-comma_group' === e.type)) {
     let r = e.groups.findIndex((e) => 'value-number' === e.type && '...' === e.unit);
     -1 !== r && ((t.groups[r].unit = ''), t.groups.splice(r + 1, 0, { type: 'value-word', value: '...', isColor: !1, isHex: !1 }));
    }
    return 'value-comma_group' === e.type && e.groups.some((e) => ('value-atword' === e.type && e.value.endsWith('[')) || ('value-word' === e.type && e.value.startsWith(']'))) ? { type: 'value-atword', value: e.groups.map((e) => e.value).join(''), group: { open: null, close: null, groups: [], type: 'value-paren_group' } } : void 0;
   }
   Jt.ignoredProperties = qt;
   var Wt = Jt;
   var zt = async function (e, t) {
    if ('yaml' === e.language) {
     let r = e.value.trim(),
      s = r ? await t(r, { parser: 'yaml' }) : '';
     return (function (e) {
      return Tt({ type: 'root' }, e);
     })([e.startDelimiter, e.explicitLanguage, It, s, s ? It : '', e.endDelimiter]);
    }
   };
   function Vt(e) {
    let { node: t } = e;
    if ('front-matter' === t.type)
     return async (e) => {
      let r = await zt(t, e);
      return r ? [r, It] : void 0;
     };
   }
   Vt.getVisitorKeys = (e) => ('css-root' === e.type ? ['frontMatter'] : []);
   var Ht = Vt,
    Kt = null;
   function Xt(e) {
    if (null !== Kt && (Kt.property, 1)) {
     let e = Kt;
     return (Kt = Xt.prototype = null), e;
    }
    return (Kt = Xt.prototype = e ?? Object.create(null)), new Xt();
   }
   for (let Dn = 0; Dn <= 10; Dn++) Xt();
   var Gt = (function (e, t = 'type') {
    return (
     (function (e) {
      Xt(e);
     })(e),
     function (r) {
      let s = r[t],
       n = e[s];
      if (!Array.isArray(n)) throw Object.assign(new Error(`Missing visitor keys for '${s}'.`), { node: r });
      return n;
     }
    );
   })({ 'front-matter': [], 'css-root': ['frontMatter', 'nodes'], 'css-comment': [], 'css-rule': ['selector', 'nodes'], 'css-decl': ['value', 'selector', 'nodes'], 'css-atrule': ['selector', 'params', 'value', 'nodes'], 'media-query-list': ['nodes'], 'media-query': ['nodes'], 'media-type': [], 'media-feature-expression': ['nodes'], 'media-feature': [], 'media-colon': [], 'media-value': [], 'media-keyword': [], 'media-url': [], 'media-unknown': [], 'selector-root': ['nodes'], 'selector-selector': ['nodes'], 'selector-comment': [], 'selector-string': [], 'selector-tag': [], 'selector-id': [], 'selector-class': [], 'selector-attribute': [], 'selector-combinator': ['nodes'], 'selector-universal': [], 'selector-pseudo': ['nodes'], 'selector-nesting': [], 'selector-unknown': [], 'value-value': ['group'], 'value-root': ['group'], 'value-comment': [], 'value-comma_group': ['groups'], 'value-paren_group': ['open', 'groups', 'close'], 'value-func': ['group'], 'value-paren': [], 'value-number': [], 'value-operator': [], 'value-word': [], 'value-colon': [], 'value-comma': [], 'value-string': [], 'value-atword': [], 'value-unicode-range': [], 'value-unknown': [] });
   var Yt = function (e, t) {
    let r = 0;
    for (let s = 0; s < e.line - 1; ++s) r = t.indexOf('\n', r) + 1;
    return r + e.column;
   };
   function Qt(e) {
    return (t, r, s) => {
     let n = !(null == s || !s.backwards);
     if (!1 === r) return !1;
     let { length: i } = t,
      a = r;
     for (; a >= 0 && a < i; ) {
      let r = t.charAt(a);
      if (e instanceof RegExp) {
       if (!e.test(r)) return a;
      } else if (!e.includes(r)) return a;
      n ? a-- : a++;
     }
     return (-1 === a || a === i) && a;
    };
   }
   Qt(/\s/u);
   var Zt = Qt(' \t'),
    er = Qt(',; \t'),
    tr = Qt(/[^\n\r]/u);
   function rr(e, t) {
    var r, s, n;
    if ('number' == typeof (null == (s = null == (r = e.source) ? void 0 : r.start) ? void 0 : s.offset)) return e.source.start.offset;
    if ('number' == typeof e.sourceIndex) return e.sourceIndex;
    if (null != (n = e.source) && n.start) return Yt(e.source.start, t);
    throw Object.assign(new Error('Can not locate node.'), { node: e });
   }
   function sr(e, t) {
    var r, s;
    if ('css-comment' === e.type && e.inline) return tr(t, e.source.startOffset);
    if ('number' == typeof (null == (s = null == (r = e.source) ? void 0 : r.end) ? void 0 : s.offset)) return e.source.end.offset;
    if (e.source) {
     if (e.source.end) return Yt(e.source.end, t);
     if (Bt(e.nodes)) return sr(ct(!1, e.nodes, -1), t);
    }
    return null;
   }
   function nr(e, t) {
    e.source && ((e.source.startOffset = rr(e, t)), (e.source.endOffset = sr(e, t)));
    for (let r in e) {
     let s = e[r];
     'source' === r || !s || 'object' != typeof s || ('value-root' === s.type || 'value-unknown' === s.type ? ir(s, ar(e), s.text || s.value) : nr(s, t));
    }
   }
   function ir(e, t, r) {
    e.source && ((e.source.startOffset = rr(e, r) + t), (e.source.endOffset = sr(e, r) + t));
    for (let s in e) {
     let n = e[s];
     'source' === s || !n || 'object' != typeof n || ir(n, t, r);
    }
   }
   function ar(e) {
    var t;
    let r = e.source.startOffset;
    return 'string' == typeof e.prop && (r += e.prop.length), 'css-atrule' === e.type && 'string' == typeof e.name && (r += 1 + e.name.length + e.raws.afterName.match(/^\s*:?\s*/u)[0].length), 'css-atrule' !== e.type && 'string' == typeof (null == (t = e.raws) ? void 0 : t.between) && (r += e.raws.between.length), r;
   }
   function or(e) {
    var t;
    return null == (t = e.source) ? void 0 : t.startOffset;
   }
   function ur(e) {
    var t;
    return null == (t = e.source) ? void 0 : t.endOffset;
   }
   var lr = /\*\/$/,
    pr = /^\/\*\*?/,
    cr = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/,
    hr = /(^|\s+)\/\/([^\n\r]*)/g,
    dr = /^(\r?\n)+/,
    fr = /(?:^|\r?\n) *(@[^\n\r]*?) *\r?\n *(?![^\n\r@]*\/\/[^]*)([^\s@][^\n\r@]+?) *\r?\n/g,
    mr = /(?:^|\r?\n) *@(\S+) *([^\n\r]*)/g,
    yr = /(\r?\n|^) *\* ?/g,
    Dr = [];
   function gr(e, t) {
    return [...Dr, ...(Array.isArray(t) ? t : [t])].map((t) => `@${e} ${t}`.trim());
   }
   var xr = function (e) {
    if (!e.startsWith('#!')) return '';
    let t = e.indexOf('\n');
    return -1 === t ? e : e.slice(0, t);
   };
   function Er(e) {
    let t = xr(e);
    t && (e = e.slice(t.length + 1));
    let r = (function (e) {
      let t = e.match(cr);
      return t ? t[0].trimStart() : '';
     })(e),
     { pragmas: s, comments: n } = (function (e) {
      e = Ke(!1, e.replace(pr, '').replace(lr, ''), yr, '$1');
      let t = '';
      for (; t !== e; ) (t = e), (e = Ke(!1, e, fr, '\n$1 $2\n'));
      e = e.replace(dr, '').trimEnd();
      let r,
       s = Object.create(null),
       n = Ke(!1, e, mr, '').replace(dr, '').trimEnd();
      for (; (r = mr.exec(e)); ) {
       let e = Ke(!1, r[2], hr, '');
       if ('string' == typeof s[r[1]] || Array.isArray(s[r[1]])) {
        let t = s[r[1]];
        s[r[1]] = [...Dr, ...(Array.isArray(t) ? t : [t]), e];
       } else s[r[1]] = e;
      }
      return { comments: n, pragmas: s };
     })(r);
    return { shebang: t, text: e, pragmas: s, comments: n };
   }
   function br(e) {
    let { shebang: t, text: r, pragmas: s, comments: n } = Er(e),
     i = (function (e) {
      let t = e.match(cr),
       r = null == t ? void 0 : t[0];
      return null == r ? e : e.slice(r.length);
     })(r),
     a = (function ({ comments: e = '', pragmas: t = {} }) {
      let r = '\n',
       s = ' *',
       n = Object.keys(t),
       i = n
        .flatMap((e) => gr(e, t[e]))
        .map((e) => `${s} ${e}${r}`)
        .join('');
      if (!e) {
       if (0 === n.length) return '';
       if (1 === n.length && !Array.isArray(t[n[0]])) {
        let e = t[n[0]];
        return `/** ${gr(n[0], e)[0]} */`;
       }
      }
      let a =
       e
        .split(r)
        .map((e) => `${s} ${e}`)
        .join(r) + r;
      return '/**\n' + (e ? a : '') + (e && n.length > 0 ? s + r : '') + i + ' */';
     })({ pragmas: { format: '', ...s }, comments: n.trimStart() });
    return (t ? `${t}\n` : '') + a + (i.startsWith('\n') ? '\n' : '\n\n') + i;
   }
   var Tr = 3;
   var Ar = function (e) {
    let t = (function (e) {
     let t = e.slice(0, Tr);
     if ('---' !== t && '+++' !== t) return;
     let r = e.indexOf('\n', Tr);
     if (-1 === r) return;
     let s = e.slice(Tr, r).trim(),
      n = e.indexOf(`\n${t}`, r),
      i = s;
     if ((i || (i = '+++' === t ? 'toml' : 'yaml'), -1 === n && '---' === t && 'yaml' === i && (n = e.indexOf('\n...', r)), -1 === n)) return;
     let a = n + 1 + Tr,
      o = e.charAt(a + 1);
     if (!/\s?/u.test(o)) return;
     let u = e.slice(0, a);
     return { type: 'front-matter', language: i, explicitLanguage: s, value: e.slice(r + 1, n), startDelimiter: t, endDelimiter: u.slice(-Tr), raw: u };
    })(e);
    if (!t) return { content: e };
    let { raw: r } = t;
    return { frontMatter: t, content: Ke(!1, r, /[^\n]/gu, ' ') + e.slice(r.length) };
   };
   var Cr = new Set(['red', 'green', 'blue', 'alpha', 'a', 'rgb', 'hue', 'h', 'saturation', 's', 'lightness', 'l', 'whiteness', 'w', 'blackness', 'b', 'tint', 'shade', 'blend', 'blenda', 'contrast', 'hsl', 'hsla', 'hwb', 'hwba']);
   var vr = new Set(['initial', 'inherit', 'unset', 'revert']);
   function Fr(e, t) {
    var r;
    let s = e.findAncestor((e) => 'css-atrule' === e.type);
    return (null == (r = null == s ? void 0 : s.name) ? void 0 : r.toLowerCase().endsWith('keyframes')) && ['from', 'to'].includes(t.toLowerCase());
   }
   function wr(e) {
    return e.includes('$') || e.includes('@') || e.includes('#') || e.startsWith('%') || e.startsWith('--') || e.startsWith(':--') || (e.includes('(') && e.includes(')')) ? e : e.toLowerCase();
   }
   function Sr(e, t) {
    var r;
    let s = e.findAncestor((e) => 'value-func' === e.type);
    return (null == (r = null == s ? void 0 : s.value) ? void 0 : r.toLowerCase()) === t;
   }
   function Pr(e) {
    var t;
    let r = e.findAncestor((e) => 'css-rule' === e.type),
     s = null == (t = null == r ? void 0 : r.raws) ? void 0 : t.selector;
    return s && (s.startsWith(':import') || s.startsWith(':export'));
   }
   function kr(e, t) {
    let r = Array.isArray(t) ? t : [t],
     s = e.findAncestor((e) => 'css-atrule' === e.type);
    return s && r.includes(s.name.toLowerCase());
   }
   function Ir(e) {
    let { selector: t } = e;
    return !!t && (('string' == typeof t && /^@.+:.*$/u.test(t)) || (t.value && /^@.+:.*$/u.test(t.value)));
   }
   function Nr(e) {
    return 'value-word' === e.type && ['from', 'through', 'end'].includes(e.value);
   }
   function Br(e) {
    return 'value-word' === e.type && ['and', 'or', 'not'].includes(e.value);
   }
   function Or(e) {
    return 'value-word' === e.type && 'in' === e.value;
   }
   function Lr(e) {
    return 'value-operator' === e.type && '*' === e.value;
   }
   function Mr(e) {
    return 'value-operator' === e.type && '/' === e.value;
   }
   function jr(e) {
    return 'value-operator' === e.type && '+' === e.value;
   }
   function _r(e) {
    return 'value-operator' === e.type && '-' === e.value;
   }
   function Rr(e) {
    return (
     Lr(e) ||
     Mr(e) ||
     jr(e) ||
     _r(e) ||
     (function (e) {
      return 'value-operator' === e.type && '%' === e.value;
     })(e)
    );
   }
   function Ur(e) {
    return 'value-word' === e.type && ['==', '!='].includes(e.value);
   }
   function $r(e) {
    return 'value-word' === e.type && ['<', '>', '<=', '>='].includes(e.value);
   }
   function qr(e, t) {
    return 'scss' === t.parser && 'css-atrule' === e.type && ['if', 'else', 'for', 'each', 'while'].includes(e.name);
   }
   function Jr(e) {
    var t;
    return (null == (t = e.raws) ? void 0 : t.params) && /^\(\s*\)$/u.test(e.raws.params);
   }
   function Wr(e) {
    return e.name.startsWith('prettier-placeholder');
   }
   function zr(e) {
    return e.prop.startsWith('@prettier-placeholder');
   }
   function Vr(e, t) {
    return '$$' === e.value && 'value-func' === e.type && 'value-word' === (null == t ? void 0 : t.type) && !t.raws.before;
   }
   function Hr(e) {
    var t, r, s;
    return 'value-paren_group' === (null == (s = null == (r = null == (t = e.value) ? void 0 : t.group) ? void 0 : r.group) ? void 0 : s.type) && null !== e.value.group.group.open && null !== e.value.group.group.close;
   }
   function Kr(e) {
    var t;
    return '' === (null == (t = e.raws) ? void 0 : t.before);
   }
   function Xr(e) {
    var t, r;
    return 'value-comma_group' === e.type && 'value-colon' === (null == (r = null == (t = e.groups) ? void 0 : t[1]) ? void 0 : r.type);
   }
   function Gr(e) {
    var t;
    return 'value-paren_group' === e.type && (null == (t = e.groups) ? void 0 : t[0]) && Xr(e.groups[0]);
   }
   function Yr(e, t) {
    var r;
    if ('scss' !== t.parser) return !1;
    let { node: s } = e;
    if (0 === s.groups.length) return !1;
    let n = e.grandparent;
    if (!(Gr(s) || (n && Gr(n)))) return !1;
    let i = e.findAncestor((e) => 'css-decl' === e.type);
    return !!((null != (r = null == i ? void 0 : i.prop) && r.startsWith('$')) || Gr(n) || 'value-func' === n.type);
   }
   function Qr(e) {
    return 'value-comment' === e.type && e.inline;
   }
   function Zr(e) {
    return 'value-word' === e.type && '#' === e.value;
   }
   function es(e) {
    return 'value-word' === e.type && '{' === e.value;
   }
   function ts(e) {
    return 'value-word' === e.type && '}' === e.value;
   }
   function rs(e) {
    return ['value-word', 'value-atword'].includes(e.type);
   }
   function ss(e) {
    return 'value-colon' === (null == e ? void 0 : e.type);
   }
   function ns(e) {
    return e.value && ['not', 'and', 'or'].includes(e.value.toLowerCase());
   }
   function is(e) {
    return 'value-func' === e.type && Cr.has(e.value.toLowerCase());
   }
   function as(e) {
    return /\/\//u.test(e.split(/[\n\r]/u).pop());
   }
   function os(e) {
    return 'value-atword' === (null == e ? void 0 : e.type) && e.value.startsWith('prettier-placeholder-');
   }
   function us(e) {
    var t, r;
    return 'value-paren_group' === e.type && '(' === (null == (t = e.open) ? void 0 : t.value) && ')' === (null == (r = e.close) ? void 0 : r.value);
   }
   var ls = function (e, t, r) {
    var s;
    let { node: n } = e,
     i = e.parent,
     a = e.grandparent,
     o = (function (e) {
      var t, r;
      return null == (r = null == (t = e.findAncestor((e) => 'css-decl' === e.type)) ? void 0 : t.prop) ? void 0 : r.toLowerCase();
     })(e),
     u = o && 'value-value' === i.type && ('grid' === o || o.startsWith('grid-template')),
     l = e.findAncestor((e) => 'css-atrule' === e.type),
     p = l && qr(l, t),
     c = n.groups.some((e) => Qr(e)),
     h = e.map(r, 'groups'),
     d = [''],
     f = Sr(e, 'url'),
     m = !1,
     y = !1;
    for (let D = 0; D < n.groups.length; ++D) {
     let r = n.groups[D - 1],
      o = n.groups[D],
      c = n.groups[D + 1],
      g = n.groups[D + 2];
     if (Qr(o) && !c) {
      d.push([d.pop(), wt([' ', h[D]])]);
      continue;
     }
     if ((d.push([d.pop(), h[D]]), f)) {
      ((c && jr(c)) || jr(o)) && d.push([d.pop(), ' ']);
      continue;
     }
     if ((ss(c) && 'value-word' === o.type && d.length > 2 && n.groups.slice(0, D).every((e) => 'value-comment' === e.type) && !Qr(r) && (d[d.length - 2] = Ct(ct(!1, d, -2))), (kr(e, 'forward') && 'value-word' === o.type && o.value && void 0 !== r && 'value-word' === r.type && 'as' === r.value && 'value-operator' === c.type && '*' === c.value) || !c || ('value-word' === o.type && o.value.endsWith('-') && os(c)))) continue;
     if ('value-string' === o.type && o.quoted) {
      let e = o.value.lastIndexOf('#{'),
       t = o.value.lastIndexOf('}');
      -1 !== e && -1 !== t ? (m = e > t) : -1 !== e ? (m = !0) : -1 !== t && (m = !1);
     }
     if (m || ss(o) || ss(c) || ('value-atword' === o.type && ('' === o.value || o.value.endsWith('['))) || ('value-word' === c.type && c.value.startsWith(']')) || '~' === o.value || ('value-string' !== o.type && o.value && o.value.includes('\\') && c && 'value-comment' !== c.type) || (null != r && r.value && r.value.indexOf('\\') === r.value.length - 1 && 'value-operator' === o.type && '/' === o.value) || '\\' === o.value || Vr(o, c) || Zr(o) || es(o) || ts(c) || (es(c) && Kr(c)) || (ts(o) && Kr(c)) || ('--' === o.value && Zr(c))) continue;
     let x = Rr(o),
      E = Rr(c);
     if ((((x && Zr(c)) || (E && ts(o))) && Kr(c)) || (!r && Mr(o)) || (Sr(e, 'calc') && (jr(o) || jr(c) || _r(o) || _r(c)) && Kr(c))) continue;
     let b = (jr(o) || _r(o)) && 0 === D && ('value-number' === c.type || c.isHex) && a && is(a) && !Kr(c),
      T = 'value-func' === (null == g ? void 0 : g.type) || (g && rs(g)) || 'value-func' === o.type || rs(o),
      A = 'value-func' === c.type || rs(c) || 'value-func' === (null == r ? void 0 : r.type) || (r && rs(r));
     if ('scss' === t.parser && x && '-' === o.value && 'value-func' === c.type && ur(o) !== or(c)) d.push([d.pop(), ' ']);
     else if ((Lr(c) || Lr(o) || Sr(e, 'calc') || b || !((Mr(c) && !T) || (Mr(o) && !A) || (jr(c) && !T) || (jr(o) && !A) || _r(c) || _r(o)) || !(Kr(c) || (x && (!r || (r && Rr(r)))))) && (('scss' !== t.parser && 'less' !== t.parser) || !x || '-' !== o.value || !us(c) || ur(o) !== or(c.open) || '(' !== c.open.value)) {
      if (Qr(o)) {
       if ('value-paren_group' === i.type) {
        d.push(Ct(It), '');
        continue;
       }
       d.push(It, '');
       continue;
      }
      if (p && (Ur(c) || $r(c) || Br(c) || Or(o) || Nr(o))) {
       d.push([d.pop(), ' ']);
       continue;
      }
      if (l && 'namespace' === l.name.toLowerCase()) {
       d.push([d.pop(), ' ']);
       continue;
      }
      if (u) {
       o.source && c.source && o.source.start.line !== c.source.start.line ? (d.push(It, ''), (y = !0)) : d.push([d.pop(), ' ']);
       continue;
      }
      if (E) {
       d.push([d.pop(), ' ']);
       continue;
      }
      if (!('...' === (null == c ? void 0 : c.value) || (os(o) && os(c) && ur(o) === or(c)))) {
       if (os(o) && us(c) && ur(o) === or(c.open)) {
        d.push(kt, '');
        continue;
       }
       if ('with' === o.value && us(c)) {
        d = [[vt(d), ' ']];
        continue;
       }
       (null != (s = o.value) && s.endsWith('#') && '{' === c.value && us(c.group)) || (Qr(c) && !g) || d.push(Pt, '');
      }
     }
    }
    return (
     c && d.push([d.pop(), St]),
     y && d.unshift('', It),
     p
      ? At(bt(d))
      : (function (e) {
           var t;
           let { node: r } = e;
           return 'url' === r.groups[0].value && 2 === r.groups.length && 'import' === (null == (t = e.findAncestor((e) => 'css-atrule' === e.type)) ? void 0 : t.name);
          })(e)
        ? At(vt(d))
        : At(bt(vt(d)))
    );
   };
   var ps = function (e) {
     return 1 === e.length
      ? e
      : e
         .toLowerCase()
         .replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(?=\d)/u, '$1$2')
         .replace(/^([+-]?[\d.]+)e[+-]?0+$/u, '$1')
         .replace(/^([+-])?\./u, '$10.')
         .replace(/(\.\d+?)0+(?=e|$)/u, '$1')
         .replace(/\.(?=e|$)/u, '');
    },
    cs = new Map([
     ['em', 'em'],
     ['rem', 'rem'],
     ['ex', 'ex'],
     ['rex', 'rex'],
     ['cap', 'cap'],
     ['rcap', 'rcap'],
     ['ch', 'ch'],
     ['rch', 'rch'],
     ['ic', 'ic'],
     ['ric', 'ric'],
     ['lh', 'lh'],
     ['rlh', 'rlh'],
     ['vw', 'vw'],
     ['svw', 'svw'],
     ['lvw', 'lvw'],
     ['dvw', 'dvw'],
     ['vh', 'vh'],
     ['svh', 'svh'],
     ['lvh', 'lvh'],
     ['dvh', 'dvh'],
     ['vi', 'vi'],
     ['svi', 'svi'],
     ['lvi', 'lvi'],
     ['dvi', 'dvi'],
     ['vb', 'vb'],
     ['svb', 'svb'],
     ['lvb', 'lvb'],
     ['dvb', 'dvb'],
     ['vmin', 'vmin'],
     ['svmin', 'svmin'],
     ['lvmin', 'lvmin'],
     ['dvmin', 'dvmin'],
     ['vmax', 'vmax'],
     ['svmax', 'svmax'],
     ['lvmax', 'lvmax'],
     ['dvmax', 'dvmax'],
     ['cm', 'cm'],
     ['mm', 'mm'],
     ['q', 'Q'],
     ['in', 'in'],
     ['pt', 'pt'],
     ['pc', 'pc'],
     ['px', 'px'],
     ['deg', 'deg'],
     ['grad', 'grad'],
     ['rad', 'rad'],
     ['turn', 'turn'],
     ['s', 's'],
     ['ms', 'ms'],
     ['hz', 'Hz'],
     ['khz', 'kHz'],
     ['dpi', 'dpi'],
     ['dpcm', 'dpcm'],
     ['dppx', 'dppx'],
     ['x', 'x'],
     ['cqw', 'cqw'],
     ['cqh', 'cqh'],
     ['cqi', 'cqi'],
     ['cqb', 'cqb'],
     ['cqmin', 'cqmin'],
     ['cqmax', 'cqmax'],
     ['fr', 'fr'],
    ]);
   function hs(e) {
    let t = e.toLowerCase();
    return cs.has(t) ? cs.get(t) : e;
   }
   var ds = /(["'])(?:(?!\1)[^\\]|\\.)*\1/gsu,
    fs = new RegExp(ds.source + `|(${/[$@]?[_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/giu.source})?(${/(?:\d*\.\d+|\d+\.?)(?:e[+-]?\d+)?/giu.source})(${/[a-z]+/giu.source})?`, 'giu');
   function ms(e, t) {
    return Ke(!1, e, ds, (e) => Rt(e, t));
   }
   function ys(e, t) {
    let r = t.singleQuote ? "'" : '"';
    return e.includes('"') || e.includes("'") ? e : r + e + r;
   }
   function Ds(e) {
    return Ke(!1, e, fs, (e, t, r, s, n) => (!r && s ? gs(s) + wr(n || '') : e));
   }
   function gs(e) {
    return ps(e).replace(/\.0(?=$|e)/u, '');
   }
   var xs = function (e, t, r) {
    let s = !(null == r || !r.backwards);
    if (!1 === t) return !1;
    let n = e.charAt(t);
    if (s) {
     if ('\r' === e.charAt(t - 1) && '\n' === n) return t - 2;
     if ('\n' === n || '\r' === n || '\u2028' === n || '\u2029' === n) return t - 1;
    } else {
     if ('\r' === n && '\n' === e.charAt(t + 1)) return t + 2;
     if ('\n' === n || '\r' === n || '\u2028' === n || '\u2029' === n) return t + 1;
    }
    return t;
   };
   var Es = function (e, t, r = {}) {
    let s = Zt(e, r.backwards ? t - 1 : t, r);
    return s !== xs(e, s, r);
   };
   var bs = function (e, t) {
    if (!1 === t) return !1;
    if ('/' === e.charAt(t) && '*' === e.charAt(t + 1)) for (let r = t + 2; r < e.length; ++r) if ('*' === e.charAt(r) && '/' === e.charAt(r + 1)) return r + 2;
    return t;
   };
   var Ts = function (e, t) {
    return !1 !== t && ('/' === e.charAt(t) && '/' === e.charAt(t + 1) ? tr(e, t) : t);
   };
   var As = function (e, t) {
    let r = null,
     s = t;
    for (; s !== r; ) (r = s), (s = er(e, s)), (s = bs(e, s)), (s = Zt(e, s));
    return (s = Ts(e, s)), (s = xs(e, s)), !1 !== s && Es(e, s);
   };
   function Cs(e, t) {
    return (function (e) {
     return 'value-func' === e.type && 'var' === e.value.toLowerCase();
    })(e.grandparent) &&
     (function ({ node: e, parent: t }, r) {
      return !(!e.source || !r.originalText.slice(or(e), or(t.close)).trimEnd().endsWith(','));
     })(e, t)
     ? ','
     : 'value-comment' === e.node.type ||
         ('value-comma_group' === e.node.type && e.node.groups.every((e) => 'value-comment' === e.type)) ||
         !(function (e) {
          return 'es5' === e.trailingComma || 'all' === e.trailingComma;
         })(t) ||
         !e.callParent(() => Yr(e, t))
       ? ''
       : Ft(',');
   }
   function vs(e, t, r) {
    let { node: s, parent: n } = e,
     i = e.map(({ node: e }) => ('string' == typeof e ? e : r()), 'groups');
    if (
     n &&
     (function (e) {
      return 'value-func' === e.type && 'url' === e.value.toLowerCase();
     })(n) &&
     (1 === s.groups.length || (s.groups.length > 0 && 'value-comma_group' === s.groups[0].type && s.groups[0].groups.length > 0 && 'value-word' === s.groups[0].groups[0].type && s.groups[0].groups[0].value.startsWith('data:')))
    )
     return [s.open ? r('open') : '', Nt(',', i), s.close ? r('close') : ''];
    if (!s.open) {
     let t = Fs(e);
     xt(i);
     let r = (function (e, t) {
       let r = [];
       for (let s = 0; s < e.length; s += t) r.push(e.slice(s, s + t));
       return r;
      })(Nt(',', i), 2),
      s = Nt(t ? It : Pt, r);
     return bt(t ? [It, s] : At([ws(e) ? kt : '', vt(s)]));
    }
    let a = e.map(({ node: r, isLast: s, index: n }) => {
      var a;
      let o = i[n];
      Xr(r) && 'value-comma_group' === r.type && r.groups && 'value-paren_group' !== r.groups[0].type && 'value-paren_group' === (null == (a = r.groups[2]) ? void 0 : a.type) && ht(o) === tt && ht(o.contents) === Qe && ht(o.contents.contents) === rt && (o = At(Ct(o)));
      let u = [o, s ? Cs(e, t) : ','];
      if (!s && 'value-comma_group' === r.type && Bt(r.groups)) {
       let e = ct(!1, r.groups, -1);
       !e.source && e.close && (e = e.close), e.source && As(t.originalText, ur(e)) && u.push(It);
      }
      return u;
     }, 'groups'),
     o = (function (e, t) {
      if (!Xr(t)) return !1;
      let { groups: r } = t,
       s = r.indexOf(e);
      return -1 !== s && ss(r[s + 1]);
     })(s, n),
     u = (function (e, t) {
      var r, s;
      if ('(' !== (null == (r = e.open) ? void 0 : r.value) || ')' !== (null == (s = e.close) ? void 0 : s.value) || e.groups.some((e) => 'value-comma_group' !== e.type)) return !1;
      if ('value-comma_group' === t.type) {
       let r = t.groups.indexOf(e) - 1,
        s = t.groups[r];
       if ('value-word' === (null == s ? void 0 : s.type) && 'with' === s.value) return !0;
      }
      return !1;
     })(s, n),
     l = Yr(e, t),
     p = u || (l && !o),
     c = u || o,
     h = At([s.open ? r('open') : '', bt([kt, Nt(Pt, a)]), kt, s.close ? r('close') : ''], { shouldBreak: p });
    return c ? Ct(h) : h;
   }
   function Fs(e) {
    return e.match(
     (e) => 'value-paren_group' === e.type && !e.open && e.groups.some((e) => 'value-comma_group' === e.type),
     (e, t) => 'group' === t && 'value-value' === e.type,
     (e, t) => 'group' === t && 'value-root' === e.type,
     (e, t) => 'value' === t && (('css-decl' === e.type && !e.prop.startsWith('--')) || ('css-atrule' === e.type && e.variable)),
    );
   }
   function ws(e) {
    return e.match(
     (e) => 'value-paren_group' === e.type && !e.open,
     (e, t) => 'group' === t && 'value-value' === e.type,
     (e, t) => 'group' === t && 'value-root' === e.type,
     (e, t) => 'value' === t && 'css-decl' === e.type,
    );
   }
   var Ss = function (e, t, r) {
    let s = [];
    return (
     e.each(() => {
      let { node: n, previous: i } = e;
      if (('css-comment' === (null == i ? void 0 : i.type) && 'prettier-ignore' === i.text.trim() ? s.push(t.originalText.slice(or(n), ur(n))) : s.push(r()), e.isLast)) return;
      let { next: a } = e;
      ('css-comment' === a.type && !Es(t.originalText, or(a), { backwards: !0 }) && !$t(n)) || ('css-atrule' === a.type && 'else' === a.name && 'css-comment' !== n.type) ? s.push(' ') : (s.push(t.__isHTMLStyleAttribute ? Pt : It), As(t.originalText, ur(n)) && !$t(n) && s.push(It));
     }, 'nodes'),
     s
    );
   };
   var Ps = {
     print: function (e, t, r) {
      var s, n, i, a, o, u;
      let { node: l } = e;
      switch (l.type) {
       case 'front-matter':
        return [l.raw, It];
       case 'css-root': {
        let s = Ss(e, t, r),
         n = l.raws.after.trim();
        return n.startsWith(';') && (n = n.slice(1).trim()), [l.frontMatter ? [r('frontMatter'), It] : '', s, n ? ` ${n}` : '', l.nodes.length > 0 ? It : ''];
       }
       case 'css-comment': {
        let e = l.inline || l.raws.inline,
         r = t.originalText.slice(or(l), ur(l));
        return e ? r.trimEnd() : r;
       }
       case 'css-rule':
        return [r('selector'), l.important ? ' !important' : '', l.nodes ? ['selector-unknown' === (null == (s = l.selector) ? void 0 : s.type) && as(l.selector.value) ? Pt : l.selector ? ' ' : '', '{', l.nodes.length > 0 ? bt([It, Ss(e, t, r)]) : '', It, '}', Ir(l) ? ';' : ''] : ';'];
       case 'css-decl': {
        let s = e.parent,
         { between: a } = l.raws,
         o = a.trim(),
         u = ':' === o,
         p = 'string' == typeof l.value && /^ *$/u.test(l.value),
         c = 'string' == typeof l.value ? l.value : r('value');
        return (
         (c = (function (e) {
          var t, r;
          return 'value-root' === (null == (t = e.value) ? void 0 : t.type) && 'value-value' === (null == (r = e.value.group) ? void 0 : r.type) && 'composes' === e.prop.toLowerCase();
         })(l)
          ? (function (e) {
             return mt(e, yt);
            })(c)
          : c),
         !u && as(o) && !(null != (i = null == (n = l.value) ? void 0 : n.group) && i.group && e.call(() => Fs(e), 'value', 'group', 'group')) && (c = bt([It, Ct(c)])),
         [Ke(!1, l.raws.before, /[\s;]/gu, ''), ('css-atrule' === s.type && s.variable) || Pr(e) ? l.prop : wr(l.prop), o.startsWith('//') ? ' ' : '', o, l.extend || p ? '' : ' ', 'less' === t.parser && l.extend && l.selector ? ['extend(', r('selector'), ')'] : '', c, l.raws.important ? l.raws.important.replace(/\s*!\s*important/iu, ' !important') : l.important ? ' !important' : '', l.raws.scssDefault ? l.raws.scssDefault.replace(/\s*!default/iu, ' !default') : l.scssDefault ? ' !default' : '', l.raws.scssGlobal ? l.raws.scssGlobal.replace(/\s*!global/iu, ' !global') : l.scssGlobal ? ' !global' : '', l.nodes ? [' {', bt([kt, Ss(e, t, r)]), kt, '}'] : zr(l) && !s.raws.semicolon && ';' !== t.originalText[ur(l) - 1] ? '' : t.__isHTMLStyleAttribute && e.isLast ? Ft(';') : ';']
        );
       }
       case 'css-atrule': {
        let s = e.parent,
         n = Wr(l) && !s.raws.semicolon && ';' !== t.originalText[ur(l) - 1];
        if ('less' === t.parser) {
         if (l.mixin) return [r('selector'), l.important ? ' !important' : '', n ? '' : ';'];
         if (l.function) return [l.name, 'string' == typeof l.params ? l.params : r('params'), n ? '' : ';'];
         if (l.variable) return ['@', l.name, ': ', l.value ? r('value') : '', l.raws.between.trim() ? l.raws.between.trim() + ' ' : '', l.nodes ? ['{', bt([l.nodes.length > 0 ? kt : '', Ss(e, t, r)]), kt, '}'] : '', n ? '' : ';'];
        }
        let i = 'import' === l.name && 'value-unknown' === (null == (a = l.params) ? void 0 : a.type) && l.params.value.endsWith(';');
        return ['@', Jr(l) || l.name.endsWith(':') || Wr(l) ? l.name : wr(l.name), l.params ? [Jr(l) ? '' : Wr(l) ? ('' === l.raws.afterName ? '' : l.name.endsWith(':') ? ' ' : /^\s*\n\s*\n/u.test(l.raws.afterName) ? [It, It] : /^\s*\n/u.test(l.raws.afterName) ? It : ' ') : ' ', 'string' == typeof l.params ? l.params : r('params')] : '', l.selector ? bt([' ', r('selector')]) : '', l.value ? At([' ', r('value'), qr(l, t) ? (Hr(l) ? ' ' : Pt) : '']) : 'else' === l.name ? ' ' : '', l.nodes ? [qr(l, t) ? '' : (l.selector && !l.selector.nodes && 'string' == typeof l.selector.value && as(l.selector.value)) || (!l.selector && 'string' == typeof l.params && as(l.params)) ? Pt : ' ', '{', bt([l.nodes.length > 0 ? kt : '', Ss(e, t, r)]), kt, '}'] : n || i ? '' : ';'];
       }
       case 'media-query-list': {
        let t = [];
        return (
         e.each(({ node: e }) => {
          ('media-query' === e.type && '' === e.value) || t.push(r());
         }, 'nodes'),
         At(bt(Nt(Pt, t)))
        );
       }
       case 'media-query':
        return [Nt(' ', e.map(r, 'nodes')), e.isLast ? '' : ','];
       case 'media-type':
       case 'media-value':
        return Ds(ms(l.value, t));
       case 'media-feature-expression':
        return l.nodes ? ['(', ...e.map(r, 'nodes'), ')'] : l.value;
       case 'media-feature':
        return wr(ms(Ke(!1, l.value, / +/gu, ' '), t));
       case 'media-colon':
        return [l.value, ' '];
       case 'media-keyword':
       case 'selector-string':
        return ms(l.value, t);
       case 'media-url':
        return ms(Ke(!1, Ke(!1, l.value, /^url\(\s+/giu, 'url('), /\s+\)$/gu, ')'), t);
       case 'media-unknown':
       case 'selector-comment':
       case 'selector-nesting':
       case 'value-paren':
       case 'value-operator':
       case 'value-unicode-range':
       case 'value-unknown':
        return l.value;
       case 'selector-root':
        return At([kr(e, 'custom-selector') ? [e.findAncestor((e) => 'css-atrule' === e.type).customSelector, Pt] : '', Nt([',', kr(e, ['extend', 'custom-selector', 'nest']) ? Pt : It], e.map(r, 'nodes'))]);
       case 'selector-selector':
        return At((l.nodes.length > 1 ? bt : (e) => e)(e.map(r, 'nodes')));
       case 'selector-tag':
        return [l.namespace ? [!0 === l.namespace ? '' : l.namespace.trim(), '|'] : '', 'selector-nesting' === (null == (o = e.previous) ? void 0 : o.type) ? l.value : Ds(Fr(e, l.value) ? l.value.toLowerCase() : l.value)];
       case 'selector-id':
        return ['#', l.value];
       case 'selector-class':
        return ['.', Ds(ms(l.value, t))];
       case 'selector-attribute':
        return ['[', l.namespace ? [!0 === l.namespace ? '' : l.namespace.trim(), '|'] : '', l.attribute.trim(), l.operator ?? '', l.value ? ys(ms(l.value.trim(), t), t) : '', l.insensitive ? ' i' : '', ']'];
       case 'selector-combinator':
        if ('+' === l.value || '>' === l.value || '~' === l.value || '>>>' === l.value) {
         let t = e.parent;
         return ['selector-selector' === t.type && t.nodes[0] === l ? '' : Pt, l.value, e.isLast ? '' : ' '];
        }
        return [l.value.trim().startsWith('(') ? Pt : '', Ds(ms(l.value.trim(), t)) || Pt];
       case 'selector-universal':
        return [l.namespace ? [!0 === l.namespace ? '' : l.namespace.trim(), '|'] : '', l.value];
       case 'selector-pseudo':
        return [wr(l.value), Bt(l.nodes) ? At(['(', bt([kt, Nt([',', Pt], e.map(r, 'nodes'))]), kt, ')']) : ''];
       case 'selector-unknown': {
        let r = e.findAncestor((e) => 'css-rule' === e.type);
        if (null != r && r.isSCSSNesterProperty) return Ds(ms(wr(l.value), t));
        let s = e.parent;
        if (null != (u = s.raws) && u.selector) {
         let e = or(s),
          r = e + s.raws.selector.length;
         return t.originalText.slice(e, r).trim();
        }
        let n = e.grandparent;
        if ('value-paren_group' === s.type && 'value-func' === (null == n ? void 0 : n.type) && 'selector' === n.value) {
         let e = ur(s.open) + 1,
          r = or(s.close),
          n = t.originalText.slice(e, r).trim();
         return as(n) ? [St, n] : n;
        }
        return l.value;
       }
       case 'value-value':
       case 'value-root':
        return r('group');
       case 'value-comment':
        return t.originalText.slice(or(l), ur(l));
       case 'value-comma_group':
        return ls(e, t, r);
       case 'value-paren_group':
        return vs(e, t, r);
       case 'value-func':
        return [l.value, kr(e, 'supports') && ns(l) ? ' ' : '', r('group')];
       case 'value-number':
        return [gs(l.value), hs(l.unit)];
       case 'value-word':
        return (l.isColor && l.isHex) ||
         (function (e) {
          return vr.has(e.toLowerCase());
         })(l.value)
         ? l.value.toLowerCase()
         : l.value;
       case 'value-colon': {
        let { previous: t } = e;
        return At([l.value, ('string' == typeof (null == t ? void 0 : t.value) && t.value.endsWith('\\')) || Sr(e, 'url') ? '' : Pt]);
       }
       case 'value-string':
        return Rt(l.raws.quote + l.value + l.raws.quote, t);
       case 'value-atword':
        return ['@', l.value];
       default:
        throw new Ut(l, 'PostCSS');
      }
     },
     embed: Ht,
     insertPragma: function (e) {
      let { frontMatter: t, content: r } = Ar(e);
      return (t ? t.raw + '\n\n' : '') + br(r);
     },
     massageAstNode: Wt,
     getVisitorKeys: Gt,
    },
    ks = [
     { linguistLanguageId: 50, name: 'CSS', type: 'markup', tmScope: 'source.css', aceMode: 'css', codemirrorMode: 'css', codemirrorMimeType: 'text/css', color: '#563d7c', extensions: ['.css', '.wxss'], parsers: ['css'], vscodeLanguageIds: ['css'] },
     { linguistLanguageId: 262764437, name: 'PostCSS', type: 'markup', color: '#dc3a0c', tmScope: 'source.postcss', group: 'CSS', extensions: ['.pcss', '.postcss'], aceMode: 'text', parsers: ['css'], vscodeLanguageIds: ['postcss'] },
     { linguistLanguageId: 198, name: 'Less', type: 'markup', color: '#1d365d', aliases: ['less-css'], extensions: ['.less'], tmScope: 'source.css.less', aceMode: 'less', codemirrorMode: 'css', codemirrorMimeType: 'text/css', parsers: ['less'], vscodeLanguageIds: ['less'] },
     { linguistLanguageId: 329, name: 'SCSS', type: 'markup', color: '#c6538c', tmScope: 'source.css.scss', aceMode: 'scss', codemirrorMode: 'css', codemirrorMimeType: 'text/x-scss', extensions: ['.scss'], parsers: ['scss'], vscodeLanguageIds: ['scss'] },
    ],
    Is = { singleQuote: { category: 'Common', type: 'boolean', default: !1, description: 'Use single quotes instead of double quotes.' } },
    Ns = {};
   p(Ns, { css: () => hn, less: () => dn, scss: () => fn });
   var Bs = c(N(), 1),
    Os = c(U(), 1),
    Ls = c(ee(), 1);
   var Ms = function (e, t) {
    let r = new SyntaxError(e + ' (' + t.loc.start.line + ':' + t.loc.start.column + ')');
    return Object.assign(r, t);
   };
   function js(e, t, r) {
    if (e && 'object' == typeof e) {
     delete e.parent;
     for (let s in e) js(e[s], t, r), 'type' === s && 'string' == typeof e[s] && !e[s].startsWith(t) && (!r || !r.test(e[s])) && (e[s] = t + e[s]);
    }
    return e;
   }
   function _s(e) {
    if (e && 'object' == typeof e) {
     delete e.parent;
     for (let t in e) _s(e[t]);
     !Array.isArray(e) && e.value && !e.type && (e.type = 'unknown');
    }
    return e;
   }
   var Rs = c(ne(), 1).default.default;
   var Us = function (e) {
     let t;
     try {
      t = Rs(e);
     } catch {
      return { type: 'selector-unknown', value: e };
     }
     return js(_s(t), 'media-');
    },
    $s = c(we(), 1);
   var qs = function (e) {
     if (/\/\/|\/\*/u.test(e)) return { type: 'selector-unknown', value: e.trim() };
     let t;
     try {
      new $s.default((e) => {
       t = e;
      }).process(e);
     } catch {
      return { type: 'selector-unknown', value: e };
     }
     return js(t, 'selector-');
    },
    Js = c(Ve(), 1),
    Ws = (e) => {
     for (; e.parent; ) e = e.parent;
     return e;
    };
   var zs = function (e) {
    return Ws(e)
     .text.slice(e.group.open.sourceIndex + 1, e.group.close.sourceIndex)
     .trim();
   };
   var Vs = function (e) {
    if (Bt(e)) for (let t = e.length - 1; t > 0; t--) if ('word' === e[t].type && '{' === e[t].value && 'word' === e[t - 1].type && e[t - 1].value.endsWith('#')) return !0;
    return !1;
   };
   var Hs = function (e) {
    return e.some((e) => 'string' === e.type || ('func' === e.type && !e.value.endsWith('\\')));
   };
   var Ks = function (e, t) {
     return !('scss' !== t.parser || 'word' !== (null == e ? void 0 : e.type) || !e.value.startsWith('$'));
    },
    Xs = (e) => 'paren' === e.type && ')' === e.value;
   function Gs(e, t) {
    var r;
    let { nodes: s } = e,
     n = { open: null, close: null, groups: [], type: 'paren_group' },
     i = [n],
     a = n,
     o = { groups: [], type: 'comma_group' },
     u = [o];
    for (let l = 0; l < s.length; ++l) {
     let a = s[l];
     if (('scss' === t.parser && 'number' === a.type && '..' === a.unit && a.value.endsWith('.') && ((a.value = a.value.slice(0, -1)), (a.unit = '...')), 'func' === a.type && 'selector' === a.value && (a.group.groups = [qs(Ws(e).text.slice(a.group.open.sourceIndex + 1, a.group.close.sourceIndex))]), 'func' === a.type && 'url' === a.value)) {
      let e = (null == (r = a.group) ? void 0 : r.groups) ?? [],
       s = [];
      for (let t = 0; t < e.length; t++) {
       let r = e[t];
       'comma_group' === r.type ? (s = [...s, ...r.groups]) : s.push(r);
      }
      (Vs(s) || (!Hs(s) && !Ks(s[0], t))) && (a.group.groups = [zs(a)]);
     }
     if ('paren' === a.type && '(' === a.value) (n = { open: a, close: null, groups: [], type: 'paren_group' }), i.push(n), (o = { groups: [], type: 'comma_group' }), u.push(o);
     else if (Xs(a)) {
      if ((o.groups.length > 0 && n.groups.push(o), (n.close = a), 1 === u.length)) throw new Error('Unbalanced parenthesis');
      u.pop(), (o = ct(!1, u, -1)), o.groups.push(n), i.pop(), (n = ct(!1, i, -1));
     } else if ('comma' === a.type) {
      if (l === s.length - 3 && 'comment' === s[l + 1].type && Xs(s[l + 2])) continue;
      n.groups.push(o), (o = { groups: [], type: 'comma_group' }), (u[u.length - 1] = o);
     } else o.groups.push(a);
    }
    return o.groups.length > 0 && n.groups.push(o), a;
   }
   function Ys(e) {
    return ('paren_group' === e.type && !e.open && !e.close && 1 === e.groups.length) || ('comma_group' === e.type && 1 === e.groups.length) ? Ys(e.groups[0]) : 'paren_group' === e.type || 'comma_group' === e.type ? { ...e, groups: e.groups.map(Ys) } : e;
   }
   function Qs(e, t) {
    if (e && 'object' == typeof e) for (let r in e) 'parent' !== r && (Qs(e[r], t), 'nodes' === r && ((e.group = Ys(Gs(e, t))), delete e[r]));
    return e;
   }
   var Zs = function (e, t) {
     if ('less' === t.parser && e.startsWith('~`')) return { type: 'value-unknown', value: e };
     let r = null;
     try {
      r = new Js.default(e, { loose: !0 }).parse();
     } catch {
      return { type: 'value-unknown', value: e };
     }
     return (r.text = e), js(Qs(r, t), 'value-', /^selector-/u);
    },
    en = new Set(['import', 'use', 'forward']);
   var tn = function (e) {
    return en.has(e);
   };
   var rn = function (e, t) {
     return (
      !('scss' !== t.parser || !e.selector) &&
      e.selector
       .replace(/\/\*.*?\*\//u, '')
       .replace(/\/\/.*\n/u, '')
       .trim()
       .endsWith(':')
     );
    },
    sn = /(\s*)(!default).*$/u,
    nn = /(\s*)(!global).*$/u;
   function an(e, t) {
    var r, s;
    if (e && 'object' == typeof e) {
     delete e.parent;
     for (let r in e) an(e[r], t);
     if (!e.type) return e;
     if ((e.raws ?? (e.raws = {}), 'css-decl' === e.type && 'string' == typeof e.prop && e.prop.startsWith('--') && 'string' == typeof e.value && e.value.startsWith('{'))) {
      let s;
      if (e.value.trimEnd().endsWith('}')) {
       let n,
        i,
        a = t.originalText.slice(0, e.source.start.offset),
        o = 'a'.repeat(e.prop.length) + t.originalText.slice(e.source.start.offset + e.prop.length, e.source.end.offset),
        u = Ke(!1, a, /[^\n]/gu, ' ') + o;
       n = 'scss' === t.parser ? pn : 'less' === t.parser ? ln : un;
       try {
        i = n(u, { ...t });
       } catch {}
       1 === (null == (r = null == i ? void 0 : i.nodes) ? void 0 : r.length) && 'css-rule' === i.nodes[0].type && (s = i.nodes[0].nodes);
      }
      return (e.value = s ? { type: 'css-rule', nodes: s } : { type: 'value-unknown', value: e.raws.value.raw }), e;
     }
     let n = '';
     'string' == typeof e.selector && ((n = e.raws.selector ? (e.raws.selector.scss ?? e.raws.selector.raw) : e.selector), e.raws.between && e.raws.between.trim().length > 0 && (n += e.raws.between), (e.raws.selector = n));
     let i = '';
     'string' == typeof e.value && ((i = e.raws.value ? (e.raws.value.scss ?? e.raws.value.raw) : e.value), (e.raws.value = i.trim()));
     let a = '';
     if (('string' == typeof e.params && ((a = e.raws.params ? (e.raws.params.scss ?? e.raws.params.raw) : e.params), e.raws.afterName && e.raws.afterName.trim().length > 0 && (a = e.raws.afterName + a), e.raws.between && e.raws.between.trim().length > 0 && (a += e.raws.between), (a = a.trim()), (e.raws.params = a)), n.trim().length > 0)) return n.startsWith('@') && n.endsWith(':') ? e : e.mixin ? ((e.selector = Zs(n, t)), e) : (rn(e, t) && (e.isSCSSNesterProperty = !0), (e.selector = qs(n)), e);
     if (i.trim().length > 0) {
      let r = i.match(sn);
      r && ((i = i.slice(0, r.index)), (e.scssDefault = !0), '!default' !== r[0].trim() && (e.raws.scssDefault = r[0]));
      let s = i.match(nn);
      if ((s && ((i = i.slice(0, s.index)), (e.scssGlobal = !0), '!global' !== s[0].trim() && (e.raws.scssGlobal = s[0])), i.startsWith('progid:'))) return { type: 'value-unknown', value: i };
      e.value = Zs(i, t);
     }
     if (('less' === t.parser && 'css-decl' === e.type && i.startsWith('extend(') && (e.extend || (e.extend = ':' === e.raws.between), e.extend && !e.selector && (delete e.value, (e.selector = qs(i.slice(7, -1))))), 'css-atrule' === e.type)) {
      if ('less' === t.parser) {
       if (e.mixin) {
        let t = e.raws.identifier + e.name + e.raws.afterName + e.raws.params;
        return (e.selector = qs(t)), delete e.params, e;
       }
       if (e.function) return e;
      }
      if ('css' === t.parser && 'custom-selector' === e.name) {
       let t = e.params.match(/:--\S+\s+/u)[0].trim();
       return (e.customSelector = t), (e.selector = qs(e.params.slice(t.length).trim())), delete e.params, e;
      }
      if ('less' === t.parser) {
       if (e.name.includes(':') && !e.params) {
        e.variable = !0;
        let r = e.name.split(':');
        (e.name = r[0]), (e.value = Zs(r.slice(1).join(':'), t));
       }
       if (!['page', 'nest', 'keyframes'].includes(e.name) && ':' === (null == (s = e.params) ? void 0 : s[0])) {
        e.variable = !0;
        let r = e.params.slice(1);
        r && (e.value = Zs(r, t)), (e.raws.afterName += ':');
       }
       if (e.variable) return delete e.params, e.value || delete e.value, e;
      }
     }
     if ('css-atrule' === e.type && a.length > 0) {
      let { name: r } = e,
       s = e.name.toLowerCase();
      return 'warn' === r || 'error' === r ? ((e.params = { type: 'media-unknown', value: a }), e) : 'extend' === r || 'nest' === r ? ((e.selector = qs(a)), delete e.params, e) : 'at-root' === r ? (/^\(\s*(?:without|with)\s*:.+\)$/su.test(a) ? (e.params = Zs(a, t)) : ((e.selector = qs(a)), delete e.params), e) : tn(s) ? ((e.import = !0), delete e.filename, (e.params = Zs(a, t)), e) : ['namespace', 'supports', 'if', 'else', 'for', 'each', 'while', 'debug', 'mixin', 'include', 'function', 'return', 'define-mixin', 'add-mixin'].includes(r) ? ((a = a.replace(/(\$\S+?)(\s+)?\.{3}/u, '$1...$2')), (a = a.replace(/^(?!if)(\S+)(\s+)\(/u, '$1($2')), (e.value = Zs(a, t)), delete e.params, e) : ['media', 'custom-media'].includes(s) ? (a.includes('#{') ? { type: 'media-unknown', value: a } : ((e.params = Us(a)), e)) : ((e.params = a), e);
     }
    }
    return e;
   }
   function on(e, t, r) {
    let s,
     n = Ar(t),
     { frontMatter: i } = n;
    t = n.content;
    try {
     s = e(t, { map: !1 });
    } catch (a) {
     let { name: e, reason: t, line: r, column: s } = a;
     throw 'number' != typeof r ? a : Ms(`${e}: ${t}`, { loc: { start: { line: r, column: s } }, cause: a });
    }
    return (r.originalText = t), (s = an(js(s, 'css-'), r)), nr(s, t), i && ((i.source = { startOffset: 0, endOffset: i.raw.length }), (s.frontMatter = i)), s;
   }
   function un(e, t = {}) {
    return on(Bs.default.default, e, t);
   }
   function ln(e, t = {}) {
    return on(
     (e) =>
      Os.default.parse(
       (function (e) {
        let t,
         r = 'initial',
         s = 'initial',
         n = !1,
         i = [];
        for (let a = 0; a < e.length; a++) {
         let o = e[a];
         switch (r) {
          case 'initial':
           if ("'" === o) {
            r = 'single-quotes';
            continue;
           }
           if ('"' === o) {
            r = 'double-quotes';
            continue;
           }
           if (('u' === o || 'U' === o) && 'url(' === e.slice(a, a + 4).toLowerCase()) {
            (r = 'url'), (a += 3);
            continue;
           }
           if ('*' === o && '/' === e[a - 1]) {
            r = 'comment-block';
            continue;
           }
           if ('/' === o && '/' === e[a - 1]) {
            (r = 'comment-inline'), (t = a - 1);
            continue;
           }
           continue;
          case 'single-quotes':
           if (("'" === o && '\\' !== e[a - 1] && ((r = s), (s = 'initial')), '\n' === o || '\r' === o)) return e;
           continue;
          case 'double-quotes':
           if (('"' === o && '\\' !== e[a - 1] && ((r = s), (s = 'initial')), '\n' === o || '\r' === o)) return e;
           continue;
          case 'url':
           if ((')' === o && (r = 'initial'), '\n' === o || '\r' === o)) return e;
           if ("'" === o) {
            (r = 'single-quotes'), (s = 'url');
            continue;
           }
           if ('"' === o) {
            (r = 'double-quotes'), (s = 'url');
            continue;
           }
           continue;
          case 'comment-block':
           '/' === o && '*' === e[a - 1] && (r = 'initial');
           continue;
          case 'comment-inline':
           ('"' === o || "'" === o || '*' === o) && (n = !0), ('\n' === o || '\r' === o) && (n && i.push([t, a]), (r = 'initial'), (n = !1));
           continue;
         }
        }
        for (let [a, o] of i) e = e.slice(0, a) + Ke(!1, e.slice(a, o), /["'*]/gu, ' ') + e.slice(o);
        return e;
       })(e),
      ),
     e,
     t,
    );
   }
   function pn(e, t = {}) {
    return on(Ls.default, e, t);
   }
   var cn = {
     astFormat: 'postcss',
     hasPragma: function (e) {
      return (function (e) {
       let { pragmas: t } = Er(e);
       return Object.prototype.hasOwnProperty.call(t, 'prettier') || Object.prototype.hasOwnProperty.call(t, 'format');
      })(Ar(e).content);
     },
     locStart: or,
     locEnd: ur,
    },
    hn = { ...cn, parse: un },
    dn = { ...cn, parse: ln },
    fn = { ...cn, parse: pn },
    mn = { postcss: Ps },
    yn = He;
  },
  75119: (e, t, r) => {
   r.d(t, { ZP: () => Bs });
   var s = Object.create,
    n = Object.defineProperty,
    i = Object.getOwnPropertyDescriptor,
    a = Object.getOwnPropertyNames,
    o = Object.getPrototypeOf,
    u = Object.prototype.hasOwnProperty,
    l = (e) => {
     throw TypeError(e);
    },
    p = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports),
    c = (e, t) => {
     for (var r in t) n(e, r, { get: t[r], enumerable: !0 });
    },
    h = (e, t, r) => (
     (r = null != e ? s(o(e)) : {}),
     ((e, t, r, s) => {
      if ((t && 'object' == typeof t) || 'function' == typeof t) for (let o of a(t)) !u.call(e, o) && o !== r && n(e, o, { get: () => t[o], enumerable: !(s = i(t, o)) || s.enumerable });
      return e;
     })(!t && e && e.__esModule ? r : n(r, 'default', { value: e, enumerable: !0 }), e)
    ),
    d = (e, t, r) => (
     ((e, t, r) => {
      t.has(e) || l('Cannot ' + r);
     })(e, t, 'access private method'),
     r
    ),
    f = p((e, t) => {
     var r = new Proxy(String, { get: () => r });
     t.exports = r;
    }),
    m = p((e) => {
     Object.defineProperty(e, '__esModule', { value: !0 });
     var t = /\r\n|[\n\r\u2028\u2029]/;
     e.codeFrameColumns = function (e, r, s = {}) {
      let n = new Proxy({}, { get: () => (e) => e }),
       i = e.split(t),
       {
        start: a,
        end: o,
        markerLines: u,
       } = (function (e, t, r) {
        let s = Object.assign({ column: 0, line: -1 }, e.start),
         n = Object.assign({}, s, e.end),
         { linesAbove: i = 2, linesBelow: a = 3 } = r || {},
         o = s.line,
         u = s.column,
         l = n.line,
         p = n.column,
         c = Math.max(o - (i + 1), 0),
         h = Math.min(t.length, l + a);
        -1 === o && (c = 0), -1 === l && (h = t.length);
        let d = l - o,
         f = {};
        if (d)
         for (let m = 0; m <= d; m++) {
          let e = m + o;
          if (u)
           if (0 === m) {
            let r = t[e - 1].length;
            f[e] = [u, r - u + 1];
           } else if (m === d) f[e] = [0, p];
           else {
            let r = t[e - m].length;
            f[e] = [0, r];
           }
          else f[e] = !0;
         }
        else f[o] = u === p ? !u || [u, 0] : [u, p - u];
        return { start: c, end: h, markerLines: f };
       })(r, i, s),
       l = r.start && 'number' == typeof r.start.column,
       p = String(o).length,
       c = e
        .split(t, o)
        .slice(a, o)
        .map((e, t) => {
         let r = a + 1 + t,
          i = ` ${` ${r}`.slice(-p)} |`,
          o = u[r],
          l = !u[r + 1];
         if (o) {
          let t = '';
          if (Array.isArray(o)) {
           let r = e.slice(0, Math.max(o[0] - 1, 0)).replace(/[^\t]/g, ' '),
            a = o[1] || 1;
           (t = ['\n ', n.gutter(i.replace(/\d/g, ' ')), ' ', r, n.marker('^').repeat(a)].join('')), l && s.message && (t += ' ' + n.message(s.message));
          }
          return [n.marker('>'), n.gutter(i), e.length > 0 ? ` ${e}` : '', t].join('');
         }
         return ` ${n.gutter(i)}${e.length > 0 ? ` ${e}` : ''}`;
        })
        .join('\n');
      return s.message && !l && (c = `${' '.repeat(p + 1)}${s.message}\n${c}`), c;
     };
    }),
    y = {};
   c(y, { __debug: () => Ns, check: () => ks, doc: () => as, format: () => Ps, formatWithCursor: () => Ss, getSupportInfo: () => Is, util: () => cs, version: () => ps });
   var D = (e, t, r, s) => {
    if (!e || null != t) return t.replaceAll ? t.replaceAll(r, s) : r.global ? t.replace(r, s) : t.split(r).join(s);
   };
   function g() {}
   function x(e, t, r, s, n) {
    for (var i, a = []; t; ) a.push(t), (i = t.previousComponent), delete t.previousComponent, (t = i);
    a.reverse();
    for (var o = 0, u = a.length, l = 0, p = 0; o < u; o++) {
     var c = a[o];
     if (c.removed) (c.value = e.join(s.slice(p, p + c.count))), (p += c.count);
     else {
      if (!c.added && n) {
       var h = r.slice(l, l + c.count);
       (h = h.map(function (e, t) {
        var r = s[p + t];
        return r.length > e.length ? r : e;
       })),
        (c.value = e.join(h));
      } else c.value = e.join(r.slice(l, l + c.count));
      (l += c.count), c.added || (p += c.count);
     }
    }
    return a;
   }
   g.prototype = {
    diff: function (e, t) {
     var r,
      s = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
      n = s.callback;
     'function' == typeof s && ((n = s), (s = {}));
     var i = this;
     function a(e) {
      return (
       (e = i.postProcess(e, s)),
       n
        ? (setTimeout(function () {
           n(e);
          }, 0),
          !0)
        : e
      );
     }
     (e = this.castInput(e, s)), (t = this.castInput(t, s)), (e = this.removeEmpty(this.tokenize(e, s)));
     var o = (t = this.removeEmpty(this.tokenize(t, s))).length,
      u = e.length,
      l = 1,
      p = o + u;
     null != s.maxEditLength && (p = Math.min(p, s.maxEditLength));
     var c = null !== (r = s.timeout) && void 0 !== r ? r : 1 / 0,
      h = Date.now() + c,
      d = [{ oldPos: -1, lastComponent: void 0 }],
      f = this.extractCommon(d[0], t, e, 0, s);
     if (d[0].oldPos + 1 >= u && f + 1 >= o) return a(x(i, d[0].lastComponent, t, e, i.useLongestToken));
     var m = -1 / 0,
      y = 1 / 0;
     function D() {
      for (var r = Math.max(m, -l); r <= Math.min(y, l); r += 2) {
       var n = void 0,
        p = d[r - 1],
        c = d[r + 1];
       p && (d[r - 1] = void 0);
       var h = !1;
       if (c) {
        var D = c.oldPos - r;
        h = c && 0 <= D && D < o;
       }
       var g = p && p.oldPos + 1 < u;
       if (h || g) {
        if (((n = !g || (h && p.oldPos < c.oldPos) ? i.addToPath(c, !0, !1, 0, s) : i.addToPath(p, !1, !0, 1, s)), (f = i.extractCommon(n, t, e, r, s)), n.oldPos + 1 >= u && f + 1 >= o)) return a(x(i, n.lastComponent, t, e, i.useLongestToken));
        (d[r] = n), n.oldPos + 1 >= u && (y = Math.min(y, r - 1)), f + 1 >= o && (m = Math.max(m, r + 1));
       } else d[r] = void 0;
      }
      l++;
     }
     if (n)
      !(function e() {
       setTimeout(function () {
        if (l > p || Date.now() > h) return n();
        D() || e();
       }, 0);
      })();
     else
      for (; l <= p && Date.now() <= h; ) {
       var g = D();
       if (g) return g;
      }
    },
    addToPath: function (e, t, r, s, n) {
     var i = e.lastComponent;
     return i && !n.oneChangePerToken && i.added === t && i.removed === r ? { oldPos: e.oldPos + s, lastComponent: { count: i.count + 1, added: t, removed: r, previousComponent: i.previousComponent } } : { oldPos: e.oldPos + s, lastComponent: { count: 1, added: t, removed: r, previousComponent: i } };
    },
    extractCommon: function (e, t, r, s, n) {
     for (var i = t.length, a = r.length, o = e.oldPos, u = o - s, l = 0; u + 1 < i && o + 1 < a && this.equals(r[o + 1], t[u + 1], n); ) u++, o++, l++, n.oneChangePerToken && (e.lastComponent = { count: 1, previousComponent: e.lastComponent, added: !1, removed: !1 });
     return l && !n.oneChangePerToken && (e.lastComponent = { count: l, previousComponent: e.lastComponent, added: !1, removed: !1 }), (e.oldPos = o), u;
    },
    equals: function (e, t, r) {
     return r.comparator ? r.comparator(e, t) : e === t || (r.ignoreCase && e.toLowerCase() === t.toLowerCase());
    },
    removeEmpty: function (e) {
     for (var t = [], r = 0; r < e.length; r++) e[r] && t.push(e[r]);
     return t;
    },
    castInput: function (e) {
     return e;
    },
    tokenize: function (e) {
     return Array.from(e);
    },
    join: function (e) {
     return e.join('');
    },
    postProcess: function (e) {
     return e;
    },
   };
   new g();
   function E(e, t) {
    var r;
    for (r = 0; r < e.length && r < t.length; r++) if (e[r] != t[r]) return e.slice(0, r);
    return e.slice(0, r);
   }
   function b(e, t) {
    var r;
    if (!e || !t || e[e.length - 1] != t[t.length - 1]) return '';
    for (r = 0; r < e.length && r < t.length; r++) if (e[e.length - (r + 1)] != t[t.length - (r + 1)]) return e.slice(-r);
    return e.slice(-r);
   }
   function T(e, t, r) {
    if (e.slice(0, t.length) != t) throw Error('string '.concat(JSON.stringify(e), " doesn't start with prefix ").concat(JSON.stringify(t), '; this is a bug'));
    return r + e.slice(t.length);
   }
   function A(e, t, r) {
    if (!t) return e + r;
    if (e.slice(-t.length) != t) throw Error('string '.concat(JSON.stringify(e), " doesn't end with suffix ").concat(JSON.stringify(t), '; this is a bug'));
    return e.slice(0, -t.length) + r;
   }
   function C(e, t) {
    return T(e, t, '');
   }
   function v(e, t) {
    return A(e, t, '');
   }
   function F(e, t) {
    return t.slice(
     0,
     (function (e, t) {
      var r = 0;
      e.length > t.length && (r = e.length - t.length);
      var s = t.length;
      e.length < t.length && (s = e.length);
      var n = Array(s),
       i = 0;
      n[0] = 0;
      for (var a = 1; a < s; a++) {
       for (t[a] == t[i] ? (n[a] = n[i]) : (n[a] = i); i > 0 && t[a] != t[i]; ) i = n[i];
       t[a] == t[i] && i++;
      }
      i = 0;
      for (var o = r; o < e.length; o++) {
       for (; i > 0 && e[o] != t[i]; ) i = n[i];
       e[o] == t[i] && i++;
      }
      return i;
     })(e, t),
    );
   }
   var w = 'a-zA-Z0-9_\\u{C0}-\\u{FF}\\u{D8}-\\u{F6}\\u{F8}-\\u{2C6}\\u{2C8}-\\u{2D7}\\u{2DE}-\\u{2FF}\\u{1E00}-\\u{1EFF}',
    S = new RegExp('['.concat(w, ']+|\\s+|[^').concat(w, ']'), 'ug'),
    P = new g();
   function k(e, t, r, s) {
    if (t && r) {
     var n = t.value.match(/^\s*/)[0],
      i = t.value.match(/\s*$/)[0],
      a = r.value.match(/^\s*/)[0],
      o = r.value.match(/\s*$/)[0];
     if (e) {
      var u = E(n, a);
      (e.value = A(e.value, a, u)), (t.value = C(t.value, u)), (r.value = C(r.value, u));
     }
     if (s) {
      var l = b(i, o);
      (s.value = T(s.value, o, l)), (t.value = v(t.value, l)), (r.value = v(r.value, l));
     }
    } else if (r) e && (r.value = r.value.replace(/^\s*/, '')), s && (s.value = s.value.replace(/^\s*/, ''));
    else if (e && s) {
     var p = s.value.match(/^\s*/)[0],
      c = t.value.match(/^\s*/)[0],
      h = t.value.match(/\s*$/)[0],
      d = E(p, c);
     t.value = C(t.value, d);
     var f = b(C(p, d), h);
     (t.value = v(t.value, f)), (s.value = T(s.value, p, f)), (e.value = A(e.value, p, p.slice(0, p.length - f.length)));
    } else if (s) {
     var m = s.value.match(/^\s*/)[0],
      y = F(t.value.match(/\s*$/)[0], m);
     t.value = v(t.value, y);
    } else if (e) {
     var D = F(e.value.match(/\s*$/)[0], t.value.match(/^\s*/)[0]);
     t.value = C(t.value, D);
    }
   }
   (P.equals = function (e, t, r) {
    return r.ignoreCase && ((e = e.toLowerCase()), (t = t.toLowerCase())), e.trim() === t.trim();
   }),
    (P.tokenize = function (e) {
     var t,
      r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
     if (r.intlSegmenter) {
      if ('word' != r.intlSegmenter.resolvedOptions().granularity) throw new Error('The segmenter passed must have a granularity of "word"');
      t = Array.from(r.intlSegmenter.segment(e), function (e) {
       return e.segment;
      });
     } else t = e.match(S) || [];
     var s = [],
      n = null;
     return (
      t.forEach(function (e) {
       /\s/.test(e) ? (null == n ? s.push(e) : s.push(s.pop() + e)) : /\s/.test(n) ? (s[s.length - 1] == n ? s.push(s.pop() + e) : s.push(n + e)) : s.push(e), (n = e);
      }),
      s
     );
    }),
    (P.join = function (e) {
     return e
      .map(function (e, t) {
       return 0 == t ? e : e.replace(/^\s+/, '');
      })
      .join('');
    }),
    (P.postProcess = function (e, t) {
     if (!e || t.oneChangePerToken) return e;
     var r = null,
      s = null,
      n = null;
     return (
      e.forEach(function (e) {
       e.added ? (s = e) : e.removed ? (n = e) : ((s || n) && k(r, n, s, e), (r = e), (s = null), (n = null));
      }),
      (s || n) && k(r, n, s, null),
      e
     );
    }),
    (new g().tokenize = function (e) {
     var t = new RegExp('(\\r?\\n)|['.concat(w, ']+|[^\\S\\n\\r]+|[^').concat(w, ']'), 'ug');
     return e.match(t) || [];
    });
   var I = new g();
   function N(e) {
    return (N =
     'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
      ? function (e) {
         return typeof e;
        }
      : function (e) {
         return e && 'function' == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e;
        })(e);
   }
   (I.tokenize = function (e, t) {
    t.stripTrailingCr && (e = e.replace(/\r\n/g, '\n'));
    var r = [],
     s = e.split(/(\n|\r\n)/);
    s[s.length - 1] || s.pop();
    for (var n = 0; n < s.length; n++) {
     var i = s[n];
     n % 2 && !t.newlineIsToken ? (r[r.length - 1] += i) : r.push(i);
    }
    return r;
   }),
    (I.equals = function (e, t, r) {
     return r.ignoreWhitespace ? ((!r.newlineIsToken || !e.includes('\n')) && (e = e.trim()), (!r.newlineIsToken || !t.includes('\n')) && (t = t.trim())) : r.ignoreNewlineAtEof && !r.newlineIsToken && (e.endsWith('\n') && (e = e.slice(0, -1)), t.endsWith('\n') && (t = t.slice(0, -1))), g.prototype.equals.call(this, e, t, r);
    }),
    (new g().tokenize = function (e) {
     return e.split(/(\S.+?[.!?])(?=\s+|$)/);
    }),
    (new g().tokenize = function (e) {
     return e.split(/([{}:;,]|\s+)/);
    });
   var B = new g();
   function O(e, t, r, s, n) {
    var i, a;
    for (t = t || [], r = r || [], s && (e = s(n, e)), i = 0; i < t.length; i += 1) if (t[i] === e) return r[i];
    if ('[object Array]' === Object.prototype.toString.call(e)) {
     for (t.push(e), a = new Array(e.length), r.push(a), i = 0; i < e.length; i += 1) a[i] = O(e[i], t, r, s, n);
     return t.pop(), r.pop(), a;
    }
    if ((e && e.toJSON && (e = e.toJSON()), 'object' === N(e) && null !== e)) {
     t.push(e), (a = {}), r.push(a);
     var o,
      u = [];
     for (o in e) Object.prototype.hasOwnProperty.call(e, o) && u.push(o);
     for (u.sort(), i = 0; i < u.length; i += 1) a[(o = u[i])] = O(e[o], t, r, s, o);
     t.pop(), r.pop();
    } else a = e;
    return a;
   }
   (B.useLongestToken = !0),
    (B.tokenize = I.tokenize),
    (B.castInput = function (e, t) {
     var r = t.undefinedReplacement,
      s = t.stringifyReplacer,
      n =
       void 0 === s
        ? function (e, t) {
           return typeof t > 'u' ? r : t;
          }
        : s;
     return 'string' == typeof e ? e : JSON.stringify(O(e, null, null, n), n, '  ');
    }),
    (B.equals = function (e, t, r) {
     return g.prototype.equals.call(B, e.replace(/,([\r\n])/g, '$1'), t.replace(/,([\r\n])/g, '$1'), r);
    });
   var L = new g();
   function M(e) {
    switch (e) {
     case 'cr':
      return '\r';
     case 'crlf':
      return '\r\n';
     default:
      return '\n';
    }
   }
   function j(e, t) {
    let r;
    switch (t) {
     case '\n':
      r = /\n/gu;
      break;
     case '\r':
      r = /\r/gu;
      break;
     case '\r\n':
      r = /\r\n/gu;
      break;
     default:
      throw new Error(`Unexpected "eol" ${JSON.stringify(t)}.`);
    }
    let s = e.match(r);
    return s ? s.length : 0;
   }
   (L.tokenize = function (e) {
    return e.slice();
   }),
    (L.join = L.removeEmpty =
     function (e) {
      return e;
     });
   var _ = 'string',
    R = 'array',
    U = 'cursor',
    $ = 'indent',
    q = 'align',
    J = 'trim',
    W = 'group',
    z = 'fill',
    V = 'if-break',
    H = 'indent-if-break',
    K = 'line-suffix',
    X = 'line-suffix-boundary',
    G = 'line',
    Y = 'label',
    Q = 'break-parent',
    Z = new Set([U, $, q, J, W, z, V, H, K, X, G, Y, Q]),
    ee = (e, t, r) => {
     if (!e || null != t) return Array.isArray(t) || 'string' == typeof t ? t[r < 0 ? t.length + r : r] : t.at(r);
    };
   var te = function (e) {
    if ('string' == typeof e) return _;
    if (Array.isArray(e)) return R;
    if (!e) return;
    let { type: t } = e;
    return Z.has(t) ? t : void 0;
   };
   function re(e) {
    let t = null === e ? 'null' : typeof e;
    if ('string' !== t && 'object' !== t) return `Unexpected doc '${t}', \nExpected it to be 'string' or 'object'.`;
    if (te(e)) throw new Error('doc is valid.');
    let r = Object.prototype.toString.call(e);
    if ('[object Object]' !== r) return `Unexpected doc '${r}'.`;
    let s = ((e) => new Intl.ListFormat('en-US', { type: 'disjunction' }).format(e))([...Z].map((e) => `'${e}'`));
    return `Unexpected doc.type '${e.type}'.\nExpected it to be ${s}.`;
   }
   var se = class extends Error {
     name = 'InvalidDocError';
     constructor(e) {
      super(re(e)), (this.doc = e);
     }
    },
    ne = {};
   var ie = function (e, t, r, s) {
    let n = [e];
    for (; n.length > 0; ) {
     let e = n.pop();
     if (e === ne) {
      r(n.pop());
      continue;
     }
     r && n.push(e, ne);
     let i = te(e);
     if (!i) throw new se(e);
     if (!1 !== (null == t ? void 0 : t(e)))
      switch (i) {
       case R:
       case z: {
        let t = i === R ? e : e.parts;
        for (let e = t.length - 1; e >= 0; --e) n.push(t[e]);
        break;
       }
       case V:
        n.push(e.flatContents, e.breakContents);
        break;
       case W:
        if (s && e.expandedStates) for (let t = e.expandedStates.length - 1; t >= 0; --t) n.push(e.expandedStates[t]);
        else n.push(e.contents);
        break;
       case q:
       case $:
       case H:
       case Y:
       case K:
        n.push(e.contents);
        break;
       case _:
       case U:
       case J:
       case X:
       case G:
       case Q:
        break;
       default:
        throw new se(e);
      }
    }
   };
   function ae(e, t) {
    if ('string' == typeof e) return t(e);
    let r = new Map();
    return s(e);
    function s(e) {
     if (r.has(e)) return r.get(e);
     let n = (function (e) {
      switch (te(e)) {
       case R:
        return t(e.map(s));
       case z:
        return t({ ...e, parts: e.parts.map(s) });
       case V:
        return t({ ...e, breakContents: s(e.breakContents), flatContents: s(e.flatContents) });
       case W: {
        let { expandedStates: r, contents: n } = e;
        return r ? ((r = r.map(s)), (n = r[0])) : (n = s(n)), t({ ...e, contents: n, expandedStates: r });
       }
       case q:
       case $:
       case H:
       case Y:
       case K:
        return t({ ...e, contents: s(e.contents) });
       case _:
       case U:
       case J:
       case X:
       case G:
       case Q:
        return t(e);
       default:
        throw new se(e);
      }
     })(e);
     return r.set(e, n), n;
    }
   }
   function oe(e, t, r) {
    let s = r,
     n = !1;
    return (
     ie(e, function (e) {
      if (n) return !1;
      let r = t(e);
      void 0 !== r && ((n = !0), (s = r));
     }),
     s
    );
   }
   function ue(e) {
    if ((e.type === W && e.break) || (e.type === G && e.hard) || e.type === Q) return !0;
   }
   function le(e) {
    if (e.length > 0) {
     let t = ee(!1, e, -1);
     !t.expandedStates && !t.break && (t.break = 'propagated');
    }
    return null;
   }
   function pe(e) {
    return e.type !== G || e.hard ? (e.type === V ? e.flatContents : e) : e.soft ? '' : ' ';
   }
   function ce(e) {
    for (e = [...e]; e.length >= 2 && ee(!1, e, -2).type === G && ee(!1, e, -1).type === Q; ) e.length -= 2;
    if (e.length > 0) {
     let t = he(ee(!1, e, -1));
     e[e.length - 1] = t;
    }
    return e;
   }
   function he(e) {
    switch (te(e)) {
     case $:
     case H:
     case W:
     case K:
     case Y: {
      let t = he(e.contents);
      return { ...e, contents: t };
     }
     case V:
      return { ...e, breakContents: he(e.breakContents), flatContents: he(e.flatContents) };
     case z:
      return { ...e, parts: ce(e.parts) };
     case R:
      return ce(e);
     case _:
      return e.replace(/[\n\r]*$/u, '');
     case q:
     case U:
     case J:
     case X:
     case G:
     case Q:
      break;
     default:
      throw new se(e);
    }
    return e;
   }
   function de(e) {
    return he(
     (function (e) {
      return ae(e, (e) =>
       (function (e) {
        switch (te(e)) {
         case z:
          if (e.parts.every((e) => '' === e)) return '';
          break;
         case W:
          if (!(e.contents || e.id || e.break || e.expandedStates)) return '';
          if (e.contents.type === W && e.contents.id === e.id && e.contents.break === e.break && e.contents.expandedStates === e.expandedStates) return e.contents;
          break;
         case q:
         case $:
         case H:
         case K:
          if (!e.contents) return '';
          break;
         case V:
          if (!e.flatContents && !e.breakContents) return '';
          break;
         case R: {
          let t = [];
          for (let r of e) {
           if (!r) continue;
           let [e, ...s] = Array.isArray(r) ? r : [r];
           'string' == typeof e && 'string' == typeof ee(!1, t, -1) ? (t[t.length - 1] += e) : t.push(e), t.push(...s);
          }
          return 0 === t.length ? '' : 1 === t.length ? t[0] : t;
         }
         case _:
         case U:
         case J:
         case X:
         case G:
         case Y:
         case Q:
          break;
         default:
          throw new se(e);
        }
        return e;
       })(e),
      );
     })(e),
    );
   }
   function fe(e) {
    if (e.type === G) return !0;
   }
   function me(e, t) {
    return e.type === Y ? { ...e, contents: t(e.contents) } : t(e);
   }
   var ye = () => {},
    De = ye,
    ge = ye,
    xe = ye;
   function Ee(e) {
    return De(e), { type: $, contents: e };
   }
   function be(e, t) {
    return De(t), { type: q, contents: t, n: e };
   }
   function Te(e, t = {}) {
    return De(e), ge(t.expandedStates, !0), { type: W, id: t.id, contents: e, break: !!t.shouldBreak, expandedStates: t.expandedStates };
   }
   function Ae(e) {
    return De(e), { type: K, contents: e };
   }
   var Ce = { type: X },
    ve = { type: Q },
    Fe = { type: J },
    we = { type: G, hard: !0 },
    Se = { type: G, hard: !0, literal: !0 },
    Pe = { type: G },
    ke = { type: G, soft: !0 },
    Ie = [we, ve],
    Ne = [Se, ve],
    Be = { type: U };
   function Oe(e, t) {
    De(e), ge(t);
    let r = [];
    for (let s = 0; s < t.length; s++) 0 !== s && r.push(e), r.push(t[s]);
    return r;
   }
   function Le(e, t, r) {
    De(e);
    let s = e;
    if (t > 0) {
     for (let e = 0; e < Math.floor(t / r); ++e) s = Ee(s);
     (s = be(t % r, s)), (s = be(Number.NEGATIVE_INFINITY, s));
    }
    return s;
   }
   function Me(e) {
    var t;
    if (!e) return '';
    if (Array.isArray(e)) {
     let t = [];
     for (let r of e)
      if (Array.isArray(r)) t.push(...Me(r));
      else {
       let e = Me(r);
       '' !== e && t.push(e);
      }
     return t;
    }
    return e.type === V ? { ...e, breakContents: Me(e.breakContents), flatContents: Me(e.flatContents) } : e.type === W ? { ...e, contents: Me(e.contents), expandedStates: null == (t = e.expandedStates) ? void 0 : t.map(Me) } : e.type === z ? { type: 'fill', parts: e.parts.map(Me) } : e.contents ? { ...e, contents: Me(e.contents) } : e;
   }
   var je = (e) =>
     !(
      (function (e) {
       return 12288 === e || (e >= 65281 && e <= 65376) || (e >= 65504 && e <= 65510);
      })(e) ||
      (function (e) {
       return (e >= 4352 && e <= 4447) || 8986 === e || 8987 === e || 9001 === e || 9002 === e || (e >= 9193 && e <= 9196) || 9200 === e || 9203 === e || 9725 === e || 9726 === e || 9748 === e || 9749 === e || (e >= 9776 && e <= 9783) || (e >= 9800 && e <= 9811) || 9855 === e || (e >= 9866 && e <= 9871) || 9875 === e || 9889 === e || 9898 === e || 9899 === e || 9917 === e || 9918 === e || 9924 === e || 9925 === e || 9934 === e || 9940 === e || 9962 === e || 9970 === e || 9971 === e || 9973 === e || 9978 === e || 9981 === e || 9989 === e || 9994 === e || 9995 === e || 10024 === e || 10060 === e || 10062 === e || (e >= 10067 && e <= 10069) || 10071 === e || (e >= 10133 && e <= 10135) || 10160 === e || 10175 === e || 11035 === e || 11036 === e || 11088 === e || 11093 === e || (e >= 11904 && e <= 11929) || (e >= 11931 && e <= 12019) || (e >= 12032 && e <= 12245) || (e >= 12272 && e <= 12287) || (e >= 12289 && e <= 12350) || (e >= 12353 && e <= 12438) || (e >= 12441 && e <= 12543) || (e >= 12549 && e <= 12591) || (e >= 12593 && e <= 12686) || (e >= 12688 && e <= 12773) || (e >= 12783 && e <= 12830) || (e >= 12832 && e <= 12871) || (e >= 12880 && e <= 42124) || (e >= 42128 && e <= 42182) || (e >= 43360 && e <= 43388) || (e >= 44032 && e <= 55203) || (e >= 63744 && e <= 64255) || (e >= 65040 && e <= 65049) || (e >= 65072 && e <= 65106) || (e >= 65108 && e <= 65126) || (e >= 65128 && e <= 65131) || (e >= 94176 && e <= 94180) || 94192 === e || 94193 === e || (e >= 94208 && e <= 100343) || (e >= 100352 && e <= 101589) || (e >= 101631 && e <= 101640) || (e >= 110576 && e <= 110579) || (e >= 110581 && e <= 110587) || 110589 === e || 110590 === e || (e >= 110592 && e <= 110882) || 110898 === e || (e >= 110928 && e <= 110930) || 110933 === e || (e >= 110948 && e <= 110951) || (e >= 110960 && e <= 111355) || (e >= 119552 && e <= 119638) || (e >= 119648 && e <= 119670) || 126980 === e || 127183 === e || 127374 === e || (e >= 127377 && e <= 127386) || (e >= 127488 && e <= 127490) || (e >= 127504 && e <= 127547) || (e >= 127552 && e <= 127560) || 127568 === e || 127569 === e || (e >= 127584 && e <= 127589) || (e >= 127744 && e <= 127776) || (e >= 127789 && e <= 127797) || (e >= 127799 && e <= 127868) || (e >= 127870 && e <= 127891) || (e >= 127904 && e <= 127946) || (e >= 127951 && e <= 127955) || (e >= 127968 && e <= 127984) || 127988 === e || (e >= 127992 && e <= 128062) || 128064 === e || (e >= 128066 && e <= 128252) || (e >= 128255 && e <= 128317) || (e >= 128331 && e <= 128334) || (e >= 128336 && e <= 128359) || 128378 === e || 128405 === e || 128406 === e || 128420 === e || (e >= 128507 && e <= 128591) || (e >= 128640 && e <= 128709) || 128716 === e || (e >= 128720 && e <= 128722) || (e >= 128725 && e <= 128727) || (e >= 128732 && e <= 128735) || 128747 === e || 128748 === e || (e >= 128756 && e <= 128764) || (e >= 128992 && e <= 129003) || 129008 === e || (e >= 129292 && e <= 129338) || (e >= 129340 && e <= 129349) || (e >= 129351 && e <= 129535) || (e >= 129648 && e <= 129660) || (e >= 129664 && e <= 129673) || (e >= 129679 && e <= 129734) || (e >= 129742 && e <= 129756) || (e >= 129759 && e <= 129769) || (e >= 129776 && e <= 129784) || (e >= 131072 && e <= 196605) || (e >= 196608 && e <= 262141);
      })(e)
     ),
    _e = /[^\x20-\x7F]/u;
   var Re = function (e) {
     if (!e) return 0;
     if (!_e.test(e)) return e.length;
     e = e.replace(/[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE89\uDE8F-\uDEC2\uDEC6\uDECE-\uDEDC\uDEDF-\uDEE9]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g, '  ');
     let t = 0;
     for (let r of e) {
      let e = r.codePointAt(0);
      e <= 31 || (e >= 127 && e <= 159) || (e >= 768 && e <= 879) || (t += je(e) ? 1 : 2);
     }
     return t;
    },
    Ue = Symbol('MODE_BREAK'),
    $e = Symbol('MODE_FLAT'),
    qe = Symbol('cursor'),
    Je = Symbol('DOC_FILL_PRINTED_LENGTH');
   function We(e, t) {
    return Ve(e, { type: 'indent' }, t);
   }
   function ze(e, t, r) {
    return t === Number.NEGATIVE_INFINITY ? e.root || { value: '', length: 0, queue: [] } : t < 0 ? Ve(e, { type: 'dedent' }, r) : t ? ('root' === t.type ? { ...e, root: e } : Ve(e, { type: 'string' == typeof t ? 'stringAlign' : 'numberAlign', n: t }, r)) : e;
   }
   function Ve(e, t, r) {
    let s = 'dedent' === t.type ? e.queue.slice(0, -1) : [...e.queue, t],
     n = '',
     i = 0,
     a = 0,
     o = 0;
    for (let d of s)
     switch (d.type) {
      case 'indent':
       p(), r.useTabs ? u(1) : l(r.tabWidth);
       break;
      case 'stringAlign':
       p(), (n += d.n), (i += d.n.length);
       break;
      case 'numberAlign':
       (a += 1), (o += d.n);
       break;
      default:
       throw new Error(`Unexpected type '${d.type}'`);
     }
    return c(), { ...e, value: n, length: i, queue: s };
    function u(e) {
     (n += '\t'.repeat(e)), (i += r.tabWidth * e);
    }
    function l(e) {
     (n += ' '.repeat(e)), (i += e);
    }
    function p() {
     r.useTabs ? (a > 0 && u(a), h()) : c();
    }
    function c() {
     o > 0 && l(o), h();
    }
    function h() {
     (a = 0), (o = 0);
    }
   }
   function He(e) {
    let t = 0,
     r = 0,
     s = e.length;
    e: for (; s--; ) {
     let n = e[s];
     if (n !== qe)
      for (let r = n.length - 1; r >= 0; r--) {
       let i = n[r];
       if (' ' !== i && '\t' !== i) {
        e[s] = n.slice(0, r + 1);
        break e;
       }
       t++;
      }
     else r++;
    }
    if (t > 0 || r > 0) for (e.length = s + 1; r-- > 0; ) e.push(qe);
    return t;
   }
   function Ke(e, t, r, s, n, i) {
    if (r === Number.POSITIVE_INFINITY) return !0;
    let a = t.length,
     o = [e],
     u = [];
    for (; r >= 0; ) {
     if (0 === o.length) {
      if (0 === a) return !0;
      o.push(t[--a]);
      continue;
     }
     let { mode: e, doc: l } = o.pop(),
      p = te(l);
     switch (p) {
      case _:
       u.push(l), (r -= Re(l));
       break;
      case R:
      case z: {
       let t = p === R ? l : l.parts,
        r = l[Je] ?? 0;
       for (let s = t.length - 1; s >= r; s--) o.push({ mode: e, doc: t[s] });
       break;
      }
      case $:
      case q:
      case H:
      case Y:
       o.push({ mode: e, doc: l.contents });
       break;
      case J:
       r += He(u);
       break;
      case W: {
       if (i && l.break) return !1;
       let t = l.break ? Ue : e,
        r = l.expandedStates && t === Ue ? ee(!1, l.expandedStates, -1) : l.contents;
       o.push({ mode: t, doc: r });
       break;
      }
      case V: {
       let t = (l.groupId ? n[l.groupId] || $e : e) === Ue ? l.breakContents : l.flatContents;
       t && o.push({ mode: e, doc: t });
       break;
      }
      case G:
       if (e === Ue || l.hard) return !0;
       l.soft || (u.push(' '), r--);
       break;
      case K:
       s = !0;
       break;
      case X:
       if (s) return !1;
     }
    }
    return !1;
   }
   function Xe(e, t) {
    let r = {},
     s = t.printWidth,
     n = M(t.endOfLine),
     i = 0,
     a = [{ ind: { value: '', length: 0, queue: [] }, mode: Ue, doc: e }],
     o = [],
     u = !1,
     l = [],
     p = 0;
    for (
     (function (e) {
      let t = new Set(),
       r = [];
      ie(
       e,
       function (e) {
        if ((e.type === Q && le(r), e.type === W)) {
         if ((r.push(e), t.has(e))) return !1;
         t.add(e);
        }
       },
       function (e) {
        e.type === W && r.pop().break && le(r);
       },
       !0,
      );
     })(e);
     a.length > 0;

    ) {
     let { ind: e, mode: c, doc: h } = a.pop();
     switch (te(h)) {
      case _: {
       let e = '\n' !== n ? D(!1, h, '\n', n) : h;
       o.push(e), a.length > 0 && (i += Re(e));
       break;
      }
      case R:
       for (let t = h.length - 1; t >= 0; t--) a.push({ ind: e, mode: c, doc: h[t] });
       break;
      case U:
       if (p >= 2) throw new Error("There are too many 'cursor' in doc.");
       o.push(qe), p++;
       break;
      case $:
       a.push({ ind: We(e, t), mode: c, doc: h.contents });
       break;
      case q:
       a.push({ ind: ze(e, h.n, t), mode: c, doc: h.contents });
       break;
      case J:
       i -= He(o);
       break;
      case W:
       switch (c) {
        case $e:
         if (!u) {
          a.push({ ind: e, mode: h.break ? Ue : $e, doc: h.contents });
          break;
         }
        case Ue: {
         u = !1;
         let t = { ind: e, mode: $e, doc: h.contents },
          n = s - i,
          o = l.length > 0;
         if (!h.break && Ke(t, a, n, o, r)) a.push(t);
         else if (h.expandedStates) {
          let t = ee(!1, h.expandedStates, -1);
          if (h.break) {
           a.push({ ind: e, mode: Ue, doc: t });
           break;
          }
          for (let s = 1; s < h.expandedStates.length + 1; s++) {
           if (s >= h.expandedStates.length) {
            a.push({ ind: e, mode: Ue, doc: t });
            break;
           }
           {
            let t = h.expandedStates[s],
             i = { ind: e, mode: $e, doc: t };
            if (Ke(i, a, n, o, r)) {
             a.push(i);
             break;
            }
           }
          }
         } else a.push({ ind: e, mode: Ue, doc: h.contents });
         break;
        }
       }
       h.id && (r[h.id] = ee(!1, a, -1).mode);
       break;
      case z: {
       let t = s - i,
        n = h[Je] ?? 0,
        { parts: o } = h,
        u = o.length - n;
       if (0 === u) break;
       let p = o[n + 0],
        d = o[n + 1],
        f = { ind: e, mode: $e, doc: p },
        m = { ind: e, mode: Ue, doc: p },
        y = Ke(f, [], t, l.length > 0, r, !0);
       if (1 === u) {
        y ? a.push(f) : a.push(m);
        break;
       }
       let D = { ind: e, mode: $e, doc: d },
        g = { ind: e, mode: Ue, doc: d };
       if (2 === u) {
        y ? a.push(D, f) : a.push(g, m);
        break;
       }
       let x = o[n + 2],
        E = { ind: e, mode: c, doc: { ...h, [Je]: n + 2 } };
       Ke({ ind: e, mode: $e, doc: [p, d, x] }, [], t, l.length > 0, r, !0) ? a.push(E, D, f) : y ? a.push(E, g, f) : a.push(E, g, m);
       break;
      }
      case V:
      case H: {
       let t = h.groupId ? r[h.groupId] : c;
       if (t === Ue) {
        let t = h.type === V ? h.breakContents : h.negate ? h.contents : Ee(h.contents);
        t && a.push({ ind: e, mode: c, doc: t });
       }
       if (t === $e) {
        let t = h.type === V ? h.flatContents : h.negate ? Ee(h.contents) : h.contents;
        t && a.push({ ind: e, mode: c, doc: t });
       }
       break;
      }
      case K:
       l.push({ ind: e, mode: c, doc: h.contents });
       break;
      case X:
       l.length > 0 && a.push({ ind: e, mode: c, doc: we });
       break;
      case G:
       switch (c) {
        case $e:
         if (!h.hard) {
          h.soft || (o.push(' '), (i += 1));
          break;
         }
         u = !0;
        case Ue:
         if (l.length > 0) {
          a.push({ ind: e, mode: c, doc: h }, ...l.reverse()), (l.length = 0);
          break;
         }
         h.literal ? (e.root ? (o.push(n, e.root.value), (i = e.root.length)) : (o.push(n), (i = 0))) : ((i -= He(o)), o.push(n + e.value), (i = e.length));
       }
       break;
      case Y:
       a.push({ ind: e, mode: c, doc: h.contents });
       break;
      case Q:
       break;
      default:
       throw new se(h);
     }
     0 === a.length && l.length > 0 && (a.push(...l.reverse()), (l.length = 0));
    }
    let c = o.indexOf(qe);
    if (-1 !== c) {
     let e = o.indexOf(qe, c + 1);
     if (-1 === e) return { formatted: o.filter((e) => e !== qe).join('') };
     let t = o.slice(0, c).join(''),
      r = o.slice(c + 1, e).join('');
     return { formatted: t + r + o.slice(e + 1).join(''), cursorNodeStart: t.length, cursorNodeText: r };
    }
    return { formatted: o.join('') };
   }
   var Ge,
    Ye,
    Qe,
    Ze = function (e, t, r = 0) {
     let s = 0;
     for (let n = r; n < e.length; ++n) '\t' === e[n] ? (s = s + t - (s % t)) : s++;
     return s;
    };
   (Ge = new WeakSet()),
    (Ye = function (e) {
     let { stack: t } = this;
     for (let r = t.length - 1; r >= 0; r -= 2) if (!Array.isArray(t[r]) && --e < 0) return r;
     return -1;
    }),
    (Qe = function* () {
     let { stack: e } = this;
     for (let t = e.length - 3; t >= 0; t -= 2) {
      let r = e[t];
      Array.isArray(r) || (yield r);
     }
    });
   var et = class {
     constructor(e) {
      ((e, t, r) => {
       t.has(e) ? l('Cannot add the same private member more than once') : t instanceof WeakSet ? t.add(e) : t.set(e, r);
      })(this, Ge),
       (this.stack = [e]);
     }
     get key() {
      let { stack: e, siblings: t } = this;
      return ee(!1, e, null === t ? -2 : -4) ?? null;
     }
     get index() {
      return null === this.siblings ? null : ee(!1, this.stack, -2);
     }
     get node() {
      return ee(!1, this.stack, -1);
     }
     get parent() {
      return this.getNode(1);
     }
     get grandparent() {
      return this.getNode(2);
     }
     get isInArray() {
      return null !== this.siblings;
     }
     get siblings() {
      let { stack: e } = this,
       t = ee(!1, e, -3);
      return Array.isArray(t) ? t : null;
     }
     get next() {
      let { siblings: e } = this;
      return null === e ? null : e[this.index + 1];
     }
     get previous() {
      let { siblings: e } = this;
      return null === e ? null : e[this.index - 1];
     }
     get isFirst() {
      return 0 === this.index;
     }
     get isLast() {
      let { siblings: e, index: t } = this;
      return null !== e && t === e.length - 1;
     }
     get isRoot() {
      return 1 === this.stack.length;
     }
     get root() {
      return this.stack[0];
     }
     get ancestors() {
      return [...d(this, Ge, Qe).call(this)];
     }
     getName() {
      let { stack: e } = this,
       { length: t } = e;
      return t > 1 ? ee(!1, e, -2) : null;
     }
     getValue() {
      return ee(!1, this.stack, -1);
     }
     getNode(e = 0) {
      let t = d(this, Ge, Ye).call(this, e);
      return -1 === t ? null : this.stack[t];
     }
     getParentNode(e = 0) {
      return this.getNode(e + 1);
     }
     call(e, ...t) {
      let { stack: r } = this,
       { length: s } = r,
       n = ee(!1, r, -1);
      for (let i of t) (n = n[i]), r.push(i, n);
      try {
       return e(this);
      } finally {
       r.length = s;
      }
     }
     callParent(e, t = 0) {
      let r = d(this, Ge, Ye).call(this, t + 1),
       s = this.stack.splice(r + 1);
      try {
       return e(this);
      } finally {
       this.stack.push(...s);
      }
     }
     each(e, ...t) {
      let { stack: r } = this,
       { length: s } = r,
       n = ee(!1, r, -1);
      for (let i of t) (n = n[i]), r.push(i, n);
      try {
       for (let t = 0; t < n.length; ++t) r.push(t, n[t]), e(this, t, n), (r.length -= 2);
      } finally {
       r.length = s;
      }
     }
     map(e, ...t) {
      let r = [];
      return (
       this.each(
        (t, s, n) => {
         r[s] = e(t, s, n);
        },
        ...t,
       ),
       r
      );
     }
     match(...e) {
      let t = this.stack.length - 1,
       r = null,
       s = this.stack[t--];
      for (let n of e) {
       if (void 0 === s) return !1;
       let e = null;
       if (('number' == typeof r && ((e = r), (r = this.stack[t--]), (s = this.stack[t--])), n && !n(s, r, e))) return !1;
       (r = this.stack[t--]), (s = this.stack[t--]);
      }
      return !0;
     }
     findAncestor(e) {
      for (let t of d(this, Ge, Qe).call(this)) if (e(t)) return t;
     }
     hasAncestor(e) {
      for (let t of d(this, Ge, Qe).call(this)) if (e(t)) return !0;
      return !1;
     }
    },
    tt = new Proxy(() => {}, { get: () => tt }),
    rt = tt;
   var st = function (e) {
    return null !== e && 'object' == typeof e;
   };
   function* nt(e, t) {
    let { getVisitorKeys: r, filter: s = () => !0 } = t,
     n = (e) => st(e) && s(e);
    for (let i of r(e)) {
     let t = e[i];
     if (Array.isArray(t)) for (let e of t) n(e) && (yield e);
     else n(t) && (yield t);
    }
   }
   function it(e) {
    return (t, r, s) => {
     let n = !(null == s || !s.backwards);
     if (!1 === r) return !1;
     let { length: i } = t,
      a = r;
     for (; a >= 0 && a < i; ) {
      let r = t.charAt(a);
      if (e instanceof RegExp) {
       if (!e.test(r)) return a;
      } else if (!e.includes(r)) return a;
      n ? a-- : a++;
     }
     return (-1 === a || a === i) && a;
    };
   }
   var at = it(/\s/u),
    ot = it(' \t'),
    ut = it(',; \t'),
    lt = it(/[^\n\r]/u);
   var pt = function (e, t, r) {
    let s = !(null == r || !r.backwards);
    if (!1 === t) return !1;
    let n = e.charAt(t);
    if (s) {
     if ('\r' === e.charAt(t - 1) && '\n' === n) return t - 2;
     if ('\n' === n || '\r' === n || '\u2028' === n || '\u2029' === n) return t - 1;
    } else {
     if ('\r' === n && '\n' === e.charAt(t + 1)) return t + 2;
     if ('\n' === n || '\r' === n || '\u2028' === n || '\u2029' === n) return t + 1;
    }
    return t;
   };
   var ct = function (e, t, r = {}) {
    let s = ot(e, r.backwards ? t - 1 : t, r);
    return s !== pt(e, s, r);
   };
   var ht = function (e) {
     return Array.isArray(e) && e.length > 0;
    },
    dt = new Set(['tokens', 'comments', 'parent', 'enclosingNode', 'precedingNode', 'followingNode']),
    ft = (e) => Object.keys(e).filter((e) => !dt.has(e));
   var mt = function (e) {
    return e ? (t) => e(t, dt) : ft;
   };
   function yt(e, t) {
    (e.comments ?? (e.comments = [])).push(t),
     (t.printed = !1),
     (t.nodeDescription = (function (e) {
      let t = e.type || e.kind || '(unknown type)',
       r = String(e.name || (e.id && ('object' == typeof e.id ? e.id.name : e.id)) || (e.key && ('object' == typeof e.key ? e.key.name : e.key)) || (e.value && ('object' == typeof e.value ? '' : String(e.value))) || e.operator || '');
      return r.length > 20 && (r = r.slice(0, 19) + '\u2026'), t + (r ? ' ' + r : '');
     })(e));
   }
   function Dt(e, t) {
    (t.leading = !0), (t.trailing = !1), yt(e, t);
   }
   function gt(e, t, r) {
    (t.leading = !1), (t.trailing = !1), r && (t.marker = r), yt(e, t);
   }
   function xt(e, t) {
    (t.leading = !1), (t.trailing = !0), yt(e, t);
   }
   var Et = new WeakMap();
   function bt(e, t) {
    if (Et.has(e)) return Et.get(e);
    let {
     printer: { getCommentChildNodes: r, canAttachComment: s, getVisitorKeys: n },
     locStart: i,
     locEnd: a,
    } = t;
    if (!s) return [];
    let o = ((null == r ? void 0 : r(e, t)) ?? [...nt(e, { getVisitorKeys: mt(n) })]).flatMap((e) => (s(e) ? [e] : bt(e, t)));
    return o.sort((e, t) => i(e) - i(t) || a(e) - a(t)), Et.set(e, o), o;
   }
   function Tt(e, t, r, s) {
    let n,
     i,
     { locStart: a, locEnd: o } = r,
     u = a(t),
     l = o(t),
     p = bt(e, r),
     c = 0,
     h = p.length;
    for (; c < h; ) {
     let e = (c + h) >> 1,
      s = p[e],
      d = a(s),
      f = o(s);
     if (d <= u && l <= f) return Tt(s, t, r, s);
     if (f <= u) (n = s), (c = e + 1);
     else {
      if (!(l <= d)) throw new Error('Comment location overlaps with node location');
      (i = s), (h = e);
     }
    }
    if ('TemplateLiteral' === (null == s ? void 0 : s.type)) {
     let { quasis: e } = s,
      a = St(e, t, r);
     n && St(e, n, r) !== a && (n = null), i && St(e, i, r) !== a && (i = null);
    }
    return { enclosingNode: s, precedingNode: n, followingNode: i };
   }
   var At = () => !1;
   var Ct = (e) => !/[\S\n\u2028\u2029]/u.test(e);
   function vt(e, t, r, s) {
    let { comment: n, precedingNode: i } = r[s],
     { locStart: a, locEnd: o } = t,
     u = a(n);
    if (i)
     for (let l = s - 1; l >= 0; l--) {
      let { comment: t, precedingNode: s } = r[l];
      if (s !== i || !Ct(e.slice(o(t), u))) break;
      u = a(t);
     }
    return ct(e, u, { backwards: !0 });
   }
   function Ft(e, t, r, s) {
    let { comment: n, followingNode: i } = r[s],
     { locStart: a, locEnd: o } = t,
     u = o(n);
    if (i)
     for (let l = s + 1; l < r.length; l++) {
      let { comment: t, followingNode: s } = r[l];
      if (s !== i || !Ct(e.slice(u, a(t)))) break;
      u = o(t);
     }
    return ct(e, u);
   }
   function wt(e, t) {
    var r, s;
    let n = e.length;
    if (0 === n) return;
    let i,
     { precedingNode: a, followingNode: o } = e[0],
     u = t.locStart(o);
    for (i = n; i > 0; --i) {
     let { comment: n, precedingNode: l, followingNode: p } = e[i - 1];
     rt.strictEqual(l, a), rt.strictEqual(p, o);
     let c = t.originalText.slice(t.locEnd(n), u);
     if (!((null == (s = (r = t.printer).isGap) ? void 0 : s.call(r, c, t)) ?? /^[\s(]*$/u.test(c))) break;
     u = t.locStart(n);
    }
    for (let [l, { comment: p }] of e.entries()) l < i ? xt(a, p) : Dt(o, p);
    for (let l of [a, o]) l.comments && l.comments.length > 1 && l.comments.sort((e, r) => t.locStart(e) - t.locStart(r));
    e.length = 0;
   }
   function St(e, t, r) {
    let s = r.locStart(t) - 1;
    for (let n = 1; n < e.length; ++n) if (s < r.locStart(e[n])) return n - 1;
    return 0;
   }
   var Pt = function (e, t) {
    let r = t - 1;
    return (r = ot(e, r, { backwards: !0 })), (r = pt(e, r, { backwards: !0 })), (r = ot(e, r, { backwards: !0 })), r !== pt(e, r, { backwards: !0 });
   };
   function kt(e, t) {
    return (e.node.printed = !0), t.printer.printComment(e, t);
   }
   function It(e, t) {
    let r = e.node;
    if (!r) return {};
    let s = t[Symbol.for('printedComments')];
    if (0 === (r.comments || []).filter((e) => !s.has(e)).length) return { leading: '', trailing: '' };
    let n,
     i = [],
     a = [];
    return (
     e.each(() => {
      let r = e.node;
      if (null != s && s.has(r)) return;
      let { leading: o, trailing: u } = r;
      o
       ? i.push(
          (function (e, t) {
           var r;
           let s = e.node,
            n = [kt(e, t)],
            { printer: i, originalText: a, locStart: o, locEnd: u } = t;
           if (null == (r = i.isBlockComment) ? void 0 : r.call(i, s)) {
            let e = ct(a, u(s)) ? (ct(a, o(s), { backwards: !0 }) ? Ie : Pe) : ' ';
            n.push(e);
           } else n.push(Ie);
           let l = pt(a, ot(a, u(s)));
           return !1 !== l && ct(a, l) && n.push(Ie), n;
          })(e, t),
         )
       : u &&
         ((n = (function (e, t, r) {
          var s;
          let n = e.node,
           i = kt(e, t),
           { printer: a, originalText: o, locStart: u } = t,
           l = null == (s = a.isBlockComment) ? void 0 : s.call(a, n);
          if ((null != r && r.hasLineSuffix && (null == r || !r.isBlock)) || ct(o, u(n), { backwards: !0 })) {
           let e = Pt(o, u(n));
           return { doc: Ae([Ie, e ? Ie : '', i]), isBlock: l, hasLineSuffix: !0 };
          }
          return !l || (null != r && r.hasLineSuffix) ? { doc: [Ae([' ', i]), ve], isBlock: l, hasLineSuffix: !0 } : { doc: [' ', i], isBlock: l, hasLineSuffix: !1 };
         })(e, t, n)),
         a.push(n.doc));
     }, 'comments'),
     { leading: i, trailing: a }
    );
   }
   var Nt = function (e) {
     return () => {};
    },
    Bt = class extends Error {
     name = 'ConfigError';
    },
    Ot = class extends Error {
     name = 'UndefinedParserError';
    },
    Lt = {
     cursorOffset: { category: 'Special', type: 'int', default: -1, range: { start: -1, end: 1 / 0, step: 1 }, description: 'Print (to stderr) where a cursor at the given position would move to after formatting.', cliCategory: 'Editor' },
     endOfLine: {
      category: 'Global',
      type: 'choice',
      default: 'lf',
      description: 'Which end of line characters to apply.',
      choices: [
       { value: 'lf', description: 'Line Feed only (\\n), common on Linux and macOS as well as inside git repos' },
       { value: 'crlf', description: 'Carriage Return + Line Feed characters (\\r\\n), common on Windows' },
       { value: 'cr', description: 'Carriage Return character only (\\r), used very rarely' },
       { value: 'auto', description: "Maintain existing\n(mixed values within one file are normalised by looking at what's used after the first line)" },
      ],
     },
     filepath: { category: 'Special', type: 'path', description: 'Specify the input filepath. This will be used to do parser inference.', cliName: 'stdin-filepath', cliCategory: 'Other', cliDescription: 'Path to the file to pretend that stdin comes from.' },
     insertPragma: { category: 'Special', type: 'boolean', default: !1, description: "Insert @format pragma into file's first docblock comment.", cliCategory: 'Other' },
     parser: {
      category: 'Global',
      type: 'choice',
      default: void 0,
      description: 'Which parser to use.',
      exception: (e) => 'string' == typeof e || 'function' == typeof e,
      choices: [
       { value: 'flow', description: 'Flow' },
       { value: 'babel', description: 'JavaScript' },
       { value: 'babel-flow', description: 'Flow' },
       { value: 'babel-ts', description: 'TypeScript' },
       { value: 'typescript', description: 'TypeScript' },
       { value: 'acorn', description: 'JavaScript' },
       { value: 'espree', description: 'JavaScript' },
       { value: 'meriyah', description: 'JavaScript' },
       { value: 'css', description: 'CSS' },
       { value: 'less', description: 'Less' },
       { value: 'scss', description: 'SCSS' },
       { value: 'json', description: 'JSON' },
       { value: 'json5', description: 'JSON5' },
       { value: 'jsonc', description: 'JSON with Comments' },
       { value: 'json-stringify', description: 'JSON.stringify' },
       { value: 'graphql', description: 'GraphQL' },
       { value: 'markdown', description: 'Markdown' },
       { value: 'mdx', description: 'MDX' },
       { value: 'vue', description: 'Vue' },
       { value: 'yaml', description: 'YAML' },
       { value: 'glimmer', description: 'Ember / Handlebars' },
       { value: 'html', description: 'HTML' },
       { value: 'angular', description: 'Angular' },
       { value: 'lwc', description: 'Lightning Web Components' },
      ],
     },
     plugins: { type: 'path', array: !0, default: [{ value: [] }], category: 'Global', description: 'Add a plugin. Multiple plugins can be passed as separate `--plugin`s.', exception: (e) => 'string' == typeof e || 'object' == typeof e, cliName: 'plugin', cliCategory: 'Config' },
     printWidth: { category: 'Global', type: 'int', default: 80, description: 'The line length where Prettier will try wrap.', range: { start: 0, end: 1 / 0, step: 1 } },
     rangeEnd: { category: 'Special', type: 'int', default: 1 / 0, range: { start: 0, end: 1 / 0, step: 1 }, description: 'Format code ending at a given character offset (exclusive).\nThe range will extend forwards to the end of the selected statement.', cliCategory: 'Editor' },
     rangeStart: { category: 'Special', type: 'int', default: 0, range: { start: 0, end: 1 / 0, step: 1 }, description: 'Format code starting at a given character offset.\nThe range will extend backwards to the start of the first line containing the selected statement.', cliCategory: 'Editor' },
     requirePragma: { category: 'Special', type: 'boolean', default: !1, description: "Require either '@prettier' or '@format' to be present in the file's first docblock comment\nin order for it to be formatted.", cliCategory: 'Other' },
     tabWidth: { type: 'int', category: 'Global', default: 2, description: 'Number of spaces per indentation level.', range: { start: 0, end: 1 / 0, step: 1 } },
     useTabs: { category: 'Global', type: 'boolean', default: !1, description: 'Indent with tabs instead of spaces.' },
     embeddedLanguageFormatting: {
      category: 'Global',
      type: 'choice',
      default: 'auto',
      description: 'Control how Prettier formats quoted code embedded in the file.',
      choices: [
       { value: 'auto', description: 'Format embedded code if Prettier can automatically identify it.' },
       { value: 'off', description: 'Never automatically format embedded code.' },
      ],
     },
    };
   function Mt({ plugins: e = [], showDeprecated: t = !1 } = {}) {
    let r = e.flatMap((e) => e.languages ?? []),
     s = [];
    for (let n of (function (e) {
     let t = [];
     for (let [r, s] of Object.entries(e)) {
      let e = { name: r, ...s };
      Array.isArray(e.default) && (e.default = ee(!1, e.default, -1).value), t.push(e);
     }
     return t;
    })(Object.assign({}, ...e.map(({ options: e }) => e), Lt)))
     (!t && n.deprecated) ||
      (Array.isArray(n.choices) && (t || (n.choices = n.choices.filter((e) => !e.deprecated)), 'parser' === n.name && (n.choices = [...n.choices, ...jt(n.choices, r, e)])),
      (n.pluginDefaults = Object.fromEntries(
       e
        .filter((e) => {
         var t;
         return void 0 !== (null == (t = e.defaultOptions) ? void 0 : t[n.name]);
        })
        .map((e) => [e.name, e.defaultOptions[n.name]]),
      )),
      s.push(n));
    return { languages: r, options: s };
   }
   function* jt(e, t, r) {
    let s = new Set(e.map((e) => e.value));
    for (let n of t)
     if (n.parsers)
      for (let e of n.parsers)
       if (!s.has(e)) {
        s.add(e);
        let t = r.find((t) => t.parsers && Object.prototype.hasOwnProperty.call(t.parsers, e)),
         i = n.name;
        null != t && t.name && (i += ` (plugin: ${t.name})`), yield { value: e, description: i };
       }
   }
   var _t = (e) => String(e).split(/[/\\]/u).pop();
   function Rt(e, t) {
    if (!t) return;
    let r = _t(t).toLowerCase();
    return e.find(({ filenames: e }) => (null == e ? void 0 : e.some((e) => e.toLowerCase() === r))) ?? e.find(({ extensions: e }) => (null == e ? void 0 : e.some((e) => r.endsWith(e))));
   }
   var Ut = function (e, t) {
     let r = e.plugins.flatMap((e) => e.languages ?? []),
      s =
       (function (e, t) {
        if (t) return e.find(({ name: e }) => e.toLowerCase() === t) ?? e.find(({ aliases: e }) => (null == e ? void 0 : e.includes(t))) ?? e.find(({ extensions: e }) => (null == e ? void 0 : e.includes(`.${t}`)));
       })(r, t.language) ??
       Rt(r, t.physicalFile) ??
       Rt(r, t.file) ??
       void t.physicalFile;
     return null == s ? void 0 : s.parsers[0];
    },
    $t = {
     key: (e) => (/^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(e) ? e : JSON.stringify(e)),
     value(e) {
      if (null === e || 'object' != typeof e) return JSON.stringify(e);
      if (Array.isArray(e)) return `[${e.map((e) => $t.value(e)).join(', ')}]`;
      let t = Object.keys(e);
      return 0 === t.length ? '{}' : `{ ${t.map((t) => `${$t.key(t)}: ${$t.value(e[t])}`).join(', ')} }`;
     },
     pair: ({ key: e, value: t }) => $t.value({ [e]: t }),
    },
    qt = h(f(), 1),
    Jt = h(f(), 1),
    Wt = Symbol.for('vnopts.VALUE_NOT_EXIST'),
    zt = Symbol.for('vnopts.VALUE_UNCHANGED'),
    Vt = ' '.repeat(2);
   function Ht(e, t, r, s) {
    return [`Invalid ${Jt.default.red(s.key(e))} value.`, `Expected ${Jt.default.blue(r)},`, `but received ${t === Wt ? Jt.default.gray('nothing') : Jt.default.red(s.value(t))}.`].join(' ');
   }
   function Kt({ text: e, list: t }, r) {
    let s = [];
    return e && s.push(`- ${Jt.default.blue(e)}`), t && s.push([`- ${Jt.default.blue(t.title)}:`].concat(t.values.map((e) => Kt(e, r - Vt.length).replace(/^|\n/g, `$&${Vt}`))).join('\n')), Xt(s, r);
   }
   function Xt(e, t) {
    if (1 === e.length) return e[0];
    let [r, s] = e,
     [n, i] = e.map((e) => e.split('\n', 1)[0].length);
    return n > t && n > i ? s : r;
   }
   var Gt = h(f(), 1),
    Yt = [],
    Qt = [];
   var Zt = (e, t, { descriptor: r, logger: s, schemas: n }) => {
     let i = [`Ignored unknown option ${Gt.default.yellow(r.pair({ key: e, value: t }))}.`],
      a = Object.keys(n)
       .sort()
       .find(
        (t) =>
         (function (e, t) {
          if (e === t) return 0;
          let r = e;
          e.length > t.length && ((e = t), (t = r));
          let s = e.length,
           n = t.length;
          for (; s > 0 && e.charCodeAt(~-s) === t.charCodeAt(~-n); ) s--, n--;
          let i = 0;
          for (; i < s && e.charCodeAt(i) === t.charCodeAt(i); ) i++;
          if (((s -= i), (n -= i), 0 === s)) return n;
          let a,
           o,
           u,
           l,
           p = 0,
           c = 0;
          for (; p < s; ) (Qt[p] = e.charCodeAt(i + p)), (Yt[p] = ++p);
          for (; c < n; ) for (a = t.charCodeAt(i + c), u = c++, o = c, p = 0; p < s; p++) (l = a === Qt[p] ? u : u + 1), (u = Yt[p]), (o = Yt[p] = u > o ? (l > o ? o + 1 : l) : l > u ? u + 1 : l);
          return o;
         })(e, t) < 3,
       );
     a && i.push(`Did you mean ${Gt.default.blue(r.key(a))}?`), s.warn(i.join(' '));
    },
    er = ['default', 'expected', 'validate', 'deprecated', 'forward', 'redirect', 'overlap', 'preprocess', 'postprocess'];
   var tr = class {
    static create(e) {
     return (function (e, t) {
      let r = new e(t),
       s = Object.create(r);
      for (let n of er) n in t && (s[n] = rr(t[n], r, tr.prototype[n].length));
      return s;
     })(this, e);
    }
    constructor(e) {
     this.name = e.name;
    }
    default(e) {}
    expected(e) {
     return 'nothing';
    }
    validate(e, t) {
     return !1;
    }
    deprecated(e, t) {
     return !1;
    }
    forward(e, t) {}
    redirect(e, t) {}
    overlap(e, t, r) {
     return e;
    }
    preprocess(e, t) {
     return e;
    }
    postprocess(e, t) {
     return zt;
    }
   };
   function rr(e, t, r) {
    return 'function' == typeof e ? (...s) => e(...s.slice(0, r - 1), t, ...s.slice(r - 1)) : () => e;
   }
   var sr = class extends tr {
     constructor(e) {
      super(e), (this._sourceName = e.sourceName);
     }
     expected(e) {
      return e.schemas[this._sourceName].expected(e);
     }
     validate(e, t) {
      return t.schemas[this._sourceName].validate(e, t);
     }
     redirect(e, t) {
      return this._sourceName;
     }
    },
    nr = class extends tr {
     expected() {
      return 'anything';
     }
     validate() {
      return !0;
     }
    },
    ir = class extends tr {
     constructor({ valueSchema: e, name: t = e.name, ...r }) {
      super({ ...r, name: t }), (this._valueSchema = e);
     }
     expected(e) {
      let { text: t, list: r } = e.normalizeExpectedResult(this._valueSchema.expected(e));
      return { text: t && `an array of ${t}`, list: r && { title: 'an array of the following values', values: [{ list: r }] } };
     }
     validate(e, t) {
      if (!Array.isArray(e)) return !1;
      let r = [];
      for (let s of e) {
       let e = t.normalizeValidateResult(this._valueSchema.validate(s, t), s);
       !0 !== e && r.push(e.value);
      }
      return 0 === r.length || { value: r };
     }
     deprecated(e, t) {
      let r = [];
      for (let s of e) {
       let e = t.normalizeDeprecatedResult(this._valueSchema.deprecated(s, t), s);
       !1 !== e && r.push(...e.map(({ value: e }) => ({ value: [e] })));
      }
      return r;
     }
     forward(e, t) {
      let r = [];
      for (let s of e) {
       let e = t.normalizeForwardResult(this._valueSchema.forward(s, t), s);
       r.push(...e.map(ar));
      }
      return r;
     }
     redirect(e, t) {
      let r = [],
       s = [];
      for (let n of e) {
       let e = t.normalizeRedirectResult(this._valueSchema.redirect(n, t), n);
       'remain' in e && r.push(e.remain), s.push(...e.redirect.map(ar));
      }
      return 0 === r.length ? { redirect: s } : { redirect: s, remain: r };
     }
     overlap(e, t) {
      return e.concat(t);
     }
    };
   function ar({ from: e, to: t }) {
    return { from: [e], to: t };
   }
   var or = class extends tr {
    expected() {
     return 'true or false';
    }
    validate(e) {
     return 'boolean' == typeof e;
    }
   };
   function ur(e, t) {
    let r = Object.create(null);
    for (let s of e) {
     let e = s[t];
     if (r[e]) throw new Error(`Duplicate ${t} ${JSON.stringify(e)}`);
     r[e] = s;
    }
    return r;
   }
   function lr(e, t) {
    if (e === t) return 0;
    let r = typeof e,
     s = typeof t,
     n = ['undefined', 'object', 'boolean', 'number', 'string'];
    return r !== s ? n.indexOf(r) - n.indexOf(s) : 'string' !== r ? Number(e) - Number(t) : e.localeCompare(t);
   }
   function pr(e) {
    return void 0 === e ? {} : e;
   }
   function cr(e) {
    if ('string' == typeof e) return { text: e };
    let { text: t, list: r } = e;
    return (
     (function (e, t) {
      if (!e) throw new Error(t);
     })(void 0 !== (t || r), 'Unexpected `expected` result, there should be at least one field.'),
     r ? { text: t, list: { title: r.title, values: r.values.map(cr) } } : { text: t }
    );
   }
   function hr(e, t) {
    return !0 === e || (!1 === e ? { value: t } : e);
   }
   function dr(e, t, r = !1) {
    return !1 !== e && (!0 === e ? !!r || [{ value: t }] : 'value' in e ? [e] : 0 !== e.length && e);
   }
   function fr(e, t) {
    return 'string' == typeof e || 'key' in e ? { from: t, to: e } : 'from' in e ? { from: e.from, to: e.to } : { from: t, to: e.to };
   }
   function mr(e, t) {
    return void 0 === e ? [] : Array.isArray(e) ? e.map((e) => fr(e, t)) : [fr(e, t)];
   }
   function yr(e, t) {
    let r = mr('object' == typeof e && 'redirect' in e ? e.redirect : e, t);
    return 0 === r.length ? { remain: t, redirect: r } : 'object' == typeof e && 'remain' in e ? { remain: e.remain, redirect: r } : { redirect: r };
   }
   var Dr,
    gr = class extends tr {
     constructor(e) {
      super(e),
       (this._choices = (function (e, t) {
        let r = new Map();
        for (let s of e) {
         let e = s[t];
         if (r.has(e)) throw new Error(`Duplicate ${t} ${JSON.stringify(e)}`);
         r.set(e, s);
        }
        return r;
       })(
        e.choices.map((e) => (e && 'object' == typeof e ? e : { value: e })),
        'value',
       ));
     }
     expected({ descriptor: e }) {
      let t = Array.from(this._choices.keys())
        .map((e) => this._choices.get(e))
        .filter(({ hidden: e }) => !e)
        .map((e) => e.value)
        .sort(lr)
        .map(e.value),
       r = t.slice(0, -2),
       s = t.slice(-2);
      return { text: r.concat(s.join(' or ')).join(', '), list: { title: 'one of the following values', values: t } };
     }
     validate(e) {
      return this._choices.has(e);
     }
     deprecated(e) {
      let t = this._choices.get(e);
      return !(!t || !t.deprecated) && { value: e };
     }
     forward(e) {
      let t = this._choices.get(e);
      return t ? t.forward : void 0;
     }
     redirect(e) {
      let t = this._choices.get(e);
      return t ? t.redirect : void 0;
     }
    },
    xr = class extends tr {
     expected() {
      return 'a number';
     }
     validate(e, t) {
      return 'number' == typeof e;
     }
    },
    Er = class extends xr {
     expected() {
      return 'an integer';
     }
     validate(e, t) {
      return !0 === t.normalizeValidateResult(super.validate(e, t), e) && (r = e) === Math.floor(r);
      var r;
     }
    },
    br = class extends tr {
     expected() {
      return 'a string';
     }
     validate(e) {
      return 'string' == typeof e;
     }
    },
    Tr = $t,
    Ar = Zt,
    Cr = (e, t, r) => {
     let { text: s, list: n } = r.normalizeExpectedResult(r.schemas[e].expected(r)),
      i = [];
     return s && i.push(Ht(e, t, s, r.descriptor)), n && i.push([Ht(e, t, n.title, r.descriptor)].concat(n.values.map((e) => Kt(e, r.loggerPrintWidth))).join('\n')), Xt(i, r.loggerPrintWidth);
    },
    vr = (e, t, { descriptor: r }) => {
     let s = [`${qt.default.yellow('string' == typeof e ? r.key(e) : r.pair(e))} is deprecated`];
     return t && s.push(`we now treat it as ${qt.default.blue('string' == typeof t ? r.key(t) : r.pair(t))}`), s.join('; ') + '.';
    },
    Fr = class {
     constructor(e, t) {
      let { logger: r = console, loggerPrintWidth: s = 80, descriptor: n = Tr, unknown: i = Ar, invalid: a = Cr, deprecated: o = vr, missing: u = () => !1, required: l = () => !1, preprocess: p = (e) => e, postprocess: c = () => zt } = t || {};
      var h;
      (this._utils = { descriptor: n, logger: r || { warn: () => {} }, loggerPrintWidth: s, schemas: ur(e, 'name'), normalizeDefaultResult: pr, normalizeExpectedResult: cr, normalizeDeprecatedResult: dr, normalizeForwardResult: mr, normalizeRedirectResult: yr, normalizeValidateResult: hr }),
       (this._unknownHandler = i),
       (this._invalidHandler =
        ((h = a),
        (...e) => {
         let t = h(...e);
         return 'string' == typeof t ? new Error(t) : t;
        })),
       (this._deprecatedHandler = o),
       (this._identifyMissing = (e, t) => !(e in t) || u(e, t)),
       (this._identifyRequired = l),
       (this._preprocess = p),
       (this._postprocess = c),
       this.cleanHistory();
     }
     cleanHistory() {
      this._hasDeprecationWarned = (function () {
       let e = Object.create(null);
       return (t) => {
        let r = JSON.stringify(t);
        return !!e[r] || ((e[r] = !0), !1);
       };
      })();
     }
     normalize(e) {
      let t = {},
       r = [this._preprocess(e, this._utils)],
       s = () => {
        for (; 0 !== r.length; ) {
         let e = r.shift(),
          s = this._applyNormalization(e, t);
         r.push(...s);
        }
       };
      s();
      for (let n of Object.keys(this._utils.schemas)) {
       let e = this._utils.schemas[n];
       if (!(n in t)) {
        let t = pr(e.default(this._utils));
        'value' in t && r.push({ [n]: t.value });
       }
      }
      s();
      for (let n of Object.keys(this._utils.schemas)) {
       if (!(n in t)) continue;
       let e = this._utils.schemas[n],
        r = t[n],
        s = e.postprocess(r, this._utils);
       s !== zt && (this._applyValidation(s, n, e), (t[n] = s));
      }
      return this._applyPostprocess(t), this._applyRequiredCheck(t), t;
     }
     _applyNormalization(e, t) {
      let r = [],
       { knownKeys: s, unknownKeys: n } = this._partitionOptionKeys(e);
      for (let i of s) {
       let s = this._utils.schemas[i],
        n = s.preprocess(e[i], this._utils);
       this._applyValidation(n, i, s);
       let a = ({ from: e, to: t }) => {
         r.push('string' == typeof t ? { [t]: e } : { [t.key]: t.value });
        },
        o = ({ value: e, redirectTo: t }) => {
         let r = dr(s.deprecated(e, this._utils), n, !0);
         if (!1 !== r)
          if (!0 === r) this._hasDeprecationWarned(i) || this._utils.logger.warn(this._deprecatedHandler(i, t, this._utils));
          else
           for (let { value: s } of r) {
            let e = { key: i, value: s };
            if (!this._hasDeprecationWarned(e)) {
             let r = 'string' == typeof t ? { key: t, value: s } : t;
             this._utils.logger.warn(this._deprecatedHandler(e, r, this._utils));
            }
           }
        };
       mr(s.forward(n, this._utils), n).forEach(a);
       let u = yr(s.redirect(n, this._utils), n);
       if ((u.redirect.forEach(a), 'remain' in u)) {
        let e = u.remain;
        (t[i] = i in t ? s.overlap(t[i], e, this._utils) : e), o({ value: e });
       }
       for (let { from: e, to: t } of u.redirect) o({ value: e, redirectTo: t });
      }
      for (let i of n) {
       let s = e[i];
       this._applyUnknownHandler(i, s, t, (e, t) => {
        r.push({ [e]: t });
       });
      }
      return r;
     }
     _applyRequiredCheck(e) {
      for (let t of Object.keys(this._utils.schemas)) if (this._identifyMissing(t, e) && this._identifyRequired(t)) throw this._invalidHandler(t, Wt, this._utils);
     }
     _partitionOptionKeys(e) {
      let [t, r] = (function (e, t) {
       let r = [],
        s = [];
       for (let n of e) t(n) ? r.push(n) : s.push(n);
       return [r, s];
      })(
       Object.keys(e).filter((t) => !this._identifyMissing(t, e)),
       (e) => e in this._utils.schemas,
      );
      return { knownKeys: t, unknownKeys: r };
     }
     _applyValidation(e, t, r) {
      let s = hr(r.validate(e, this._utils), e);
      if (!0 !== s) throw this._invalidHandler(t, s.value, this._utils);
     }
     _applyUnknownHandler(e, t, r, s) {
      let n = this._unknownHandler(e, t, this._utils);
      if (n)
       for (let i of Object.keys(n)) {
        if (this._identifyMissing(i, n)) continue;
        let e = n[i];
        i in this._utils.schemas ? s(i, e) : (r[i] = e);
       }
     }
     _applyPostprocess(e) {
      let t = this._postprocess(e, this._utils);
      if (t !== zt) {
       if (t.delete) for (let r of t.delete) delete e[r];
       if (t.override) {
        let { knownKeys: r, unknownKeys: s } = this._partitionOptionKeys(t.override);
        for (let n of r) {
         let r = t.override[n];
         this._applyValidation(r, n, this._utils.schemas[n]), (e[n] = r);
        }
        for (let n of s) {
         let r = t.override[n];
         this._applyUnknownHandler(n, r, e, (t, r) => {
          let s = this._utils.schemas[t];
          this._applyValidation(r, t, s), (e[t] = r);
         });
        }
       }
      }
     }
    };
   function wr(e, { isCLI: t, optionInfos: r, FlagSchema: s }) {
    let n,
     { name: i } = e,
     a = { name: i },
     o = {};
    switch (e.type) {
     case 'int':
      (n = Er), t && (a.preprocess = Number);
      break;
     case 'string':
     case 'path':
      n = br;
      break;
     case 'choice':
      (n = gr), (a.choices = e.choices.map((t) => (null != t && t.redirect ? { ...t, redirect: { to: { key: e.name, value: t.redirect } } } : t)));
      break;
     case 'boolean':
      n = or;
      break;
     case 'flag':
      (n = s), (a.flags = r.flatMap((e) => [e.alias, e.description && e.name, e.oppositeDescription && `no-${e.name}`].filter(Boolean)));
      break;
     default:
      throw new Error(`Unexpected type ${e.type}`);
    }
    if ((e.exception ? (a.validate = (t, r, s) => e.exception(t) || r.validate(t, s)) : (a.validate = (e, t, r) => void 0 === e || t.validate(e, r)), e.redirect && (o.redirect = (t) => (t ? { to: 'string' == typeof e.redirect ? e.redirect : { key: e.redirect.option, value: e.redirect.value } } : void 0)), e.deprecated && (o.deprecated = !0), t && !e.array)) {
     let e = a.preprocess || ((e) => e);
     a.preprocess = (t, r, s) => r.preprocess(e(Array.isArray(t) ? ee(!1, t, -1) : t), s);
    }
    return e.array ? ir.create({ ...(t ? { preprocess: (e) => (Array.isArray(e) ? e : [e]) } : {}), ...o, valueSchema: n.create(a) }) : n.create({ ...a, ...o });
   }
   var Sr = function (e, t, { logger: r = !1, isCLI: s = !1, passThrough: n = !1, FlagSchema: i, descriptor: a } = {}) {
     if (s) {
      if (!i) throw new Error("'FlagSchema' option is required.");
      if (!a) throw new Error("'descriptor' option is required.");
     } else a = $t;
     let o = n
       ? Array.isArray(n)
         ? (e, t) => (n.includes(e) ? { [e]: t } : void 0)
         : (e, t) => ({ [e]: t })
       : (e, t, r) => {
          let { _: s, ...n } = r.schemas;
          return Zt(e, t, { ...r, schemas: n });
         },
      u = (function (e, { isCLI: t, FlagSchema: r }) {
       let s = [];
       t && s.push(nr.create({ name: '_' }));
       for (let n of e) s.push(wr(n, { isCLI: t, optionInfos: e, FlagSchema: r })), n.alias && t && s.push(sr.create({ name: n.alias, sourceName: n.name }));
       return s;
      })(t, { isCLI: s, FlagSchema: i }),
      l = new Fr(u, { logger: r, unknown: o, descriptor: a }),
      p = !1 !== r;
     p && Dr && (l._hasDeprecationWarned = Dr);
     let c = l.normalize(e);
     return p && (Dr = l._hasDeprecationWarned), c;
    },
    Pr = (e, t, r) => {
     if (!e || null != t) {
      if (t.findLast) return t.findLast(r);
      for (let e = t.length - 1; e >= 0; e--) {
       let s = t[e];
       if (r(s, e, t)) return s;
      }
     }
    };
   function kr(e, t) {
    if (!t) throw new Error('parserName is required.');
    let r = Pr(!1, e, (e) => e.parsers && Object.prototype.hasOwnProperty.call(e.parsers, t));
    if (r) return r;
    let s = `Couldn't resolve parser "${t}".`;
    throw ((s += ' Plugins must be explicitly added to the standalone bundle.'), new Bt(s));
   }
   function Ir({ plugins: e, parser: t }) {
    return Nr(kr(e, t), t);
   }
   function Nr(e, t) {
    let r = e.parsers[t];
    return 'function' == typeof r ? r() : r;
   }
   var Br = { astFormat: 'estree', printer: {}, originalText: void 0, locStart: null, locEnd: null };
   var Or = async function (e, t = {}) {
     var r;
     let s = { ...e };
     if (!s.parser) {
      if (!s.filepath) throw new Ot("No parser and no file path given, couldn't infer a parser.");
      if (((s.parser = Ut(s, { physicalFile: s.filepath })), !s.parser)) throw new Ot(`No parser could be inferred for file "${s.filepath}".`);
     }
     let n = Mt({ plugins: e.plugins, showDeprecated: !0 }).options,
      i = { ...Br, ...Object.fromEntries(n.filter((e) => void 0 !== e.default).map((e) => [e.name, e.default])) },
      a = kr(s.plugins, s.parser),
      o = await Nr(a, s.parser);
     (s.astFormat = o.astFormat), (s.locEnd = o.locEnd), (s.locStart = o.locStart);
     let u =
       null != (r = a.printers) && r[o.astFormat]
        ? a
        : (function (e, t) {
           if (!t) throw new Error('astFormat is required.');
           let r = Pr(!1, e, (e) => e.printers && Object.prototype.hasOwnProperty.call(e.printers, t));
           if (r) return r;
           let s = `Couldn't find plugin for AST format "${t}".`;
           throw ((s += ' Plugins must be explicitly added to the standalone bundle.'), new Bt(s));
          })(s.plugins, o.astFormat),
      l = await (function (e, t) {
       let r = e.printers[t];
       return 'function' == typeof r ? r() : r;
      })(u, o.astFormat);
     s.printer = l;
     let p = { ...i, ...(u.defaultOptions ? Object.fromEntries(Object.entries(u.defaultOptions).filter(([, e]) => void 0 !== e)) : {}) };
     for (let [c, h] of Object.entries(p)) (null === s[c] || void 0 === s[c]) && (s[c] = h);
     return 'json' === s.parser && (s.trailingComma = 'none'), Sr(s, n, { passThrough: Object.keys(Br), ...t });
    },
    Lr = h(m(), 1);
   var Mr = async function (e, t) {
    let r,
     s = await Ir(t),
     n = s.preprocess ? s.preprocess(e, t) : e;
    t.originalText = n;
    try {
     r = await s.parse(n, t, t);
    } catch (i) {
     !(function (e, t) {
      let { loc: r } = e;
      if (r) {
       let s = (0, Lr.codeFrameColumns)(t, r, { highlightCode: !0 });
       throw ((e.message += '\n' + s), (e.codeFrame = s), e);
      }
      throw e;
     })(i, e);
    }
    return { text: n, ast: r };
   };
   async function jr(e, t, r, s, n) {
    let {
     embeddedLanguageFormatting: i,
     printer: { embed: a, hasPrettierIgnore: o = () => !1, getVisitorKeys: u },
    } = r;
    if (!a || 'auto' !== i) return;
    if (a.length > 2) throw new Error('printer.embed has too many parameters. The API changed in Prettier v3. Please update your plugin. See https://prettier.io/docs/en/plugins.html#optional-embed');
    let l = mt(a.getVisitorKeys ?? u),
     p = [];
    !(function t() {
     let { node: s } = e;
     if (null === s || 'object' != typeof s || o(e)) return;
     for (let r of l(s)) Array.isArray(s[r]) ? e.each(t, r) : e.call(t, r);
     let i = a(e, r);
     if (i) {
      if ('function' == typeof i) return void p.push({ print: i, node: s, pathStack: [...e.stack] });
      n.set(s, i);
     }
    })();
    let c = e.stack;
    for (let { print: f, node: m, pathStack: y } of p)
     try {
      e.stack = y;
      let s = await f(h, t, e, r);
      s && n.set(m, s);
     } catch (d) {
      if (globalThis.PRETTIER_DEBUG) throw d;
     }
    function h(e, t) {
     return (async function (e, t, r, s) {
      let n = await Or({ ...r, ...t, parentParser: r.parser, originalText: e }, { passThrough: !0 }),
       { ast: i } = await Mr(e, n),
       a = await s(i, n);
      return de(a);
     })(e, t, r, s);
    }
    e.stack = c;
   }
   var _r = function (e, t) {
    let { originalText: r, [Symbol.for('comments')]: s, locStart: n, locEnd: i, [Symbol.for('printedComments')]: a } = t,
     { node: o } = e,
     u = n(o),
     l = i(o);
    for (let p of s) n(p) >= u && i(p) <= l && a.add(p);
    return r.slice(u, l);
   };
   async function Rr(e, t) {
    ({ ast: e } = await $r(e, t));
    let r = new Map(),
     s = new et(e),
     n = Nt(t),
     i = new Map();
    await jr(s, o, t, Rr, i);
    let a = await Ur(s, t, o, void 0, i);
    return (
     (function (e) {
      let { [Symbol.for('comments')]: t, [Symbol.for('printedComments')]: r } = e;
      for (let s of t) {
       if (!s.printed && !r.has(s)) throw new Error('Comment "' + s.value.trim() + '" was not printed. Please report this error!');
       delete s.printed;
      }
     })(t),
     t.nodeAfterCursor && !t.nodeBeforeCursor ? [Be, a] : t.nodeBeforeCursor && !t.nodeAfterCursor ? [a, Be] : a
    );
    function o(e, t) {
     return void 0 === e || e === s ? u(t) : Array.isArray(e) ? s.call(() => u(t), ...e) : s.call(() => u(t), e);
    }
    function u(e) {
     n(s);
     let a = s.node;
     if (null == a) return '';
     let u = a && 'object' == typeof a && void 0 === e;
     if (u && r.has(a)) return r.get(a);
     let l = Ur(s, t, o, e, i);
     return u && r.set(a, l), l;
    }
   }
   function Ur(e, t, r, s, n) {
    var i;
    let a,
     { node: o } = e,
     { printer: u } = t;
    switch (((a = null != (i = u.hasPrettierIgnore) && i.call(u, e) ? _r(e, t) : n.has(o) ? n.get(o) : u.print(e, t, r, s)), o)) {
     case t.cursorNode:
      a = me(a, (e) => [Be, e, Be]);
      break;
     case t.nodeBeforeCursor:
      a = me(a, (e) => [e, Be]);
      break;
     case t.nodeAfterCursor:
      a = me(a, (e) => [Be, e]);
    }
    return (
     u.printComment &&
      (!u.willPrintOwnComments || !u.willPrintOwnComments(e, t)) &&
      (a = (function (e, t, r) {
       let { leading: s, trailing: n } = It(e, r);
       return s || n ? me(t, (e) => [s, e, n]) : t;
      })(e, a, t)),
     a
    );
   }
   async function $r(e, t) {
    let r = e.comments ?? [];
    (t[Symbol.for('comments')] = r),
     (t[Symbol.for('tokens')] = e.tokens ?? []),
     (t[Symbol.for('printedComments')] = new Set()),
     (function (e, t) {
      let { comments: r } = e;
      if ((delete e.comments, !ht(r) || !t.printer.canAttachComment)) return;
      let s = [],
       {
        locStart: n,
        locEnd: i,
        printer: { experimentalFeatures: { avoidAstMutation: a = !1 } = {}, handleComments: o = {} },
        originalText: u,
       } = t,
       { ownLine: l = At, endOfLine: p = At, remaining: c = At } = o,
       h = r.map((s, n) => ({ ...Tt(e, s, t), comment: s, text: u, options: t, ast: e, isLastComment: r.length - 1 === n }));
      for (let [d, f] of h.entries()) {
       let e,
        { comment: t, precedingNode: r, enclosingNode: o, followingNode: u, text: m, options: y, ast: D, isLastComment: g } = f;
       if ('json' === y.parser || 'json5' === y.parser || 'jsonc' === y.parser || '__js_expression' === y.parser || '__ts_expression' === y.parser || '__vue_expression' === y.parser || '__vue_ts_expression' === y.parser) {
        if (n(t) - n(D) <= 0) {
         Dt(D, t);
         continue;
        }
        if (i(t) - i(D) >= 0) {
         xt(D, t);
         continue;
        }
       }
       if ((a ? (e = [f]) : ((t.enclosingNode = o), (t.precedingNode = r), (t.followingNode = u), (e = [t, m, y, D, g])), vt(m, y, h, d))) (t.placement = 'ownLine'), l(...e) || (u ? Dt(u, t) : r ? xt(r, t) : gt(o || D, t));
       else if (Ft(m, y, h, d)) (t.placement = 'endOfLine'), p(...e) || (r ? xt(r, t) : u ? Dt(u, t) : gt(o || D, t));
       else if (((t.placement = 'remaining'), !c(...e)))
        if (r && u) {
         let e = s.length;
         e > 0 && s[e - 1].followingNode !== u && wt(s, y), s.push(f);
        } else r ? xt(r, t) : u ? Dt(u, t) : gt(o || D, t);
      }
      if ((wt(s, t), !a)) for (let d of r) delete d.precedingNode, delete d.enclosingNode, delete d.followingNode;
     })(e, t);
    let {
     printer: { preprocess: s },
    } = t;
    return { ast: (e = s ? await s(e, t) : e), comments: r };
   }
   var qr = function (e, t) {
    let { cursorOffset: r, locStart: s, locEnd: n } = t,
     i = mt(t.printer.getVisitorKeys),
     a = (e) => s(e) <= r && n(e) >= r,
     o = e,
     u = [e];
    for (let d of (function* (e, t) {
     let r = [e];
     for (let s = 0; s < r.length; s++) {
      let e = r[s];
      for (let s of nt(e, t)) yield s, r.push(s);
     }
    })(e, { getVisitorKeys: i, filter: a }))
     u.push(d), (o = d);
    if (
     (function (e, t) {
      return nt(e, t).next().done;
     })(o, { getVisitorKeys: i })
    )
     return { cursorNode: o };
    let l,
     p,
     c = -1,
     h = Number.POSITIVE_INFINITY;
    for (; u.length > 0 && (void 0 === l || void 0 === p); ) {
     o = u.pop();
     let e = void 0 !== l,
      t = void 0 !== p;
     for (let a of nt(o, { getVisitorKeys: i })) {
      if (!e) {
       let e = n(a);
       e <= r && e > c && ((l = a), (c = e));
      }
      if (!t) {
       let e = s(a);
       e >= r && e < h && ((p = a), (h = e));
      }
     }
    }
    return { nodeBeforeCursor: l, nodeAfterCursor: p };
   };
   var Jr = function (e, t) {
     let {
      printer: { massageAstNode: r, getVisitorKeys: s },
     } = t;
     if (!r) return e;
     let n = mt(s),
      i = r.ignoredProperties ?? new Set();
     return (function e(t, s) {
      if (null === t || 'object' != typeof t) return t;
      if (Array.isArray(t)) return t.map((t) => e(t, s)).filter(Boolean);
      let a = {},
       o = new Set(n(t));
      for (let r in t) !Object.prototype.hasOwnProperty.call(t, r) || i.has(r) || (o.has(r) ? (a[r] = e(t[r], t)) : (a[r] = t[r]));
      let u = r(t, a, s);
      if (null !== u) return u ?? a;
     })(e);
    },
    Wr = (e, t, r) => {
     if (!e || null != t) {
      if (t.findLastIndex) return t.findLastIndex(r);
      for (let e = t.length - 1; e >= 0; e--) {
       if (r(t[e], e, t)) return e;
      }
      return -1;
     }
    },
    zr = ({ parser: e }) => 'json' === e || 'json5' === e || 'jsonc' === e || 'json-stringify' === e;
   function Vr(e) {
    let t = Wr(!1, e, (e) => 'Program' !== e.type && 'File' !== e.type);
    return -1 === t ? e : e.slice(0, t + 1);
   }
   function Hr(e, t, r, s, n = [], i) {
    let { locStart: a, locEnd: o } = r,
     u = a(e),
     l = o(e);
    if (!(t > l || t < u || ('rangeEnd' === i && t === u) || ('rangeStart' === i && t === l))) {
     for (let a of bt(e, r)) {
      let o = Hr(a, t, r, s, [e, ...n], i);
      if (o) return o;
     }
     if (!s || s(e, n[0])) return { node: e, parentNodes: n };
    }
   }
   var Kr = new Set(['JsonRoot', 'ObjectExpression', 'ArrayExpression', 'StringLiteral', 'NumericLiteral', 'BooleanLiteral', 'NullLiteral', 'UnaryExpression', 'TemplateLiteral']),
    Xr = new Set(['OperationDefinition', 'FragmentDefinition', 'VariableDefinition', 'TypeExtensionDefinition', 'ObjectTypeDefinition', 'FieldDefinition', 'DirectiveDefinition', 'EnumTypeDefinition', 'EnumValueDefinition', 'InputValueDefinition', 'InputObjectTypeDefinition', 'SchemaDefinition', 'OperationTypeDefinition', 'InterfaceTypeDefinition', 'UnionTypeDefinition', 'ScalarTypeDefinition']);
   function Gr(e, t, r) {
    if (!t) return !1;
    switch (e.parser) {
     case 'flow':
     case 'babel':
     case 'babel-flow':
     case 'babel-ts':
     case 'typescript':
     case 'acorn':
     case 'espree':
     case 'meriyah':
     case '__babel_estree':
      return (function (e, t) {
       return 'DeclareExportDeclaration' !== t && 'TypeParameterDeclaration' !== e && ('Directive' === e || 'TypeAlias' === e || 'TSExportAssignment' === e || e.startsWith('Declare') || e.startsWith('TSDeclare') || e.endsWith('Statement') || e.endsWith('Declaration'));
      })(t.type, null == r ? void 0 : r.type);
     case 'json':
     case 'json5':
     case 'jsonc':
     case 'json-stringify':
      return Kr.has(t.type);
     case 'graphql':
      return Xr.has(t.kind);
     case 'vue':
      return 'root' !== t.tag;
    }
    return !1;
   }
   function Yr(e, t, r) {
    let { rangeStart: s, rangeEnd: n, locStart: i, locEnd: a } = t;
    rt.ok(n > s);
    let o = e.slice(s, n).search(/\S/u),
     u = -1 === o;
    if (!u) for (s += o; n > s && !/\S/u.test(e[n - 1]); --n);
    let l,
     p,
     c = Hr(r, s, t, (e, r) => Gr(t, e, r), [], 'rangeStart'),
     h = u ? c : Hr(r, n, t, (e) => Gr(t, e), [], 'rangeEnd');
    if (!c || !h) return { rangeStart: 0, rangeEnd: 0 };
    if (zr(t)) {
     let e = (function (e, t) {
      let r = [e.node, ...e.parentNodes],
       s = new Set([t.node, ...t.parentNodes]);
      return r.find((e) => Kr.has(e.type) && s.has(e));
     })(c, h);
     (l = e), (p = e);
    } else
     ({ startNode: l, endNode: p } = (function (e, t, { locStart: r, locEnd: s }) {
      let n = e.node,
       i = t.node;
      if (n === i) return { startNode: n, endNode: i };
      let a = r(e.node);
      for (let u of Vr(t.parentNodes)) {
       if (!(r(u) >= a)) break;
       i = u;
      }
      let o = s(t.node);
      for (let u of Vr(e.parentNodes)) {
       if (!(s(u) <= o)) break;
       if (((n = u), n === i)) break;
      }
      return { startNode: n, endNode: i };
     })(c, h, t));
    return { rangeStart: Math.min(i(l), i(p)), rangeEnd: Math.max(a(l), a(p)) };
   }
   var Qr = '\ufeff',
    Zr = Symbol('cursor');
   async function es(e, t, r = 0) {
    if (!e || 0 === e.trim().length) return { formatted: '', cursorOffset: -1, comments: [] };
    let { ast: s, text: n } = await Mr(e, t);
    t.cursorOffset >= 0 && (t = { ...t, ...qr(s, t) });
    let i = await Rr(s, t);
    r > 0 && (i = Le([Ie, i], r, t.tabWidth));
    let a = Xe(i, t);
    if (r > 0) {
     let e = a.formatted.trim();
     void 0 !== a.cursorNodeStart && ((a.cursorNodeStart -= a.formatted.indexOf(e)), a.cursorNodeStart < 0 && ((a.cursorNodeStart = 0), (a.cursorNodeText = a.cursorNodeText.trimStart())), a.cursorNodeStart + a.cursorNodeText.length > e.length && (a.cursorNodeText = a.cursorNodeText.trimEnd())), (a.formatted = e + M(t.endOfLine));
    }
    let o = t[Symbol.for('comments')];
    if (t.cursorOffset >= 0) {
     let e, r, s, i;
     if ((t.cursorNode || t.nodeBeforeCursor || t.nodeAfterCursor) && a.cursorNodeText)
      if (((s = a.cursorNodeStart), (i = a.cursorNodeText), t.cursorNode)) (e = t.locStart(t.cursorNode)), (r = n.slice(e, t.locEnd(t.cursorNode)));
      else {
       if (!t.nodeBeforeCursor && !t.nodeAfterCursor) throw new Error('Cursor location must contain at least one of cursorNode, nodeBeforeCursor, nodeAfterCursor');
       e = t.nodeBeforeCursor ? t.locEnd(t.nodeBeforeCursor) : 0;
       let s = t.nodeAfterCursor ? t.locStart(t.nodeAfterCursor) : n.length;
       r = n.slice(e, s);
      }
     else (e = 0), (r = n), (s = 0), (i = a.formatted);
     let u = t.cursorOffset - e;
     if (r === i) return { formatted: a.formatted, cursorOffset: s + u, comments: o };
     let l = r.split('');
     l.splice(u, 0, Zr);
     let p = (function (e, t, r) {
       return L.diff(e, t, r);
      })(l, i.split('')),
      c = s;
     for (let t of p)
      if (t.removed) {
       if (t.value.includes(Zr)) break;
      } else c += t.count;
     return { formatted: a.formatted, cursorOffset: c, comments: o };
    }
    return { formatted: a.formatted, cursorOffset: -1, comments: o };
   }
   function ts(e, t, r) {
    return 'number' != typeof t || Number.isNaN(t) || t < 0 || t > e.length ? r : t;
   }
   function rs(e, t) {
    let { cursorOffset: r, rangeStart: s, rangeEnd: n } = t;
    return (r = ts(e, r, -1)), (s = ts(e, s, 0)), (n = ts(e, n, e.length)), { ...t, cursorOffset: r, rangeStart: s, rangeEnd: n };
   }
   function ss(e, t) {
    let { cursorOffset: r, rangeStart: s, rangeEnd: n, endOfLine: i } = rs(e, t),
     a = e.charAt(0) === Qr;
    if (
     (a && ((e = e.slice(1)), r--, s--, n--),
     'auto' === i &&
      (i = (function (e) {
       let t = e.indexOf('\r');
       return -1 !== t ? ('\n' === e.charAt(t + 1) ? 'crlf' : 'cr') : 'lf';
      })(e)),
     e.includes('\r'))
    ) {
     let t = (t) => j(e.slice(0, Math.max(t, 0)), '\r\n');
     (r -= t(r)),
      (s -= t(s)),
      (n -= t(n)),
      (e = (function (e) {
       return D(!1, e, /\r\n?/gu, '\n');
      })(e));
    }
    return { hasBOM: a, text: e, options: rs(e, { ...t, cursorOffset: r, rangeStart: s, rangeEnd: n, endOfLine: i }) };
   }
   async function ns(e, t) {
    let r = await Ir(t);
    return !r.hasPragma || r.hasPragma(e);
   }
   async function is(e, t) {
    let r,
     { hasBOM: s, text: n, options: i } = ss(e, await Or(t));
    return (i.rangeStart >= i.rangeEnd && '' !== n) || (i.requirePragma && !(await ns(n, i)))
     ? { formatted: e, cursorOffset: t.cursorOffset, comments: [] }
     : (i.rangeStart > 0 || i.rangeEnd < n.length
        ? (r = await (async function (e, t) {
           let { ast: r, text: s } = await Mr(e, t),
            { rangeStart: n, rangeEnd: i } = Yr(s, t, r),
            a = s.slice(n, i),
            o = Math.min(n, s.lastIndexOf('\n', n) + 1),
            u = s.slice(o, n).match(/^\s*/u)[0],
            l = Ze(u, t.tabWidth),
            p = await es(a, { ...t, rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: t.cursorOffset > n && t.cursorOffset <= i ? t.cursorOffset - n : -1, endOfLine: 'lf' }, l),
            c = p.formatted.trimEnd(),
            { cursorOffset: h } = t;
           h > i ? (h += c.length - a.length) : p.cursorOffset >= 0 && (h = p.cursorOffset + n);
           let d = s.slice(0, n) + c + s.slice(i);
           if ('lf' !== t.endOfLine) {
            let e = M(t.endOfLine);
            h >= 0 && '\r\n' === e && (h += j(d.slice(0, h), '\n')), (d = D(!1, d, '\n', e));
           }
           return { formatted: d, cursorOffset: h, comments: p.comments };
          })(n, i))
        : (!i.requirePragma && i.insertPragma && i.printer.insertPragma && !(await ns(n, i)) && (n = i.printer.insertPragma(n)), (r = await es(n, i))),
       s && ((r.formatted = Qr + r.formatted), r.cursorOffset >= 0 && r.cursorOffset++),
       r);
   }
   var as = {};
   c(as, { builders: () => os, printer: () => us, utils: () => ls });
   var os = {
     join: Oe,
     line: Pe,
     softline: ke,
     hardline: Ie,
     literalline: Ne,
     group: Te,
     conditionalGroup: function (e, t) {
      return Te(e[0], { ...t, expandedStates: e });
     },
     fill: function (e) {
      return xe(e), { type: z, parts: e };
     },
     lineSuffix: Ae,
     lineSuffixBoundary: Ce,
     cursor: Be,
     breakParent: ve,
     ifBreak: function (e, t = '', r = {}) {
      return De(e), '' !== t && De(t), { type: V, breakContents: e, flatContents: t, groupId: r.groupId };
     },
     trim: Fe,
     indent: Ee,
     indentIfBreak: function (e, t) {
      return De(e), { type: H, contents: e, groupId: t.groupId, negate: t.negate };
     },
     align: be,
     addAlignmentToDoc: Le,
     markAsRoot: function (e) {
      return be({ type: 'root' }, e);
     },
     dedentToRoot: function (e) {
      return be(Number.NEGATIVE_INFINITY, e);
     },
     dedent: function (e) {
      return be(-1, e);
     },
     hardlineWithoutBreakParent: we,
     literallineWithoutBreakParent: Se,
     label: function (e, t) {
      return De(t), e ? { type: Y, label: e, contents: t } : t;
     },
     concat: (e) => e,
    },
    us = { printDocToString: Xe },
    ls = {
     willBreak: function (e) {
      return oe(e, ue, !1);
     },
     traverseDoc: ie,
     findInDoc: oe,
     mapDoc: ae,
     removeLines: function (e) {
      return ae(e, pe);
     },
     stripTrailingHardline: de,
     replaceEndOfLine: function (e, t = Ne) {
      return ae(e, (e) => ('string' == typeof e ? Oe(t, e.split('\n')) : e));
     },
     canBreak: function (e) {
      return oe(e, fe, !1);
     },
    },
    ps = '3.5.1',
    cs = {};
   c(cs, { addDanglingComment: () => gt, addLeadingComment: () => Dt, addTrailingComment: () => xt, getAlignmentSize: () => Ze, getIndentSize: () => ys, getMaxContinuousCount: () => Ds, getNextNonSpaceNonCommentCharacter: () => gs, getNextNonSpaceNonCommentCharacterIndex: () => Cs, getPreferredQuote: () => Es, getStringWidth: () => Re, hasNewline: () => ct, hasNewlineInRange: () => bs, hasSpaces: () => Ts, isNextLineEmpty: () => Fs, isNextLineEmptyAfterIndex: () => ms, isPreviousLineEmpty: () => vs, makeString: () => As, skip: () => it, skipEverythingButNewLine: () => lt, skipInlineComment: () => hs, skipNewline: () => pt, skipSpaces: () => ot, skipToLineEnd: () => ut, skipTrailingComment: () => ds, skipWhitespace: () => at });
   var hs = function (e, t) {
    if (!1 === t) return !1;
    if ('/' === e.charAt(t) && '*' === e.charAt(t + 1)) for (let r = t + 2; r < e.length; ++r) if ('*' === e.charAt(r) && '/' === e.charAt(r + 1)) return r + 2;
    return t;
   };
   var ds = function (e, t) {
    return !1 !== t && ('/' === e.charAt(t) && '/' === e.charAt(t + 1) ? lt(e, t) : t);
   };
   var fs = function (e, t) {
    let r = null,
     s = t;
    for (; s !== r; ) (r = s), (s = ot(e, s)), (s = hs(e, s)), (s = ds(e, s)), (s = pt(e, s));
    return s;
   };
   var ms = function (e, t) {
    let r = null,
     s = t;
    for (; s !== r; ) (r = s), (s = ut(e, s)), (s = hs(e, s)), (s = ot(e, s));
    return (s = ds(e, s)), (s = pt(e, s)), !1 !== s && ct(e, s);
   };
   var ys = function (e, t) {
    let r = e.lastIndexOf('\n');
    return -1 === r ? 0 : Ze(e.slice(r + 1).match(/^[\t ]*/u)[0], t);
   };
   var Ds = function (e, t) {
    let r = e.match(
     new RegExp(
      `(${(function (e) {
       if ('string' != typeof e) throw new TypeError('Expected a string');
       return e.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&').replace(/-/g, '\\x2d');
      })(t)})+`,
      'gu',
     ),
    );
    return null === r ? 0 : r.reduce((e, r) => Math.max(e, r.length / t.length), 0);
   };
   var gs = function (e, t) {
     let r = fs(e, t);
     return !1 === r ? '' : e.charAt(r);
    },
    xs = "'";
   var Es = function (e, t) {
    let r = !0 === t || t === xs ? xs : '"',
     s = r === xs ? '"' : xs,
     n = 0,
     i = 0;
    for (let a of e) a === r ? n++ : a === s && i++;
    return n > i ? s : r;
   };
   var bs = function (e, t, r) {
    for (let s = t; s < r; ++s) if ('\n' === e.charAt(s)) return !0;
    return !1;
   };
   var Ts = function (e, t, r = {}) {
    return ot(e, r.backwards ? t - 1 : t, r) !== t;
   };
   var As = function (e, t, r) {
    let s = '"' === t ? "'" : '"',
     n = D(!1, e, /\\(.)|(["'])/gsu, (e, n, i) => (n === s ? n : i === t ? '\\' + i : i || (r && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/u.test(n) ? n : '\\' + n)));
    return t + n + t;
   };
   function Cs(e, t) {
    return 2 === arguments.length || 'number' == typeof t
     ? fs(e, t)
     : (function (e, t, r) {
        return fs(e, r(t));
       })(...arguments);
   }
   function vs(e, t) {
    return 2 === arguments.length || 'number' == typeof t
     ? Pt(e, t)
     : (function (e, t, r) {
        return Pt(e, r(t));
       })(...arguments);
   }
   function Fs(e, t) {
    return 2 === arguments.length || 'number' == typeof t
     ? ms(e, t)
     : (function (e, t, r) {
        return ms(e, r(t));
       })(...arguments);
   }
   function ws(e, t = 1) {
    return async (...r) => {
     let s = r[t] ?? {},
      n = s.plugins ?? [];
     return (r[t] = { ...s, plugins: Array.isArray(n) ? n : Object.values(n) }), e(...r);
    };
   }
   var Ss = ws(is);
   async function Ps(e, t) {
    let { formatted: r } = await Ss(e, { ...t, cursorOffset: -1 });
    return r;
   }
   async function ks(e, t) {
    return (await Ps(e, t)) === e;
   }
   var Is = ws(Mt, 0),
    Ns = {
     parse: ws(async function (e, t, r) {
      let { text: s, options: n } = ss(e, await Or(t)),
       i = await Mr(s, n);
      return r && (r.preprocessForPrint && (i.ast = await $r(i.ast, n)), r.massage && (i.ast = Jr(i.ast, n))), i;
     }),
     formatAST: ws(async function (e, t) {
      return (t = await Or(t)), Xe(await Rr(e, t), t);
     }),
     formatDoc: ws(async function (e, t) {
      let r = (function (e) {
        let t = Object.create(null),
         r = new Set();
        return (function e(t, r, n) {
         var i, a;
         if ('string' == typeof t) return JSON.stringify(t);
         if (Array.isArray(t)) {
          let r = t.map(e).filter(Boolean);
          return 1 === r.length ? r[0] : `[${r.join(', ')}]`;
         }
         if (t.type === G) {
          let e = (null == (i = null == n ? void 0 : n[r + 1]) ? void 0 : i.type) === Q;
          return t.literal ? (e ? 'literalline' : 'literallineWithoutBreakParent') : t.hard ? (e ? 'hardline' : 'hardlineWithoutBreakParent') : t.soft ? 'softline' : 'line';
         }
         if (t.type === Q) return (null == (a = null == n ? void 0 : n[r - 1]) ? void 0 : a.type) === G && n[r - 1].hard ? void 0 : 'breakParent';
         if (t.type === J) return 'trim';
         if (t.type === $) return 'indent(' + e(t.contents) + ')';
         if (t.type === q) return t.n === Number.NEGATIVE_INFINITY ? 'dedentToRoot(' + e(t.contents) + ')' : t.n < 0 ? 'dedent(' + e(t.contents) + ')' : 'root' === t.n.type ? 'markAsRoot(' + e(t.contents) + ')' : 'align(' + JSON.stringify(t.n) + ', ' + e(t.contents) + ')';
         if (t.type === V) return 'ifBreak(' + e(t.breakContents) + (t.flatContents ? ', ' + e(t.flatContents) : '') + (t.groupId ? (t.flatContents ? '' : ', ""') + `, { groupId: ${s(t.groupId)} }` : '') + ')';
         if (t.type === H) {
          let r = [];
          t.negate && r.push('negate: true'), t.groupId && r.push(`groupId: ${s(t.groupId)}`);
          let n = r.length > 0 ? `, { ${r.join(', ')} }` : '';
          return `indentIfBreak(${e(t.contents)}${n})`;
         }
         if (t.type === W) {
          let r = [];
          t.break && 'propagated' !== t.break && r.push('shouldBreak: true'), t.id && r.push(`id: ${s(t.id)}`);
          let n = r.length > 0 ? `, { ${r.join(', ')} }` : '';
          return t.expandedStates ? `conditionalGroup([${t.expandedStates.map((t) => e(t)).join(',')}]${n})` : `group(${e(t.contents)}${n})`;
         }
         if (t.type === z) return `fill([${t.parts.map((t) => e(t)).join(', ')}])`;
         if (t.type === K) return 'lineSuffix(' + e(t.contents) + ')';
         if (t.type === X) return 'lineSuffixBoundary';
         if (t.type === Y) return `label(${JSON.stringify(t.label)}, ${e(t.contents)})`;
         throw new Error('Unknown doc type ' + t.type);
        })(Me(e));
        function s(e) {
         if ('symbol' != typeof e) return JSON.stringify(String(e));
         if (e in t) return t[e];
         let s = e.description || 'symbol';
         for (let n = 0; ; n++) {
          let i = s + (n > 0 ? ` #${n}` : '');
          if (!r.has(i)) return r.add(i), (t[e] = `Symbol.for(${JSON.stringify(i)})`);
         }
        }
       })(e),
       { formatted: s } = await is(r, { ...t, parser: '__js_expression' });
      return s;
     }),
     printToDoc: ws(async function (e, t) {
      t = await Or(t);
      let { ast: r } = await Mr(e, t);
      return Rr(r, t);
     }),
     printDocToString: ws(async function (e, t) {
      return Xe(e, await Or(t));
     }),
    },
    Bs = y;
  },
 },
]);
