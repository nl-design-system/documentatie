/*! For license information please see 86069.e856251c.js.LICENSE.txt */
'use strict';
(globalThis.webpackChunk_nl_design_system_website = globalThis.webpackChunk_nl_design_system_website || []).push([
 [86069],
 {
  9016(e, t, r) {
   r.d(t, { Ay: () => i });
   var s = Object.defineProperty,
    n = (e, t) => {
     for (var r in t) s(e, r, { get: t[r], enumerable: !0 });
    },
    i = {};
   n(i, { languages: () => nu, options: () => ru, printers: () => su });
   var a = {};
   n(a, { canAttachComment: () => Ft, embed: () => an, features: () => zo, getVisitorKeys: () => K, handleComments: () => Fr, hasPrettierIgnore: () => oa, insertPragma: () => xn, isBlockComment: () => Q, isGap: () => Ar, massageAstNode: () => bt, print: () => Vo, printComment: () => Tn, printPrettierIgnored: () => Vo, willPrintOwnComments: () => Sr });
   var o =
     (e, t) =>
     (r, s, ...n) =>
      1 | r && null == s ? void 0 : (t.call(s) ?? s[e]).apply(s, n),
    u =
     String.prototype.replaceAll ??
     function (e, t) {
      return e.global ? this.replace(e, t) : this.split(e).join(t);
     },
    l = o('replaceAll', function () {
     if ('string' == typeof this) return u;
    });
   function p(e) {
    return this[e < 0 ? this.length + e : e];
   }
   var c = o('at', function () {
    if (Array.isArray(this) || 'string' == typeof this) return p;
   });
   var h = function (e) {
    return null !== e && 'object' == typeof e;
   };
   function* d(e, t) {
    let { getVisitorKeys: r, filter: s = () => !0 } = t,
     n = (e) => h(e) && s(e);
    for (let i of r(e)) {
     let t = e[i];
     if (Array.isArray(t)) for (let e of t) n(e) && (yield e);
     else n(t) && (yield t);
    }
   }
   function f(e, { getVisitorKeys: t, predicate: r }) {
    for (let s of (function* (e, t) {
     let r = [e];
     for (let s = 0; s < r.length; s++) {
      let e = r[s];
      for (let s of d(e, t)) (yield s, r.push(s));
     }
    })(e, { getVisitorKeys: t }))
     if (r(s)) return !0;
    return !1;
   }
   function m(e) {
    return 12288 === e || (e >= 65281 && e <= 65376) || (e >= 65504 && e <= 65510);
   }
   function y(e) {
    return (e >= 4352 && e <= 4447) || 8986 === e || 8987 === e || 9001 === e || 9002 === e || (e >= 9193 && e <= 9196) || 9200 === e || 9203 === e || 9725 === e || 9726 === e || 9748 === e || 9749 === e || (e >= 9776 && e <= 9783) || (e >= 9800 && e <= 9811) || 9855 === e || (e >= 9866 && e <= 9871) || 9875 === e || 9889 === e || 9898 === e || 9899 === e || 9917 === e || 9918 === e || 9924 === e || 9925 === e || 9934 === e || 9940 === e || 9962 === e || 9970 === e || 9971 === e || 9973 === e || 9978 === e || 9981 === e || 9989 === e || 9994 === e || 9995 === e || 10024 === e || 10060 === e || 10062 === e || (e >= 10067 && e <= 10069) || 10071 === e || (e >= 10133 && e <= 10135) || 10160 === e || 10175 === e || 11035 === e || 11036 === e || 11088 === e || 11093 === e || (e >= 11904 && e <= 11929) || (e >= 11931 && e <= 12019) || (e >= 12032 && e <= 12245) || (e >= 12272 && e <= 12287) || (e >= 12289 && e <= 12350) || (e >= 12353 && e <= 12438) || (e >= 12441 && e <= 12543) || (e >= 12549 && e <= 12591) || (e >= 12593 && e <= 12686) || (e >= 12688 && e <= 12773) || (e >= 12783 && e <= 12830) || (e >= 12832 && e <= 12871) || (e >= 12880 && e <= 42124) || (e >= 42128 && e <= 42182) || (e >= 43360 && e <= 43388) || (e >= 44032 && e <= 55203) || (e >= 63744 && e <= 64255) || (e >= 65040 && e <= 65049) || (e >= 65072 && e <= 65106) || (e >= 65108 && e <= 65126) || (e >= 65128 && e <= 65131) || (e >= 94176 && e <= 94180) || (e >= 94192 && e <= 94198) || (e >= 94208 && e <= 101589) || (e >= 101631 && e <= 101662) || (e >= 101760 && e <= 101874) || (e >= 110576 && e <= 110579) || (e >= 110581 && e <= 110587) || 110589 === e || 110590 === e || (e >= 110592 && e <= 110882) || 110898 === e || (e >= 110928 && e <= 110930) || 110933 === e || (e >= 110948 && e <= 110951) || (e >= 110960 && e <= 111355) || (e >= 119552 && e <= 119638) || (e >= 119648 && e <= 119670) || 126980 === e || 127183 === e || 127374 === e || (e >= 127377 && e <= 127386) || (e >= 127488 && e <= 127490) || (e >= 127504 && e <= 127547) || (e >= 127552 && e <= 127560) || 127568 === e || 127569 === e || (e >= 127584 && e <= 127589) || (e >= 127744 && e <= 127776) || (e >= 127789 && e <= 127797) || (e >= 127799 && e <= 127868) || (e >= 127870 && e <= 127891) || (e >= 127904 && e <= 127946) || (e >= 127951 && e <= 127955) || (e >= 127968 && e <= 127984) || 127988 === e || (e >= 127992 && e <= 128062) || 128064 === e || (e >= 128066 && e <= 128252) || (e >= 128255 && e <= 128317) || (e >= 128331 && e <= 128334) || (e >= 128336 && e <= 128359) || 128378 === e || 128405 === e || 128406 === e || 128420 === e || (e >= 128507 && e <= 128591) || (e >= 128640 && e <= 128709) || 128716 === e || (e >= 128720 && e <= 128722) || (e >= 128725 && e <= 128728) || (e >= 128732 && e <= 128735) || 128747 === e || 128748 === e || (e >= 128756 && e <= 128764) || (e >= 128992 && e <= 129003) || 129008 === e || (e >= 129292 && e <= 129338) || (e >= 129340 && e <= 129349) || (e >= 129351 && e <= 129535) || (e >= 129648 && e <= 129660) || (e >= 129664 && e <= 129674) || (e >= 129678 && e <= 129734) || 129736 === e || (e >= 129741 && e <= 129756) || (e >= 129759 && e <= 129770) || (e >= 129775 && e <= 129784) || (e >= 131072 && e <= 196605) || (e >= 196608 && e <= 262141);
   }
   var D = /[^\x20-\x7F]/u,
    g = new Set('\xa9\xae\u203c\u2049\u2122\u2139\u2194\u2195\u2196\u2197\u2198\u2199\u21a9\u21aa\u2328\u23cf\u23f1\u23f2\u23f8\u23f9\u23fa\u25aa\u25ab\u25b6\u25c0\u25fb\u25fc\u2600\u2601\u2602\u2603\u2604\u260e\u2611\u2618\u261d\u2620\u2622\u2623\u2626\u262a\u262e\u262f\u2638\u2639\u263a\u2640\u2642\u265f\u2660\u2663\u2665\u2666\u2668\u267b\u267e\u2692\u2694\u2695\u2696\u2697\u2699\u269b\u269c\u26a0\u26a7\u26b0\u26b1\u26c8\u26cf\u26d1\u26d3\u26e9\u26f1\u26f7\u26f8\u26f9\u2702\u2708\u2709\u270c\u270d\u270f\u2712\u2714\u2716\u271d\u2721\u2733\u2734\u2744\u2747\u2763\u2764\u27a1\u2934\u2935\u2b05\u2b06\u2b07');
   var x = function (e) {
    if (!e) return 0;
    if (!D.test(e)) return e.length;
    e = e.replace(/[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E-\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED8\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFC-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFE])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFE])))?))?|\uDD75(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3C-\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE8A\uDE8E-\uDEC2\uDEC6\uDEC8\uDECD-\uDEDC\uDEDF-\uDEEA\uDEEF]|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g, (e) => (g.has(e) ? ' ' : '  '));
    let t = 0;
    for (let r of e) {
     let e = r.codePointAt(0);
     e <= 31 || (e >= 127 && e <= 159) || (e >= 768 && e <= 879) || (e >= 65024 && e <= 65039) || (t += m(e) || y(e) ? 2 : 1);
    }
    return t;
   };
   function E(e) {
    return (t, r, s) => {
     let n = !!s?.backwards;
     if (!1 === r) return !1;
     let { length: i } = t,
      a = r;
     for (; a >= 0 && a < i; ) {
      let r = t.charAt(a);
      if (e instanceof RegExp) {
       if (!e.test(r)) return a;
      } else if (!e.includes(r)) return a;
      n ? a-- : a++;
     }
     return (-1 === a || a === i) && a;
    };
   }
   E(/\s/u);
   var b = E(' \t'),
    T = E(',; \t'),
    C = E(/[^\n\r]/u),
    F = (e) => '\n' === e || '\r' === e || '\u2028' === e || '\u2029' === e;
   var A = function (e, t, r) {
    let s = !!r?.backwards;
    if (!1 === t) return !1;
    let n = e.charAt(t);
    if (s) {
     if ('\r' === e.charAt(t - 1) && '\n' === n) return t - 2;
     if (F(n)) return t - 1;
    } else {
     if ('\r' === n && '\n' === e.charAt(t + 1)) return t + 2;
     if (F(n)) return t + 1;
    }
    return t;
   };
   var w = function (e, t, r = {}) {
    let s = b(e, r.backwards ? t - 1 : t, r);
    return s !== A(e, s, r);
   };
   var S = function (e, t) {
    if (!1 === t) return !1;
    if ('/' === e.charAt(t) && '*' === e.charAt(t + 1)) for (let r = t + 2; r < e.length; ++r) if ('*' === e.charAt(r) && '/' === e.charAt(r + 1)) return r + 2;
    return t;
   };
   var v = function (e, t) {
    return !1 !== t && ('/' === e.charAt(t) && '/' === e.charAt(t + 1) ? C(e, t) : t);
   };
   var P = function (e, t) {
    let r = null,
     s = t;
    for (; s !== r; ) ((r = s), (s = T(e, s)), (s = S(e, s)), (s = b(e, s)));
    return ((s = v(e, s)), (s = A(e, s)), !1 !== s && w(e, s));
   };
   var k = function (e) {
     return Array.isArray(e) && e.length > 0;
    },
    I = () => {},
    N = Object.freeze({ character: "'", codePoint: 39 }),
    B = Object.freeze({ character: '"', codePoint: 34 }),
    O = Object.freeze({ preferred: N, alternate: B }),
    L = Object.freeze({ preferred: B, alternate: N });
   var M = function (e, t) {
     let { preferred: r, alternate: s } = !0 === t || "'" === t ? O : L,
      { length: n } = e,
      i = 0,
      a = 0;
     for (let o = 0; o < n; o++) {
      let t = e.charCodeAt(o);
      t === r.codePoint ? i++ : t === s.codePoint && a++;
     }
     return (i > a ? s : r).character;
    },
    j = /\\(["'\\])|(["'])/gu;
   var _ = function (e, t) {
    let r = '"' === t ? "'" : '"',
     s = l(0, e, j, (e, s, n) => (s ? (s === r ? r : e) : n === t ? '\\' + n : n));
    return t + s + t;
   };
   var R = function (e, t) {
     I(/^(?<quote>["']).*\k<quote>$/su.test(e));
     let r = e.slice(1, -1),
      s = 'json' === t.parser || 'jsonc' === t.parser || ('json5' === t.parser && 'preserve' === t.quoteProps && !t.singleQuote) ? '"' : t.__isInHtmlAttribute ? "'" : M(r, t.singleQuote);
     return e.charAt(0) === s ? e : _(r, s);
    },
    U = (e) => Number.isInteger(e) && e >= 0;
   function $(e) {
    let t = e.range?.[0] ?? e.start,
     r = (e.declaration?.decorators ?? e.decorators)?.[0];
    return r ? Math.min($(r), t) : t;
   }
   function q(e) {
    return e.range?.[1] ?? e.end;
   }
   function J(e, t) {
    let r = $(e);
    return U(r) && r === $(t);
   }
   function W(e, t) {
    return (
     J(e, t) &&
     (function (e, t) {
      let r = q(e);
      return U(r) && r === q(t);
     })(e, t)
    );
   }
   var V = null;
   function z(e) {
    if (null !== V && (V.property, 1)) {
     let e = V;
     return ((V = z.prototype = null), e);
    }
    return ((V = z.prototype = e ?? Object.create(null)), new z());
   }
   for (let iu = 0; iu <= 10; iu++) z();
   var H = function (e, t = 'type') {
     return (
      (function (e) {
       z(e);
      })(e),
      function (r) {
       let s = r[t],
        n = e[s];
       if (!Array.isArray(n)) throw Object.assign(new Error(`Missing visitor keys for '${s}'.`), { node: r });
       return n;
      }
     );
    },
    X = [['decorators', 'key', 'typeAnnotation', 'value'], [], ['elementType'], ['expression'], ['expression', 'typeAnnotation'], ['left', 'right'], ['argument'], ['directives', 'body'], ['label'], ['callee', 'typeArguments', 'arguments'], ['body'], ['decorators', 'id', 'typeParameters', 'superClass', 'superTypeArguments', 'mixins', 'implements', 'body', 'superTypeParameters'], ['id', 'typeParameters'], ['decorators', 'key', 'typeParameters', 'params', 'returnType', 'body'], ['decorators', 'variance', 'key', 'typeAnnotation', 'value'], ['name', 'typeAnnotation'], ['test', 'consequent', 'alternate'], ['checkType', 'extendsType', 'trueType', 'falseType'], ['value'], ['id', 'body'], ['declaration', 'specifiers', 'source', 'attributes'], ['id'], ['id', 'typeParameters', 'extends', 'body'], ['typeAnnotation'], ['id', 'typeParameters', 'right'], ['body', 'test'], ['members'], ['id', 'init'], ['exported'], ['left', 'right', 'body'], ['id', 'typeParameters', 'params', 'predicate', 'returnType', 'body'], ['id', 'params', 'body', 'typeParameters', 'returnType'], ['key', 'value'], ['local'], ['objectType', 'indexType'], ['typeParameter'], ['types'], ['node'], ['object', 'property'], ['argument', 'cases'], ['pattern', 'body', 'guard'], ['literal'], ['decorators', 'key', 'value'], ['expressions'], ['qualification', 'id'], ['decorators', 'key', 'typeAnnotation'], ['typeParameters', 'params', 'returnType'], ['expression', 'typeArguments'], ['params'], ['parameterName', 'typeAnnotation']],
    K = H({ AccessorProperty: X[0], AnyTypeAnnotation: X[1], ArgumentPlaceholder: X[1], ArrayExpression: ['elements'], ArrayPattern: ['elements', 'typeAnnotation', 'decorators'], ArrayTypeAnnotation: X[2], ArrowFunctionExpression: ['typeParameters', 'params', 'predicate', 'returnType', 'body'], AsConstExpression: X[3], AsExpression: X[4], AssignmentExpression: X[5], AssignmentPattern: ['left', 'right', 'decorators', 'typeAnnotation'], AwaitExpression: X[6], BigIntLiteral: X[1], BigIntLiteralTypeAnnotation: X[1], BigIntTypeAnnotation: X[1], BinaryExpression: X[5], BindExpression: ['object', 'callee'], BlockStatement: X[7], BooleanLiteral: X[1], BooleanLiteralTypeAnnotation: X[1], BooleanTypeAnnotation: X[1], BreakStatement: X[8], CallExpression: X[9], CatchClause: ['param', 'body'], ChainExpression: X[3], ClassAccessorProperty: X[0], ClassBody: X[10], ClassDeclaration: X[11], ClassExpression: X[11], ClassImplements: X[12], ClassMethod: X[13], ClassPrivateMethod: X[13], ClassPrivateProperty: X[14], ClassProperty: X[14], ComponentDeclaration: ['id', 'params', 'body', 'typeParameters', 'rendersType'], ComponentParameter: ['name', 'local'], ComponentTypeAnnotation: ['params', 'rest', 'typeParameters', 'rendersType'], ComponentTypeParameter: X[15], ConditionalExpression: X[16], ConditionalTypeAnnotation: X[17], ContinueStatement: X[8], DebuggerStatement: X[1], DeclareClass: ['id', 'typeParameters', 'extends', 'mixins', 'implements', 'body'], DeclareComponent: ['id', 'params', 'rest', 'typeParameters', 'rendersType'], DeclaredPredicate: X[18], DeclareEnum: X[19], DeclareExportAllDeclaration: ['source', 'attributes'], DeclareExportDeclaration: X[20], DeclareFunction: ['id', 'predicate'], DeclareHook: X[21], DeclareInterface: X[22], DeclareModule: X[19], DeclareModuleExports: X[23], DeclareNamespace: X[19], DeclareOpaqueType: ['id', 'typeParameters', 'supertype', 'lowerBound', 'upperBound'], DeclareTypeAlias: X[24], DeclareVariable: X[21], Decorator: X[3], Directive: X[18], DirectiveLiteral: X[1], DoExpression: X[10], DoWhileStatement: X[25], EmptyStatement: X[1], EmptyTypeAnnotation: X[1], EnumBigIntBody: X[26], EnumBigIntMember: X[27], EnumBooleanBody: X[26], EnumBooleanMember: X[27], EnumDeclaration: X[19], EnumDefaultedMember: X[21], EnumNumberBody: X[26], EnumNumberMember: X[27], EnumStringBody: X[26], EnumStringMember: X[27], EnumSymbolBody: X[26], ExistsTypeAnnotation: X[1], ExperimentalRestProperty: X[6], ExperimentalSpreadProperty: X[6], ExportAllDeclaration: ['source', 'attributes', 'exported'], ExportDefaultDeclaration: ['declaration'], ExportDefaultSpecifier: X[28], ExportNamedDeclaration: X[20], ExportNamespaceSpecifier: X[28], ExportSpecifier: ['local', 'exported'], ExpressionStatement: X[3], File: ['program'], ForInStatement: X[29], ForOfStatement: X[29], ForStatement: ['init', 'test', 'update', 'body'], FunctionDeclaration: X[30], FunctionExpression: X[30], FunctionTypeAnnotation: ['typeParameters', 'this', 'params', 'rest', 'returnType'], FunctionTypeParam: X[15], GenericTypeAnnotation: X[12], HookDeclaration: X[31], HookTypeAnnotation: ['params', 'returnType', 'rest', 'typeParameters'], Identifier: ['typeAnnotation', 'decorators'], IfStatement: X[16], ImportAttribute: X[32], ImportDeclaration: ['specifiers', 'source', 'attributes'], ImportDefaultSpecifier: X[33], ImportExpression: ['source', 'options'], ImportNamespaceSpecifier: X[33], ImportSpecifier: ['imported', 'local'], IndexedAccessType: X[34], InferredPredicate: X[1], InferTypeAnnotation: X[35], InterfaceDeclaration: X[22], InterfaceExtends: X[12], InterfaceTypeAnnotation: ['extends', 'body'], InterpreterDirective: X[1], IntersectionTypeAnnotation: X[36], JsExpressionRoot: X[37], JsonRoot: X[37], JSXAttribute: ['name', 'value'], JSXClosingElement: ['name'], JSXClosingFragment: X[1], JSXElement: ['openingElement', 'children', 'closingElement'], JSXEmptyExpression: X[1], JSXExpressionContainer: X[3], JSXFragment: ['openingFragment', 'children', 'closingFragment'], JSXIdentifier: X[1], JSXMemberExpression: X[38], JSXNamespacedName: ['namespace', 'name'], JSXOpeningElement: ['name', 'typeArguments', 'attributes'], JSXOpeningFragment: X[1], JSXSpreadAttribute: X[6], JSXSpreadChild: X[3], JSXText: X[1], KeyofTypeAnnotation: X[6], LabeledStatement: ['label', 'body'], Literal: X[1], LogicalExpression: X[5], MatchArrayPattern: ['elements', 'rest'], MatchAsPattern: ['pattern', 'target'], MatchBindingPattern: X[21], MatchExpression: X[39], MatchExpressionCase: X[40], MatchIdentifierPattern: X[21], MatchLiteralPattern: X[41], MatchMemberPattern: ['base', 'property'], MatchObjectPattern: ['properties', 'rest'], MatchObjectPatternProperty: ['key', 'pattern'], MatchOrPattern: ['patterns'], MatchRestPattern: X[6], MatchStatement: X[39], MatchStatementCase: X[40], MatchUnaryPattern: X[6], MatchWildcardPattern: X[1], MemberExpression: X[38], MetaProperty: ['meta', 'property'], MethodDefinition: X[42], MixedTypeAnnotation: X[1], ModuleExpression: X[10], NeverTypeAnnotation: X[1], NewExpression: X[9], NGChainedExpression: X[43], NGEmptyExpression: X[1], NGMicrosyntax: X[10], NGMicrosyntaxAs: ['key', 'alias'], NGMicrosyntaxExpression: ['expression', 'alias'], NGMicrosyntaxKey: X[1], NGMicrosyntaxKeyedExpression: ['key', 'expression'], NGMicrosyntaxLet: X[32], NGPipeExpression: ['left', 'right', 'arguments'], NGRoot: X[37], NullableTypeAnnotation: X[23], NullLiteral: X[1], NullLiteralTypeAnnotation: X[1], NumberLiteralTypeAnnotation: X[1], NumberTypeAnnotation: X[1], NumericLiteral: X[1], ObjectExpression: ['properties'], ObjectMethod: X[13], ObjectPattern: ['decorators', 'properties', 'typeAnnotation'], ObjectProperty: X[42], ObjectTypeAnnotation: ['properties', 'indexers', 'callProperties', 'internalSlots'], ObjectTypeCallProperty: X[18], ObjectTypeIndexer: ['variance', 'id', 'key', 'value'], ObjectTypeInternalSlot: ['id', 'value'], ObjectTypeMappedTypeProperty: ['keyTparam', 'propType', 'sourceType', 'variance'], ObjectTypeProperty: ['key', 'value', 'variance'], ObjectTypeSpreadProperty: X[6], OpaqueType: ['id', 'typeParameters', 'supertype', 'impltype', 'lowerBound', 'upperBound'], OptionalCallExpression: X[9], OptionalIndexedAccessType: X[34], OptionalMemberExpression: X[38], ParenthesizedExpression: X[3], PipelineBareFunction: ['callee'], PipelinePrimaryTopicReference: X[1], PipelineTopicExpression: X[3], Placeholder: X[1], PrivateIdentifier: X[1], PrivateName: X[21], Program: X[7], Property: X[32], PropertyDefinition: X[14], QualifiedTypeIdentifier: X[44], QualifiedTypeofIdentifier: X[44], RegExpLiteral: X[1], RestElement: ['argument', 'typeAnnotation', 'decorators'], ReturnStatement: X[6], SatisfiesExpression: X[4], SequenceExpression: X[43], SpreadElement: X[6], StaticBlock: X[10], StringLiteral: X[1], StringLiteralTypeAnnotation: X[1], StringTypeAnnotation: X[1], Super: X[1], SwitchCase: ['test', 'consequent'], SwitchStatement: ['discriminant', 'cases'], SymbolTypeAnnotation: X[1], TaggedTemplateExpression: ['tag', 'typeArguments', 'quasi'], TemplateElement: X[1], TemplateLiteral: ['quasis', 'expressions'], ThisExpression: X[1], ThisTypeAnnotation: X[1], ThrowStatement: X[6], TopicReference: X[1], TryStatement: ['block', 'handler', 'finalizer'], TSAbstractAccessorProperty: X[45], TSAbstractKeyword: X[1], TSAbstractMethodDefinition: X[32], TSAbstractPropertyDefinition: X[45], TSAnyKeyword: X[1], TSArrayType: X[2], TSAsExpression: X[4], TSAsyncKeyword: X[1], TSBigIntKeyword: X[1], TSBooleanKeyword: X[1], TSCallSignatureDeclaration: X[46], TSClassImplements: X[47], TSConditionalType: X[17], TSConstructorType: X[46], TSConstructSignatureDeclaration: X[46], TSDeclareFunction: X[31], TSDeclareKeyword: X[1], TSDeclareMethod: ['decorators', 'key', 'typeParameters', 'params', 'returnType'], TSEmptyBodyFunctionExpression: ['id', 'typeParameters', 'params', 'returnType'], TSEnumBody: X[26], TSEnumDeclaration: X[19], TSEnumMember: ['id', 'initializer'], TSExportAssignment: X[3], TSExportKeyword: X[1], TSExternalModuleReference: X[3], TSFunctionType: X[46], TSImportEqualsDeclaration: ['id', 'moduleReference'], TSImportType: ['options', 'qualifier', 'typeArguments', 'source'], TSIndexedAccessType: X[34], TSIndexSignature: ['parameters', 'typeAnnotation'], TSInferType: X[35], TSInstantiationExpression: X[47], TSInterfaceBody: X[10], TSInterfaceDeclaration: X[22], TSInterfaceHeritage: X[47], TSIntersectionType: X[36], TSIntrinsicKeyword: X[1], TSJSDocAllType: X[1], TSJSDocNonNullableType: X[23], TSJSDocNullableType: X[23], TSJSDocUnknownType: X[1], TSLiteralType: X[41], TSMappedType: ['key', 'constraint', 'nameType', 'typeAnnotation'], TSMethodSignature: ['key', 'typeParameters', 'params', 'returnType'], TSModuleBlock: X[10], TSModuleDeclaration: X[19], TSNamedTupleMember: ['label', 'elementType'], TSNamespaceExportDeclaration: X[21], TSNeverKeyword: X[1], TSNonNullExpression: X[3], TSNullKeyword: X[1], TSNumberKeyword: X[1], TSObjectKeyword: X[1], TSOptionalType: X[23], TSParameterProperty: ['parameter', 'decorators'], TSParenthesizedType: X[23], TSPrivateKeyword: X[1], TSPropertySignature: ['key', 'typeAnnotation'], TSProtectedKeyword: X[1], TSPublicKeyword: X[1], TSQualifiedName: X[5], TSReadonlyKeyword: X[1], TSRestType: X[23], TSSatisfiesExpression: X[4], TSStaticKeyword: X[1], TSStringKeyword: X[1], TSSymbolKeyword: X[1], TSTemplateLiteralType: ['quasis', 'types'], TSThisType: X[1], TSTupleType: ['elementTypes'], TSTypeAliasDeclaration: ['id', 'typeParameters', 'typeAnnotation'], TSTypeAnnotation: X[23], TSTypeAssertion: X[4], TSTypeLiteral: X[26], TSTypeOperator: X[23], TSTypeParameter: ['name', 'constraint', 'default'], TSTypeParameterDeclaration: X[48], TSTypeParameterInstantiation: X[48], TSTypePredicate: X[49], TSTypeQuery: ['exprName', 'typeArguments'], TSTypeReference: ['typeName', 'typeArguments'], TSUndefinedKeyword: X[1], TSUnionType: X[36], TSUnknownKeyword: X[1], TSVoidKeyword: X[1], TupleTypeAnnotation: ['types', 'elementTypes'], TupleTypeLabeledElement: ['label', 'elementType', 'variance'], TupleTypeSpreadElement: ['label', 'typeAnnotation'], TypeAlias: X[24], TypeAnnotation: X[23], TypeCastExpression: X[4], TypeofTypeAnnotation: ['argument', 'typeArguments'], TypeOperator: X[23], TypeParameter: ['bound', 'default', 'variance'], TypeParameterDeclaration: X[48], TypeParameterInstantiation: X[48], TypePredicate: X[49], UnaryExpression: X[6], UndefinedTypeAnnotation: X[1], UnionTypeAnnotation: X[36], UnknownTypeAnnotation: X[1], UpdateExpression: X[6], V8IntrinsicIdentifier: X[1], VariableDeclaration: ['declarations'], VariableDeclarator: X[27], Variance: X[1], VoidPattern: X[1], VoidTypeAnnotation: X[1], WhileStatement: X[25], WithStatement: ['object', 'body'], YieldExpression: X[6] });
   var G = function (e) {
    let t = new Set(e);
    return (e) => t.has(e?.type);
   };
   var Y = function (e) {
     return e.extra?.raw ?? e.raw;
    },
    Q = G(['Block', 'CommentBlock', 'MultiLine']),
    Z = G(['AnyTypeAnnotation', 'ThisTypeAnnotation', 'NumberTypeAnnotation', 'VoidTypeAnnotation', 'BooleanTypeAnnotation', 'BigIntTypeAnnotation', 'SymbolTypeAnnotation', 'StringTypeAnnotation', 'NeverTypeAnnotation', 'UndefinedTypeAnnotation', 'UnknownTypeAnnotation', 'EmptyTypeAnnotation', 'MixedTypeAnnotation']),
    ee = G(['Line', 'CommentLine', 'SingleLine', 'HashbangComment', 'HTMLOpen', 'HTMLClose', 'Hashbang', 'InterpreterDirective']);
   var te = function (e, t) {
    return t.some((t) =>
     (function (e, t) {
      let r = t.split('.');
      for (let s = r.length - 1; s >= 0; s--) {
       let t = r[s];
       if (0 === s) return 'Identifier' === e.type && e.name === t;
       if (1 !== s || 'MetaProperty' !== e.type || 'Identifier' !== e.property.type || e.property.name !== t) {
        if ('MemberExpression' !== e.type || e.optional || e.computed || 'Identifier' !== e.property.type || e.property.name !== t) return !1;
        e = e.object;
       } else e = e.meta;
      }
     })(e, t),
    );
   };
   var re = function ({ type: e }) {
    return e.startsWith('TS') && e.endsWith('Keyword');
   };
   var se = function ({ node: e, parent: t }) {
    return 'EmptyStatement' === e?.type && ('IfStatement' === t.type ? t.consequent === e || t.alternate === e : ('DoWhileStatement' === t.type || 'ForInStatement' === t.type || 'ForOfStatement' === t.type || 'ForStatement' === t.type || 'LabeledStatement' === t.type || 'WithStatement' === t.type || 'WhileStatement' === t.type) && t.body === e);
   };
   function ne(e, t) {
    return t(e) || f(e, { getVisitorKeys: K, predicate: t });
   }
   function ie(e) {
    return 'AssignmentExpression' === e.type || 'BinaryExpression' === e.type || 'LogicalExpression' === e.type || 'NGPipeExpression' === e.type || 'ConditionalExpression' === e.type || ke(e) || Ie(e) || 'SequenceExpression' === e.type || 'TaggedTemplateExpression' === e.type || 'BindExpression' === e.type || ('UpdateExpression' === e.type && !e.prefix) || ht(e) || 'TSNonNullExpression' === e.type || 'ChainExpression' === e.type;
   }
   function ae(e) {
    return e.expressions ? e.expressions[0] : (e.left ?? e.test ?? e.callee ?? e.object ?? e.tag ?? e.argument ?? e.expression);
   }
   function oe(e) {
    if (e.expressions) return ['expressions', 0];
    if (e.left) return ['left'];
    if (e.test) return ['test'];
    if (e.object) return ['object'];
    if (e.callee) return ['callee'];
    if (e.tag) return ['tag'];
    if (e.argument) return ['argument'];
    if (e.expression) return ['expression'];
    throw new Error('Unexpected node has no left side.');
   }
   var ue = G(['ExportDefaultDeclaration', 'DeclareExportDeclaration', 'ExportNamedDeclaration', 'ExportAllDeclaration', 'DeclareExportAllDeclaration']),
    le = G(['ArrayExpression']),
    pe = G(['ObjectExpression']);
   function ce(e) {
    return 'NumericLiteral' === e.type || ('Literal' === e.type && 'number' == typeof e.value);
   }
   function he(e) {
    return 'UnaryExpression' === e.type && ('+' === e.operator || '-' === e.operator) && ce(e.argument);
   }
   function de(e) {
    return !(!e || ('StringLiteral' !== e.type && ('Literal' !== e.type || 'string' != typeof e.value)));
   }
   function fe(e) {
    return 'RegExpLiteral' === e.type || ('Literal' === e.type && !!e.regex);
   }
   var me = G(['Literal', 'BooleanLiteral', 'BigIntLiteral', 'DirectiveLiteral', 'NullLiteral', 'NumericLiteral', 'RegExpLiteral', 'StringLiteral']),
    ye = G(['Identifier', 'ThisExpression', 'Super', 'PrivateName', 'PrivateIdentifier']),
    De = G(['ObjectTypeAnnotation', 'TSTypeLiteral', 'TSMappedType']),
    ge = G(['FunctionExpression', 'ArrowFunctionExpression']);
   function xe(e) {
    return ke(e) && 'Identifier' === e.callee.type && ['async', 'inject', 'fakeAsync', 'waitForAsync'].includes(e.callee.name);
   }
   var Ee = G(['JSXElement', 'JSXFragment']);
   function be(e) {
    return (e.method && 'init' === e.kind) || 'get' === e.kind || 'set' === e.kind;
   }
   function Te(e) {
    return !(('ObjectTypeProperty' !== e.type && 'ObjectTypeInternalSlot' !== e.type) || e.static || e.method || 'get' === e.kind || 'set' === e.kind || 'FunctionTypeAnnotation' !== e.value.type);
   }
   var Ce = G(['BinaryExpression', 'LogicalExpression', 'NGPipeExpression']);
   function Fe(e) {
    return Ie(e) || ('BindExpression' === e.type && !!e.object);
   }
   var Ae = G(['TSThisType', 'NullLiteralTypeAnnotation', 'BooleanLiteralTypeAnnotation', 'StringLiteralTypeAnnotation', 'BigIntLiteralTypeAnnotation', 'NumberLiteralTypeAnnotation', 'TSLiteralType', 'TSTemplateLiteralType']);
   function we(e) {
    return re(e) || Z(e) || Ae(e) || ('GenericTypeAnnotation' === e.type && !e.typeParameters) || ('TSTypeReference' === e.type && !e.typeArguments);
   }
   var Se = ['it', 'it.only', 'it.skip', 'describe', 'describe.only', 'describe.skip', 'test', 'test.only', 'test.skip', 'test.fixme', 'test.step', 'test.describe', 'test.describe.only', 'test.describe.skip', 'test.describe.fixme', 'test.describe.parallel', 'test.describe.parallel.only', 'test.describe.serial', 'test.describe.serial.only', 'skip', 'xit', 'xdescribe', 'xtest', 'fit', 'fdescribe', 'ftest'];
   function ve(e, t) {
    if ('CallExpression' !== e?.type || e.optional) return !1;
    let r = et(e);
    if (1 === r.length) {
     if (xe(e) && ve(t)) return ge(r[0]);
     if (
      (function (e) {
       return 'Identifier' === e.type && ('beforeEach' === e.name || 'beforeAll' === e.name || 'afterEach' === e.name || 'afterAll' === e.name);
      })(e.callee)
     )
      return xe(r[0]);
    } else if (
     (2 === r.length || 3 === r.length) &&
     ('TemplateLiteral' === r[0].type || de(r[0])) &&
     (function (e) {
      return te(e, Se);
     })(e.callee)
    )
     return (
      !(r[2] && !ce(r[2])) &&
      ((2 === r.length
       ? ge(r[1])
       : (function (e) {
          return 'FunctionExpression' === e.type || ('ArrowFunctionExpression' === e.type && 'BlockStatement' === e.body.type);
         })(r[1]) && Qe(r[1]).length <= 1) ||
       xe(r[1]))
     );
    return !1;
   }
   var Pe = (e) => (t) => ('ChainExpression' === t?.type && (t = t.expression), e(t)),
    ke = Pe(G(['CallExpression', 'OptionalCallExpression'])),
    Ie = Pe(G(['MemberExpression', 'OptionalMemberExpression']));
   function Ne(e, t = 5) {
    return Be(e, t) <= t;
   }
   function Be(e, t) {
    let r = 0;
    for (let s in e) {
     let n = e[s];
     if ((h(n) && 'string' == typeof n.type && (r++, (r += Be(n, t - r))), r > t)) return r;
    }
    return r;
   }
   function Oe(e, t) {
    let { printWidth: r } = t;
    if (ot(e)) return !1;
    let s = 0.25 * r;
    if ('ThisExpression' === e.type || ('Identifier' === e.type && e.name.length <= s) || (he(e) && !ot(e.argument))) return !0;
    let n = ('Literal' === e.type && 'regex' in e && e.regex.pattern) || ('RegExpLiteral' === e.type && e.pattern);
    return n ? n.length <= s : de(e) ? R(Y(e), t).length <= s : 'TemplateLiteral' === e.type ? 0 === e.expressions.length && e.quasis[0].value.raw.length <= s && !e.quasis[0].value.raw.includes('\n') : 'UnaryExpression' === e.type ? Oe(e.argument, { printWidth: r }) : 'CallExpression' === e.type && 0 === e.arguments.length && 'Identifier' === e.callee.type ? e.callee.name.length <= s - 2 : me(e);
   }
   function Le(e, t) {
    return Ee(t) ? nt(t) : ot(t, it.Leading, (t) => w(e, q(t)));
   }
   function Me(e) {
    return e.quasis.some((e) => e.value.raw.includes('\n'));
   }
   function je(e, t) {
    return (('TemplateLiteral' === e.type && Me(e)) || ('TaggedTemplateExpression' === e.type && Me(e.quasi))) && !w(t, $(e), { backwards: !0 });
   }
   function _e(e) {
    if (!ot(e)) return !1;
    let t = c(0, ut(e, it.Dangling), -1);
    return t && !Q(t);
   }
   function Re(e) {
    let { node: t, parent: r, key: s } = e;
    return 'callee' === s && ke(t) && ke(r) && r.arguments.length > 0 && t.arguments.length > r.arguments.length;
   }
   var Ue = new Set(['!', '-', '+', '~']);
   function $e(e, t = 2) {
    if (t <= 0) return !1;
    if ('ChainExpression' === e.type || 'TSNonNullExpression' === e.type) return $e(e.expression, t);
    let r = (e) => $e(e, t - 1);
    if (fe(e)) return x(e.pattern ?? e.regex.pattern) <= 5;
    if (me(e) || ye(e) || 'ArgumentPlaceholder' === e.type) return !0;
    if ('TemplateLiteral' === e.type) return e.quasis.every((e) => !e.value.raw.includes('\n')) && e.expressions.every(r);
    if (pe(e)) return e.properties.every((e) => !e.computed && (e.shorthand || (e.value && r(e.value))));
    if (le(e)) return e.elements.every((e) => null === e || r(e));
    if (pt(e)) {
     if ('ImportExpression' === e.type || $e(e.callee, t)) {
      let s = et(e);
      return s.length <= t && s.every(r);
     }
     return !1;
    }
    return Ie(e) ? $e(e.object, t) && $e(e.property, t) : !!(('UnaryExpression' === e.type && Ue.has(e.operator)) || 'UpdateExpression' === e.type) && $e(e.argument, t);
   }
   function qe(e, t = 'es5') {
    return ('es5' === e.trailingComma && 'es5' === t) || ('all' === e.trailingComma && ('all' === t || 'es5' === t));
   }
   function Je(e, t) {
    switch (e.type) {
     case 'BinaryExpression':
     case 'LogicalExpression':
     case 'AssignmentExpression':
     case 'NGPipeExpression':
      return Je(e.left, t);
     case 'MemberExpression':
     case 'OptionalMemberExpression':
      return Je(e.object, t);
     case 'TaggedTemplateExpression':
      return 'FunctionExpression' !== e.tag.type && Je(e.tag, t);
     case 'CallExpression':
     case 'OptionalCallExpression':
      return 'FunctionExpression' !== e.callee.type && Je(e.callee, t);
     case 'ConditionalExpression':
      return Je(e.test, t);
     case 'UpdateExpression':
      return !e.prefix && Je(e.argument, t);
     case 'BindExpression':
      return e.object && Je(e.object, t);
     case 'SequenceExpression':
      return Je(e.expressions[0], t);
     case 'ChainExpression':
     case 'TSSatisfiesExpression':
     case 'TSAsExpression':
     case 'TSNonNullExpression':
     case 'AsExpression':
     case 'AsConstExpression':
     case 'SatisfiesExpression':
      return Je(e.expression, t);
     default:
      return t(e);
    }
   }
   var We = { '==': !0, '!=': !0, '===': !0, '!==': !0 },
    Ve = { '*': !0, '/': !0, '%': !0 },
    ze = { '>>': !0, '>>>': !0, '<<': !0 };
   function He(e, t) {
    return !(Ke(t) !== Ke(e) || '**' === e || (We[e] && We[t]) || ('%' === t && Ve[e]) || ('%' === e && Ve[t]) || (t !== e && Ve[t] && Ve[e]) || (ze[e] && ze[t]));
   }
   var Xe = new Map([['|>'], ['??'], ['||'], ['&&'], ['|'], ['^'], ['&'], ['==', '===', '!=', '!=='], ['<', '>', '<=', '>=', 'in', 'instanceof'], ['>>', '<<', '>>>'], ['+', '-'], ['*', '/', '%'], ['**']].flatMap((e, t) => e.map((e) => [e, t])));
   function Ke(e) {
    return Xe.get(e);
   }
   function Ge(e) {
    if (e.rest) return !0;
    let t = Qe(e);
    return 'RestElement' === c(0, t, -1)?.type;
   }
   var Ye = new WeakMap();
   function Qe(e) {
    if (Ye.has(e)) return Ye.get(e);
    let t = [];
    return (e.this && t.push(e.this), t.push(...e.params), e.rest && t.push(e.rest), Ye.set(e, t), t);
   }
   var Ze = new WeakMap();
   function et(e) {
    if (Ze.has(e)) return Ze.get(e);
    if ('ChainExpression' === e.type) return et(e.expression);
    let t;
    return ('ImportExpression' === e.type || 'TSImportType' === e.type ? ((t = [e.source]), e.options && t.push(e.options)) : (t = 'TSExternalModuleReference' === e.type ? [e.expression] : e.arguments), Ze.set(e, t), t);
   }
   function tt(e, t) {
    let { node: r } = e;
    if ('ChainExpression' === r.type) return e.call(() => tt(e, t), 'expression');
    'ImportExpression' === r.type || 'TSImportType' === r.type ? (e.call(() => t(e, 0), 'source'), r.options && e.call(() => t(e, 1), 'options')) : 'TSExternalModuleReference' === r.type ? e.call(() => t(e, 0), 'expression') : e.each(t, 'arguments');
   }
   function rt(e, t) {
    let r = [];
    if (('ChainExpression' === e.type && ((e = e.expression), r.push('expression')), 'ImportExpression' === e.type || 'TSImportType' === e.type)) {
     if (0 === t || t === (e.options ? -2 : -1)) return [...r, 'source'];
     if (e.options && (1 === t || -1 === t)) return [...r, 'options'];
     throw new RangeError('Invalid argument index');
    }
    if ('TSExternalModuleReference' === e.type) {
     if (0 === t || -1 === t) return [...r, 'expression'];
    } else if ((t < 0 && (t = e.arguments.length + t), t >= 0 && t < e.arguments.length)) return [...r, 'arguments', t];
    throw new RangeError('Invalid argument index');
   }
   function st(e) {
    return 'prettier-ignore' === e.value.trim() && !e.unignore;
   }
   function nt(e) {
    return e?.prettierIgnore || ot(e, it.PrettierIgnore);
   }
   var it = { Leading: 2, Trailing: 4, Dangling: 8, Block: 16, Line: 32, PrettierIgnore: 64, First: 128, Last: 256 },
    at = (e, t) => {
     if (('function' == typeof e && ((t = e), (e = 0)), e || t)) return (r, s, n) => !((e & it.Leading && !r.leading) || (e & it.Trailing && !r.trailing) || (e & it.Dangling && (r.leading || r.trailing)) || (e & it.Block && !Q(r)) || (e & it.Line && !ee(r)) || (e & it.First && 0 !== s) || (e & it.Last && s !== n.length - 1) || (e & it.PrettierIgnore && !st(r)) || (t && !t(r)));
    };
   function ot(e, t, r) {
    if (!k(e?.comments)) return !1;
    let s = at(t, r);
    return !s || e.comments.some(s);
   }
   function ut(e, t, r) {
    if (!Array.isArray(e?.comments)) return [];
    let s = at(t, r);
    return s ? e.comments.filter(s) : e.comments;
   }
   var lt = (e, { originalText: t }) => P(t, q(e));
   function pt(e) {
    return ke(e) || 'NewExpression' === e.type || 'ImportExpression' === e.type;
   }
   function ct(e) {
    return e && ('ObjectProperty' === e.type || ('Property' === e.type && !be(e)));
   }
   var ht = G(['TSAsExpression', 'TSSatisfiesExpression', 'AsExpression', 'AsConstExpression', 'SatisfiesExpression']),
    dt = G(['TSUnionType', 'UnionTypeAnnotation']),
    ft = G(['TSIntersectionType', 'IntersectionTypeAnnotation']),
    mt = G(['TSConditionalType', 'ConditionalTypeAnnotation']),
    yt = G(['TSTypeAliasDeclaration', 'TypeAlias']);
   function Dt({ key: e, parent: t }) {
    return !(('types' === e && dt(t)) || ('types' === e && ft(t)));
   }
   var gt = new Set(['range', 'raw', 'comments', 'leadingComments', 'trailingComments', 'innerComments', 'extra', 'start', 'end', 'loc', 'flags', 'errors', 'tokens']),
    xt = (e) => {
     for (let t of e.quasis) delete t.value;
    };
   function Et(e, t, r) {
    if (('Program' === e.type && delete t.sourceType, ('BigIntLiteral' === e.type || 'Literal' === e.type) && e.bigint && (t.bigint = e.bigint.toLowerCase()), ('EmptyStatement' === e.type && !se({ node: e, parent: r })) || 'JSXText' === e.type || ('JSXExpressionContainer' === e.type && ('Literal' === e.expression.type || 'StringLiteral' === e.expression.type) && ' ' === e.expression.value))) return null;
    if (('Property' === e.type || 'ObjectProperty' === e.type || 'MethodDefinition' === e.type || 'ClassProperty' === e.type || 'ClassMethod' === e.type || 'PropertyDefinition' === e.type || 'TSDeclareMethod' === e.type || 'TSPropertySignature' === e.type || 'ObjectTypeProperty' === e.type || 'ImportAttribute' === e.type) && e.key && !e.computed) {
     let { key: r } = e;
     de(r) || ce(r) ? (t.key = String(r.value)) : 'Identifier' === r.type && (t.key = r.name);
    }
    if ('JSXElement' === e.type && 'style' === e.openingElement.name.name && e.openingElement.attributes.some((e) => 'JSXAttribute' === e.type && 'jsx' === e.name.name)) for (let { type: n, expression: i } of t.children) 'JSXExpressionContainer' === n && 'TemplateLiteral' === i.type && xt(i);
    ('JSXAttribute' === e.type && 'css' === e.name.name && 'JSXExpressionContainer' === e.value.type && 'TemplateLiteral' === e.value.expression.type && xt(t.value.expression), 'JSXAttribute' === e.type && 'Literal' === e.value?.type && /["']|&quot;|&apos;/u.test(e.value.value) && (t.value.value = l(0, e.value.value, /["']|&quot;|&apos;/gu, '"')));
    let s = e.expression || e.callee;
    if ('Decorator' === e.type && 'CallExpression' === s.type && 'Component' === s.callee.name && 1 === s.arguments.length) {
     let r = e.expression.arguments[0].properties;
     for (let [e, s] of t.expression.arguments[0].properties.entries())
      switch (r[e].key.name) {
       case 'styles':
        le(s.value) && xt(s.value.elements[0]);
        break;
       case 'template':
        'TemplateLiteral' === s.value.type && xt(s.value);
      }
    }
    ('TaggedTemplateExpression' === e.type && ('MemberExpression' === e.tag.type || ('Identifier' === e.tag.type && ('gql' === e.tag.name || 'graphql' === e.tag.name || 'css' === e.tag.name || 'md' === e.tag.name || 'markdown' === e.tag.name || 'html' === e.tag.name)) || 'CallExpression' === e.tag.type) && xt(t.quasi), 'TemplateLiteral' === e.type && xt(t), 'ChainExpression' === e.type && 'TSNonNullExpression' === e.expression.type && ((t.type = 'TSNonNullExpression'), (t.expression.type = 'ChainExpression')));
   }
   Et.ignoredProperties = gt;
   var bt = Et,
    Tt = G(['File', 'TemplateElement', 'TSEmptyBodyFunctionExpression', 'ChainExpression']),
    Ct = (e, [t]) => t?.typeAnnotation === e && ((e) => 'TSAsExpression' === e?.type && 'TSTypeReference' === e.typeAnnotation.type && 'Identifier' === e.typeAnnotation.typeName.type && 'const' === e.typeAnnotation.typeName.name)(t);
   var Ft = function (e, t) {
    return !(Tt(e) || ((e, [t]) => ('ComponentParameter' === t?.type && t.shorthand && t.name === e && t.local !== t.name) || ('MatchObjectPatternProperty' === t?.type && t.shorthand && t.key === e && t.value !== t.key) || ('ObjectProperty' === t?.type && t.shorthand && t.key === e && t.value !== t.key) || ('Property' === t?.type && t.shorthand && t.key === e && !be(t) && t.value !== t.key))(e, t) || ((e, [t]) => !('FunctionExpression' !== e.type || 'MethodDefinition' !== t.type || t.value !== e || 0 !== Qe(e).length || e.returnType || k(e.typeParameters) || !e.body))(e, t)) && ('EmptyStatement' === e.type ? se({ node: e, parent: t[0] }) : !(((e, [t, ...r]) => Ct(e, [t]) || (t?.typeName === e && Ct(t, r)))(e, t) || ('TSTypeAnnotation' === e.type && 'TSPropertySignature' === t[0].type)));
   };
   function At(e, t) {
    ((e.comments ?? (e.comments = [])).push(t),
     (t.printed = !1),
     (t.nodeDescription = (function (e) {
      let t = e.type || e.kind || '(unknown type)',
       r = String(e.name || (e.id && ('object' == typeof e.id ? e.id.name : e.id)) || (e.key && ('object' == typeof e.key ? e.key.name : e.key)) || (e.value && ('object' == typeof e.value ? '' : String(e.value))) || e.operator || '');
      return (r.length > 20 && (r = r.slice(0, 19) + '\u2026'), t + (r ? ' ' + r : ''));
     })(e)));
   }
   function wt(e, t) {
    ((t.leading = !0), (t.trailing = !1), At(e, t));
   }
   function St(e, t, r) {
    ((t.leading = !1), (t.trailing = !1), r && (t.marker = r), At(e, t));
   }
   function vt(e, t) {
    ((t.leading = !1), (t.trailing = !0), At(e, t));
   }
   var Pt = function (e, t) {
    let r = null,
     s = t;
    for (; s !== r; ) ((r = s), (s = b(e, s)), (s = S(e, s)), (s = v(e, s)), (s = A(e, s)));
    return s;
   };
   var kt = function (e, t) {
    let r = Pt(e, t);
    return !1 === r ? '' : e.charAt(r);
   };
   var It = function (e, t, r) {
     for (let s = t; s < r; ++s) if ('\n' === e.charAt(s)) return !0;
     return !1;
    },
    Nt = new WeakMap();
   var Bt = function (e) {
     return (Nt.has(e) || Nt.set(e, Q(e) && '*' === e.value[0] && /@(?:type|satisfies)\b/u.test(e.value)), Nt.get(e));
    },
    Ot = (e, t) => ee(e) || !It(t, $(e), q(e));
   function Lt(e, t) {
    let r = (e.body || e.properties).find(({ type: e }) => 'EmptyStatement' !== e);
    r ? wt(r, t) : St(e, t);
   }
   function Mt(e, t) {
    'BlockStatement' === e.type ? Lt(e, t) : wt(e, t);
   }
   function jt({ comment: e, followingNode: t }) {
    return !(!t || !Bt(e)) && (wt(t, e), !0);
   }
   function _t({ comment: e, precedingNode: t, enclosingNode: r, followingNode: s, text: n }) {
    if ('IfStatement' !== r?.type || !s) return !1;
    if (')' === kt(n, q(e))) return (vt(t, e), !0);
    if ('BlockStatement' === s.type && s === r.consequent && $(e) >= q(t) && q(e) <= $(s)) return (wt(s, e), !0);
    if (t === r.consequent && s === r.alternate) {
     let i = Pt(n, q(r.consequent));
     if ('BlockStatement' === s.type && $(e) >= i && q(e) <= $(s)) return (wt(s, e), !0);
     if ($(e) < i || 'BlockStatement' === r.alternate.type) return 'BlockStatement' === t.type || (Ot(e, n) && !It(n, $(t), $(e))) ? (vt(t, e), !0) : (St(r, e), !0);
    }
    return 'BlockStatement' === s.type ? (Lt(s, e), !0) : 'IfStatement' === s.type ? (Mt(s.consequent, e), !0) : r.consequent === s && (wt(s, e), !0);
   }
   function Rt({ comment: e, precedingNode: t, enclosingNode: r, followingNode: s, text: n }) {
    return !('WhileStatement' !== r?.type || !s) && (')' === kt(n, q(e)) ? (vt(t, e), !0) : 'BlockStatement' === s.type ? (Lt(s, e), !0) : r.body === s && (wt(s, e), !0));
   }
   function Ut({ comment: e, precedingNode: t, enclosingNode: r, followingNode: s }) {
    return !(('TryStatement' !== r?.type && 'CatchClause' !== r?.type) || !s) && ('CatchClause' === r.type && t ? (vt(t, e), !0) : 'BlockStatement' === s.type ? (Lt(s, e), !0) : 'TryStatement' === s.type ? (Mt(s.finalizer, e), !0) : 'CatchClause' === s.type && (Mt(s.body, e), !0));
   }
   function $t({ comment: e, enclosingNode: t, followingNode: r }) {
    return !(!Ie(t) || 'Identifier' !== r?.type) && (wt(t, e), !0);
   }
   function qt({ comment: e, enclosingNode: t, followingNode: r, options: s }) {
    return !(!s.experimentalTernaries || ('ConditionalExpression' !== t?.type && !mt(t))) && !('ConditionalExpression' !== r?.type && !mt(r)) && (St(t, e), !0);
   }
   function Jt({ comment: e, precedingNode: t, enclosingNode: r, followingNode: s, text: n, options: i }) {
    let a = t && !It(n, q(t), $(e));
    return !((t && a) || ('ConditionalExpression' !== r?.type && !mt(r)) || !s) && (!i.experimentalTernaries || r.alternate !== s || (Q(e) && !It(i.originalText, $(e), q(e))) ? (wt(s, e), !0) : (St(r, e), !0));
   }
   var Wt = G(['ClassDeclaration', 'ClassExpression', 'DeclareClass', 'DeclareInterface', 'InterfaceDeclaration', 'TSInterfaceDeclaration']);
   function Vt({ comment: e, precedingNode: t, enclosingNode: r, followingNode: s }) {
    if (Wt(r)) {
     if (k(r.decorators) && 'Decorator' !== s?.type) return (vt(c(0, r.decorators, -1), e), !0);
     if (r.body && s === r.body) return (Lt(r.body, e), !0);
     if (s) {
      if (r.superClass && s === r.superClass && t && (t === r.id || t === r.typeParameters)) return (vt(t, e), !0);
      for (let n of ['implements', 'extends', 'mixins']) if (r[n] && s === r[n][0]) return (!t || (t !== r.id && t !== r.typeParameters && t !== r.superClass) ? St(r, e, n) : vt(t, e), !0);
     }
    }
    return !1;
   }
   var zt = G(['ClassMethod', 'ClassProperty', 'PropertyDefinition', 'TSAbstractPropertyDefinition', 'TSAbstractMethodDefinition', 'TSDeclareMethod', 'MethodDefinition', 'ClassAccessorProperty', 'AccessorProperty', 'TSAbstractAccessorProperty', 'TSParameterProperty']);
   function Ht({ comment: e, precedingNode: t, enclosingNode: r, text: s }) {
    return ((r && t && '(' === kt(s, q(e)) && ('Property' === r.type || 'TSDeclareMethod' === r.type || 'TSAbstractMethodDefinition' === r.type) && 'Identifier' === t.type && r.key === t && ':' !== kt(s, q(t))) || !('Decorator' !== t?.type || !zt(r) || (!ee(e) && 'ownLine' !== e.placement))) && (vt(t, e), !0);
   }
   var Xt = G(['FunctionDeclaration', 'FunctionExpression', 'ClassMethod', 'MethodDefinition', 'ObjectMethod']);
   function Kt({ comment: e, precedingNode: t, enclosingNode: r, text: s }) {
    return '(' === kt(s, q(e)) && !(!t || !Xt(r)) && (vt(t, e), !0);
   }
   function Gt({ comment: e, enclosingNode: t, text: r }) {
    if ('ArrowFunctionExpression' !== t?.type) return !1;
    let s = Pt(r, q(e));
    return !1 !== s && '=>' === r.slice(s, s + 2) && (St(t, e), !0);
   }
   function Yt({ comment: e, enclosingNode: t, text: r }) {
    return ')' === kt(r, q(e)) && (t && ((Cr(t) && 0 === Qe(t).length) || (pt(t) && 0 === et(t).length)) ? (St(t, e), !0) : ('MethodDefinition' === t?.type || 'TSAbstractMethodDefinition' === t?.type) && 0 === Qe(t.value).length && (St(t.value, e), !0));
   }
   function Qt({ comment: e, precedingNode: t, enclosingNode: r, followingNode: s, text: n }) {
    return 'ComponentTypeParameter' !== t?.type || ('DeclareComponent' !== r?.type && 'ComponentTypeAnnotation' !== r?.type) || 'ComponentTypeParameter' === s?.type ? ('ComponentParameter' === t?.type || 'RestElement' === t?.type) && 'ComponentDeclaration' === r?.type && ')' === kt(n, q(e)) && (vt(t, e), !0) : (vt(t, e), !0);
   }
   function Zt({ comment: e, precedingNode: t, enclosingNode: r, followingNode: s, text: n }) {
    return 'FunctionTypeParam' === t?.type && 'FunctionTypeAnnotation' === r?.type && 'FunctionTypeParam' !== s?.type ? (vt(t, e), !0) : ('Identifier' !== t?.type && 'AssignmentPattern' !== t?.type && 'ObjectPattern' !== t?.type && 'ArrayPattern' !== t?.type && 'RestElement' !== t?.type && 'TSParameterProperty' !== t?.type) || !Cr(r) || ')' !== kt(n, q(e)) ? !(Q(e) || 'BlockStatement' !== s?.type || !Xt(r) || ('MethodDefinition' === r.type ? r.value.body : r.body) !== s || Pt(n, q(e)) !== $(s)) && (Lt(s, e), !0) : (vt(t, e), !0);
   }
   function er({ comment: e, enclosingNode: t }) {
    return 'LabeledStatement' === t?.type && (wt(t, e), !0);
   }
   function tr({ comment: e, enclosingNode: t }) {
    return !(('ContinueStatement' !== t?.type && 'BreakStatement' !== t?.type) || t.label) && (vt(t, e), !0);
   }
   function rr({ comment: e, precedingNode: t, enclosingNode: r }) {
    return !!(ke(r) && t && r.callee === t && r.arguments.length > 0) && (wt(r.arguments[0], e), !0);
   }
   function sr({ comment: e, precedingNode: t, enclosingNode: r, followingNode: s }) {
    return dt(r) ? (st(e) && ((s.prettierIgnore = !0), (e.unignore = !0)), !!t && (vt(t, e), !0)) : (dt(s) && st(e) && ((s.types[0].prettierIgnore = !0), (e.unignore = !0)), !1);
   }
   function nr({ comment: e, precedingNode: t, enclosingNode: r, followingNode: s }) {
    return r && 'MatchOrPattern' === r.type ? (st(e) && ((s.prettierIgnore = !0), (e.unignore = !0)), !!t && (vt(t, e), !0)) : (s && 'MatchOrPattern' === s.type && st(e) && ((s.types[0].prettierIgnore = !0), (e.unignore = !0)), !1);
   }
   function ir({ comment: e, enclosingNode: t }) {
    return !!ct(t) && (wt(t, e), !0);
   }
   function ar({ comment: e, enclosingNode: t, ast: r, isLastComment: s }) {
    return 0 === r?.body?.length ? (s ? St(r, e) : wt(r, e), !0) : 'Program' === t?.type && 0 === t.body.length && !k(t.directives) && (s ? St(t, e) : wt(t, e), !0);
   }
   function or({ comment: e, enclosingNode: t, followingNode: r }) {
    return ('ForInStatement' === t?.type || 'ForOfStatement' === t?.type) && r !== t.body && (wt(t, e), !0);
   }
   function ur({ comment: e, precedingNode: t, enclosingNode: r, text: s }) {
    if ('ImportSpecifier' === r?.type || 'ExportSpecifier' === r?.type) return (wt(r, e), !0);
    return !((!('ImportSpecifier' === t?.type && 'ImportDeclaration' === r?.type) && !('ExportSpecifier' === t?.type && 'ExportNamedDeclaration' === r?.type)) || !w(s, q(e))) && (vt(t, e), !0);
   }
   function lr({ comment: e, enclosingNode: t }) {
    return 'AssignmentPattern' === t?.type && (wt(t, e), !0);
   }
   var pr = G(['VariableDeclarator', 'AssignmentExpression', 'TypeAlias', 'TSTypeAliasDeclaration']),
    cr = G(['ObjectExpression', 'ArrayExpression', 'TemplateLiteral', 'TaggedTemplateExpression', 'ObjectTypeAnnotation', 'TSTypeLiteral']);
   function hr({ comment: e, enclosingNode: t, followingNode: r }) {
    return !(!pr(t) || !r || (!cr(r) && !Q(e))) && (wt(r, e), !0);
   }
   function dr({ comment: e, enclosingNode: t, precedingNode: r, followingNode: s, text: n }) {
    return !(s || ('TSMethodSignature' !== t?.type && 'TSDeclareFunction' !== t?.type && 'TSAbstractMethodDefinition' !== t?.type) || (r && r === t.returnType) || ';' !== kt(n, q(e))) && (vt(t, e), !0);
   }
   function fr({ comment: e, enclosingNode: t, followingNode: r }) {
    if (st(e) && 'TSMappedType' === t?.type && r === t.key) return ((t.prettierIgnore = !0), (e.unignore = !0), !0);
   }
   function mr({ comment: e, precedingNode: t, enclosingNode: r }) {
    if ('TSMappedType' === r?.type && !t) return (St(r, e), !0);
   }
   function yr({ comment: e, enclosingNode: t, followingNode: r }) {
    return !(!t || 'SwitchCase' !== t.type || t.test || !r || r !== t.consequent[0]) && ('BlockStatement' === r.type && ee(e) ? Lt(r, e) : St(t, e), !0);
   }
   function Dr({ comment: e, precedingNode: t, enclosingNode: r, followingNode: s }) {
    return !(!dt(t) || ((('TSArrayType' !== r.type && 'ArrayTypeAnnotation' !== r.type) || s) && !ft(r))) && (vt(c(0, t.types, -1), e), !0);
   }
   function gr({ comment: e, enclosingNode: t, precedingNode: r, followingNode: s }) {
    if (('ObjectPattern' === t?.type || 'ArrayPattern' === t?.type) && 'TSTypeAnnotation' === s?.type) return (r ? vt(r, e) : St(t, e), !0);
   }
   function xr({ comment: e, precedingNode: t, enclosingNode: r, followingNode: s, text: n }) {
    return !(s || 'UnaryExpression' !== r?.type || ('LogicalExpression' !== t?.type && 'BinaryExpression' !== t?.type) || !It(n, $(r.argument), $(t.right)) || !Ot(e, n) || It(n, $(t.right), $(e))) && (vt(t.right, e), !0);
   }
   function Er({ enclosingNode: e, followingNode: t, comment: r }) {
    if (e && ('TSPropertySignature' === e.type || 'ObjectTypeProperty' === e.type) && (dt(t) || ft(t))) return (wt(t, r), !0);
   }
   function br({ enclosingNode: e, precedingNode: t, followingNode: r, comment: s, text: n }) {
    if (ht(e) && t === e.expression && !Ot(s, n)) return (r ? wt(r, s) : vt(e, s), !0);
   }
   function Tr({ comment: e, enclosingNode: t, followingNode: r, precedingNode: s }) {
    return !(!(t && r && s && 'ArrowFunctionExpression' === t.type && t.returnType === s) || ('TSTypeAnnotation' !== s.type && 'TypeAnnotation' !== s.type)) && (wt(r, e), !0);
   }
   var Cr = G(['ArrowFunctionExpression', 'FunctionExpression', 'FunctionDeclaration', 'ObjectMethod', 'ClassMethod', 'TSDeclareFunction', 'TSCallSignatureDeclaration', 'TSConstructSignatureDeclaration', 'TSMethodSignature', 'TSConstructorType', 'TSFunctionType', 'TSDeclareMethod']),
    Fr = {
     endOfLine: function (e) {
      return [jt, Zt, Jt, ur, _t, Rt, Ut, Vt, er, rr, ir, ar, hr, tr, yr, Dr, xr, mr, Tr, Er, br].some((t) => t(e));
     },
     ownLine: function (e) {
      return [fr, Jt, Zt, Qt, $t, _t, Rt, Ut, Vt, or, sr, nr, ar, ur, lr, Ht, er, tr, qt, gr, mr, br].some((t) => t(e));
     },
     remaining: function (e) {
      return [fr, _t, Rt, Yt, Ht, ar, Gt, Kt, tr, dr, br].some((t) => t(e));
     },
    };
   var Ar = function (e, { parser: t }) {
     if ('flow' === t || 'hermes' === t || 'babel-flow' === t) return '' === (e = l(0, e, /[\s(]/gu, '')) || '/*' === e || '/*::' === e;
    },
    wr = G(['ClassDeclaration', 'ClassExpression', 'DeclareClass', 'DeclareInterface', 'InterfaceDeclaration', 'TSInterfaceDeclaration']);
   var Sr = function (e) {
     let { key: t, parent: r } = e;
     if (('types' === t && dt(r)) || ('argument' === t && 'JSXSpreadAttribute' === r.type) || ('expression' === t && 'JSXSpreadChild' === r.type) || ('superClass' === t && ('ClassDeclaration' === r.type || 'ClassExpression' === r.type)) || (('id' === t || 'typeParameters' === t) && wr(r)) || ('patterns' === t && 'MatchOrPattern' === r.type)) return !0;
     let { node: s } = e;
     return !nt(s) && (dt(s) ? Dt(e) : !!Ee(s));
    },
    vr = 'string',
    Pr = 'array',
    kr = 'cursor',
    Ir = 'indent',
    Nr = 'align',
    Br = 'trim',
    Or = 'group',
    Lr = 'fill',
    Mr = 'if-break',
    jr = 'indent-if-break',
    _r = 'line-suffix',
    Rr = 'line-suffix-boundary',
    Ur = 'line',
    $r = 'label',
    qr = 'break-parent',
    Jr = new Set([kr, Ir, Nr, Br, Or, Lr, Mr, jr, _r, Rr, Ur, $r, qr]);
   var Wr = function (e) {
    if ('string' == typeof e) return vr;
    if (Array.isArray(e)) return Pr;
    if (!e) return;
    let { type: t } = e;
    return Jr.has(t) ? t : void 0;
   };
   function Vr(e) {
    let t = null === e ? 'null' : typeof e;
    if ('string' !== t && 'object' !== t) return `Unexpected doc '${t}', \nExpected it to be 'string' or 'object'.`;
    if (Wr(e)) throw new Error('doc is valid.');
    let r = Object.prototype.toString.call(e);
    if ('[object Object]' !== r) return `Unexpected doc '${r}'.`;
    let s = ((e) => new Intl.ListFormat('en-US', { type: 'disjunction' }).format(e))([...Jr].map((e) => `'${e}'`));
    return `Unexpected doc.type '${e.type}'.\nExpected it to be ${s}.`;
   }
   var zr = class extends Error {
     name = 'InvalidDocError';
     constructor(e) {
      (super(Vr(e)), (this.doc = e));
     }
    },
    Hr = {};
   var Xr = function (e, t, r, s) {
    let n = [e];
    for (; n.length > 0; ) {
     let e = n.pop();
     if (e === Hr) {
      r(n.pop());
      continue;
     }
     r && n.push(e, Hr);
     let i = Wr(e);
     if (!i) throw new zr(e);
     if (!1 !== t?.(e))
      switch (i) {
       case Pr:
       case Lr: {
        let t = i === Pr ? e : e.parts;
        for (let e = t.length - 1; e >= 0; --e) n.push(t[e]);
        break;
       }
       case Mr:
        n.push(e.flatContents, e.breakContents);
        break;
       case Or:
        if (s && e.expandedStates) for (let t = e.expandedStates.length - 1; t >= 0; --t) n.push(e.expandedStates[t]);
        else n.push(e.contents);
        break;
       case Nr:
       case Ir:
       case jr:
       case $r:
       case _r:
        n.push(e.contents);
        break;
       case vr:
       case kr:
       case Br:
       case Rr:
       case Ur:
       case qr:
        break;
       default:
        throw new zr(e);
      }
    }
   };
   function Kr(e, t) {
    if ('string' == typeof e) return t(e);
    let r = new Map();
    return s(e);
    function s(e) {
     if (r.has(e)) return r.get(e);
     let n = (function (e) {
      switch (Wr(e)) {
       case Pr:
        return t(e.map(s));
       case Lr:
        return t({ ...e, parts: e.parts.map(s) });
       case Mr:
        return t({ ...e, breakContents: s(e.breakContents), flatContents: s(e.flatContents) });
       case Or: {
        let { expandedStates: r, contents: n } = e;
        return (r ? ((r = r.map(s)), (n = r[0])) : (n = s(n)), t({ ...e, contents: n, expandedStates: r }));
       }
       case Nr:
       case Ir:
       case jr:
       case $r:
       case _r:
        return t({ ...e, contents: s(e.contents) });
       case vr:
       case kr:
       case Br:
       case Rr:
       case Ur:
       case qr:
        return t(e);
       default:
        throw new zr(e);
      }
     })(e);
     return (r.set(e, n), n);
    }
   }
   function Gr(e, t, r) {
    let s = r,
     n = !1;
    return (
     Xr(e, function (e) {
      if (n) return !1;
      let r = t(e);
      void 0 !== r && ((n = !0), (s = r));
     }),
     s
    );
   }
   function Yr(e) {
    if ((e.type === Or && e.break) || (e.type === Ur && e.hard) || e.type === qr) return !0;
   }
   function Qr(e) {
    return Gr(e, Yr, !1);
   }
   function Zr(e) {
    if (e.length > 0) {
     let t = c(0, e, -1);
     !t.expandedStates && !t.break && (t.break = 'propagated');
    }
    return null;
   }
   function es(e) {
    return e.type !== Ur || e.hard ? (e.type === Mr ? e.flatContents : e) : e.soft ? '' : ' ';
   }
   function ts(e) {
    return Kr(e, es);
   }
   function rs(e) {
    return Kr(e, (e) =>
     (function (e) {
      switch (Wr(e)) {
       case Lr:
        if (e.parts.every((e) => '' === e)) return '';
        break;
       case Or:
        if (!(e.contents || e.id || e.break || e.expandedStates)) return '';
        if (e.contents.type === Or && e.contents.id === e.id && e.contents.break === e.break && e.contents.expandedStates === e.expandedStates) return e.contents;
        break;
       case Nr:
       case Ir:
       case jr:
       case _r:
        if (!e.contents) return '';
        break;
       case Mr:
        if (!e.flatContents && !e.breakContents) return '';
        break;
       case Pr: {
        let t = [];
        for (let r of e) {
         if (!r) continue;
         let [e, ...s] = Array.isArray(r) ? r : [r];
         ('string' == typeof e && 'string' == typeof c(0, t, -1) ? (t[t.length - 1] += e) : t.push(e), t.push(...s));
        }
        return 0 === t.length ? '' : 1 === t.length ? t[0] : t;
       }
       case vr:
       case kr:
       case Br:
       case Rr:
       case Ur:
       case $r:
       case qr:
        break;
       default:
        throw new zr(e);
      }
      return e;
     })(e),
    );
   }
   function ss(e, t = vs) {
    return Kr(e, (e) => ('string' == typeof e ? Ts(t, e.split('\n')) : e));
   }
   function ns(e) {
    if (e.type === Ur) return !0;
   }
   function is(e, t) {
    return e.type === $r ? { ...e, contents: t(e.contents) } : t(e);
   }
   function as(e) {
    let t = !0;
    return (
     Xr(e, (e) => {
      switch (Wr(e)) {
       case vr:
        if ('' === e) break;
       case Br:
       case Rr:
       case Ur:
       case qr:
        return ((t = !1), !1);
      }
     }),
     t
    );
   }
   var os = I,
    us = I,
    ls = I,
    ps = I;
   function cs(e) {
    return (os(e), { type: Ir, contents: e });
   }
   function hs(e, t) {
    return (ps(e), os(t), { type: Nr, contents: t, n: e });
   }
   function ds(e) {
    return hs(Number.NEGATIVE_INFINITY, e);
   }
   function fs(e) {
    return hs(-1, e);
   }
   var ms = { type: qr },
    ys = { type: kr };
   function Ds(e) {
    return (ls(e), { type: Lr, parts: e });
   }
   function gs(e, t = {}) {
    return (os(e), us(t.expandedStates, !0), { type: Or, id: t.id, contents: e, break: !!t.shouldBreak, expandedStates: t.expandedStates });
   }
   function xs(e, t) {
    return gs(e[0], { ...t, expandedStates: e });
   }
   function Es(e, t = '', r = {}) {
    return (os(e), '' !== t && os(t), { type: Mr, breakContents: e, flatContents: t, groupId: r.groupId });
   }
   function bs(e, t) {
    return (os(e), { type: jr, contents: e, groupId: t.groupId, negate: t.negate });
   }
   function Ts(e, t) {
    (os(e), us(t));
    let r = [];
    for (let s = 0; s < t.length; s++) (0 !== s && r.push(e), r.push(t[s]));
    return r;
   }
   function Cs(e, t) {
    return (os(t), e ? { type: $r, label: e, contents: t } : t);
   }
   var Fs = { type: Ur },
    As = { type: Ur, soft: !0 },
    ws = { type: Ur, hard: !0 },
    Ss = [ws, ms],
    vs = [{ type: Ur, hard: !0, literal: !0 }, ms];
   function Ps(e) {
    return (os(e), { type: _r, contents: e });
   }
   var ks = { type: Rr };
   var Is = { type: 0 },
    Ns = { type: 1 },
    Bs = {
     value: '',
     length: 0,
     queue: [],
     get root() {
      return Bs;
     },
    };
   function Os(e, t, r) {
    let s = 1 === t.type ? e.queue.slice(0, -1) : [...e.queue, t],
     n = '',
     i = 0,
     a = 0,
     o = 0;
    for (let d of s)
     switch (d.type) {
      case 0:
       (p(), r.useTabs ? u(1) : l(r.tabWidth));
       break;
      case 3: {
       let { string: e } = d;
       (p(), (n += e), (i += e.length));
       break;
      }
      case 2: {
       let { width: e } = d;
       ((a += 1), (o += e));
       break;
      }
      default:
       throw new Error(`Unexpected indent comment '${d.type}'.`);
     }
    return (c(), { ...e, value: n, length: i, queue: s });
    function u(e) {
     ((n += '\t'.repeat(e)), (i += r.tabWidth * e));
    }
    function l(e) {
     ((n += ' '.repeat(e)), (i += e));
    }
    function p() {
     r.useTabs ? (a > 0 && u(a), h()) : c();
    }
    function c() {
     (o > 0 && l(o), h());
    }
    function h() {
     ((a = 0), (o = 0));
    }
   }
   function Ls(e, t, r) {
    if (!t) return e;
    if ('root' === t.type) return { ...e, root: e };
    if (t === Number.NEGATIVE_INFINITY) return e.root;
    let s;
    return ((s = 'number' == typeof t ? (t < 0 ? Ns : { type: 2, width: t }) : { type: 3, string: t }), Os(e, s, r));
   }
   function Ms(e, t) {
    return Os(e, Is, t);
   }
   function js(e) {
    let t = (function (e) {
     let t = 0;
     for (let r = e.length - 1; r >= 0; r--) {
      let s = e[r];
      if (' ' !== s && '\t' !== s) break;
      t++;
     }
     return t;
    })(e);
    return { text: 0 === t ? e : e.slice(0, e.length - t), count: t };
   }
   var _s = Symbol('MODE_BREAK'),
    Rs = Symbol('MODE_FLAT'),
    Us = Symbol('DOC_FILL_PRINTED_LENGTH');
   function $s(e, t, r, s, n, i) {
    if (r === Number.POSITIVE_INFINITY) return !0;
    let a = t.length,
     o = !1,
     u = [e],
     l = '';
    for (; r >= 0; ) {
     if (0 === u.length) {
      if (0 === a) return !0;
      u.push(t[--a]);
      continue;
     }
     let { mode: e, doc: p } = u.pop(),
      h = Wr(p);
     switch (h) {
      case vr:
       p && (o && ((l += ' '), (r -= 1), (o = !1)), (l += p), (r -= x(p)));
       break;
      case Pr:
      case Lr: {
       let t = h === Pr ? p : p.parts,
        r = p[Us] ?? 0;
       for (let s = t.length - 1; s >= r; s--) u.push({ mode: e, doc: t[s] });
       break;
      }
      case Ir:
      case Nr:
      case jr:
      case $r:
       u.push({ mode: e, doc: p.contents });
       break;
      case Br: {
       let { text: e, count: t } = js(l);
       ((l = e), (r += t));
       break;
      }
      case Or: {
       if (i && p.break) return !1;
       let t = p.break ? _s : e,
        r = p.expandedStates && t === _s ? c(0, p.expandedStates, -1) : p.contents;
       u.push({ mode: t, doc: r });
       break;
      }
      case Mr: {
       let t = (p.groupId ? n[p.groupId] || Rs : e) === _s ? p.breakContents : p.flatContents;
       t && u.push({ mode: e, doc: t });
       break;
      }
      case Ur:
       if (e === _s || p.hard) return !0;
       p.soft || (o = !0);
       break;
      case _r:
       s = !0;
       break;
      case Rr:
       if (s) return !1;
     }
    }
    return !1;
   }
   function qs(e, t) {
    let r = Object.create(null),
     s = t.printWidth,
     n = (function (e) {
      return 'cr' === e ? '\r' : 'crlf' === e ? '\r\n' : '\n';
     })(t.endOfLine),
     i = 0,
     a = [{ indent: Bs, mode: _s, doc: e }],
     o = '',
     u = !1,
     p = [],
     h = [],
     d = [],
     f = [],
     m = 0;
    for (
     (function (e) {
      let t = new Set(),
       r = [];
      Xr(
       e,
       function (e) {
        if ((e.type === qr && Zr(r), e.type === Or)) {
         if ((r.push(e), t.has(e))) return !1;
         t.add(e);
        }
       },
       function (e) {
        e.type === Or && r.pop().break && Zr(r);
       },
       !0,
      );
     })(e);
     a.length > 0;
    ) {
     let { indent: e, mode: d, doc: f } = a.pop();
     switch (Wr(f)) {
      case vr: {
       let e = '\n' !== n ? l(0, f, '\n', n) : f;
       e && ((o += e), a.length > 0 && (i += x(e)));
       break;
      }
      case Pr:
       for (let t = f.length - 1; t >= 0; t--) a.push({ indent: e, mode: d, doc: f[t] });
       break;
      case kr:
       if (h.length >= 2) throw new Error("There are too many 'cursor' in doc.");
       h.push(m + o.length);
       break;
      case Ir:
       a.push({ indent: Ms(e, t), mode: d, doc: f.contents });
       break;
      case Nr:
       a.push({ indent: Ls(e, f.n, t), mode: d, doc: f.contents });
       break;
      case Br:
       E();
       break;
      case Or:
       switch (d) {
        case Rs:
         if (!u) {
          a.push({ indent: e, mode: f.break ? _s : Rs, doc: f.contents });
          break;
         }
        case _s: {
         u = !1;
         let t = { indent: e, mode: Rs, doc: f.contents },
          n = s - i,
          o = p.length > 0;
         if (!f.break && $s(t, a, n, o, r)) a.push(t);
         else if (f.expandedStates) {
          let t = c(0, f.expandedStates, -1);
          if (f.break) {
           a.push({ indent: e, mode: _s, doc: t });
           break;
          }
          for (let s = 1; s < f.expandedStates.length + 1; s++) {
           if (s >= f.expandedStates.length) {
            a.push({ indent: e, mode: _s, doc: t });
            break;
           }
           {
            let t = f.expandedStates[s],
             i = { indent: e, mode: Rs, doc: t };
            if ($s(i, a, n, o, r)) {
             a.push(i);
             break;
            }
           }
          }
         } else a.push({ indent: e, mode: _s, doc: f.contents });
         break;
        }
       }
       f.id && (r[f.id] = c(0, a, -1).mode);
       break;
      case Lr: {
       let t = s - i,
        n = f[Us] ?? 0,
        { parts: o } = f,
        u = o.length - n;
       if (0 === u) break;
       let l = o[n + 0],
        c = o[n + 1],
        h = { indent: e, mode: Rs, doc: l },
        m = { indent: e, mode: _s, doc: l },
        y = $s(h, [], t, p.length > 0, r, !0);
       if (1 === u) {
        y ? a.push(h) : a.push(m);
        break;
       }
       let D = { indent: e, mode: Rs, doc: c },
        g = { indent: e, mode: _s, doc: c };
       if (2 === u) {
        y ? a.push(D, h) : a.push(g, m);
        break;
       }
       let x = o[n + 2],
        E = { indent: e, mode: d, doc: { ...f, [Us]: n + 2 } },
        b = $s({ indent: e, mode: Rs, doc: [l, c, x] }, [], t, p.length > 0, r, !0);
       (a.push(E), b ? a.push(D, h) : y ? a.push(g, h) : a.push(g, m));
       break;
      }
      case Mr:
      case jr: {
       let t = f.groupId ? r[f.groupId] : d;
       if (t === _s) {
        let t = f.type === Mr ? f.breakContents : f.negate ? f.contents : cs(f.contents);
        t && a.push({ indent: e, mode: d, doc: t });
       }
       if (t === Rs) {
        let t = f.type === Mr ? f.flatContents : f.negate ? cs(f.contents) : f.contents;
        t && a.push({ indent: e, mode: d, doc: t });
       }
       break;
      }
      case _r:
       p.push({ indent: e, mode: d, doc: f.contents });
       break;
      case Rr:
       p.length > 0 && a.push({ indent: e, mode: d, doc: ws });
       break;
      case Ur:
       switch (d) {
        case Rs:
         if (!f.hard) {
          f.soft || ((o += ' '), (i += 1));
          break;
         }
         u = !0;
        case _s:
         if (p.length > 0) {
          (a.push({ indent: e, mode: d, doc: f }, ...p.reverse()), (p.length = 0));
          break;
         }
         f.literal ? ((o += n), (i = 0), e.root && (e.root.value && (o += e.root.value), (i = e.root.length))) : (E(), (o += n + e.value), (i = e.length));
       }
       break;
      case $r:
       a.push({ indent: e, mode: d, doc: f.contents });
       break;
      case qr:
       break;
      default:
       throw new zr(f);
     }
     0 === a.length && p.length > 0 && (a.push(...p.reverse()), (p.length = 0));
    }
    let y = d.join('') + o,
     D = [...f, ...h];
    if (2 !== D.length) return { formatted: y };
    let g = D[0];
    return { formatted: y, cursorNodeStart: g, cursorNodeText: y.slice(g, c(0, D, -1)) };
    function E() {
     let { text: e, count: t } = js(o);
     (e && (d.push(e), (m += e.length)), (o = ''), (i -= t), h.length > 0 && (f.push(...h.map((e) => Math.min(e, m))), (h.length = 0)));
    }
   }
   var Js = function (e, t, r = 0) {
    let s = 0;
    for (let n = r; n < e.length; ++n) '\t' === e[n] ? (s = s + t - (s % t)) : s++;
    return s;
   };
   var Ws = function (e, t) {
    let r = e.lastIndexOf('\n');
    return -1 === r ? 0 : Js(e.slice(r + 1).match(/^[\t ]*/u)[0], t);
   };
   function Vs(e, t, r) {
    let { node: s } = e;
    if (
     'TemplateLiteral' === s.type &&
     (function ({ node: e, parent: t }) {
      let r = /^[fx]?(?:describe|it|test)$/u;
      return 'TaggedTemplateExpression' === t.type && t.quasi === e && 'MemberExpression' === t.tag.type && 'Identifier' === t.tag.property.type && 'each' === t.tag.property.name && (('Identifier' === t.tag.object.type && r.test(t.tag.object.name)) || ('MemberExpression' === t.tag.object.type && 'Identifier' === t.tag.object.property.type && ('only' === t.tag.object.property.name || 'skip' === t.tag.object.property.name) && 'Identifier' === t.tag.object.object.type && r.test(t.tag.object.object.name)));
     })(e)
    ) {
     let s = (function (e, t, r) {
      let { node: s } = e,
       n = s.quasis[0].value.raw.trim().split(/\s*\|\s*/u);
      if (n.length > 1 || n.some((e) => e.length > 0)) {
       t.__inJestEach = !0;
       let i = e.map(r, 'expressions');
       t.__inJestEach = !1;
       let a = i.map((e) => '${' + qs(e, { ...t, printWidth: Number.POSITIVE_INFINITY, endOfLine: 'lf' }).formatted + '}'),
        o = [{ hasLineBreak: !1, cells: [] }];
       for (let e = 1; e < s.quasis.length; e++) {
        let t = c(0, o, -1),
         r = a[e - 1];
        (t.cells.push(r), r.includes('\n') && (t.hasLineBreak = !0), s.quasis[e].value.raw.includes('\n') && o.push({ hasLineBreak: !1, cells: [] }));
       }
       let u = Math.max(n.length, ...o.map((e) => e.cells.length)),
        l = Array.from({ length: u }).fill(0),
        p = [{ cells: n }, ...o.filter((e) => e.cells.length > 0)];
       for (let { cells: e } of p.filter((e) => !e.hasLineBreak)) for (let [t, r] of e.entries()) l[t] = Math.max(l[t], x(r));
       return [
        ks,
        '`',
        cs([
         Ss,
         Ts(
          Ss,
          p.map((e) =>
           Ts(
            ' | ',
            e.cells.map((t, r) => (e.hasLineBreak ? t : t + ' '.repeat(l[r] - x(t)))),
           ),
          ),
         ),
        ]),
        Ss,
        '`',
       ];
      }
     })(e, t, r);
     if (s) return s;
    }
    let n = 'expressions';
    'TSTemplateLiteralType' === s.type && (n = 'types');
    let i = [],
     a = e.map(r, n);
    i.push(ks, '`');
    let o = 0;
    return (
     e.each(({ index: e, node: u }) => {
      if ((i.push(r()), u.tail)) return;
      let { tabWidth: l } = t,
       p = u.value.raw,
       c = p.includes('\n') ? Ws(p, l) : o;
      o = c;
      let h = a[e],
       d = s[n][e],
       f = It(t.originalText, q(u), $(s.quasis[e + 1]));
      if (!f) {
       let e = qs(h, { ...t, printWidth: Number.POSITIVE_INFINITY }).formatted;
       e.includes('\n') ? (f = !0) : (h = e);
      }
      f && (ot(d) || 'Identifier' === d.type || Ie(d) || 'ConditionalExpression' === d.type || 'SequenceExpression' === d.type || ht(d) || Ce(d)) && (h = [cs([As, h]), As]);
      let m =
       0 === c && p.endsWith('\n')
        ? hs(Number.NEGATIVE_INFINITY, h)
        : (function (e, t, r) {
           os(e);
           let s = e;
           if (t > 0) {
            for (let e = 0; e < Math.floor(t / r); ++e) s = cs(s);
            ((s = hs(t % r, s)), (s = hs(Number.NEGATIVE_INFINITY, s)));
           }
           return s;
          })(h, c, l);
      i.push(gs(['${', m, ks, '}']));
     }, 'quasis'),
     i.push('`'),
     i
    );
   }
   function zs(e, t) {
    return e.map(
     () =>
      (function (e, t) {
       let { node: r } = e,
        s = t();
       return (ot(r) && (s = gs([cs([As, s]), As])), ['${', s, ks, '}']);
      })(e, t),
     'expressions',
    );
   }
   function Hs(e, t) {
    return Kr(e, (e) => ('string' == typeof e ? (t ? l(0, e, /(\\*)`/gu, '$1$1\\`') : Xs(e)) : e));
   }
   function Xs(e) {
    return l(0, e, /([\\`]|\$\{)/gu, '\\$1');
   }
   var Ks = [(e, t) => 'ObjectExpression' === e.type && 'properties' === t, (e, t) => 'CallExpression' === e.type && 'Identifier' === e.callee.type && 'Component' === e.callee.name && 'arguments' === t, (e, t) => 'Decorator' === e.type && 'expression' === t];
   function Gs(e, t) {
    return ot(e, it.Block | it.Leading, ({ value: e }) => e === ` ${t} `);
   }
   function Ys({ node: e, parent: t }, r) {
    return (
     Gs(e, r) ||
     ((function (e) {
      return 'AsConstExpression' === e.type || ('TSAsExpression' === e.type && 'TSTypeReference' === e.typeAnnotation.type && 'Identifier' === e.typeAnnotation.typeName.type && 'const' === e.typeAnnotation.typeName.name);
     })(t) &&
      Gs(t, r)) ||
     ('ExpressionStatement' === t.type && Gs(t, r))
    );
   }
   function Qs(e) {
    return 'Identifier' === e.type && 'styled' === e.name;
   }
   function Zs(e) {
    return /^[A-Z]/u.test(e.object.name) && 'extend' === e.property.name;
   }
   function en(e) {
    let t = [],
     r = !1,
     s = e.map((e) => e.trim());
    for (let [n, i] of s.entries()) '' !== i && ('' === s[n - 1] && r ? t.push([Ss, i]) : t.push(i), (r = !0));
    return 0 === t.length ? null : Ts(Ss, t);
   }
   var tn = 0;
   async function rn(e, t, r, s, n) {
    let { node: i } = s,
     a = tn;
    tn = (tn + 1) >>> 0;
    let o = (e) => `PRETTIER_HTML_PLACEHOLDER_${e}_${a}_IN_JS`,
     u = i.quasis.map((e, t, r) => (t === r.length - 1 ? e.value.cooked : e.value.cooked + o(t))).join(''),
     p = zs(s, r),
     c = new RegExp(o('(\\d+)'), 'gu'),
     h = 0,
     d = Kr(
      await t(u, {
       parser: e,
       __onHtmlRoot(e) {
        h = e.children.length;
       },
      }),
      (e) => {
       if ('string' != typeof e) return e;
       let t = [],
        r = e.split(c);
       for (let s = 0; s < r.length; s++) {
        let e = r[s];
        if (s % 2 == 0) {
         e && ((e = Xs(e)), n.__embeddedInHtml && (e = l(0, e, /<\/(?=script\b)/giu, '<\\/')), t.push(e));
         continue;
        }
        let i = Number(e);
        t.push(p[i]);
       }
       return t;
      },
     ),
     f = /^\s/u.test(u) ? ' ' : '',
     m = /\s$/u.test(u) ? ' ' : '',
     y = 'ignore' === n.htmlWhitespaceSensitivity ? Ss : f && m ? Fs : null;
    return y ? gs(['`', cs([y, gs(d)]), y, '`']) : Cs({ hug: !1 }, gs(['`', f, h > 1 ? cs(gs(d)) : gs(d), m, '`']));
   }
   var sn = [
    {
     test: (e) =>
      (function (e) {
       return (
        e.match(void 0, (e, t) => 'quasi' === t && 'TaggedTemplateExpression' === e.type && te(e.tag, ['css', 'css.global', 'css.resolve'])) ||
        e.match(
         void 0,
         (e, t) => 'expression' === t && 'JSXExpressionContainer' === e.type,
         (e, t) => 'children' === t && 'JSXElement' === e.type && 'JSXIdentifier' === e.openingElement.name.type && 'style' === e.openingElement.name.name && e.openingElement.attributes.some((e) => 'JSXAttribute' === e.type && 'JSXIdentifier' === e.name.type && 'jsx' === e.name.name),
        )
       );
      })(e) ||
      (function ({ parent: e }) {
       if (!e || 'TaggedTemplateExpression' !== e.type) return !1;
       let t = 'ParenthesizedExpression' === e.tag.type ? e.tag.expression : e.tag;
       switch (t.type) {
        case 'MemberExpression':
         return Qs(t.object) || Zs(t);
        case 'CallExpression':
         return Qs(t.callee) || ('MemberExpression' === t.callee.type && (('MemberExpression' === t.callee.object.type && (Qs(t.callee.object.object) || Zs(t.callee.object))) || ('CallExpression' === t.callee.object.type && Qs(t.callee.object.callee))));
        case 'Identifier':
         return 'css' === t.name;
        default:
         return !1;
       }
      })(e) ||
      (function ({ parent: e, grandparent: t }) {
       return 'JSXAttribute' === t?.type && 'JSXExpressionContainer' === e.type && 'JSXIdentifier' === t.name.type && 'css' === t.name.name;
      })(e) ||
      (function (e) {
       let t = (e) => 'TemplateLiteral' === e.type,
        r = (e, t) => ct(e) && !e.computed && 'Identifier' === e.key.type && 'styles' === e.key.name && 'value' === t;
       return e.match(t, (e, t) => le(e) && 'elements' === t, r, ...Ks) || e.match(t, r, ...Ks);
      })(e),
     print: async function (e, t, r) {
      let { node: s } = r,
       n = '';
      for (let [a, o] of s.quasis.entries()) {
       let { raw: e } = o.value;
       (a > 0 && (n += '@prettier-placeholder-' + (a - 1) + '-id'), (n += e));
      }
      let i = (function (e, t) {
       if (!k(t)) return e;
       let r = 0,
        s = Kr(rs(e), (e) => ('string' == typeof e && e.includes('@prettier-placeholder') ? e.split(/@prettier-placeholder-(\d+)-id/u).map((e, s) => (s % 2 == 0 ? ss(e) : (r++, t[e]))) : e));
       return t.length === r ? s : null;
      })(await e(n, { parser: 'scss' }), zs(r, t));
      if (!i) throw new Error("Couldn't insert all the expressions");
      return ['`', cs([Ss, i]), As, '`'];
     },
    },
    {
     test: function ({ node: e, parent: t }) {
      return Ys({ node: e, parent: t }, 'GraphQL') || (t && (('TaggedTemplateExpression' === t.type && (('MemberExpression' === t.tag.type && 'graphql' === t.tag.object.name && 'experimental' === t.tag.property.name) || ('Identifier' === t.tag.type && ('gql' === t.tag.name || 'graphql' === t.tag.name)))) || ('CallExpression' === t.type && 'Identifier' === t.callee.type && 'graphql' === t.callee.name)));
     },
     print: async function (e, t, r) {
      let { node: s } = r,
       n = s.quasis.length,
       i = zs(r, t),
       a = [];
      for (let o = 0; o < n; o++) {
       let t = 0 === o,
        r = o === n - 1,
        u = s.quasis[o].value.cooked,
        l = u.split('\n'),
        p = l.length,
        c = i[o],
        h = p > 2 && '' === l[0].trim() && '' === l[1].trim(),
        d = p > 2 && '' === l[p - 1].trim() && '' === l[p - 2].trim(),
        f = l.every((e) => /^\s*(?:#[^\n\r]*)?$/u.test(e));
       if (!r && /#[^\n\r]*$/u.test(l[p - 1])) return null;
       let m = null;
       ((m = f ? en(l) : await e(u, { parser: 'graphql' })), m ? ((m = Hs(m, !1)), !t && h && a.push(''), a.push(m), !r && d && a.push('')) : !t && !r && h && a.push(''), c && a.push(c));
      }
      return ['`', cs([Ss, Ts(Ss, a)]), Ss, '`'];
     },
    },
    {
     test: function (e) {
      return (
       Ys(e, 'HTML') ||
       e.match(
        (e) => 'TemplateLiteral' === e.type,
        (e, t) => 'TaggedTemplateExpression' === e.type && 'Identifier' === e.tag.type && 'html' === e.tag.name && 'quasi' === t,
       )
      );
     },
     print: rn.bind(void 0, 'html'),
    },
    {
     test: function (e) {
      return e.match(
       (e) => 'TemplateLiteral' === e.type,
       (e, t) => ct(e) && !e.computed && 'Identifier' === e.key.type && 'template' === e.key.name && 'value' === t,
       ...Ks,
      );
     },
     print: rn.bind(void 0, 'angular'),
    },
    {
     test: function ({ node: e, parent: t }) {
      return 'TaggedTemplateExpression' === t?.type && 1 === e.quasis.length && 'Identifier' === t.tag.type && ('md' === t.tag.name || 'markdown' === t.tag.name);
     },
     print: async function (e, t, r) {
      let { node: s } = r,
       n = l(0, s.quasis[0].value.raw, /((?:\\\\)*)\\`/gu, (e, t) => '\\'.repeat(t.length / 2) + '`'),
       i = (function (e) {
        let t = e.match(/^([^\S\n]*)\S/mu);
        return null === t ? '' : t[1];
       })(n),
       a = '' !== i;
      a && (n = l(0, n, new RegExp(`^${i}`, 'gmu'), ''));
      let o = Hs(await e(n, { parser: 'markdown', __inJsTemplate: !0 }), !0);
      return ['`', a ? cs([As, o]) : [vs, ds(o)], As, '`'];
     },
    },
   ].map(({ test: e, print: t }) => ({ test: e, print: nn(t) }));
   function nn(e) {
    return async (...t) => {
     let r = await e(...t);
     return r && Cs({ embed: !0, ...r.label }, r);
    };
   }
   var an = function (e) {
     let { node: t } = e;
     if (
      'TemplateLiteral' !== t.type ||
      (function ({ quasis: e }) {
       return e.some(({ value: { cooked: e } }) => null === e);
      })(t)
     )
      return;
     let r = sn.find(({ test: t }) => t(e));
     return r ? (1 === t.quasis.length && '' === t.quasis[0].value.raw.trim() ? '``' : r.print) : void 0;
    },
    on = /\*\/$/,
    un = /^\/\*\*?/,
    ln = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/,
    pn = /(^|\s+)\/\/([^\n\r]*)/g,
    cn = /^(\r?\n)+/,
    hn = /(?:^|\r?\n) *(@[^\n\r]*?) *\r?\n *(?![^\n\r@]*\/\/[^]*)([^\s@][^\n\r@]+?) *\r?\n/g,
    dn = /(?:^|\r?\n) *@(\S+) *([^\n\r]*)/g,
    fn = /(\r?\n|^) *\* ?/g,
    mn = [];
   function yn(e, t) {
    return [...mn, ...(Array.isArray(t) ? t : [t])].map((t) => `@${e} ${t}`.trim());
   }
   var Dn = function (e) {
    if (!e.startsWith('#!')) return '';
    let t = e.indexOf('\n');
    return -1 === t ? e : e.slice(0, t);
   };
   function gn(e) {
    let t = Dn(e);
    t && (e = e.slice(t.length + 1));
    let r = (function (e) {
      let t = e.match(ln);
      return t ? t[0].trimStart() : '';
     })(e),
     { pragmas: s, comments: n } = (function (e) {
      e = l(0, e.replace(un, '').replace(on, ''), fn, '$1');
      let t = '';
      for (; t !== e; ) ((t = e), (e = l(0, e, hn, '\n$1 $2\n')));
      e = e.replace(cn, '').trimEnd();
      let r,
       s = Object.create(null),
       n = l(0, e, dn, '').replace(cn, '').trimEnd();
      for (; (r = dn.exec(e)); ) {
       let e = l(0, r[2], pn, '');
       if ('string' == typeof s[r[1]] || Array.isArray(s[r[1]])) {
        let t = s[r[1]];
        s[r[1]] = [...mn, ...(Array.isArray(t) ? t : [t]), e];
       } else s[r[1]] = e;
      }
      return { comments: n, pragmas: s };
     })(r);
    return { shebang: t, text: e, pragmas: s, comments: n };
   }
   function xn(e) {
    let { shebang: t, text: r, pragmas: s, comments: n } = gn(e),
     i = (function (e) {
      let t = e.match(ln)?.[0];
      return null == t ? e : e.slice(t.length);
     })(r),
     a = (function ({ comments: e = '', pragmas: t = {} }) {
      let r = Object.keys(t),
       s = r
        .flatMap((e) => yn(e, t[e]))
        .map((e) => ` * ${e}\n`)
        .join('');
      if (!e) {
       if (0 === r.length) return '';
       if (1 === r.length && !Array.isArray(t[r[0]])) {
        let e = t[r[0]];
        return `/** ${yn(r[0], e)[0]} */`;
       }
      }
      let n =
       e
        .split('\n')
        .map((e) => ` * ${e}`)
        .join('\n') + '\n';
      return '/**\n' + (e ? n : '') + (e && r.length > 0 ? ' *\n' : '') + s + ' */';
     })({ pragmas: { format: '', ...s }, comments: n.trimStart() });
    return (t ? `${t}\n` : '') + a + (i.startsWith('\n') ? '\n' : '\n\n') + i;
   }
   var En = new WeakMap();
   var bn = function (e) {
    return (
     En.has(e) ||
      En.set(
       e,
       (function (e) {
        if (!Q(e)) return !1;
        let t = `*${e.value}*`.split('\n');
        return t.length > 1 && t.every((e) => '*' === e.trimStart()[0]);
       })(e),
      ),
     En.get(e)
    );
   };
   function Tn(e, t) {
    let r = e.node;
    if (ee(r)) return t.originalText.slice($(r), q(r)).trimEnd();
    if (bn(r))
     return (function (e) {
      let t = e.value.split('\n');
      return [
       '/*',
       Ts(
        Ss,
        t.map((e, r) => (0 === r ? e.trimEnd() : ' ' + (r < t.length - 1 ? e.trim() : e.trimStart()))),
       ),
       '*/',
      ];
     })(r);
    if (Q(r)) return ['/*', ss(r.value), '*/'];
    throw new Error('Not a comment: ' + JSON.stringify(r));
   }
   function Cn(e, t) {
    if (e.isRoot) return !1;
    let { node: r, key: s, parent: n } = e;
    if (
     t.__isInHtmlInterpolation &&
     !t.bracketSpacing &&
     (function (e) {
      return pe(e);
     })(r) &&
     An(e)
    )
     return !0;
    if (Fn(r)) return !1;
    if ('Identifier' === r.type) {
     if ((r.extra?.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/u.test(r.name)) || ('left' === s && (('async' === r.name && !n.await) || 'let' === r.name) && 'ForOfStatement' === n.type)) return !0;
     if ('let' === r.name) {
      let t = e.findAncestor((e) => 'ForOfStatement' === e.type)?.left;
      if (t && Je(t, (e) => e === r)) return !0;
     }
     if ('object' === s && 'let' === r.name && 'MemberExpression' === n.type && n.computed && !n.optional) {
      let t = e.findAncestor((e) => 'ExpressionStatement' === e.type || 'ForStatement' === e.type || 'ForInStatement' === e.type),
       s = t ? ('ExpressionStatement' === t.type ? t.expression : 'ForStatement' === t.type ? t.init : t.left) : void 0;
      if (s && Je(s, (e) => e === r)) return !0;
     }
     if ('expression' === s)
      switch (r.name) {
       case 'await':
       case 'interface':
       case 'module':
       case 'using':
       case 'yield':
       case 'let':
       case 'component':
       case 'hook':
       case 'type': {
        let t = e.findAncestor((e) => !ht(e));
        if (t !== n && 'ExpressionStatement' === t.type) return !0;
       }
      }
     return !1;
    }
    if ('ObjectExpression' === r.type || 'FunctionExpression' === r.type || 'ClassExpression' === r.type || 'DoExpression' === r.type) {
     let t = e.findAncestor((e) => 'ExpressionStatement' === e.type)?.expression;
     if (t && Je(t, (e) => e === r)) return !0;
    }
    if ('ObjectExpression' === r.type) {
     let t = e.findAncestor((e) => 'ArrowFunctionExpression' === e.type)?.body;
     if (t && 'SequenceExpression' !== t.type && 'AssignmentExpression' !== t.type && Je(t, (e) => e === r)) return !0;
    }
    switch (n.type) {
     case 'ParenthesizedExpression':
      return !1;
     case 'ClassDeclaration':
     case 'ClassExpression':
      if ('superClass' === s && ('ArrowFunctionExpression' === r.type || 'AssignmentExpression' === r.type || 'AwaitExpression' === r.type || 'BinaryExpression' === r.type || 'ConditionalExpression' === r.type || 'LogicalExpression' === r.type || 'NewExpression' === r.type || 'ObjectExpression' === r.type || 'SequenceExpression' === r.type || 'TaggedTemplateExpression' === r.type || 'UnaryExpression' === r.type || 'UpdateExpression' === r.type || 'YieldExpression' === r.type || 'TSNonNullExpression' === r.type || ('ClassExpression' === r.type && k(r.decorators)))) return !0;
      break;
     case 'ExportDefaultDeclaration':
      return wn(e, t) || 'SequenceExpression' === r.type;
     case 'Decorator':
      if (
       'expression' === s &&
       !(function (e) {
        return ('ChainExpression' === e.type && (e = e.expression), Sn(e) || (ke(e) && !e.optional && Sn(e.callee)));
       })(r)
      )
       return !0;
      break;
     case 'TypeAnnotation':
      if (
       e.match(void 0, void 0, (e, t) => 'returnType' === t && 'ArrowFunctionExpression' === e.type) &&
       (function (e) {
        return ne(e, (e) => 'ObjectTypeAnnotation' === e.type && ne(e, (e) => 'FunctionTypeAnnotation' === e.type));
       })(r)
      )
       return !0;
      break;
     case 'BinaryExpression':
      if ('left' === s && ('in' === n.operator || 'instanceof' === n.operator) && 'UnaryExpression' === r.type) return !0;
      break;
     case 'VariableDeclarator':
      if (
       'init' === s &&
       e.match(
        void 0,
        void 0,
        (e, t) => 'declarations' === t && 'VariableDeclaration' === e.type,
        (e, t) => 'left' === t && 'ForInStatement' === e.type,
       )
      )
       return !0;
    }
    switch (r.type) {
     case 'UpdateExpression':
      if ('UnaryExpression' === n.type) return r.prefix && (('++' === r.operator && '+' === n.operator) || ('--' === r.operator && '-' === n.operator));
     case 'UnaryExpression':
      switch (n.type) {
       case 'UnaryExpression':
        return r.operator === n.operator && ('+' === r.operator || '-' === r.operator);
       case 'BindExpression':
       case 'TaggedTemplateExpression':
       case 'TSNonNullExpression':
        return !0;
       case 'MemberExpression':
       case 'OptionalMemberExpression':
        return 'object' === s;
       case 'NewExpression':
       case 'CallExpression':
       case 'OptionalCallExpression':
        return 'callee' === s;
       case 'BinaryExpression':
        return 'left' === s && '**' === n.operator;
       default:
        return !1;
      }
     case 'BinaryExpression':
      if (
       'UpdateExpression' === n.type ||
       ('in' === r.operator &&
        (function (e) {
         let t = 0,
          { node: r } = e;
         for (; r; ) {
          let s = e.getParentNode(t++);
          if ('ForStatement' === s?.type && s.init === r) return !0;
          r = s;
         }
         return !1;
        })(e))
      )
       return !0;
      if ('|>' === r.operator && r.extra?.parenthesized) {
       let t = e.grandparent;
       if ('BinaryExpression' === t.type && '|>' === t.operator) return !0;
      }
     case 'TSTypeAssertion':
     case 'TSAsExpression':
     case 'TSSatisfiesExpression':
     case 'AsExpression':
     case 'AsConstExpression':
     case 'SatisfiesExpression':
     case 'LogicalExpression':
      switch (n.type) {
       case 'TSAsExpression':
       case 'TSSatisfiesExpression':
       case 'AsExpression':
       case 'AsConstExpression':
       case 'SatisfiesExpression':
        return !ht(r);
       case 'ConditionalExpression':
        return (
         ht(r) ||
         (function (e) {
          return 'LogicalExpression' === e.type && '??' === e.operator;
         })(r)
        );
       case 'CallExpression':
       case 'NewExpression':
       case 'OptionalCallExpression':
        return 'callee' === s;
       case 'ClassExpression':
       case 'ClassDeclaration':
        return 'superClass' === s;
       case 'TSTypeAssertion':
       case 'TaggedTemplateExpression':
       case 'UnaryExpression':
       case 'JSXSpreadAttribute':
       case 'SpreadElement':
       case 'BindExpression':
       case 'AwaitExpression':
       case 'TSNonNullExpression':
       case 'UpdateExpression':
        return !0;
       case 'MemberExpression':
       case 'OptionalMemberExpression':
        return 'object' === s;
       case 'AssignmentExpression':
       case 'AssignmentPattern':
        return 'left' === s && ('TSTypeAssertion' === r.type || ht(r));
       case 'LogicalExpression':
        if ('LogicalExpression' === r.type) return n.operator !== r.operator;
       case 'BinaryExpression': {
        let { operator: e, type: t } = r;
        if (!e && 'TSTypeAssertion' !== t) return !0;
        let i = Ke(e),
         a = n.operator,
         o = Ke(a);
        return !!(
         o > i ||
         ('right' === s && o === i) ||
         (o === i && !He(a, e)) ||
         (o < i && '%' === e && ('+' === a || '-' === a)) ||
         (function (e) {
          return !!ze[e] || '|' === e || '^' === e || '&' === e;
         })(a)
        );
       }
       default:
        return !1;
      }
     case 'SequenceExpression':
      return 'ForStatement' !== n.type;
     case 'YieldExpression':
      if ('AwaitExpression' === n.type || 'TSTypeAssertion' === n.type) return !0;
     case 'AwaitExpression':
      switch (n.type) {
       case 'TaggedTemplateExpression':
       case 'UnaryExpression':
       case 'LogicalExpression':
       case 'SpreadElement':
       case 'TSAsExpression':
       case 'TSSatisfiesExpression':
       case 'TSNonNullExpression':
       case 'AsExpression':
       case 'AsConstExpression':
       case 'SatisfiesExpression':
       case 'BindExpression':
        return !0;
       case 'MemberExpression':
       case 'OptionalMemberExpression':
        return 'object' === s;
       case 'NewExpression':
       case 'CallExpression':
       case 'OptionalCallExpression':
        return 'callee' === s;
       case 'ConditionalExpression':
        return 'test' === s;
       case 'BinaryExpression':
        return !(!r.argument && '|>' === n.operator);
       default:
        return !1;
      }
     case 'TSFunctionType':
      if (
       e.match(
        (e) => 'TSFunctionType' === e.type,
        (e, t) => 'typeAnnotation' === t && 'TSTypeAnnotation' === e.type,
        (e, t) => 'returnType' === t && 'ArrowFunctionExpression' === e.type,
       )
      )
       return !0;
     case 'TSConditionalType':
     case 'TSConstructorType':
     case 'ConditionalTypeAnnotation':
      if (('extendsType' === s && mt(r) && n.type === r.type) || ('checkType' === s && mt(n))) return !0;
      if ('extendsType' === s && 'TSConditionalType' === n.type) {
       let { typeAnnotation: e } = r.returnType || r.typeAnnotation;
       if (('TSTypePredicate' === e.type && e.typeAnnotation && (e = e.typeAnnotation.typeAnnotation), 'TSInferType' === e.type && e.typeParameter.constraint)) return !0;
      }
     case 'TSUnionType':
     case 'TSIntersectionType':
      if (dt(n) || ft(n)) return !0;
     case 'TSInferType':
      if ('TSInferType' === r.type) {
       if ('TSRestType' === n.type) return !1;
       if ('types' === s && ('TSUnionType' === n.type || 'TSIntersectionType' === n.type) && 'TSTypeParameter' === r.typeParameter.type && r.typeParameter.constraint) return !0;
      }
     case 'TSTypeOperator':
      return 'TSArrayType' === n.type || 'TSOptionalType' === n.type || 'TSRestType' === n.type || ('objectType' === s && 'TSIndexedAccessType' === n.type) || 'TSTypeOperator' === n.type || ('TSTypeAnnotation' === n.type && e.grandparent.type.startsWith('TSJSDoc'));
     case 'TSTypeQuery':
      return ('objectType' === s && 'TSIndexedAccessType' === n.type) || ('elementType' === s && 'TSArrayType' === n.type);
     case 'TypeOperator':
      return 'ArrayTypeAnnotation' === n.type || 'NullableTypeAnnotation' === n.type || ('objectType' === s && ('IndexedAccessType' === n.type || 'OptionalIndexedAccessType' === n.type)) || 'TypeOperator' === n.type;
     case 'TypeofTypeAnnotation':
      return ('objectType' === s && ('IndexedAccessType' === n.type || 'OptionalIndexedAccessType' === n.type)) || ('elementType' === s && 'ArrayTypeAnnotation' === n.type);
     case 'ArrayTypeAnnotation':
      return 'NullableTypeAnnotation' === n.type;
     case 'IntersectionTypeAnnotation':
     case 'UnionTypeAnnotation':
      return 'TypeOperator' === n.type || 'KeyofTypeAnnotation' === n.type || 'ArrayTypeAnnotation' === n.type || 'NullableTypeAnnotation' === n.type || 'IntersectionTypeAnnotation' === n.type || 'UnionTypeAnnotation' === n.type || ('objectType' === s && ('IndexedAccessType' === n.type || 'OptionalIndexedAccessType' === n.type));
     case 'InferTypeAnnotation':
     case 'NullableTypeAnnotation':
      return 'ArrayTypeAnnotation' === n.type || ('objectType' === s && ('IndexedAccessType' === n.type || 'OptionalIndexedAccessType' === n.type));
     case 'ComponentTypeAnnotation':
     case 'FunctionTypeAnnotation': {
      if ('ComponentTypeAnnotation' === r.type && (null === r.rendersType || void 0 === r.rendersType)) return !1;
      if (
       e.match(
        void 0,
        (e, t) => 'typeAnnotation' === t && 'TypeAnnotation' === e.type,
        (e, t) => 'returnType' === t && 'ArrowFunctionExpression' === e.type,
       ) ||
       e.match(
        void 0,
        (e, t) => 'typeAnnotation' === t && 'TypePredicate' === e.type,
        (e, t) => 'typeAnnotation' === t && 'TypeAnnotation' === e.type,
        (e, t) => 'returnType' === t && 'ArrowFunctionExpression' === e.type,
       )
      )
       return !0;
      let t = 'NullableTypeAnnotation' === n.type ? e.grandparent : n;
      return 'UnionTypeAnnotation' === t.type || 'IntersectionTypeAnnotation' === t.type || 'ArrayTypeAnnotation' === t.type || ('objectType' === s && ('IndexedAccessType' === t.type || 'OptionalIndexedAccessType' === t.type)) || ('checkType' === s && 'ConditionalTypeAnnotation' === n.type) || ('extendsType' === s && 'ConditionalTypeAnnotation' === n.type && 'InferTypeAnnotation' === r.returnType?.type && r.returnType?.typeParameter.bound) || 'NullableTypeAnnotation' === t.type || ('FunctionTypeParam' === n.type && null === n.name && Qe(r).some((e) => 'NullableTypeAnnotation' === e.typeAnnotation?.type));
     }
     case 'OptionalIndexedAccessType':
      return 'objectType' === s && 'IndexedAccessType' === n.type;
     case 'StringLiteral':
     case 'NumericLiteral':
     case 'Literal':
      if ('string' == typeof r.value && 'ExpressionStatement' === n.type && 'string' != typeof n.directive) {
       let t = e.grandparent;
       return 'Program' === t.type || 'BlockStatement' === t.type;
      }
      return 'object' === s && Ie(n) && ce(r);
     case 'AssignmentExpression':
      return !((('init' === s || 'update' === s) && 'ForStatement' === n.type) || ('expression' === s && 'ObjectPattern' !== r.left.type && 'ExpressionStatement' === n.type) || ('key' === s && 'TSPropertySignature' === n.type) || 'AssignmentExpression' === n.type || ('expressions' === s && 'SequenceExpression' === n.type && e.match(void 0, void 0, (e, t) => ('init' === t || 'update' === t) && 'ForStatement' === e.type)) || ('value' === s && 'Property' === n.type && e.match(void 0, void 0, (e, t) => 'properties' === t && 'ObjectPattern' === e.type)) || 'NGChainedExpression' === n.type || ('node' === s && 'JsExpressionRoot' === n.type));
     case 'ConditionalExpression':
      switch (n.type) {
       case 'TaggedTemplateExpression':
       case 'UnaryExpression':
       case 'SpreadElement':
       case 'BinaryExpression':
       case 'LogicalExpression':
       case 'NGPipeExpression':
       case 'ExportDefaultDeclaration':
       case 'AwaitExpression':
       case 'JSXSpreadAttribute':
       case 'TSTypeAssertion':
       case 'TypeCastExpression':
       case 'TSAsExpression':
       case 'TSSatisfiesExpression':
       case 'AsExpression':
       case 'AsConstExpression':
       case 'SatisfiesExpression':
       case 'TSNonNullExpression':
        return !0;
       case 'NewExpression':
       case 'CallExpression':
       case 'OptionalCallExpression':
        return 'callee' === s;
       case 'ConditionalExpression':
        return !t.experimentalTernaries && 'test' === s;
       case 'MemberExpression':
       case 'OptionalMemberExpression':
        return 'object' === s;
       default:
        return !1;
      }
     case 'FunctionExpression':
      switch (n.type) {
       case 'NewExpression':
       case 'CallExpression':
       case 'OptionalCallExpression':
        return 'callee' === s;
       case 'TaggedTemplateExpression':
        return !0;
       default:
        return !1;
      }
     case 'ArrowFunctionExpression':
      switch (n.type) {
       case 'BinaryExpression':
        return '|>' !== n.operator || r.extra?.parenthesized;
       case 'NewExpression':
       case 'CallExpression':
       case 'OptionalCallExpression':
        return 'callee' === s;
       case 'MemberExpression':
       case 'OptionalMemberExpression':
        return 'object' === s;
       case 'TSAsExpression':
       case 'TSSatisfiesExpression':
       case 'AsExpression':
       case 'AsConstExpression':
       case 'SatisfiesExpression':
       case 'TSNonNullExpression':
       case 'BindExpression':
       case 'TaggedTemplateExpression':
       case 'UnaryExpression':
       case 'LogicalExpression':
       case 'AwaitExpression':
       case 'TSTypeAssertion':
       case 'MatchExpressionCase':
        return !0;
       case 'TSInstantiationExpression':
        return 'expression' === s;
       case 'ConditionalExpression':
        return 'test' === s;
       default:
        return !1;
      }
     case 'ClassExpression':
      return 'NewExpression' === n.type && 'callee' === s;
     case 'OptionalMemberExpression':
     case 'OptionalCallExpression':
     case 'CallExpression':
     case 'MemberExpression':
      if (
       (function (e) {
        return !!(
         e.match(
          void 0,
          (e, t) => 'expression' === t && 'ChainExpression' === e.type,
          (e, t) => 'tag' === t && 'TaggedTemplateExpression' === e.type,
         ) ||
         e.match(
          (e) => 'OptionalCallExpression' === e.type || 'OptionalMemberExpression' === e.type,
          (e, t) => 'tag' === t && 'TaggedTemplateExpression' === e.type,
         ) ||
         e.match(
          (e) => 'OptionalCallExpression' === e.type || 'OptionalMemberExpression' === e.type,
          (e, t) => 'expression' === t && 'TSNonNullExpression' === e.type,
          (e, t) => 'tag' === t && 'TaggedTemplateExpression' === e.type,
         ) ||
         e.match(
          void 0,
          (e, t) => 'expression' === t && 'ChainExpression' === e.type,
          (e, t) => 'expression' === t && 'TSNonNullExpression' === e.type,
          (e, t) => 'tag' === t && 'TaggedTemplateExpression' === e.type,
         ) ||
         e.match(
          void 0,
          (e, t) => 'expression' === t && 'TSNonNullExpression' === e.type,
          (e, t) => 'expression' === t && 'ChainExpression' === e.type,
          (e, t) => 'tag' === t && 'TaggedTemplateExpression' === e.type,
         ) ||
         e.match(
          (e) => 'OptionalMemberExpression' === e.type || 'OptionalCallExpression' === e.type,
          (e, t) => ('object' === t && 'MemberExpression' === e.type) || ('callee' === t && ('CallExpression' === e.type || 'NewExpression' === e.type)),
         ) ||
         e.match(
          (e) => 'OptionalMemberExpression' === e.type || 'OptionalCallExpression' === e.type,
          (e, t) => 'expression' === t && 'TSNonNullExpression' === e.type,
          (e, t) => ('object' === t && 'MemberExpression' === e.type) || ('callee' === t && 'CallExpression' === e.type),
         ) ||
         (e.match(
          (e) => 'CallExpression' === e.type || 'MemberExpression' === e.type,
          (e, t) => 'expression' === t && 'ChainExpression' === e.type,
         ) &&
          (e.match(void 0, void 0, (e, t) => ('callee' === t && (('CallExpression' === e.type && !e.optional) || 'NewExpression' === e.type)) || ('object' === t && 'MemberExpression' === e.type && !e.optional)) ||
           e.match(
            void 0,
            void 0,
            (e, t) => 'expression' === t && 'TSNonNullExpression' === e.type,
            (e, t) => ('object' === t && 'MemberExpression' === e.type) || ('callee' === t && 'CallExpression' === e.type),
           ))) ||
         e.match(
          (e) => 'CallExpression' === e.type || 'MemberExpression' === e.type,
          (e, t) => 'expression' === t && 'TSNonNullExpression' === e.type,
          (e, t) => 'expression' === t && 'ChainExpression' === e.type,
          (e, t) => ('object' === t && 'MemberExpression' === e.type) || ('callee' === t && 'CallExpression' === e.type),
         )
        );
       })(e)
      )
       return !0;
     case 'TaggedTemplateExpression':
     case 'TSNonNullExpression':
      if ('callee' === s && ('BindExpression' === n.type || 'NewExpression' === n.type)) {
       let e = r;
       for (; e; )
        switch (e.type) {
         case 'CallExpression':
         case 'OptionalCallExpression':
          return !0;
         case 'MemberExpression':
         case 'OptionalMemberExpression':
         case 'BindExpression':
          e = e.object;
          break;
         case 'TaggedTemplateExpression':
          e = e.tag;
          break;
         case 'TSNonNullExpression':
          e = e.expression;
          break;
         default:
          return !1;
        }
      }
      return !1;
     case 'BindExpression':
      return ('callee' === s && ('BindExpression' === n.type || 'NewExpression' === n.type)) || ('object' === s && Ie(n));
     case 'NGPipeExpression':
      return !('NGRoot' === n.type || 'NGMicrosyntaxExpression' === n.type || ('ObjectProperty' === n.type && !r.extra?.parenthesized) || le(n) || ('arguments' === s && ke(n)) || ('right' === s && 'NGPipeExpression' === n.type) || ('property' === s && 'MemberExpression' === n.type) || 'AssignmentExpression' === n.type);
     case 'JSXFragment':
     case 'JSXElement':
      return 'callee' === s || ('left' === s && 'BinaryExpression' === n.type && '<' === n.operator) || (!le(n) && 'ArrowFunctionExpression' !== n.type && 'AssignmentExpression' !== n.type && 'AssignmentPattern' !== n.type && 'BinaryExpression' !== n.type && 'NewExpression' !== n.type && 'ConditionalExpression' !== n.type && 'ExpressionStatement' !== n.type && 'JsExpressionRoot' !== n.type && 'JSXAttribute' !== n.type && 'JSXElement' !== n.type && 'JSXExpressionContainer' !== n.type && 'JSXFragment' !== n.type && 'LogicalExpression' !== n.type && !ke(n) && !ct(n) && 'ReturnStatement' !== n.type && 'ThrowStatement' !== n.type && 'TypeCastExpression' !== n.type && 'VariableDeclarator' !== n.type && 'YieldExpression' !== n.type && 'MatchExpressionCase' !== n.type);
     case 'TSInstantiationExpression':
      return 'object' === s && Ie(n);
     case 'MatchOrPattern':
      return 'MatchAsPattern' === n.type;
    }
    return !1;
   }
   var Fn = G(['BlockStatement', 'BreakStatement', 'ComponentDeclaration', 'ClassBody', 'ClassDeclaration', 'ClassMethod', 'ClassProperty', 'PropertyDefinition', 'ClassPrivateProperty', 'ContinueStatement', 'DebuggerStatement', 'DeclareComponent', 'DeclareClass', 'DeclareExportAllDeclaration', 'DeclareExportDeclaration', 'DeclareFunction', 'DeclareHook', 'DeclareInterface', 'DeclareModule', 'DeclareModuleExports', 'DeclareNamespace', 'DeclareVariable', 'DeclareEnum', 'DoWhileStatement', 'EnumDeclaration', 'ExportAllDeclaration', 'ExportDefaultDeclaration', 'ExportNamedDeclaration', 'ExpressionStatement', 'ForInStatement', 'ForOfStatement', 'ForStatement', 'FunctionDeclaration', 'HookDeclaration', 'IfStatement', 'ImportDeclaration', 'InterfaceDeclaration', 'LabeledStatement', 'MethodDefinition', 'ReturnStatement', 'SwitchStatement', 'ThrowStatement', 'TryStatement', 'TSDeclareFunction', 'TSEnumDeclaration', 'TSImportEqualsDeclaration', 'TSInterfaceDeclaration', 'TSModuleDeclaration', 'TSNamespaceExportDeclaration', 'TypeAlias', 'VariableDeclaration', 'WhileStatement', 'WithStatement']);
   function An(e) {
    let { parent: t, key: r } = e;
    switch (t.type) {
     case 'NGPipeExpression':
      if ('arguments' === r && e.isLast) return e.callParent(An);
      break;
     case 'ObjectProperty':
      if ('value' === r) return e.callParent(() => 'properties' === e.key && e.isLast);
      break;
     case 'BinaryExpression':
     case 'LogicalExpression':
      if ('right' === r) return e.callParent(An);
      break;
     case 'ConditionalExpression':
      if ('alternate' === r) return e.callParent(An);
      break;
     case 'UnaryExpression':
      if (t.prefix) return e.callParent(An);
    }
    return !1;
   }
   function wn(e, t) {
    let { node: r, parent: s } = e;
    return 'FunctionExpression' === r.type || 'ClassExpression' === r.type ? 'ExportDefaultDeclaration' === s.type || !Cn(e, t) : !(!ie(r) || ('ExportDefaultDeclaration' !== s.type && Cn(e, t))) && e.call(() => wn(e, t), ...oe(r));
   }
   function Sn(e) {
    return 'Identifier' === e.type || (!!Ie(e) && !e.computed && !e.optional && 'Identifier' === e.property.type && Sn(e.object));
   }
   var vn = Cn;
   var Pn = function (e, t) {
     let r = t - 1;
     return ((r = b(e, r, { backwards: !0 })), (r = A(e, r, { backwards: !0 })), (r = b(e, r, { backwards: !0 })), r !== A(e, r, { backwards: !0 }));
    },
    kn = () => !0;
   function In(e, t) {
    return ((e.node.printed = !0), t.printer.printComment(e, t));
   }
   function Nn(e, t, r = {}) {
    let { node: s } = e;
    if (!k(s?.comments)) return '';
    let { indent: n = !1, marker: i, filter: a = kn } = r,
     o = [];
    if (
     (e.each(({ node: r }) => {
      r.leading || r.trailing || r.marker !== i || !a(r) || o.push(In(e, t));
     }, 'comments'),
     0 === o.length)
    )
     return '';
    let u = Ts(Ss, o);
    return n ? cs([Ss, u]) : u;
   }
   function Bn(e, t) {
    let r = e.node;
    if (!r) return {};
    let s = t[Symbol.for('printedComments')];
    if (0 === (r.comments || []).filter((e) => !s.has(e)).length) return { leading: '', trailing: '' };
    let n,
     i = [],
     a = [];
    return (
     e.each(() => {
      let r = e.node;
      if (s?.has(r)) return;
      let { leading: o, trailing: u } = r;
      o
       ? i.push(
          (function (e, t) {
           let r = e.node,
            s = [In(e, t)],
            { printer: n, originalText: i, locStart: a, locEnd: o } = t;
           if (n.isBlockComment?.(r)) {
            let e = w(i, o(r)) ? (w(i, a(r), { backwards: !0 }) ? Ss : Fs) : ' ';
            s.push(e);
           } else s.push(Ss);
           let u = A(i, b(i, o(r)));
           return (!1 !== u && w(i, u) && s.push(Ss), s);
          })(e, t),
         )
       : u &&
         ((n = (function (e, t, r) {
          let s = e.node,
           n = In(e, t),
           { printer: i, originalText: a, locStart: o } = t,
           u = i.isBlockComment?.(s);
          if ((r?.hasLineSuffix && !r?.isBlock) || w(a, o(s), { backwards: !0 })) {
           let e = Pn(a, o(s));
           return { doc: Ps([Ss, e ? Ss : '', n]), isBlock: u, hasLineSuffix: !0 };
          }
          return !u || r?.hasLineSuffix ? { doc: [Ps([' ', n]), ms], isBlock: u, hasLineSuffix: !0 } : { doc: [' ', n], isBlock: u, hasLineSuffix: !1 };
         })(e, t, n)),
         a.push(n.doc));
     }, 'comments'),
     { leading: i, trailing: a }
    );
   }
   function On(e, t, r) {
    let { leading: s, trailing: n } = Bn(e, r);
    return s || n ? is(t, (e) => [s, e, n]) : t;
   }
   var Ln = class extends Error {
    name = 'ArgExpansionBailout';
   };
   function Mn(e, t, r, s, n) {
    let i = e.node,
     a = Qe(i),
     o = n && i.typeParameters ? r('typeParameters') : '';
    if (0 === a.length) return [o, '(', Nn(e, t, { filter: (e) => ')' === kt(t.originalText, q(e)) }), ')'];
    let { parent: u } = e,
     l = ve(u),
     p = jn(i),
     c = [];
    if (
     ((function (e, t) {
      let { node: r } = e,
       s = 0,
       n = () => t(e, s++);
      (r.this && e.call(n, 'this'), e.each(n, 'params'), r.rest && e.call(n, 'rest'));
     })(e, (e, s) => {
      let n = s === a.length - 1;
      (n && i.rest && c.push('...'), c.push(r()), !n && (c.push(','), l || p ? c.push(' ') : lt(a[s], t) ? c.push(Ss, Ss) : c.push(Fs)));
     }),
     s &&
      !(function (e) {
       return e.match(
        (e) => 'ArrowFunctionExpression' === e.type && 'BlockStatement' === e.body.type,
        (e, t) => {
         if ('CallExpression' === e.type && 'arguments' === t && 1 === e.arguments.length && 'CallExpression' === e.callee.type) {
          let t = e.callee.callee;
          return 'Identifier' === t.type || ('MemberExpression' === t.type && !t.computed && 'Identifier' === t.object.type && 'Identifier' === t.property.type);
         }
         return !1;
        },
        (e, t) => ('VariableDeclarator' === e.type && 'init' === t) || ('ExportDefaultDeclaration' === e.type && 'declaration' === t) || ('TSExportAssignment' === e.type && 'expression' === t) || ('AssignmentExpression' === e.type && 'right' === t && 'MemberExpression' === e.left.type && 'Identifier' === e.left.object.type && 'module' === e.left.object.name && 'Identifier' === e.left.property.type && 'exports' === e.left.property.name),
        (e) => 'VariableDeclaration' !== e.type || ('const' === e.kind && 1 === e.declarations.length),
       );
      })(e))
    ) {
     if (Qr(o) || Qr(c)) throw new Ln();
     return gs([ts(o), '(', ts(c), ')']);
    }
    let h = a.every((e) => !k(e.decorators));
    return (p && h) || l
     ? [o, '(', ...c, ')']
     : (Te(u) ||
          (function (e) {
           return !(('TypeAnnotation' !== e.type && 'TSTypeAnnotation' !== e.type) || 'FunctionTypeAnnotation' !== e.typeAnnotation.type || e.static || J(e, e.typeAnnotation));
          })(u) ||
          'TypeAlias' === u.type ||
          'UnionTypeAnnotation' === u.type ||
          'IntersectionTypeAnnotation' === u.type ||
          ('FunctionTypeAnnotation' === u.type && u.returnType === i)) &&
         1 === a.length &&
         null === a[0].name &&
         i.this !== a[0] &&
         a[0].typeAnnotation &&
         null === i.typeParameters &&
         we(a[0].typeAnnotation) &&
         !i.rest
       ? 'always' === t.arrowParens || 'HookTypeAnnotation' === i.type
         ? ['(', ...c, ')']
         : c
       : [o, '(', cs([As, ...c]), Es(!Ge(i) && qe(t, 'all') ? ',' : ''), As, ')'];
   }
   function jn(e) {
    if (!e) return !1;
    let t = Qe(e);
    if (1 !== t.length) return !1;
    let [r] = t;
    return !ot(r) && ('ObjectPattern' === r.type || 'ArrayPattern' === r.type || ('Identifier' === r.type && r.typeAnnotation && ('TypeAnnotation' === r.typeAnnotation.type || 'TSTypeAnnotation' === r.typeAnnotation.type) && De(r.typeAnnotation.typeAnnotation)) || ('FunctionTypeParam' === r.type && De(r.typeAnnotation) && r !== e.rest) || ('AssignmentPattern' === r.type && ('ObjectPattern' === r.left.type || 'ArrayPattern' === r.left.type) && ('Identifier' === r.right.type || (pe(r.right) && 0 === r.right.properties.length) || (le(r.right) && 0 === r.right.elements.length))));
   }
   function _n(e, t) {
    let r = (function (e) {
     let t;
     return (e.returnType ? ((t = e.returnType), t.typeAnnotation && (t = t.typeAnnotation)) : e.typeAnnotation && (t = e.typeAnnotation), t);
    })(e);
    if (!r) return !1;
    let s = e.typeParameters?.params;
    if (s) {
     if (s.length > 1) return !1;
     if (1 === s.length) {
      let e = s[0];
      if (e.constraint || e.default) return !1;
     }
    }
    return 1 === Qe(e).length && (De(r) || Qr(t));
   }
   function Rn(e, t) {
    return ('params' === t || 'this' === t || 'rest' === t) && jn(e);
   }
   function Un(e) {
    let { node: t } = e;
    return !t.optional || ('Identifier' === t.type && t === e.parent.key) ? '' : ke(t) || (Ie(t) && t.computed) || 'OptionalIndexedAccessType' === t.type ? '?.' : '?';
   }
   function $n(e) {
    return e.node.definite || e.match(void 0, (e, t) => 'id' === t && 'VariableDeclarator' === e.type && e.definite) ? '!' : '';
   }
   var qn = G(['DeclareClass', 'DeclareComponent', 'DeclareFunction', 'DeclareHook', 'DeclareVariable', 'DeclareExportDeclaration', 'DeclareExportAllDeclaration', 'DeclareOpaqueType', 'DeclareTypeAlias', 'DeclareEnum', 'DeclareInterface']);
   function Jn(e) {
    let { node: t } = e;
    return t.declare || (qn(t) && 'DeclareExportDeclaration' !== e.parent.type) ? 'declare ' : '';
   }
   var Wn = G(['TSAbstractMethodDefinition', 'TSAbstractPropertyDefinition', 'TSAbstractAccessorProperty']);
   function Vn({ node: e }) {
    return e.abstract || Wn(e) ? 'abstract ' : '';
   }
   function zn(e, t, r) {
    return 'EmptyStatement' === e.type ? (ot(e, it.Leading) ? [' ', t] : t) : 'BlockStatement' === e.type || r ? [' ', t] : cs([Fs, t]);
   }
   function Hn(e) {
    return e.accessibility ? e.accessibility + ' ' : '';
   }
   var Xn = /^[\$A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC][\$0-9A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]*$/,
    Kn = (e) => Xn.test(e);
   var Gn = function (e) {
     return 1 === e.length
      ? e
      : e
         .toLowerCase()
         .replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(?=\d)/u, '$1$2')
         .replace(/^([+-]?[\d.]+)e[+-]?0+$/u, '$1')
         .replace(/^([+-])?\./u, '$10.')
         .replace(/(\.\d+?)0+(?=e|$)/u, '$1')
         .replace(/\.(?=e|$)/u, '');
    },
    Yn = 0;
   function Qn(e, t, r) {
    let { node: s, parent: n, grandparent: i, key: a } = e,
     o = 'body' !== a && ('IfStatement' === n.type || 'WhileStatement' === n.type || 'SwitchStatement' === n.type || 'DoWhileStatement' === n.type),
     u = '|>' === s.operator && e.root.extra?.__isUsingHackPipeline,
     l = Zn(e, t, r, !1, o);
    if (o) return l;
    if (u) return gs(l);
    if (('callee' === a && (ke(n) || 'NewExpression' === n.type)) || 'UnaryExpression' === n.type || (Ie(n) && !n.computed)) return gs([cs([As, ...l]), As]);
    let p =
      'ReturnStatement' === n.type ||
      'ThrowStatement' === n.type ||
      ('JSXExpressionContainer' === n.type && 'JSXAttribute' === i.type) ||
      ('|' !== s.operator && 'JsExpressionRoot' === n.type) ||
      ('NGPipeExpression' !== s.type && (('NGRoot' === n.type && '__ng_binding' === t.parser) || ('NGMicrosyntaxExpression' === n.type && 'NGMicrosyntax' === i.type && 1 === i.body.length))) ||
      (s === n.body && 'ArrowFunctionExpression' === n.type) ||
      (s !== n.body && 'ForStatement' === n.type) ||
      ('ConditionalExpression' === n.type && 'ReturnStatement' !== i.type && 'ThrowStatement' !== i.type && !ke(i) && 'NewExpression' !== i.type) ||
      'TemplateLiteral' === n.type ||
      (function (e) {
       if ('arguments' !== e.key) return !1;
       let { parent: t } = e;
       if (!ke(t) || t.optional || 1 !== t.arguments.length) return !1;
       let { callee: r } = t;
       return 'Identifier' === r.type && 'Boolean' === r.name;
      })(e),
     h = 'AssignmentExpression' === n.type || 'VariableDeclarator' === n.type || 'ClassProperty' === n.type || 'PropertyDefinition' === n.type || 'TSAbstractPropertyDefinition' === n.type || 'ClassPrivateProperty' === n.type || ct(n),
     d = Ce(s.left) && He(s.operator, s.left.operator);
    if (p || (ei(s) && !d) || (!ei(s) && h)) return gs(l);
    if (0 === l.length) return '';
    let f = Ee(s.right),
     m = l.findIndex((e) => 'string' != typeof e && !Array.isArray(e) && e.type === Or),
     y = l.slice(0, -1 === m ? 1 : m + 1),
     D = l.slice(y.length, f ? -1 : void 0),
     g = Symbol('logicalChain-' + ++Yn),
     x = gs([...y, cs(D)], { id: g });
    return f ? gs([x, bs(c(0, l, -1), { groupId: g })]) : x;
   }
   function Zn(e, t, r, s, n) {
    let { node: i } = e;
    if (!Ce(i)) return [gs(r())];
    let a = [];
    He(i.operator, i.left.operator) ? (a = e.call(() => Zn(e, t, r, !0, n), 'left')) : a.push(gs(r('left')));
    let o,
     u = ei(i),
     l = 'ChainExpression' === i.right.type ? i.right.expression : i.right,
     p =
      ('|>' === i.operator ||
       'NGPipeExpression' === i.type ||
       (function (e, t) {
        return ('__vue_expression' === t.parser || '__vue_ts_expression' === t.parser) && ti(e.node) && !e.hasAncestor((e) => !ti(e) && 'JsExpressionRoot' !== e.type);
       })(e, t)) &&
      !Le(t.originalText, l),
     c = !ot(l, it.Leading, Bt) && Le(t.originalText, l),
     h = 'NGPipeExpression' === i.type ? '|' : i.operator,
     d =
      'NGPipeExpression' === i.type && i.arguments.length > 0
       ? gs(
          cs([
           As,
           ': ',
           Ts(
            [Fs, ': '],
            e.map(() => hs(2, gs(r())), 'arguments'),
           ),
          ]),
         )
       : '';
    if (u) o = [h, Le(t.originalText, l) ? cs([Fs, r('right'), d]) : [' ', r('right'), d]];
    else {
     let s = '|>' === h && e.root.extra?.__isUsingHackPipeline ? e.call(() => Zn(e, t, r, !0, n), 'right') : r('right');
     if ('start' === t.experimentalOperatorPosition) {
      let e = '';
      if (c)
       switch (Wr(s)) {
        case Pr:
         e = s.splice(0, 1)[0];
         break;
        case $r:
         e = s.contents.splice(0, 1)[0];
       }
      o = [Fs, e, h, ' ', s, d];
     } else o = [p ? Fs : '', h, p ? ' ' : Fs, s, d];
    }
    let { parent: f } = e,
     m = ot(i.left, it.Trailing | it.Line);
    if (((m || (!(n && 'LogicalExpression' === i.type) && f.type !== i.type && i.left.type !== i.type && i.right.type !== i.type)) && (o = gs(o, { shouldBreak: m })), 'start' === t.experimentalOperatorPosition ? a.push(u || c ? ' ' : '', o) : a.push(p ? '' : ' ', o), s && ot(i))) {
     let r = rs(On(e, a, t));
     return r.type === Lr ? r.parts : Array.isArray(r) ? r : [r];
    }
    return a;
   }
   function ei(e) {
    return 'LogicalExpression' === e.type && !!((pe(e.right) && e.right.properties.length > 0) || (le(e.right) && e.right.elements.length > 0) || Ee(e.right));
   }
   var ti = (e) => 'BinaryExpression' === e.type && '|' === e.operator;
   function ri(e, t, r) {
    let { node: s } = e,
     { parent: n } = e,
     i = !('TypeParameterInstantiation' === n.type || (mt(n) && t.experimentalTernaries) || 'TSTypeParameterInstantiation' === n.type || 'GenericTypeAnnotation' === n.type || 'TSTypeReference' === n.type || 'TSTypeAssertion' === n.type || 'TupleTypeAnnotation' === n.type || 'TSTupleType' === n.type || ('FunctionTypeParam' === n.type && !n.name && e.grandparent.this !== n) || ((yt(n) || 'VariableDeclarator' === n.type) && Le(t.originalText, s)) || (yt(n) && ot(n.id, it.Trailing | it.Line))),
     a = ii(s),
     o = e.map(() => {
      let s = r();
      return (a || (s = hs(2, s)), On(e, s, t));
     }, 'types'),
     u = '',
     l = '';
    if ((Dt(e) && ({ leading: u, trailing: l } = Bn(e, t)), a)) return [u, Ts(' | ', o), l];
    let p = [Es([i && !Le(t.originalText, s) ? Fs : '', '| ']), Ts([Fs, '| '], o)];
    if (vn(e, t)) return [u, gs([cs(p), As]), l];
    let c = [u, gs(p)];
    return ('TupleTypeAnnotation' === n.type || 'TSTupleType' === n.type) && n['TupleTypeAnnotation' === n.type && n.types ? 'types' : 'elementTypes'].length > 1 ? [gs([cs([Es(['(', As]), c]), As, Es(')')]), l] : [gs(i ? cs(c) : c), l];
   }
   var si = G(['VoidTypeAnnotation', 'TSVoidKeyword', 'NullLiteralTypeAnnotation', 'TSNullKeyword']),
    ni = G(['ObjectTypeAnnotation', 'TSTypeLiteral', 'GenericTypeAnnotation', 'TSTypeReference']);
   function ii(e) {
    let { types: t } = e;
    if (t.some((e) => ot(e))) return !1;
    let r = t.find((e) => ni(e));
    return !!r && t.every((e) => e === r || si(e));
   }
   var ai = new WeakSet();
   function oi(e, t, r = 'typeAnnotation') {
    let {
     node: { [r]: s },
    } = e;
    if (!s) return '';
    let n = !1;
    if ('TSTypeAnnotation' === s.type || 'TypeAnnotation' === s.type) {
     let t = e.call(ui, r);
     (('=>' === t || (':' === t && ot(s, it.Leading))) && (n = !0), ai.add(s));
    }
    return n ? [' ', t(r)] : t(r);
   }
   var ui = (e) =>
    e.match(
     (e) => 'TSTypeAnnotation' === e.type,
     (e, t) => !(('returnType' !== t && 'typeAnnotation' !== t) || ('TSFunctionType' !== e.type && 'TSConstructorType' !== e.type)),
    )
     ? '=>'
     : e.match(
          (e) => 'TSTypeAnnotation' === e.type,
          (e, t) => 'typeAnnotation' === t && ('TSJSDocNullableType' === e.type || 'TSJSDocNonNullableType' === e.type || 'TSTypePredicate' === e.type),
         ) ||
         e.match(
          (e) => 'TypeAnnotation' === e.type,
          (e, t) => 'typeAnnotation' === t && 'Identifier' === e.type,
          (e, t) => 'id' === t && 'DeclareFunction' === e.type,
         ) ||
         e.match(
          (e) => 'TypeAnnotation' === e.type,
          (e, t) => 'typeAnnotation' === t && 'Identifier' === e.type,
          (e, t) => 'id' === t && 'DeclareHook' === e.type,
         ) ||
         e.match(
          (e) => 'TypeAnnotation' === e.type,
          (e, t) => 'bound' === t && 'TypeParameter' === e.type && e.usesExtendsBound,
         )
       ? ''
       : ':';
   function li(e, t, r) {
    let s = ui(e);
    return s ? [s, ' ', r('typeAnnotation')] : r('typeAnnotation');
   }
   function pi(e, t, r) {
    let { node: s } = e,
     n = [],
     i = 'TupleTypeAnnotation' === s.type && s.types ? 'types' : 'TSTupleType' === s.type || 'TupleTypeAnnotation' === s.type ? 'elementTypes' : 'elements',
     a = s[i];
    if (0 === a.length)
     n.push(
      (function (e, t, r, s) {
       let { node: n } = e,
        i = n.inexact ? '...' : '';
       return ot(n, it.Dangling) ? gs([r, i, Nn(e, t, { indent: !0 }), As, s]) : [r, i, s];
      })(e, t, '[', ']'),
     );
    else {
     let o = c(0, a, -1),
      u = 'RestElement' !== o?.type && !s.inexact,
      l = null === o,
      p = Symbol('array'),
      h =
       !t.__inJestEach &&
       a.length > 1 &&
       a.every((e, t, r) => {
        let s = e?.type;
        if (!le(e) && !pe(e)) return !1;
        let n = r[t + 1];
        if (n && s !== n.type) return !1;
        let i = le(e) ? 'elements' : 'properties';
        return e[i] && e[i].length > 1;
       }),
      d = ci(s, t),
      f = u ? (l ? ',' : qe(t) ? (d ? Es(',', '', { groupId: p }) : Es(',')) : '') : '';
     n.push(gs(['[', cs([As, d ? fi(e, t, r, f) : [di(e, t, r, i, s.inexact), f], Nn(e, t)]), As, ']'], { shouldBreak: h, id: p }));
    }
    return (n.push(Un(e), oi(e, r)), n);
   }
   function ci(e, t) {
    return le(e) && e.elements.length > 0 && e.elements.every((e) => e && (ce(e) || (he(e) && !ot(e.argument))) && !ot(e, it.Trailing | it.Line, (e) => !w(t.originalText, $(e), { backwards: !0 })));
   }
   function hi({ node: e }, { originalText: t }) {
    let r = q(e);
    if (r === $(e)) return !1;
    let { length: s } = t;
    for (; r < s && ',' !== t[r]; ) r = S(t, v(t, r + 1));
    return P(t, r);
   }
   function di(e, t, r, s, n) {
    let i = [];
    return (
     e.each(({ node: s, isLast: a }) => {
      (i.push(s ? gs(r()) : ''), (!a || n) && i.push([',', Fs, s && hi(e, t) ? As : '']));
     }, s),
     n && i.push('...'),
     i
    );
   }
   function fi(e, t, r, s) {
    let n = [];
    return (
     e.each(({ isLast: i, next: a }) => {
      (n.push([r(), i ? s : ',']), i || n.push(hi(e, t) ? [Ss, Ss] : ot(a, it.Leading | it.Line) ? Ss : Fs));
     }, 'elements'),
     Ds(n)
    );
   }
   function mi(e, t = !1) {
    return (
     (pe(e) && (e.properties.length > 0 || ot(e))) ||
     (le(e) && (e.elements.length > 0 || ot(e))) ||
     ('TSTypeAssertion' === e.type && mi(e.expression)) ||
     (ht(e) && mi(e.expression)) ||
     'FunctionExpression' === e.type ||
     ('ArrowFunctionExpression' === e.type &&
      (!e.returnType ||
       !e.returnType.typeAnnotation ||
       'TSTypeReference' !== e.returnType.typeAnnotation.type ||
       (function (e) {
        return 'BlockStatement' === e.type && (e.body.some((e) => 'EmptyStatement' !== e.type) || ot(e, it.Dangling));
       })(e.body)) &&
      ('BlockStatement' === e.body.type || ('ArrowFunctionExpression' === e.body.type && mi(e.body, !0)) || pe(e.body) || le(e.body) || (!t && (ke(e.body) || 'ConditionalExpression' === e.body.type)) || Ee(e.body))) ||
     'DoExpression' === e.type ||
     'ModuleExpression' === e.type
    );
   }
   function yi(e) {
    if ('ParenthesizedExpression' === e.type) return yi(e.expression);
    if (ht(e) || 'TypeCastExpression' === e.type) {
     let { typeAnnotation: t } = e;
     if (('TypeAnnotation' === t.type && (t = t.typeAnnotation), 'TSArrayType' === t.type && ((t = t.elementType), 'TSArrayType' === t.type && (t = t.elementType)), 'GenericTypeAnnotation' === t.type || 'TSTypeReference' === t.type)) {
      let e = 'GenericTypeAnnotation' === t.type ? t.typeParameters : t.typeArguments;
      1 === e?.params.length && (t = e.params[0]);
     }
     return we(t) && $e(e.expression, 1);
    }
    return !(pt(e) && et(e).length > 1) && (Ce(e) ? $e(e.left, 1) && $e(e.right, 1) : fe(e) || $e(e));
   }
   function Di(e, t) {
    let r = e[t],
     s = e[t + 1];
    return 'ArrowFunctionExpression' === r.type && 0 === Qe(r).length && 'BlockStatement' === r.body.type && 'ArrayExpression' === s.type && !e.some((e) => ot(e));
   }
   var gi = function (e, t, r) {
    let { node: s } = e,
     n = et(s);
    if (0 === n.length) return ['(', Nn(e, t), ')'];
    let i = n.length - 1;
    if (
     (function (e) {
      return 2 === e.length ? Di(e, 0) : 3 === e.length && 'Identifier' === e[0].type && Di(e, 1);
     })(n)
    ) {
     let t = ['('];
     return (
      tt(e, (e, s) => {
       (t.push(r()), s !== i && t.push(', '));
      }),
      t.push(')'),
      t
     );
    }
    let a = !1,
     o = [];
    tt(e, ({ node: e }, s) => {
     let n = r();
     (s === i || (lt(e, t) ? ((a = !0), (n = [n, ',', Ss, Ss])) : (n = [n, ',', Fs])), o.push(n));
    });
    let u = !t.parser.startsWith('__ng_') && 'ImportExpression' !== s.type && 'TSImportType' !== s.type && 'TSExternalModuleReference' !== s.type && qe(t, 'all') ? ',' : '';
    function l() {
     return gs(['(', cs([Fs, ...o]), u, Fs, ')'], { shouldBreak: !0 });
    }
    if (
     a ||
     ('Decorator' !== e.parent.type &&
      (function (e) {
       if (e.length <= 1) return !1;
       let t = 0;
       for (let r of e)
        if (ge(r)) {
         if (((t += 1), t > 1)) return !0;
        } else if (ke(r)) for (let e of et(r)) if (ge(e)) return !0;
       return !1;
      })(n))
    )
     return l();
    if (
     (function (e) {
      if (2 !== e.length) return !1;
      let [t, r] = e;
      return (
       !(
        'ModuleExpression' !== t.type ||
        !(function (e) {
         if ('ObjectExpression' !== e.type || 1 !== e.properties.length) return !1;
         let [t] = e.properties;
         return !!ct(t) && !t.computed && (('Identifier' === t.key.type && 'type' === t.key.name) || (de(t.key) && 'type' === t.key.value)) && de(t.value) && 'module' === t.value.value;
        })(r)
       ) ||
       (!ot(t) && ('FunctionExpression' === t.type || ('ArrowFunctionExpression' === t.type && 'BlockStatement' === t.body.type)) && 'FunctionExpression' !== r.type && 'ArrowFunctionExpression' !== r.type && 'ConditionalExpression' !== r.type && yi(r) && !mi(r))
      );
     })(n)
    ) {
     let e,
      t = o.slice(1);
     if (t.some(Qr)) return l();
     try {
      e = r(rt(s, 0), { expandFirstArg: !0 });
     } catch (h) {
      if (h instanceof Ln) return l();
      throw h;
     }
     return Qr(e) ? [ms, xs([['(', gs(e, { shouldBreak: !0 }), ', ', ...t, ')'], l()])] : xs([['(', e, ', ', ...t, ')'], ['(', gs(e, { shouldBreak: !0 }), ', ', ...t, ')'], l()]);
    }
    if (
     (function (e, t, r) {
      let s = c(0, e, -1);
      if (1 === e.length) {
       let e = c(0, t, -1);
       if (e.label?.embed && !1 !== e.label?.hug) return !0;
      }
      let n = c(0, e, -2);
      return !ot(s, it.Leading) && !ot(s, it.Trailing) && mi(s) && (!n || n.type !== s.type) && (2 !== e.length || 'ArrowFunctionExpression' !== n.type || !le(s)) && !(e.length > 1 && ci(s, r));
     })(n, o, t)
    ) {
     let e,
      t = o.slice(0, -1);
     if (t.some(Qr)) return l();
     try {
      e = r(rt(s, -1), { expandLastArg: !0 });
     } catch (h) {
      if (h instanceof Ln) return l();
      throw h;
     }
     return Qr(e) ? [ms, xs([['(', ...t, gs(e, { shouldBreak: !0 }), ')'], l()])] : xs([['(', ...t, e, ')'], ['(', ...t, gs(e, { shouldBreak: !0 }), ')'], l()]);
    }
    let p = ['(', cs([As, ...o]), Es(u), As, ')'];
    return Re(e) ? p : gs(p, { shouldBreak: o.some(Qr) || a });
   };
   function xi(e, t, r) {
    return ['::', r('callee')];
   }
   function Ei(e, t, r) {
    let s = r('object'),
     n = bi(e, t, r),
     { node: i } = e,
     a = e.findAncestor((e) => !(Ie(e) || 'TSNonNullExpression' === e.type)),
     o = e.findAncestor((e) => !('ChainExpression' === e.type || 'TSNonNullExpression' === e.type)),
     u =
      'BindExpression' === a.type ||
      ('AssignmentExpression' === a.type && 'Identifier' !== a.left.type) ||
      (function (e) {
       let { node: t, ancestors: r } = e;
       for (let s of r) {
        if (!((Ie(s) && s.object === t) || ('TSNonNullExpression' === s.type && s.expression === t))) return 'NewExpression' === s.type && s.callee === t;
        t = s;
       }
       return !1;
      })(e) ||
      i.computed ||
      ('Identifier' === i.object.type && 'Identifier' === i.property.type && !Ie(o)) ||
      (('AssignmentExpression' === o.type || 'VariableDeclarator' === o.type) && (((e) => (('ChainExpression' === e.type || 'TSNonNullExpression' === e.type) && (e = e.expression), ke(e) && et(e).length > 0))(i.object) || s.label?.memberChain));
    return Cs(s.label, [s, u ? n : gs(cs([As, n]))]);
   }
   function bi(e, t, r) {
    let s = r('property'),
     { node: n } = e,
     i = Un(e);
    return n.computed ? (!n.property || ce(n.property) ? [i, '[', s, ']'] : gs([i, '[', cs([As, s]), As, ']'])) : [i, '.', s];
   }
   var Ti = function e(t, r, s) {
    if ('ChainExpression' === t.node.type) return t.call(() => e(t, r, s), 'expression');
    let n = 'ExpressionStatement' === ('ChainExpression' === t.parent.type ? t.grandparent : t.parent).type,
     i = [];
    function a(e) {
     let { originalText: t } = r,
      s = Pt(t, q(e));
     return ')' === t.charAt(s) ? !1 !== s && P(t, s + 1) : lt(e, r);
    }
    let { node: o } = t;
    (i.unshift({ node: o, printed: [Un(t), s('typeArguments'), gi(t, r, s)] }),
     o.callee &&
      t.call(function e() {
       let { node: n } = t;
       if ('ChainExpression' === n.type) return t.call(e, 'expression');
       if (ke(n) && (Fe(n.callee) || ke(n.callee))) {
        let o = a(n);
        (i.unshift({ node: n, hasTrailingEmptyLine: o, printed: [On(t, [Un(t), s('typeArguments'), gi(t, r, s)], r), o ? Ss : ''] }), t.call(e, 'callee'));
       } else Fe(n) ? (i.unshift({ node: n, needsParens: vn(t, r), printed: On(t, Ie(n) ? bi(t, 0, s) : xi(0, 0, s), r) }), t.call(e, 'object')) : 'TSNonNullExpression' === n.type ? (i.unshift({ node: n, printed: On(t, '!', r) }), t.call(e, 'expression')) : i.unshift({ node: n, printed: s() });
      }, 'callee'));
    let u = [],
     l = [i[0]],
     p = 1;
    for (; p < i.length && ('TSNonNullExpression' === i[p].node.type || ke(i[p].node) || (Ie(i[p].node) && i[p].node.computed && ce(i[p].node.property))); ++p) l.push(i[p]);
    if (!ke(i[0].node)) for (; p + 1 < i.length && Fe(i[p].node) && Fe(i[p + 1].node); ++p) l.push(i[p]);
    (u.push(l), (l = []));
    let h = !1;
    for (; p < i.length; ++p) {
     if (h && Fe(i[p].node)) {
      if (i[p].node.computed && ce(i[p].node.property)) {
       l.push(i[p]);
       continue;
      }
      (u.push(l), (l = []), (h = !1));
     }
     ((ke(i[p].node) || 'ImportExpression' === i[p].node.type) && (h = !0), l.push(i[p]), ot(i[p].node, it.Trailing) && (u.push(l), (l = []), (h = !1)));
    }
    function d(e) {
     return /^[A-Z]|^[$_]+$/u.test(e);
    }
    l.length > 0 && u.push(l);
    let f =
     u.length >= 2 &&
     !ot(u[1][0].node) &&
     (function (e) {
      let t = e[1][0]?.node.computed;
      if (1 === e[0].length) {
       let s = e[0][0].node;
       return (
        'ThisExpression' === s.type ||
        ('Identifier' === s.type &&
         (d(s.name) ||
          (n &&
           (function (e) {
            return e.length <= r.tabWidth;
           })(s.name)) ||
          t))
       );
      }
      let s = c(0, e[0], -1).node;
      return Ie(s) && 'Identifier' === s.property.type && (d(s.property.name) || t);
     })(u);
    function m(e) {
     let t = e.map((e) => e.printed);
     return e.length > 0 && c(0, e, -1).needsParens ? ['(', ...t, ')'] : t;
    }
    let y = u.map(m),
     D = y,
     g = f ? 3 : 2,
     x = u.flat(),
     E = x.slice(1, -1).some((e) => ot(e.node, it.Leading)) || x.slice(0, -1).some((e) => ot(e.node, it.Trailing)) || (u[g] && ot(u[g][0].node, it.Leading));
    if (u.length <= g && !E && !u.some((e) => c(0, e, -1).hasTrailingEmptyLine)) return Re(t) ? D : gs(D);
    let b = c(0, u[f ? 1 : 0], -1).node,
     T = !ke(b) && a(b),
     C = [m(u[0]), f ? u.slice(1, 2).map(m) : '', T ? Ss : '', ((A = u.slice(f ? 2 : 1)), 0 === A.length ? '' : cs([Ss, Ts(Ss, A.map(m))]))],
     F = i.map(({ node: e }) => e).filter(ke);
    var A;
    let w;
    return (
     (w =
      E ||
      (F.length > 2 && F.some((e) => !e.arguments.every((e) => $e(e)))) ||
      y.slice(0, -1).some(Qr) ||
      (function () {
       let e = c(0, c(0, u, -1), -1).node,
        t = c(0, y, -1);
       return ke(e) && Qr(t) && F.slice(0, -1).some((e) => e.arguments.some(ge));
      })()
       ? gs(C)
       : [Qr(D) || T ? ms : '', xs([D, C])]),
     Cs({ memberChain: !0 }, w)
    );
   };
   function Ci(e, t, r) {
    let { node: s } = e,
     n = 'NewExpression' === s.type,
     i = Un(e),
     a = et(s),
     o = 'TSImportType' !== s.type && s.typeArguments ? r('typeArguments') : '',
     u = 1 === a.length && je(a[0], t.originalText);
    if (
     u ||
     (function (e) {
      let { node: t } = e;
      if ('ImportExpression' !== t.type && 'TSImportType' !== t.type && 'TSExternalModuleReference' !== t.type && ('CallExpression' !== t.type || t.optional || !te(t.callee, Ai))) return !1;
      let r = et(t);
      return 1 === r.length && de(r[0]) && !ot(r[0]);
     })(e) ||
     (function (e) {
      let { node: t } = e;
      if ('CallExpression' !== t.type || t.optional || 'Identifier' !== t.callee.type) return !1;
      let r = et(t);
      return 'require' === t.callee.name ? ((1 === r.length && de(r[0])) || r.length > 1) && !ot(r[0]) : 'define' === t.callee.name && 'ExpressionStatement' === e.parent.type && (1 === r.length || (2 === r.length && 'ArrayExpression' === r[0].type) || (3 === r.length && de(r[0]) && 'ArrayExpression' === r[1].type));
     })(e) ||
     ve(s, e.parent)
    ) {
     let t = [];
     if (
      (tt(e, () => {
       t.push(r());
      }),
      !u || !t[0].label?.embed)
     )
      return [n ? 'new ' : '', Fi(e, r), i, o, '(', Ts(', ', t), ')'];
    }
    let l = 'ImportExpression' === s.type || 'TSImportType' === s.type || 'TSExternalModuleReference' === s.type;
    if (!l && !n && Fe(s.callee) && !e.call(() => vn(e, t), 'callee', ...('ChainExpression' === s.callee.type ? ['expression'] : []))) return Ti(e, t, r);
    let p = [n ? 'new ' : '', Fi(e, r), i, o, gi(e, t, r)];
    return l || ke(s.callee) ? gs(p) : p;
   }
   function Fi(e, t) {
    let { node: r } = e;
    return 'ImportExpression' === r.type ? 'import' + (r.phase ? `.${r.phase}` : '') : 'TSImportType' === r.type ? 'import' : 'TSExternalModuleReference' === r.type ? 'require' : t('callee');
   }
   var Ai = ['require', 'require.resolve', 'require.resolve.paths', 'import.meta.resolve'];
   function wi(e, t, r, s, n, i) {
    let a = (function (e, t, r, s, n) {
      let { node: i } = e,
       a = i[n];
      if (!a) return 'only-left';
      let o = !Si(a);
      if (e.match(Si, vi, (e) => !o || ('ExpressionStatement' !== e.type && 'VariableDeclaration' !== e.type))) return o ? ('ArrowFunctionExpression' === a.type && 'ArrowFunctionExpression' === a.body.type ? 'chain-tail-arrow-chain' : 'chain-tail') : 'chain';
      if ((!o && Si(a.right)) || Le(t.originalText, a)) return 'break-after-operator';
      if ('ImportAttribute' === i.type || ('CallExpression' === a.type && 'require' === a.callee.name) || 'json5' === t.parser || 'jsonc' === t.parser || 'json' === t.parser) return 'never-break-after-operator';
      let u = (function (e) {
       return Gr(e, ns, !1);
      })(s);
      if (
       (function (e) {
        if (vi(e)) {
         let t = e.left || e.id;
         return 'ObjectPattern' === t.type && t.properties.length > 2 && t.properties.some((e) => ct(e) && (!e.shorthand || 'AssignmentPattern' === e.value?.type));
        }
        return !1;
       })(i) ||
       (function (e) {
        if ('VariableDeclarator' !== e.type) return !1;
        let { typeAnnotation: t } = e.id;
        if (!t || !t.typeAnnotation) return !1;
        let r = ki(t.typeAnnotation);
        return k(r) && r.length > 1 && r.some((e) => k(ki(e)) || 'TSConditionalType' === e.type);
       })(i) ||
       (Pi(i) && u)
      )
       return 'break-lhs';
      let l = (function (e, t, r) {
       return !!ct(e) && ((t = rs(t)), 'string' == typeof t && x(t) < r.tabWidth + 3);
      })(i, s, t);
      return e.call(
       () =>
        (function (e, t, r, s) {
         let n = e.node;
         if (Ce(n) && !ei(n)) return !0;
         switch (n.type) {
          case 'StringLiteralTypeAnnotation':
          case 'SequenceExpression':
           return !0;
          case 'TSConditionalType':
          case 'ConditionalTypeAnnotation':
           if (
            !t.experimentalTernaries &&
            !(function (e) {
             return Ni(e.checkType) || Ni(e.extendsType);
            })(n)
           )
            break;
           return !0;
          case 'ConditionalExpression': {
           if (!t.experimentalTernaries) {
            let { test: e } = n;
            return Ce(e) && !ei(e);
           }
           let { consequent: e, alternate: r } = n;
           return 'ConditionalExpression' === e.type || 'ConditionalExpression' === r.type;
          }
          case 'ClassExpression':
           return k(n.decorators);
         }
         if (s) return !1;
         let i = n,
          a = [];
         for (;;)
          if ('UnaryExpression' === i.type || 'AwaitExpression' === i.type || ('YieldExpression' === i.type && null !== i.argument)) ((i = i.argument), a.push('argument'));
          else {
           if ('TSNonNullExpression' !== i.type) break;
           ((i = i.expression), a.push('expression'));
          }
         return !(!de(i) && !e.call(() => Ii(e, t, r), ...a));
        })(e, t, r, l),
       n,
      )
       ? 'break-after-operator'
       : (function (e) {
            let t = (function (e) {
             if (yt(e)) return e.typeParameters?.params;
            })(e);
            if (k(t)) {
             let r = 'TSTypeAliasDeclaration' === e.type ? 'constraint' : 'bound';
             if (t.length > 1 && t.some((e) => e[r] || e.default)) return !0;
            }
            return !1;
           })(i)
         ? 'break-lhs'
         : !u &&
             (l ||
              'TemplateLiteral' === a.type ||
              'TaggedTemplateExpression' === a.type ||
              (function (e) {
               return 'BooleanLiteral' === e.type || ('Literal' === e.type && 'boolean' == typeof e.value);
              })(a) ||
              ce(a) ||
              'ClassExpression' === a.type)
           ? 'never-break-after-operator'
           : 'fluid';
     })(e, t, r, s, i),
     o = i ? r(i, { assignmentLayout: a }) : '';
    switch (a) {
     case 'break-after-operator':
      return gs([gs(s), n, gs(cs([Fs, o]))]);
     case 'never-break-after-operator':
      return gs([gs(s), n, ' ', o]);
     case 'fluid': {
      let e = Symbol('assignment');
      return gs([gs(s), n, gs(cs(Fs), { id: e }), ks, bs(o, { groupId: e })]);
     }
     case 'break-lhs':
      return gs([s, n, ' ', gs(o)]);
     case 'chain':
      return [gs(s), n, Fs, o];
     case 'chain-tail':
      return [gs(s), n, cs([Fs, o])];
     case 'chain-tail-arrow-chain':
      return [gs(s), n, o];
     case 'only-left':
      return s;
    }
   }
   function Si(e) {
    return 'AssignmentExpression' === e.type;
   }
   function vi(e) {
    return Si(e) || 'VariableDeclarator' === e.type;
   }
   function Pi(e) {
    return 'VariableDeclarator' === e.type && 'ArrowFunctionExpression' === e.init?.type;
   }
   function ki(e) {
    let t;
    switch (e.type) {
     case 'GenericTypeAnnotation':
      t = e.typeParameters;
      break;
     case 'TSTypeReference':
      t = e.typeArguments;
    }
    return t?.params;
   }
   function Ii(e, t, r, s = !1) {
    let { node: n } = e,
     i = () => Ii(e, t, r, !0);
    if ('ChainExpression' === n.type || 'TSNonNullExpression' === n.type) return e.call(i, 'expression');
    if (ke(n)) {
     if (Ci(e, t, r).label?.memberChain) return !1;
     let s = et(n);
     return (
      !(
       !(0 === s.length || (1 === s.length && Oe(s[0], t))) ||
       (function (e, t) {
        let r = (function (e) {
         return (e.typeParameters ?? e.typeArguments)?.params;
        })(e);
        if (k(r)) {
         if (r.length > 1) return !0;
         if (1 === r.length) {
          let e = r[0];
          if (dt(e) || ft(e) || 'TSTypeLiteral' === e.type || 'ObjectTypeAnnotation' === e.type) return !0;
         }
         if (Qr(t(e.typeParameters ? 'typeParameters' : 'typeArguments'))) return !0;
        }
        return !1;
       })(n, r)
      ) && e.call(i, 'callee')
     );
    }
    return Ie(n) ? e.call(i, 'object') : s && ('Identifier' === n.type || 'ThisExpression' === n.type);
   }
   function Ni(e) {
    switch (e.type) {
     case 'FunctionTypeAnnotation':
     case 'GenericTypeAnnotation':
     case 'TSFunctionType':
      return !!e.typeParameters;
     case 'TSTypeReference':
      return !!e.typeArguments;
     default:
      return !1;
    }
   }
   var Bi = new WeakMap();
   function Oi(e) {
    return /^(?:\d+|\d+\.\d+)$/u.test(e);
   }
   function Li(e, t) {
    return !('json' === t.parser || 'jsonc' === t.parser || !de(e.key) || R(Y(e.key), t).slice(1, -1) !== e.key.value) && !((!Kn(e.key.value) || ('babel-ts' === t.parser && 'ClassProperty' === e.type) || (('typescript' === t.parser || 'oxc-ts' === t.parser) && 'PropertyDefinition' === e.type)) && (!Oi(e.key.value) || String(Number(e.key.value)) !== e.key.value || 'ImportAttribute' === e.type || ('babel' !== t.parser && 'acorn' !== t.parser && 'oxc' !== t.parser && 'espree' !== t.parser && 'meriyah' !== t.parser && '__babel_estree' !== t.parser)));
   }
   function Mi(e, t, r) {
    let { node: s } = e;
    if (s.computed) return ['[', r('key'), ']'];
    let { parent: n } = e,
     { key: i } = s;
    if ('consistent' === t.quoteProps && !Bi.has(n)) {
     let r = e.siblings.some((e) => !e.computed && de(e.key) && !Li(e, t));
     Bi.set(n, r);
    }
    if (
     (function (e, t) {
      let { key: r } = e.node;
      return ('Identifier' === r.type || (ce(r) && Oi(Gn(Y(r))) && String(r.value) === Gn(Y(r)) && !('typescript' === t.parser || 'babel-ts' === t.parser || 'oxc-ts' === t.parser))) && ('json' === t.parser || 'jsonc' === t.parser || ('consistent' === t.quoteProps && Bi.get(e.parent)));
     })(e, t)
    ) {
     let r = R(JSON.stringify('Identifier' === i.type ? i.name : i.value.toString()), t);
     return e.call(() => On(e, r, t), 'key');
    }
    return Li(s, t) && ('as-needed' === t.quoteProps || ('consistent' === t.quoteProps && !Bi.get(n))) ? e.call(() => On(e, /^\d/u.test(i.value) ? Gn(i.value) : i.value, t), 'key') : r('key');
   }
   function ji(e, t, r) {
    let { node: s } = e;
    return s.shorthand ? r('value') : wi(e, t, r, Mi(e, t, r), ':', 'value');
   }
   function _i(e, t, r, s) {
    if ((({ node: e, key: t, parent: r }) => 'value' === t && 'FunctionExpression' === e.type && ('ObjectMethod' === r.type || 'ClassMethod' === r.type || 'ClassPrivateMethod' === r.type || 'MethodDefinition' === r.type || 'TSAbstractMethodDefinition' === r.type || 'TSDeclareMethod' === r.type || ('Property' === r.type && be(r))))(e)) return Ui(e, t, r);
    let { node: n } = e,
     i = !1;
    if (('FunctionDeclaration' === n.type || 'FunctionExpression' === n.type) && s?.expandLastArg) {
     let { parent: t } = e;
     ke(t) && (et(t).length > 1 || Qe(n).every((e) => 'Identifier' === e.type && !e.typeAnnotation)) && (i = !0);
    }
    let a = [Jn(e), n.async ? 'async ' : '', `function${n.generator ? '*' : ''} `, n.id ? r('id') : ''],
     o = Mn(e, t, r, i),
     u = qi(e, r),
     l = _n(n, u);
    return (a.push(r('typeParameters'), gs([l ? gs(o) : o, u]), n.body ? ' ' : '', r('body')), t.semi && (n.declare || !n.body) && a.push(';'), a);
   }
   function Ri(e, t, r) {
    let { node: s } = e,
     { kind: n } = s,
     i = s.value || s,
     a = [];
    return (n && 'init' !== n && 'method' !== n && 'constructor' !== n ? (I('get' === n || 'set' === n), a.push(n, ' ')) : i.async && a.push('async '), i.generator && a.push('*'), a.push(Mi(e, t, r), s.optional ? '?' : '', s === i ? Ui(e, t, r) : r('value')), a);
   }
   function Ui(e, t, r) {
    let { node: s } = e,
     n = Mn(e, t, r),
     i = qi(e, r),
     a = (function (e) {
      let t = Qe(e);
      return t.length > 1 && t.some((e) => 'TSParameterProperty' === e.type);
     })(s),
     o = _n(s, i),
     u = [r('typeParameters'), gs([a ? gs(n, { shouldBreak: !0 }) : o ? gs(n) : n, i])];
    return (s.body ? u.push(' ', r('body')) : u.push(t.semi ? ';' : ''), u);
   }
   function $i(e, t) {
    if ('always' === t.arrowParens) return !1;
    if ('avoid' === t.arrowParens) {
     let { node: t } = e;
     return (function (e) {
      let t = Qe(e);
      return !(1 !== t.length || e.typeParameters || ot(e, it.Dangling) || 'Identifier' !== t[0].type || t[0].typeAnnotation || ot(t[0]) || t[0].optional || e.predicate || e.returnType);
     })(t);
    }
    return !1;
   }
   function qi(e, t) {
    let { node: r } = e,
     s = [oi(e, t, 'returnType')];
    return (r.predicate && s.push(t('predicate')), s);
   }
   function Ji(e, t, r) {
    let { node: s } = e,
     n = [];
    if (s.argument) {
     let e = r('argument');
     (!(function (e, t) {
      if (Le(e.originalText, t) || (ot(t, it.Leading, (t) => It(e.originalText, $(t), q(t))) && !Ee(t))) return !0;
      if (ie(t)) {
       let r,
        s = t;
       for (; (r = ae(s)); ) if (((s = r), Le(e.originalText, s))) return !0;
      }
      return !1;
     })(t, s.argument)
      ? (Ce(s.argument) || (t.experimentalTernaries && 'ConditionalExpression' === s.argument.type && ('ConditionalExpression' === s.argument.consequent.type || 'ConditionalExpression' === s.argument.alternate.type))) && (e = gs([Es('('), cs([As, e]), As, Es(')')]))
      : (e = ['(', cs([Ss, e]), Ss, ')']),
      n.push(' ', e));
    }
    let i = ot(s, it.Dangling),
     a = t.semi && i && ot(s, it.Last | it.Line);
    return (a && n.push(';'), i && n.push(' ', Nn(e, t)), !a && t.semi && n.push(';'), n);
   }
   function Wi(e, t) {
    if (t.semi || Hi(e, t) || Ki(e, t) || Xi(e, t)) return !1;
    let { node: r, key: s, parent: n } = e;
    return !('ExpressionStatement' !== r.type || (('body' !== s || ('Program' !== n.type && 'BlockStatement' !== n.type && 'StaticBlock' !== n.type && 'TSModuleBlock' !== n.type)) && ('consequent' !== s || 'SwitchCase' !== n.type)) || !e.call(() => Vi(e, t), 'expression'));
   }
   function Vi(e, t) {
    let { node: r } = e;
    switch (r.type) {
     case 'ParenthesizedExpression':
     case 'TypeCastExpression':
     case 'ArrayExpression':
     case 'ArrayPattern':
     case 'TemplateLiteral':
     case 'TemplateElement':
     case 'RegExpLiteral':
      return !0;
     case 'ArrowFunctionExpression':
      if (!$i(e, t)) return !0;
      break;
     case 'UnaryExpression': {
      let { prefix: e, operator: t } = r;
      if (e && ('+' === t || '-' === t)) return !0;
      break;
     }
     case 'BindExpression':
      if (!r.object) return !0;
      break;
     case 'Literal':
      if (r.regex) return !0;
      break;
     default:
      if (Ee(r)) return !0;
    }
    return !!vn(e, t) || (!!ie(r) && e.call(() => Vi(e, t), ...oe(r)));
   }
   var zi = ({ node: e, parent: t }) => 'ExpressionStatement' === e.type && 'Program' === t.type && 1 === t.body.length && ((Array.isArray(t.directives) && 0 === t.directives.length) || !t.directives);
   function Hi(e, t) {
    return ('markdown' === t.parentParser || 'mdx' === t.parentParser) && zi(e) && Ee(e.node.expression);
   }
   function Xi(e, t) {
    return t.__isHtmlInlineEventHandler && zi(e);
   }
   function Ki(e, t) {
    return ('__vue_event_binding' === t.parser || '__vue_ts_event_binding' === t.parser) && zi(e);
   }
   var Gi = class extends Error {
    name = 'UnexpectedNodeError';
    constructor(e, t, r = 'type') {
     (super(`Unexpected ${t} node ${r}: ${JSON.stringify(e[r])}.`), (this.node = e));
    }
   };
   var Yi = new (class {
     #e;
     constructor(e) {
      this.#e = new Set(e);
     }
     getLeadingWhitespaceCount(e) {
      let t = this.#e,
       r = 0;
      for (let s = 0; s < e.length && t.has(e.charAt(s)); s++) r++;
      return r;
     }
     getTrailingWhitespaceCount(e) {
      let t = this.#e,
       r = 0;
      for (let s = e.length - 1; s >= 0 && t.has(e.charAt(s)); s--) r++;
      return r;
     }
     getLeadingWhitespace(e) {
      let t = this.getLeadingWhitespaceCount(e);
      return e.slice(0, t);
     }
     getTrailingWhitespace(e) {
      let t = this.getTrailingWhitespaceCount(e);
      return e.slice(e.length - t);
     }
     hasLeadingWhitespace(e) {
      return this.#e.has(e.charAt(0));
     }
     hasTrailingWhitespace(e) {
      return this.#e.has(c(0, e, -1));
     }
     trimStart(e) {
      let t = this.getLeadingWhitespaceCount(e);
      return e.slice(t);
     }
     trimEnd(e) {
      let t = this.getTrailingWhitespaceCount(e);
      return e.slice(0, e.length - t);
     }
     trim(e) {
      return this.trimEnd(this.trimStart(e));
     }
     split(e, t = !1) {
      let r = `[${(function (e) {
        if ('string' != typeof e) throw new TypeError('Expected a string');
        return e.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&').replace(/-/g, '\\x2d');
       })([...this.#e].join(''))}]+`,
       s = new RegExp(t ? `(${r})` : r, 'u');
      return e.split(s);
     }
     hasWhitespaceCharacter(e) {
      let t = this.#e;
      return Array.prototype.some.call(e, (e) => t.has(e));
     }
     hasNonWhitespaceCharacter(e) {
      let t = this.#e;
      return Array.prototype.some.call(e, (e) => !t.has(e));
     }
     isWhitespaceOnly(e) {
      let t = this.#e;
      return Array.prototype.every.call(e, (e) => t.has(e));
     }
     #t(e) {
      let t = Number.POSITIVE_INFINITY;
      for (let r of e.split('\n')) {
       if (0 === r.length) continue;
       let e = this.getLeadingWhitespaceCount(r);
       if (0 === e) return 0;
       r.length !== e && e < t && (t = e);
      }
      return t === Number.POSITIVE_INFINITY ? 0 : t;
     }
     dedentString(e) {
      let t = this.#t(e);
      return 0 === t
       ? e
       : e
          .split('\n')
          .map((e) => e.slice(t))
          .join('\n');
     }
    })(' \n\r\t'),
    Qi = (e) => '' === e || e === Fs || e === Ss || e === As;
   function Zi(e, t, r) {
    let { node: s } = e;
    if (
     'JSXElement' === s.type &&
     (function (e) {
      if (0 === e.children.length) return !0;
      if (e.children.length > 1) return !1;
      let t = e.children[0];
      return 'JSXText' === t.type && !aa(t);
     })(s)
    )
     return [r('openingElement'), r('closingElement')];
    let n = 'JSXElement' === s.type ? r('openingElement') : r('openingFragment'),
     i = 'JSXElement' === s.type ? r('closingElement') : r('closingFragment');
    if (1 === s.children.length && 'JSXExpressionContainer' === s.children[0].type && ('TemplateLiteral' === s.children[0].expression.type || 'TaggedTemplateExpression' === s.children[0].expression.type)) return [n, ...e.map(r, 'children'), i];
    s.children = s.children.map((e) =>
     (function (e) {
      return 'JSXExpressionContainer' === e.type && de(e.expression) && ' ' === e.expression.value && !ot(e.expression);
     })(e)
      ? { type: 'JSXText', value: ' ', raw: ' ' }
      : e,
    );
    let a = s.children.some(Ee),
     o = s.children.filter((e) => 'JSXExpressionContainer' === e.type).length > 1,
     u = 'JSXElement' === s.type && s.openingElement.attributes.length > 1,
     l = Qr(n) || a || u || o,
     p = 'mdx' === e.parent.rootMarker,
     h = t.singleQuote ? "{' '}" : '{" "}',
     d = p ? Fs : Es([h, As], ' '),
     f = (function (e, t, r, s, n) {
      let i = '',
       a = [i];
      function o(e) {
       ((i = e), a.push([a.pop(), e]));
      }
      function u(e) {
       '' !== e && ((i = e), a.push(e, ''));
      }
      return (
       e.each(({ node: e, next: t }) => {
        if ('JSXText' === e.type) {
         let r = Y(e);
         if (aa(e)) {
          let a,
           l = Yi.split(r, !0);
          if (('' === l[0] && (l.shift(), /\n/u.test(l[0]) ? u(ta(n, l[1], e, t)) : u(s), l.shift()), '' === c(0, l, -1) && (l.pop(), (a = l.pop())), 0 === l.length)) return;
          for (let [e, t] of l.entries()) e % 2 == 1 ? u(Fs) : o(t);
          void 0 !== a ? (/\n/u.test(a) ? u(ta(n, i, e, t)) : u(s)) : u(ea(n, i, e, t));
         } else /\n/u.test(r) ? r.match(/\n/gu).length > 1 && u(Ss) : u(s);
        } else {
         if ((o(r()), t && aa(t))) {
          let r = Yi.trim(Y(t)),
           [s] = Yi.split(r);
          u(ea(n, s, e, t));
         } else u(Ss);
        }
       }, 'children'),
       a
      );
     })(e, 0, r, d, 'fbt' === s.openingElement?.name?.name),
     m = s.children.some((e) => aa(e));
    for (let c = f.length - 2; c >= 0; c--) {
     let e = '' === f[c] && '' === f[c + 1],
      t = f[c] === Ss && '' === f[c + 1] && f[c + 2] === Ss,
      r = (f[c] === As || f[c] === Ss) && '' === f[c + 1] && f[c + 2] === d,
      s = f[c] === d && '' === f[c + 1] && (f[c + 2] === As || f[c + 2] === Ss),
      n = f[c] === d && '' === f[c + 1] && f[c + 2] === d,
      i = (f[c] === As && '' === f[c + 1] && f[c + 2] === Ss) || (f[c] === Ss && '' === f[c + 1] && f[c + 2] === As);
     (t && m) || e || r || n || i ? f.splice(c, 2) : s && f.splice(c + 1, 2);
    }
    for (; f.length > 0 && Qi(c(0, f, -1)); ) f.pop();
    for (; f.length > 1 && Qi(f[0]) && Qi(f[1]); ) (f.shift(), f.shift());
    let y = [''];
    for (let [c, x] of f.entries()) {
     if (x === d) {
      if (1 === c && as(f[c - 1])) {
       if (2 === f.length) {
        y.push([y.pop(), h]);
        continue;
       }
       y.push([h, Ss], '');
       continue;
      }
      if (c === f.length - 1) {
       y.push([y.pop(), h]);
       continue;
      }
      if ('' === f[c - 1] && f[c - 2] === Ss) {
       y.push([y.pop(), h]);
       continue;
      }
     }
     (c % 2 == 0 ? y.push([y.pop(), x]) : y.push(x, ''), Qr(x) && (l = !0));
    }
    let D = m ? Ds(y) : gs(y, { shouldBreak: !0 });
    if (('JSXText' === t.cursorNode?.type && s.children.includes(t.cursorNode) ? (D = [ys, D, ys]) : 'JSXText' === t.nodeBeforeCursor?.type && s.children.includes(t.nodeBeforeCursor) ? (D = [ys, D]) : 'JSXText' === t.nodeAfterCursor?.type && s.children.includes(t.nodeAfterCursor) && (D = [D, ys]), p)) return D;
    let g = gs([n, cs([Ss, D]), Ss, i]);
    return l ? g : xs([gs([n, ...f, i]), g]);
   }
   function ea(e, t, r, s) {
    return e ? '' : ('JSXElement' === r.type && !r.closingElement) || ('JSXElement' === s?.type && !s.closingElement) ? (1 === t.length ? As : Ss) : As;
   }
   function ta(e, t, r, s) {
    return e ? Ss : 1 === t.length ? (('JSXElement' === r.type && !r.closingElement) || ('JSXElement' === s?.type && !s.closingElement) ? Ss : As) : Ss;
   }
   var ra = G(['ArrayExpression', 'JSXAttribute', 'JSXElement', 'JSXExpressionContainer', 'JSXFragment', 'ExpressionStatement', 'NewExpression', 'CallExpression', 'OptionalCallExpression', 'ConditionalExpression', 'JsExpressionRoot', 'MatchExpressionCase']);
   function sa(e, t, r) {
    let { parent: s } = e;
    if (ra(s)) return t;
    let n = (function (e) {
      return (
       e.match(
        void 0,
        (e, t) => 'body' === t && 'ArrowFunctionExpression' === e.type,
        (e, t) => 'arguments' === t && ke(e),
       ) &&
       (e.match(void 0, void 0, void 0, (e, t) => 'expression' === t && 'JSXExpressionContainer' === e.type) ||
        e.match(
         void 0,
         void 0,
         void 0,
         (e, t) => 'expression' === t && 'ChainExpression' === e.type,
         (e, t) => 'expression' === t && 'JSXExpressionContainer' === e.type,
        ))
      );
     })(e),
     i = vn(e, r);
    return gs([i ? '' : Es('('), cs([As, t]), As, i ? '' : Es(')')], { shouldBreak: n });
   }
   function na(e, t, r) {
    return e.selfClosing
     ? [Fs, '/>']
     : (function (e, t, r) {
          let s = e.attributes.length > 0 && ot(c(0, e.attributes, -1), it.Trailing);
          return (0 === e.attributes.length && !r) || ((t.bracketSameLine || t.jsxBracketSameLine) && (!r || e.attributes.length > 0) && !s);
         })(e, t, r)
       ? ['>']
       : [As, '>'];
   }
   function ia(e, t, r) {
    let { node: s } = e;
    if (s.type.startsWith('JSX'))
     switch (s.type) {
      case 'JSXAttribute':
       return (function (e, t, r) {
        let { node: s } = e,
         n = [r('name')];
        if (s.value) {
         let i;
         if (de(s.value)) {
          let r = Y(s.value),
           n = l(0, l(0, r.slice(1, -1), '&apos;', "'"), '&quot;', '"'),
           a = M(n, t.jsxSingleQuote);
          ((n = '"' === a ? l(0, n, '"', '&quot;') : l(0, n, "'", '&apos;')), (i = e.call(() => On(e, ss(a + n + a), t), 'value')));
         } else i = r('value');
         n.push('=', i);
        }
        return n;
       })(e, t, r);
      case 'JSXIdentifier':
       return s.name;
      case 'JSXNamespacedName':
       return Ts(':', [r('namespace'), r('name')]);
      case 'JSXMemberExpression':
       return Ts('.', [r('object'), r('property')]);
      case 'JSXSpreadAttribute':
      case 'JSXSpreadChild':
       return (function (e, t, r) {
        let { node: s } = e;
        return [
         '{',
         e.call(
          ({ node: s }) => {
           let n = ['...', r()];
           return ot(s) ? [cs([As, On(e, n, t)]), As] : n;
          },
          'JSXSpreadAttribute' === s.type ? 'argument' : 'expression',
         ),
         '}',
        ];
       })(e, t, r);
      case 'JSXExpressionContainer':
       return (function (e, t, r) {
        let { node: s } = e,
         n = (e, t) => 'JSXEmptyExpression' === e.type || (!ot(e) && (le(e) || pe(e) || 'ArrowFunctionExpression' === e.type || ('AwaitExpression' === e.type && (n(e.argument, e) || 'JSXElement' === e.argument.type)) || ke(e) || ('ChainExpression' === e.type && ke(e.expression)) || 'FunctionExpression' === e.type || 'TemplateLiteral' === e.type || 'TaggedTemplateExpression' === e.type || 'DoExpression' === e.type || (Ee(t) && ('ConditionalExpression' === e.type || Ce(e)))));
        return n(s.expression, e.parent) ? gs(['{', r('expression'), ks, '}']) : gs(['{', cs([As, r('expression')]), As, ks, '}']);
       })(e, 0, r);
      case 'JSXFragment':
      case 'JSXElement':
       return (function (e, t, r) {
        return sa(e, On(e, Zi(e, t, r), t), t);
       })(e, t, r);
      case 'JSXOpeningElement':
       return (function (e, t, r) {
        let { node: s } = e,
         n = ot(s.name) || ot(s.typeArguments);
        if (s.selfClosing && 0 === s.attributes.length && !n) return ['<', r('name'), r('typeArguments'), ' />'];
        if (1 === s.attributes?.length && de(s.attributes[0].value) && !s.attributes[0].value.value.includes('\n') && !n && !ot(s.attributes[0])) return gs(['<', r('name'), r('typeArguments'), ' ', ...e.map(r, 'attributes'), s.selfClosing ? ' />' : '>']);
        let i = s.attributes?.some((e) => de(e.value) && e.value.value.includes('\n')),
         a = t.singleAttributePerLine && s.attributes.length > 1 ? Ss : Fs;
        return gs(['<', r('name'), r('typeArguments'), cs(e.map(() => [a, r()], 'attributes')), ...na(s, t, n)], { shouldBreak: i });
       })(e, t, r);
      case 'JSXClosingElement':
       return (function (e, t, r) {
        let { node: s } = e,
         n = ['</'],
         i = r('name');
        return (ot(s.name, it.Leading | it.Line) ? n.push(cs([Ss, i]), Ss) : ot(s.name, it.Leading | it.Block) ? n.push(' ', i) : n.push(i), n.push('>'), n);
       })(e, 0, r);
      case 'JSXOpeningFragment':
      case 'JSXClosingFragment':
       return (function (e, t) {
        let { node: r } = e,
         s = ot(r),
         n = ot(r, it.Line),
         i = 'JSXOpeningFragment' === r.type;
        return [i ? '<' : '</', cs([n ? Ss : s && !i ? ' ' : '', Nn(e, t)]), n ? Ss : '', '>'];
       })(e, t);
      case 'JSXEmptyExpression':
       return (function (e, t) {
        let { node: r } = e,
         s = ot(r, it.Line);
        return [Nn(e, t, { indent: s }), s ? Ss : ''];
       })(e, t);
      case 'JSXText':
       throw new Error('JSXText should be handled by JSXElement');
      default:
       throw new Gi(s, 'JSX');
     }
   }
   function aa(e) {
    return 'JSXText' === e.type && (Yi.hasNonWhitespaceCharacter(Y(e)) || !/\n/u.test(Y(e)));
   }
   var oa = function (e) {
    return (
     nt(e.node) ||
     (function (e) {
      let { node: t, parent: r } = e;
      if (!Ee(t) || !Ee(r)) return !1;
      let s,
       { index: n, siblings: i } = e;
      for (let a = n; a > 0; a--) {
       let e = i[a - 1];
       if ('JSXText' !== e.type || aa(e)) {
        s = e;
        break;
       }
      }
      return 'JSXExpressionContainer' === s?.type && 'JSXEmptyExpression' === s.expression.type && nt(s.expression);
     })(e)
    );
   };
   function ua(e, t, r) {
    let { node: s } = e;
    if (s.type.startsWith('NG'))
     switch (s.type) {
      case 'NGRoot':
       return r('node');
      case 'NGPipeExpression':
       return Qn(e, t, r);
      case 'NGChainedExpression':
       return gs(
        Ts(
         [';', Fs],
         e.map(
          () =>
           (function ({ node: e }) {
            return ne(e, pa);
           })(e)
            ? r()
            : ['(', r(), ')'],
          'expressions',
         ),
        ),
       );
      case 'NGEmptyExpression':
       return '';
      case 'NGMicrosyntax':
       return e.map(() => [e.isFirst ? '' : la(e) ? ' ' : [';', Fs], r()], 'body');
      case 'NGMicrosyntaxKey':
       return /^[$_a-z][\w$]*(?:-[$_a-z][\w$])*$/iu.test(s.name) ? s.name : JSON.stringify(s.name);
      case 'NGMicrosyntaxExpression':
       return [r('expression'), null === s.alias ? '' : [' as ', r('alias')]];
      case 'NGMicrosyntaxKeyedExpression': {
       let { index: t, parent: n } = e,
        i =
         la(e) ||
         (function (e) {
          let { node: t } = e;
          return 'of' === e.parent.body[1].key.name && 'NGMicrosyntaxKeyedExpression' === t.type && 'track' === t.key.name && 'NGMicrosyntaxKey' === t.key.type;
         })(e) ||
         (((1 === t && ('then' === s.key.name || 'else' === s.key.name || 'as' === s.key.name)) || (2 === t && (('else' === s.key.name && 'NGMicrosyntaxKeyedExpression' === n.body[t - 1].type && 'then' === n.body[t - 1].key.name) || 'track' === s.key.name))) && 'NGMicrosyntaxExpression' === n.body[0].type);
       return [r('key'), i ? ' ' : ': ', r('expression')];
      }
      case 'NGMicrosyntaxLet':
       return ['let ', r('key'), null === s.value ? '' : [' = ', r('value')]];
      case 'NGMicrosyntaxAs':
       return [r('key'), ' as ', r('alias')];
      default:
       throw new Gi(s, 'Angular');
     }
   }
   function la({ node: e, index: t }) {
    return 'NGMicrosyntaxKeyedExpression' === e.type && 'of' === e.key.name && 1 === t;
   }
   var pa = G(['CallExpression', 'OptionalCallExpression', 'AssignmentExpression']);
   function ca(e, t, r) {
    let { node: s } = e;
    return gs([Ts(Fs, e.map(r, 'decorators')), da(s, t) ? Ss : Fs]);
   }
   function ha(e, t, r) {
    return fa(e.node) ? [Ts(Ss, e.map(r, 'declaration', 'decorators')), Ss] : '';
   }
   function da(e, t) {
    return e.decorators.some((e) => w(t.originalText, q(e)));
   }
   function fa(e) {
    if ('ExportDefaultDeclaration' !== e.type && 'ExportNamedDeclaration' !== e.type && 'DeclareExportDeclaration' !== e.type) return !1;
    let t = e.declaration?.decorators;
    return k(t) && J(e, t[0]);
   }
   var ma = new WeakMap();
   function ya(e) {
    return (ma.has(e) || ma.set(e, 'ConditionalExpression' === e.type && !Je(e, (e) => 'ObjectExpression' === e.type)), ma.get(e));
   }
   function Da(e, t, r, s = {}) {
    let n,
     i,
     a = [],
     o = [],
     u = !1,
     l = !s.expandLastArg && 'ArrowFunctionExpression' === e.node.body.type;
    !(function p() {
     let { node: c } = e,
      h = (function (e, t, r, s) {
       let { node: n } = e,
        i = [];
       if ((n.async && i.push('async '), $i(e, t))) i.push(r(['params', 0]));
       else {
        let n = s.expandLastArg || s.expandFirstArg,
         a = qi(e, r);
        if (n) {
         if (Qr(a)) throw new Ln();
         a = gs(ts(a));
        }
        i.push(gs([Mn(e, t, r, n, !0), a]));
       }
       let a = Nn(e, t, {
        filter(e) {
         let r = Pt(t.originalText, q(e));
         return !1 !== r && '=>' === t.originalText.slice(r, r + 2);
        },
       });
       return (a && i.push(' ', a), i);
      })(e, t, r, s);
     if (0 === a.length) a.push(h);
     else {
      let { leading: r, trailing: s } = Bn(e, t);
      (a.push([r, h]), o.unshift(s));
     }
     (l && (u || (u = (c.returnType && Qe(c).length > 0) || c.typeParameters || Qe(c).some((e) => 'Identifier' !== e.type))), l && 'ArrowFunctionExpression' === c.body.type ? e.call(p, 'body') : ((n = r('body', s)), (i = c.body)));
    })();
    let p =
      !Le(t.originalText, i) &&
      (((e) => 'SequenceExpression' === e.type)(i) ||
       (function (e, t, r) {
        return le(e) || pe(e) || 'ArrowFunctionExpression' === e.type || 'DoExpression' === e.type || 'BlockStatement' === e.type || Ee(e) || (!1 !== t.label?.hug && (t.label?.embed || je(e, r.originalText)));
       })(i, n, t) ||
       (!u && ya(i))),
     c = 'callee' === e.key && pt(e.parent),
     h = Symbol('arrow-chain'),
     d = (function (e, t, { signatureDocs: r, shouldBreak: s }) {
      if (1 === r.length) return r[0];
      let { parent: n, key: i } = e;
      return ('callee' !== i && pt(n)) || Ce(n) ? gs([r[0], ' =>', cs([Fs, Ts([' =>', Fs], r.slice(1))])], { shouldBreak: s }) : ('callee' === i && pt(n)) || t.assignmentLayout ? gs(Ts([' =>', Fs], r), { shouldBreak: s }) : gs(cs(Ts([' =>', Fs], r)), { shouldBreak: s });
     })(e, s, { signatureDocs: a, shouldBreak: u }),
     f = !1,
     m = !1,
     y = !1;
    return (
     l && (c || s.assignmentLayout) && ((m = !0), (y = !ot(e.node, it.Leading & it.Line)), (f = 'chain-tail-arrow-chain' === s.assignmentLayout || (c && !p))),
     (n = (function (e, t, r, { bodyDoc: s, bodyComments: n, functionBody: i, shouldPutBodyOnSameLine: a }) {
      let { node: o, parent: u } = e,
       l = r.expandLastArg && qe(t, 'all') ? Es(',') : '',
       p = (!r.expandLastArg && 'JSXExpressionContainer' !== u.type) || ot(o) ? '' : As;
      return a && ya(i) ? [' ', gs([Es('', '('), cs([As, s]), Es('', ')'), l, p]), n] : a ? [' ', s, n] : [cs([Fs, s, n]), l, p];
     })(e, t, s, { bodyDoc: n, bodyComments: o, functionBody: i, shouldPutBodyOnSameLine: p })),
     gs([gs(m ? cs([y ? As : '', d]) : d, { shouldBreak: f, id: h }), ' =>', l ? bs(n, { groupId: h }) : gs(n), l && c ? Es(As, '', { groupId: h }) : ''])
    );
   }
   var ga =
     Array.prototype.findLast ??
     function (e) {
      for (let t = this.length - 1; t >= 0; t--) {
       let r = this[t];
       if (e(r, t, this)) return r;
      }
     },
    xa = o('findLast', function () {
     if (Array.isArray(this)) return ga;
    });
   function Ea(e, t, r, s) {
    let { node: n } = e,
     i = [],
     a = xa(0, n[s], (e) => 'EmptyStatement' !== e.type);
    return (
     e.each(({ node: e }) => {
      'EmptyStatement' !== e.type && (i.push(r()), e !== a && (i.push(Ss), lt(e, t) && i.push(Ss)));
     }, s),
     i
    );
   }
   function ba(e, t, r) {
    let s = (function (e, t, r) {
      let { node: s } = e,
       n = k(s.directives),
       i = s.body.some((e) => 'EmptyStatement' !== e.type),
       a = ot(s, it.Dangling);
      if (!n && !i && !a) return '';
      let o = [];
      return (n && (o.push(Ea(e, t, r, 'directives')), (i || a) && (o.push(Ss), lt(c(0, s.directives, -1), t) && o.push(Ss))), i && o.push(Ea(e, t, r, 'body')), a && o.push(Nn(e, t)), o);
     })(e, t, r),
     { node: n, parent: i } = e;
    if ('Program' === n.type && 'ModuleExpression' !== i?.type) return s ? [s, Ss] : '';
    let a = [];
    if (('StaticBlock' === n.type && a.push('static '), a.push('{'), s)) a.push(cs([Ss, s]), Ss);
    else {
     let t = e.grandparent;
     'ArrowFunctionExpression' === i.type || 'FunctionExpression' === i.type || 'FunctionDeclaration' === i.type || 'ComponentDeclaration' === i.type || 'HookDeclaration' === i.type || 'ObjectMethod' === i.type || 'ClassMethod' === i.type || 'ClassPrivateMethod' === i.type || 'ForStatement' === i.type || 'WhileStatement' === i.type || 'DoWhileStatement' === i.type || 'DoExpression' === i.type || 'ModuleExpression' === i.type || ('CatchClause' === i.type && !t.finalizer) || 'TSModuleDeclaration' === i.type || 'MatchStatementCase' === i.type || 'StaticBlock' === n.type || a.push(Ss);
    }
    return (a.push('}'), a);
   }
   var Ta = function (e) {
    let t = new WeakMap();
    return function (r) {
     return (t.has(r) || t.set(r, Symbol(e)), t.get(r));
    };
   };
   function Ca(e, t, r) {
    let s,
     { node: n } = e,
     i = [],
     a = 'ObjectTypeAnnotation' === n.type,
     o = !Fa(e),
     u = o ? Fs : Ss,
     l = ot(n, it.Dangling),
     [p, h] = a && n.exact ? ['{|', '|}'] : '{}';
    if (
     ((function (e, t) {
      let { node: r } = e;
      if ('ClassBody' === r.type || 'TSInterfaceBody' === r.type) return void e.each(t, 'body');
      if ('TSTypeLiteral' === r.type) return void e.each(t, 'members');
      if ('ObjectTypeAnnotation' === r.type) {
       let r = ['properties', 'indexers', 'callProperties', 'internalSlots'].flatMap((t) => e.map(({ node: e, index: r }) => ({ node: e, loc: $(e), selector: [t, r] }), t)).sort((e, t) => e.loc - t.loc);
       for (let [s, { node: n, selector: i }] of r.entries()) e.call(() => t({ node: n, next: r[s + 1]?.node, isLast: s === r.length - 1 }), ...i);
      }
     })(e, ({ node: n, next: l, isLast: p }) => {
      if ((s ?? (s = n), i.push(r()), o && a)) {
       let { parent: r } = e;
       r.inexact || !p ? i.push(',') : qe(t) && i.push(Es(','));
      }
      (!o &&
       ((function ({ node: e, next: t }, r) {
        if (r.semi || !wa(e)) return !1;
        if (!e.value && Sa(e)) return !0;
        if (!t || t.static || t.accessibility || t.readonly) return !1;
        if (!t.computed) {
         let e = t.key?.name;
         if ('in' === e || 'instanceof' === e) return !0;
        }
        if (wa(t) && t.variance && !t.static && !t.declare) return !0;
        switch (t.type) {
         case 'ClassProperty':
         case 'PropertyDefinition':
         case 'TSAbstractPropertyDefinition':
          return t.computed;
         case 'MethodDefinition':
         case 'TSAbstractMethodDefinition':
         case 'ClassMethod':
         case 'ClassPrivateMethod': {
          if ((t.value ? t.value.async : t.async) || 'get' === t.kind || 'set' === t.kind) return !1;
          let e = t.value ? t.value.generator : t.generator;
          return !(!t.computed && !e);
         }
         case 'TSIndexSignature':
          return !0;
        }
        return !1;
       })({ node: n, next: l }, t) ||
        Pa({ node: n, next: l }, t)) &&
       i.push(';'),
       p || (i.push(u), lt(n, t) && i.push(Ss)));
     }),
     l && i.push(Nn(e, t)),
     'ObjectTypeAnnotation' === n.type && n.inexact)
    ) {
     let e;
     ((e = ot(n, it.Dangling) ? [ot(n, it.Line) || w(t.originalText, q(c(0, ut(n), -1))) ? Ss : Fs, '...'] : [s ? Fs : '', '...']), i.push(e));
    }
    if (o) {
     let r,
      a = l || ('preserve' === t.objectWrap && s && It(t.originalText, $(n), $(s)));
     if (0 === i.length) r = p + h;
     else {
      let e = t.bracketSpacing ? Fs : As;
      r = [p, cs([e, ...i]), e, h];
     }
     return e.match(
      void 0,
      (e, t) => 'typeAnnotation' === t,
      (e, t) => 'typeAnnotation' === t,
      Rn,
     ) || e.match(void 0, (e, t) => 'FunctionTypeParam' === e.type && 'typeAnnotation' === t, Rn)
      ? r
      : gs(r, { shouldBreak: a });
    }
    return [p, i.length > 0 ? [cs([Ss, i]), Ss] : '', h];
   }
   function Fa(e) {
    let { node: t } = e;
    if ('ObjectTypeAnnotation' === t.type) {
     let { key: t, parent: r } = e;
     return 'body' === t && ('InterfaceDeclaration' === r.type || 'DeclareInterface' === r.type || 'DeclareClass' === r.type);
    }
    return 'ClassBody' === t.type || 'TSInterfaceBody' === t.type;
   }
   function Aa(e, t) {
    let { parent: r } = e;
    return e.callParent(Fa) ? (t.semi || 'ObjectTypeAnnotation' === r.type ? ';' : '') : 'TSTypeLiteral' === r.type ? (e.isLast ? (t.semi ? Es(';') : '') : t.semi || Pa({ node: e.node, next: e.next }, t) ? ';' : Es('', ';')) : '';
   }
   var wa = G(['ClassProperty', 'PropertyDefinition', 'ClassPrivateProperty', 'ClassAccessorProperty', 'AccessorProperty', 'TSAbstractPropertyDefinition', 'TSAbstractAccessorProperty']),
    Sa = (e) => {
     if (e.computed || e.typeAnnotation) return !1;
     let { type: t, name: r } = e.key;
     return 'Identifier' === t && ('static' === r || 'get' === r || 'set' === r);
    };
   var va = G(['TSPropertySignature']);
   function Pa({ node: e, next: t }, r) {
    return !(r.semi || !va(e)) && (!!Sa(e) || (!!t && 'TSCallSignatureDeclaration' === t.type));
   }
   var ka = Ta('heritageGroup'),
    Ia = G(['TSInterfaceDeclaration', 'DeclareInterface', 'InterfaceDeclaration', 'InterfaceTypeAnnotation']);
   function Na(e, t, r) {
    let s,
     { node: n } = e,
     i = Ia(n),
     a = [Jn(e), Vn(e), i ? 'interface' : 'class'],
     o = La(e),
     u = [],
     l = [];
    if ('InterfaceTypeAnnotation' !== n.type) {
     n.id && u.push(' ');
     for (let s of ['id', 'typeParameters'])
      if (n[s]) {
       let { leading: n, trailing: i } = e.call(() => Bn(e, t), s);
       u.push(n, r(s), cs(i));
      }
    }
    if (n.superClass) {
     let s = [ja(e, t, r), r(n.superTypeArguments ? 'superTypeArguments' : 'superTypeParameters')],
      i = e.call(() => ['extends ', On(e, s, t)], 'superClass');
     o ? l.push(Fs, gs(i)) : l.push(' ', i);
    } else l.push(Ma(e, t, r, 'extends'));
    return (
     l.push(Ma(e, t, r, 'mixins'), Ma(e, t, r, 'implements')),
     o ? ((s = ka(n)), a.push(gs([...u, cs(l)], { id: s }))) : a.push(...u, ...l),
     !i &&
     o &&
     (function (e) {
      return 'ObjectTypeAnnotation' === e.type ? ['properties', 'indexers', 'callProperties', 'internalSlots'].some((t) => k(e[t])) : k(e.body);
     })(n.body)
      ? a.push(Es(Ss, ' ', { groupId: s }))
      : a.push(' '),
     a.push(r('body')),
     a
    );
   }
   function Ba(e) {
    let t = e.superClass ? 1 : 0;
    for (let r of ['extends', 'mixins', 'implements']) if ((Array.isArray(e[r]) && (t += e[r].length), t > 1)) return !0;
    return t > 1;
   }
   var Oa = new WeakMap();
   function La(e) {
    let { node: t } = e;
    return (
     Oa.has(t) ||
      Oa.set(
       t,
       (function (e) {
        let { node: t } = e;
        if (ot(t.id, it.Trailing) || ot(t.typeParameters, it.Trailing) || ot(t.superClass) || Ba(t)) return !0;
        if (t.superClass) return 'AssignmentExpression' !== e.parent.type && !(t.superTypeArguments ?? t.superTypeParameters) && Ie(t.superClass);
        let r = t.extends?.[0] ?? t.mixins?.[0] ?? t.implements?.[0];
        return !!r && (('InterfaceExtends' === r.type && 'QualifiedTypeIdentifier' === r.id.type && !r.typeParameters) || (('TSClassImplements' === r.type || 'TSInterfaceHeritage' === r.type) && Ie(r.expression) && !r.typeArguments));
       })(e),
      ),
     Oa.get(t)
    );
   }
   function Ma(e, t, r, s) {
    let { node: n } = e;
    if (!k(n[s])) return '';
    let i = Nn(e, t, { marker: s }),
     a = Ts([',', Fs], e.map(r, s));
    if (!Ba(n)) {
     let t = [`${s} `, i, a];
     return La(e) ? [Fs, gs(t)] : [' ', t];
    }
    return [Fs, i, i && Ss, s, gs(cs([Fs, a]))];
   }
   function ja(e, t, r) {
    let s = r('superClass'),
     { parent: n } = e;
    return 'AssignmentExpression' === n.type ? gs(Es(['(', cs([As, s]), As, ')'], s)) : s;
   }
   function _a(e, t, r) {
    let { node: s } = e,
     n = [];
    return (k(s.decorators) && n.push(ca(e, t, r)), n.push(Hn(s)), s.static && n.push('static '), n.push(Vn(e)), s.override && n.push('override '), n.push(Ri(e, t, r)), n);
   }
   function Ra(e, t, r) {
    let { node: s } = e,
     n = [];
    return (k(s.decorators) && n.push(ca(e, t, r)), n.push(Jn(e), Hn(s)), s.static && n.push('static '), n.push(Vn(e)), s.override && n.push('override '), s.readonly && n.push('readonly '), s.variance && n.push(r('variance')), ('ClassAccessorProperty' === s.type || 'AccessorProperty' === s.type || 'TSAbstractAccessorProperty' === s.type) && n.push('accessor '), n.push(Mi(e, t, r), Un(e), $n(e), oi(e, r)), [wi(e, t, r, n, ' =', 'TSAbstractPropertyDefinition' === s.type || 'TSAbstractAccessorProperty' === s.type ? void 0 : 'value'), t.semi ? ';' : '']);
   }
   var Ua = G(['TSAsExpression', 'TSTypeAssertion', 'TSNonNullExpression', 'TSInstantiationExpression', 'TSSatisfiesExpression']);
   function $a(e) {
    return Ua(e) ? $a(e.expression) : e;
   }
   var qa = G(['FunctionExpression', 'ArrowFunctionExpression']);
   function Ja(e, t) {
    if (Ki(e, t)) {
     let t = $a(e.node.expression);
     return (
      qa(t) ||
      (function (e) {
       return 'MemberExpression' === e.type || 'OptionalMemberExpression' === e.type || ('Identifier' === e.type && 'undefined' !== e.name);
      })(t)
     );
    }
    return !(!t.semi || Hi(e, t) || Xi(e, t));
   }
   function Wa(e) {
    return e.toLowerCase();
   }
   function Va({ pattern: e, flags: t }) {
    return `/${e}/${(t = [...t].sort().join(''))}`;
   }
   function za(e, t) {
    let r = e.slice(1, -1);
    if ('use strict' === r || (!r.includes('"') && !r.includes("'"))) {
     let e = t.singleQuote ? "'" : '"';
     return e + r + e;
    }
    return e;
   }
   var Ha = function (e, t, r) {
     let s = e.originalText.slice(t, r);
     for (let n of e[Symbol.for('comments')]) {
      let e = $(n);
      if (e > r) break;
      let i = q(n);
      if (i < t) continue;
      let a = e - t,
       o = i - t;
      s = s.slice(0, a) + l(0, s.slice(a, o), /[^\n]/gu, ' ') + s.slice(o);
     }
     return s;
    },
    Xa = G(['ImportDeclaration', 'ExportDefaultDeclaration', 'ExportNamedDeclaration', 'ExportAllDeclaration', 'DeclareExportDeclaration', 'DeclareExportAllDeclaration']),
    Ka = G(['EnumBooleanBody', 'EnumNumberBody', 'EnumBigIntBody', 'EnumStringBody', 'EnumSymbolBody']);
   function Ga(e, t, r) {
    let { node: s, parent: n } = e,
     i = Ka(s),
     a = 'TSEnumBody' === s.type || i,
     o = Xa(s),
     u = i && s.hasUnknownMembers,
     l = a ? 'members' : o ? 'attributes' : 'properties',
     p = s[l],
     h =
      a ||
      ('ObjectPattern' === s.type && 'FunctionDeclaration' !== n.type && 'FunctionExpression' !== n.type && 'ArrowFunctionExpression' !== n.type && 'ObjectMethod' !== n.type && 'ClassMethod' !== n.type && 'ClassPrivateMethod' !== n.type && 'AssignmentPattern' !== n.type && 'CatchClause' !== n.type && s.properties.some((e) => e.value && ('ObjectPattern' === e.value.type || 'ArrayPattern' === e.value.type))) ||
      ('ObjectPattern' !== s.type &&
       'preserve' === t.objectWrap &&
       p.length > 0 &&
       (function (e, t, r) {
        let s = r.originalText,
         n = $(e),
         i = $(t);
        if (Xa(e)) {
         let t = $(e);
         n = t + Ha(r, t, i).lastIndexOf('{');
        }
        return It(s, n, i);
       })(s, p[0], t)),
     d = [],
     f = e.map(({ node: e }) => {
      let s = [...d, gs(r())];
      return ((d = [',', Fs]), lt(e, t) && d.push(Ss), s);
     }, l);
    if (u) {
     let r;
     if (ot(s, it.Dangling)) {
      let n = ot(s, it.Line);
      r = [Nn(e, t), n || w(t.originalText, q(c(0, ut(s), -1))) ? Ss : Fs, '...'];
     } else r = ['...'];
     f.push([...d, ...r]);
    }
    let m,
     y = !(u || 'RestElement' === c(0, p, -1)?.type);
    if (0 === f.length) {
     if (!ot(s, it.Dangling)) return ['{}', oi(e, r)];
     m = gs(['{', Nn(e, t, { indent: !0 }), As, '}', Un(e), oi(e, r)]);
    } else {
     let s = t.bracketSpacing ? Fs : As;
     m = ['{', cs([s, ...f]), Es(y && qe(t) ? ',' : ''), s, '}', Un(e), oi(e, r)];
    }
    return e.match((e) => 'ObjectPattern' === e.type && !k(e.decorators), Rn) ||
     (De(s) &&
      (e.match(
       void 0,
       (e, t) => 'typeAnnotation' === t,
       (e, t) => 'typeAnnotation' === t,
       Rn,
      ) ||
       e.match(void 0, (e, t) => 'FunctionTypeParam' === e.type && 'typeAnnotation' === t, Rn))) ||
     (!h &&
      e.match(
       (e) => 'ObjectPattern' === e.type,
       (e) => 'AssignmentExpression' === e.type || 'VariableDeclarator' === e.type,
      ))
     ? m
     : gs(m, { shouldBreak: h });
   }
   var Ya = (e) => 'ExportDefaultDeclaration' === e.type || ('DeclareExportDeclaration' === e.type && e.default);
   function Qa(e, t, r) {
    let { node: s } = e,
     n = [ha(e, 0, r), Jn(e), 'export', Ya(s) ? ' default' : ''],
     { declaration: i, exported: a } = s;
    return (
     ot(s, it.Dangling) && (n.push(' ', Nn(e, t)), _e(s) && n.push(Ss)),
     i
      ? n.push(' ', r('declaration'))
      : (n.push(
         (function (e) {
          return eo(e.exportKind);
         })(s),
        ),
        'ExportAllDeclaration' === s.type || 'DeclareExportAllDeclaration' === s.type ? (n.push(' *'), a && n.push(' as ', r('exported'))) : n.push(so(e, t, r)),
        n.push(ro(e, t, r), io(e, t, r))),
     n.push(
      (function (e, t) {
       return t.semi && (!e.declaration || (Ya(e) && !Za(e.declaration))) ? ';' : '';
      })(s, t),
     ),
     n
    );
   }
   var Za = G(['ClassDeclaration', 'ComponentDeclaration', 'FunctionDeclaration', 'TSInterfaceDeclaration', 'DeclareClass', 'DeclareComponent', 'DeclareFunction', 'DeclareHook', 'HookDeclaration', 'TSDeclareFunction', 'EnumDeclaration']);
   function eo(e, t = !0) {
    return e && 'value' !== e ? `${t ? ' ' : ''}${e}${t ? '' : ' '}` : '';
   }
   function to(e, t) {
    return eo(e.importKind, t);
   }
   function ro(e, t, r) {
    let { node: s } = e;
    return s.source ? [no(s, t) ? ' from' : '', ' ', r('source')] : '';
   }
   function so(e, t, r) {
    let { node: s } = e;
    if (!no(s, t)) return '';
    let n = [' '];
    if (k(s.specifiers)) {
     let i = [],
      a = [];
     (e.each(() => {
      let t = e.node.type;
      if ('ExportNamespaceSpecifier' === t || 'ExportDefaultSpecifier' === t || 'ImportNamespaceSpecifier' === t || 'ImportDefaultSpecifier' === t) i.push(r());
      else {
       if ('ExportSpecifier' !== t && 'ImportSpecifier' !== t) throw new Gi(s, 'specifier');
       a.push(r());
      }
     }, 'specifiers'),
      n.push(Ts(', ', i)),
      a.length > 0 && (i.length > 0 && n.push(', '), a.length > 1 || i.length > 0 || s.specifiers.some((e) => ot(e)) ? n.push(gs(['{', cs([t.bracketSpacing ? Fs : As, Ts([',', Fs], a)]), Es(qe(t) ? ',' : ''), t.bracketSpacing ? Fs : As, '}'])) : n.push(['{', t.bracketSpacing ? ' ' : '', ...a, t.bracketSpacing ? ' ' : '', '}'])));
    } else n.push('{}');
    return n;
   }
   function no(e, t) {
    return !('ImportDeclaration' === e.type && !k(e.specifiers) && 'type' !== e.importKind) || Ha(t, $(e), $(e.source)).trimEnd().endsWith('from');
   }
   function io(e, t, r) {
    let { node: s } = e;
    if (!s.source) return '';
    let n = (function (e, t) {
     if (e.extra?.deprecatedAssertSyntax) return 'assert';
     let r = Ha(t, q(e.source), e.attributes?.[0] ? $(e.attributes[0]) : q(e)).trimStart();
     return r.startsWith('assert') ? 'assert' : r.startsWith('with') || k(e.attributes) ? 'with' : void 0;
    })(s, t);
    if (!n) return '';
    let i = Ga(e, t, r);
    return (
     ((e) => {
      let { attributes: t } = e;
      if (1 !== t.length) return !1;
      let [r] = t,
       { type: s, key: n, value: i } = r;
      return 'ImportAttribute' === s && (('Identifier' === n.type && 'type' === n.name) || (de(n) && 'type' === n.value)) && de(i) && !ot(r) && !ot(n) && !ot(i);
     })(s) && (i = ts(i)),
     [` ${n} `, i]
    );
   }
   function ao(e, t, r) {
    let { node: s } = e,
     { type: n } = s,
     i = n.startsWith('Import'),
     a = i ? 'imported' : 'local',
     o = i ? 'local' : 'exported',
     u = s[a],
     l = s[o],
     p = '',
     c = '';
    return (
     'ExportNamespaceSpecifier' === n || 'ImportNamespaceSpecifier' === n ? (p = '*') : u && (p = r(a)),
     l &&
      !(function (e) {
       if ('ImportSpecifier' !== e.type && 'ExportSpecifier' !== e.type) return !1;
       let { local: t, ['ImportSpecifier' === e.type ? 'imported' : 'exported']: r } = e;
       if (t.type !== r.type || !W(t, r)) return !1;
       if (de(t)) return t.value === r.value && Y(t) === Y(r);
       if ('Identifier' === t.type) return t.name === r.name;
       return !1;
      })(s) &&
      (c = r(o)),
     [eo('ImportSpecifier' === n ? s.importKind : s.exportKind, !1), p, p && c ? ' as ' : '', c]
    );
   }
   function oo(e, t) {
    return ['...', t('argument'), oi(e, t)];
   }
   function uo(e, t, r) {
    let { node: s } = e,
     n = 'ConditionalExpression' === s.type,
     i = n ? 'alternate' : 'falseType',
     { parent: a } = e,
     o = n ? r('test') : [r('checkType'), ' ', 'extends', ' ', r('extendsType')];
    return a.type === s.type && a[i] === s ? hs(2, o) : o;
   }
   var lo = new Map([
    ['AssignmentExpression', 'right'],
    ['VariableDeclarator', 'init'],
    ['ReturnStatement', 'argument'],
    ['ThrowStatement', 'argument'],
    ['UnaryExpression', 'argument'],
    ['YieldExpression', 'argument'],
    ['AwaitExpression', 'argument'],
   ]);
   function po(e, t, r) {
    let s,
     n,
     { node: i } = e,
     a = 'ConditionalExpression' === i.type,
     o = a ? 'consequent' : 'trueType',
     u = a ? 'alternate' : 'falseType',
     l = a ? ['test'] : ['checkType', 'extendsType'],
     p = i[o],
     c = i[u],
     h = [],
     d = !1,
     { parent: f } = e,
     m = f.type === i.type && l.some((e) => f[e] === i),
     y = f.type === i.type && !m,
     D = 0;
    do {
     ((n = s || i), (s = e.getParentNode(D)), D++);
    } while (s && s.type === i.type && l.every((e) => s[e] !== n));
    let g = s || f,
     x = n;
    if (
     a &&
     (Ee(i[l[0]]) ||
      Ee(p) ||
      Ee(c) ||
      (function (e) {
       let t = [e];
       for (let r = 0; r < t.length; r++) {
        let e = t[r];
        for (let r of ['test', 'consequent', 'alternate']) {
         let s = e[r];
         if (Ee(s)) return !0;
         'ConditionalExpression' === s.type && t.push(s);
        }
       }
       return !1;
      })(x))
    ) {
     ((d = !0), (y = !0));
     let e = (e) => [Es('('), cs([As, e]), As, Es(')')],
      t = (e) => 'NullLiteral' === e.type || ('Literal' === e.type && null === e.value) || ('Identifier' === e.type && 'undefined' === e.name);
     h.push(' ? ', t(p) ? r(o) : e(r(o)), ' : ', c.type === i.type || t(c) ? r(u) : e(r(u)));
    } else {
     let e = (e) => (t.useTabs ? cs(r(e)) : hs(2, r(e))),
      s = [Fs, '? ', p.type === i.type ? Es('', '(') : '', e(o), p.type === i.type ? Es('', ')') : '', Fs, ': ', e(u)];
     h.push(f.type !== i.type || f[u] === i || m ? s : t.useTabs ? fs(cs(s)) : hs(Math.max(0, t.tabWidth - 2), s));
    }
    let E = !d && (Ie(f) || ('NGPipeExpression' === f.type && f.left === i)) && !f.computed,
     b = (function (e) {
      let { node: t } = e;
      if ('ConditionalExpression' !== t.type) return !1;
      let r,
       s = t;
      for (let n = 0; !r; n++) {
       let t = e.getParentNode(n);
       ('ChainExpression' === t.type && t.expression === s) || (ke(t) && t.callee === s) || (Ie(t) && t.object === s) || ('TSNonNullExpression' === t.type && t.expression === s) ? (s = t) : ('NewExpression' === t.type && t.callee === s) || (ht(t) && t.expression === s) ? ((r = e.getParentNode(n + 1)), (s = t)) : (r = t);
      }
      return s !== t && r[lo.get(r.type)] === s;
     })(e),
     T = ((C = [uo(e, 0, r), y ? h : cs(h), a && E && !b ? As : '']), f === g ? gs(C) : C);
    var C;
    return m || b ? gs([cs([As, T]), As]) : T;
   }
   var co = new Map([
    ['AssignmentExpression', 'right'],
    ['VariableDeclarator', 'init'],
    ['ReturnStatement', 'argument'],
    ['ThrowStatement', 'argument'],
    ['UnaryExpression', 'argument'],
    ['YieldExpression', 'argument'],
    ['AwaitExpression', 'argument'],
   ]);
   var ho = (e) => [Es('('), cs([As, e]), As, Es(')')];
   function fo(e, t, r, s) {
    if (!t.experimentalTernaries) return po(e, t, r);
    let n,
     i,
     { node: a } = e,
     o = 'ConditionalExpression' === a.type,
     u = mt(a),
     l = o ? 'consequent' : 'trueType',
     p = o ? 'alternate' : 'falseType',
     c = o ? ['test'] : ['checkType', 'extendsType'],
     h = a[l],
     d = a[p],
     f = c.map((e) => a[e]),
     { parent: m } = e,
     y = m.type === a.type,
     D = y && c.some((e) => m[e] === a),
     g = y && m[p] === a,
     x = h.type === a.type,
     E = d.type === a.type,
     b = E || g,
     T = t.tabWidth > 2 || t.useTabs,
     C = 0;
    do {
     ((i = n || a), (n = e.getParentNode(C)), C++);
    } while (n && n.type === a.type && c.every((e) => n[e] !== i));
    let F = n || m,
     A = s && s.assignmentLayout && 'break-after-operator' !== s.assignmentLayout && ('AssignmentExpression' === m.type || 'VariableDeclarator' === m.type || 'ClassProperty' === m.type || 'PropertyDefinition' === m.type || 'ClassPrivateProperty' === m.type || 'ObjectProperty' === m.type || 'Property' === m.type),
     w = ('ReturnStatement' === m.type || 'ThrowStatement' === m.type) && !(x || E),
     S = o && 'JSXExpressionContainer' === F.type && 'JSXAttribute' !== e.grandparent.type,
     v = (function (e) {
      let { node: t } = e;
      if ('ConditionalExpression' !== t.type) return !1;
      let r,
       s = t;
      for (let n = 0; !r; n++) {
       let t = e.getParentNode(n);
       ('ChainExpression' === t.type && t.expression === s) || (ke(t) && t.callee === s) || (Ie(t) && t.object === s) || ('TSNonNullExpression' === t.type && t.expression === s) ? (s = t) : ('NewExpression' === t.type && t.callee === s) || (ht(t) && t.expression === s) ? ((r = e.getParentNode(n + 1)), (s = t)) : (r = t);
      }
      return s !== t && r[co.get(r.type)] === s;
     })(e),
     P = (function (e, t) {
      return (Ie(t) || ('NGPipeExpression' === t.type && t.left === e)) && !t.computed;
     })(a, m),
     k = u && vn(e, t),
     I = T ? (t.useTabs ? '\t' : ' '.repeat(t.tabWidth - 1)) : '',
     N =
      (function (e, t, r, s) {
       return [...e.map((e) => ut(e)), ut(t), ut(r)].flat().some((e) => Q(e) && It(s.originalText, $(e), q(e)));
      })(f, h, d, t) ||
      x ||
      E,
     B = !b && !y && !u && (S ? 'NullLiteral' === h.type || ('Literal' === h.type && null === h.value) : Oe(h, t) && Ne(a.test, 3)),
     O = b || g || (u && !y) || (y && o && Ne(a.test, 1)) || B,
     L = [];
    !x &&
     ot(h, it.Dangling) &&
     e.call(() => {
      L.push(Nn(e, t), Ss);
     }, 'consequent');
    let M = [];
    (ot(a.test, it.Dangling) &&
     e.call(() => {
      M.push(Nn(e, t));
     }, 'test'),
     !E &&
      ot(d, it.Dangling) &&
      e.call(() => {
       M.push(Nn(e, t));
      }, 'alternate'),
     ot(a, it.Dangling) && M.push(Nn(e, t)));
    let j = Symbol('test'),
     _ = Symbol('consequent'),
     R = Symbol('test-and-consequent'),
     U = o ? [ho(r('test')), 'ConditionalExpression' === a.test.type ? ms : ''] : [r('checkType'), ' ', 'extends', ' ', mt(a.extendsType) || 'TSMappedType' === a.extendsType.type ? r('extendsType') : gs(ho(r('extendsType')))],
     J = gs([U, ' ?'], { id: j }),
     W = r(l),
     V = cs([x || (S && (Ee(h) || y || b)) ? Ss : Fs, L, W]),
     z = O ? gs([J, b ? V : Es(V, gs(V, { id: _ }), { groupId: j })], { id: R }) : [J, V],
     H = r(p),
     X = B ? Es(H, fs(ho(H)), { groupId: R }) : H,
     K = [z, M.length > 0 ? [cs([Ss, M]), Ss] : E ? Ss : B ? Es(Fs, ' ', { groupId: R }) : Fs, ':', E ? ' ' : T ? (O ? Es(I, Es(b || B ? ' ' : I, ' '), { groupId: R }) : Es(I, ' ')) : ' ', E ? X : gs([cs(X), S && !B ? As : '']), P && !v ? As : '', N ? ms : ''];
    return A && !N ? gs(cs([As, gs(K)])) : A || w ? gs(cs(K)) : v || (u && D) ? gs([cs([As, K]), k ? As : '']) : m === F ? gs(K) : K;
   }
   function mo(e, t, r, s) {
    let { node: n } = e;
    if (me(n))
     return (function (e, t) {
      let { node: r } = e;
      switch (r.type) {
       case 'RegExpLiteral':
        return Va(r);
       case 'BigIntLiteral':
        return Wa(r.extra.raw);
       case 'NumericLiteral':
        return Gn(r.extra.raw);
       case 'StringLiteral':
        return ss(R(r.extra.raw, t));
       case 'NullLiteral':
        return 'null';
       case 'BooleanLiteral':
        return String(r.value);
       case 'DirectiveLiteral':
        return za(r.extra.raw, t);
       case 'Literal': {
        if (r.regex) return Va(r.regex);
        if (r.bigint) return Wa(r.raw);
        let { value: s } = r;
        return 'number' == typeof s
         ? Gn(r.raw)
         : 'string' == typeof s
           ? (function (e) {
              if ('expression' !== e.key) return;
              let { parent: t } = e;
              return 'ExpressionStatement' === t.type && 'string' == typeof t.directive;
             })(e)
             ? za(r.raw, t)
             : ss(R(r.raw, t))
           : String(s);
       }
      }
     })(e, t);
    switch (n.type) {
     case 'JsExpressionRoot':
      return r('node');
     case 'JsonRoot':
      return [Nn(e, t), r('node'), Ss];
     case 'File':
      return (
       (function (e, t, r) {
        if (t.__isVueBindings || t.__isVueForBindingLeft) {
         let s = e.map(r, 'program', 'body', 0, 'params');
         if (1 === s.length) return s[0];
         let n = Ts([',', Fs], s);
         return t.__isVueForBindingLeft ? ['(', cs([As, gs(n)]), As, ')'] : n;
        }
        if (t.__isEmbeddedTypescriptGenericParameters) {
         let t = e.map(r, 'program', 'body', 0, 'typeParameters', 'params');
         return Ts([',', Fs], t);
        }
       })(e, t, r) ?? r('program')
      );
     case 'ExpressionStatement':
      return (function (e, t, r) {
       return [r('expression'), Ja(e, t) ? ';' : ''];
      })(e, t, r);
     case 'ChainExpression':
      return r('expression');
     case 'ParenthesizedExpression':
      return ot(n.expression) || (!pe(n.expression) && !le(n.expression)) ? gs(['(', cs([As, r('expression')]), As, ')']) : ['(', r('expression'), ')'];
     case 'AssignmentExpression':
      return (function (e, t, r) {
       let { node: s } = e;
       return wi(e, t, r, r('left'), [' ', s.operator], 'right');
      })(e, t, r);
     case 'VariableDeclarator':
      return (function (e, t, r) {
       return wi(e, t, r, r('id'), ' =', 'init');
      })(e, t, r);
     case 'BinaryExpression':
     case 'LogicalExpression':
      return Qn(e, t, r);
     case 'AssignmentPattern':
      return [r('left'), ' = ', r('right')];
     case 'OptionalMemberExpression':
     case 'MemberExpression':
      return Ei(e, t, r);
     case 'MetaProperty':
      return [r('meta'), '.', r('property')];
     case 'BindExpression':
      return (function (e, t, r) {
       return [r('object'), gs(cs([As, xi(0, 0, r)]))];
      })(0, 0, r);
     case 'Identifier':
      return [n.name, Un(e), $n(e), oi(e, r)];
     case 'V8IntrinsicIdentifier':
      return ['%', n.name];
     case 'SpreadElement':
     case 'RestElement':
      return oo(e, r);
     case 'FunctionDeclaration':
     case 'FunctionExpression':
      return _i(e, t, r, s);
     case 'ArrowFunctionExpression':
      return Da(e, t, r, s);
     case 'YieldExpression':
      return ['yield' + (n.delegate ? '*' : ''), n.argument ? [' ', r('argument')] : ''];
     case 'AwaitExpression': {
      let t = ['await'];
      if (n.argument) {
       t.push(' ', r('argument'));
       let { parent: s } = e;
       if ((ke(s) && s.callee === n) || (Ie(s) && s.object === n)) {
        t = [cs([As, ...t]), As];
        let r = e.findAncestor((e) => 'AwaitExpression' === e.type || 'BlockStatement' === e.type);
        if ('AwaitExpression' !== r?.type || !Je(r.argument, (e) => e === n)) return gs(t);
       }
      }
      return t;
     }
     case 'ExportDefaultDeclaration':
     case 'ExportNamedDeclaration':
     case 'ExportAllDeclaration':
      return Qa(e, t, r);
     case 'ImportDeclaration':
      return (function (e, t, r) {
       let { node: s } = e;
       return ['import', s.phase ? ` ${s.phase}` : '', to(s), so(e, t, r), ro(e, t, r), io(e, t, r), t.semi ? ';' : ''];
      })(e, t, r);
     case 'ImportSpecifier':
     case 'ExportSpecifier':
     case 'ImportNamespaceSpecifier':
     case 'ExportNamespaceSpecifier':
     case 'ImportDefaultSpecifier':
     case 'ExportDefaultSpecifier':
      return ao(e, 0, r);
     case 'ImportAttribute':
      return ji(e, t, r);
     case 'Program':
     case 'BlockStatement':
     case 'StaticBlock':
      return ba(e, t, r);
     case 'ClassBody':
      return Ca(e, t, r);
     case 'ThrowStatement':
      return (function (e, t, r) {
       return ['throw', Ji(e, t, r)];
      })(e, t, r);
     case 'ReturnStatement':
      return (function (e, t, r) {
       return ['return', Ji(e, t, r)];
      })(e, t, r);
     case 'NewExpression':
     case 'ImportExpression':
     case 'OptionalCallExpression':
     case 'CallExpression':
      return Ci(e, t, r);
     case 'ObjectExpression':
     case 'ObjectPattern':
      return Ga(e, t, r);
     case 'Property':
      return be(n) ? Ri(e, t, r) : ji(e, t, r);
     case 'ObjectProperty':
      return ji(e, t, r);
     case 'ObjectMethod':
      return Ri(e, t, r);
     case 'Decorator':
      return ['@', r('expression')];
     case 'ArrayExpression':
     case 'ArrayPattern':
      return pi(e, t, r);
     case 'SequenceExpression': {
      let { parent: t } = e;
      if ('ExpressionStatement' === t.type || 'ForStatement' === t.type) {
       let t = [];
       return (
        e.each(({ isFirst: e }) => {
         e ? t.push(r()) : t.push(',', cs([Fs, r()]));
        }, 'expressions'),
        gs(t)
       );
      }
      let s = Ts([',', Fs], e.map(r, 'expressions'));
      return (('ReturnStatement' === t.type || 'ThrowStatement' === t.type) && 'argument' === e.key) || ('ArrowFunctionExpression' === t.type && 'body' === e.key) ? gs(Es([cs([As, s]), As], s)) : gs(s);
     }
     case 'ThisExpression':
      return 'this';
     case 'Super':
      return 'super';
     case 'Directive':
      return [r('value'), t.semi ? ';' : ''];
     case 'UnaryExpression': {
      let e = [n.operator];
      return (/[a-z]$/u.test(n.operator) && e.push(' '), ot(n.argument) ? e.push(gs(['(', cs([As, r('argument')]), As, ')'])) : e.push(r('argument')), e);
     }
     case 'UpdateExpression':
      return [n.prefix ? n.operator : '', r('argument'), n.prefix ? '' : n.operator];
     case 'ConditionalExpression':
      return fo(e, t, r, s);
     case 'VariableDeclaration': {
      let s,
       i = e.map(r, 'declarations'),
       a = e.parent,
       o = 'ForStatement' === a.type || 'ForInStatement' === a.type || 'ForOfStatement' === a.type,
       u = n.declarations.some((e) => e.init);
      return (1 !== i.length || ot(n.declarations[0]) ? i.length > 0 && (s = cs(i[0])) : (s = i[0]), gs([Jn(e), n.kind, s ? [' ', s] : '', cs(i.slice(1).map((e) => [',', u && !o ? Ss : Fs, e])), !t.semi || (o && a.body !== n) ? '' : ';']));
     }
     case 'WithStatement':
      return gs(['with (', r('object'), ')', zn(n.body, r('body'))]);
     case 'IfStatement': {
      let s = zn(n.consequent, r('consequent')),
       i = [gs(['if (', gs([cs([As, r('test')]), As]), ')', s])];
      if (n.alternate) {
       let s = ot(n.consequent, it.Trailing | it.Line) || _e(n),
        a = 'BlockStatement' === n.consequent.type && !s;
       (i.push(a ? ' ' : Ss), ot(n, it.Dangling) && i.push(Nn(e, t), s ? Ss : ' '), i.push('else', gs(zn(n.alternate, r('alternate'), 'IfStatement' === n.alternate.type))));
      }
      return i;
     }
     case 'ForStatement': {
      let s = zn(n.body, r('body')),
       i = Nn(e, t),
       a = i ? [i, As] : '';
      return n.init || n.test || n.update ? [a, gs(['for (', gs([cs([As, r('init'), ';', Fs, r('test'), ';', n.update ? [Fs, r('update')] : Es('', Fs)]), As]), ')', s])] : [a, gs(['for (;;)', s])];
     }
     case 'WhileStatement':
      return gs(['while (', gs([cs([As, r('test')]), As]), ')', zn(n.body, r('body'))]);
     case 'ForInStatement':
      return gs(['for (', r('left'), ' in ', r('right'), ')', zn(n.body, r('body'))]);
     case 'ForOfStatement':
      return gs(['for', n.await ? ' await' : '', ' (', r('left'), ' of ', r('right'), ')', zn(n.body, r('body'))]);
     case 'DoWhileStatement':
      return [gs(['do', zn(n.body, r('body'))]), 'BlockStatement' === n.body.type ? ' ' : Ss, 'while (', gs([cs([As, r('test')]), As]), ')', t.semi ? ';' : ''];
     case 'DoExpression':
      return [n.async ? 'async ' : '', 'do ', r('body')];
     case 'BreakStatement':
     case 'ContinueStatement':
      return ['BreakStatement' === n.type ? 'break' : 'continue', n.label ? [' ', r('label')] : '', t.semi ? ';' : ''];
     case 'LabeledStatement':
      return [r('label'), ':' + ('EmptyStatement' !== n.body.type || ot(n.body, it.Leading) ? ' ' : ''), r('body')];
     case 'TryStatement':
      return ['try ', r('block'), n.handler ? [' ', r('handler')] : '', n.finalizer ? [' finally ', r('finalizer')] : ''];
     case 'CatchClause':
      if (n.param) {
       let e = ot(n.param, (e) => !Q(e) || (e.leading && w(t.originalText, q(e))) || (e.trailing && w(t.originalText, $(e), { backwards: !0 }))),
        s = r('param');
       return ['catch ', e ? ['(', cs([As, s]), As, ') '] : ['(', s, ') '], r('body')];
      }
      return ['catch ', r('body')];
     case 'SwitchStatement':
      return [
       gs(['switch (', cs([As, r('discriminant')]), As, ')']),
       ' {',
       n.cases.length > 0
        ? cs([
           Ss,
           Ts(
            Ss,
            e.map(({ node: e, isLast: s }) => [r(), !s && lt(e, t) ? Ss : ''], 'cases'),
           ),
          ])
        : '',
       Ss,
       '}',
      ];
     case 'SwitchCase': {
      let s = [];
      (n.test ? s.push('case ', r('test'), ':') : s.push('default:'), ot(n, it.Dangling) && s.push(' ', Nn(e, t)));
      let i = n.consequent.filter((e) => 'EmptyStatement' !== e.type);
      if (i.length > 0) {
       let n = Ea(e, t, r, 'consequent');
       s.push(1 === i.length && 'BlockStatement' === i[0].type ? [' ', n] : cs([Ss, n]));
      }
      return s;
     }
     case 'DebuggerStatement':
      return ['debugger', t.semi ? ';' : ''];
     case 'ClassDeclaration':
     case 'ClassExpression':
      return Na(e, t, r);
     case 'ClassMethod':
     case 'ClassPrivateMethod':
     case 'MethodDefinition':
      return _a(e, t, r);
     case 'ClassProperty':
     case 'PropertyDefinition':
     case 'ClassPrivateProperty':
     case 'ClassAccessorProperty':
     case 'AccessorProperty':
      return Ra(e, t, r);
     case 'TemplateElement':
      return ss(n.value.raw);
     case 'TemplateLiteral':
      return Vs(e, t, r);
     case 'TaggedTemplateExpression':
      return (function (e, t, r) {
       let s = r('quasi'),
        { node: n } = e,
        i = '',
        a = ut(n.quasi, it.Leading)[0];
       return (a && (i = It(t.originalText, q(n.typeArguments ?? n.tag), $(a)) ? As : ' '), Cs(s.label && { tagged: !0, ...s.label }, [r('tag'), r('typeArguments'), i, ks, s]));
      })(e, t, r);
     case 'PrivateIdentifier':
      return ['#', n.name];
     case 'PrivateName':
      return ['#', r('id')];
     case 'TopicReference':
      return '%';
     case 'ArgumentPlaceholder':
      return '?';
     case 'ModuleExpression':
      return ['module ', r('body')];
     case 'VoidPattern':
      return 'void';
     case 'EmptyStatement':
      if (se(e)) return ';';
     default:
      throw new Gi(n, 'ESTree');
    }
   }
   function yo(e) {
    return [e('elementType'), '[]'];
   }
   var Do = G(['SatisfiesExpression', 'TSSatisfiesExpression']);
   function go(e, t, r) {
    let { parent: s, node: n, key: i } = e,
     a = 'AsConstExpression' === n.type ? 'const' : r('typeAnnotation'),
     o = [r('expression'), ' ', Do(n) ? 'satisfies' : 'as', ' ', a];
    return ('callee' === i && ke(s)) || ('object' === i && Ie(s)) ? gs([cs([As, ...o]), As]) : o;
   }
   function xo(e, t, r) {
    let { node: s } = e,
     n = [Jn(e), 'component'];
    (s.id && n.push(' ', r('id')), n.push(r('typeParameters')));
    let i = (function (e, t, r) {
     let { node: s } = e,
      n = s.params;
     if ((s.rest && (n = [...n, s.rest]), 0 === n.length)) return ['(', Nn(e, t, { filter: (e) => ')' === kt(t.originalText, q(e)) }), ')'];
     let i = [];
     return (
      (function (e, t) {
       let { node: r } = e,
        s = 0,
        n = (e) => t(e, s++);
       (e.each(n, 'params'), r.rest && e.call(n, 'rest'));
      })(e, (e, a) => {
       let o = a === n.length - 1;
       (o && s.rest && i.push('...'), i.push(r()), !o && (i.push(','), lt(n[a], t) ? i.push(Ss, Ss) : i.push(Fs)));
      }),
      ['(', cs([As, ...i]), Es(qe(t, 'all') && !Eo(s, n) ? ',' : ''), As, ')']
     );
    })(e, t, r);
    return (s.rendersType ? n.push(gs([i, ' ', r('rendersType')])) : n.push(gs([i])), s.body && n.push(' ', r('body')), t.semi && 'DeclareComponent' === s.type && n.push(';'), n);
   }
   function Eo(e, t) {
    return e.rest || 'RestElement' === c(0, t, -1)?.type;
   }
   function bo(e, t, r) {
    return Ga(e, t, r);
   }
   function To(e, t) {
    let { node: r } = e,
     s = t('id');
    r.computed && (s = ['[', s, ']']);
    let n = '';
    return (r.initializer && (n = t('initializer')), r.init && (n = t('init')), n ? [s, ' = ', n] : s);
   }
   function Co(e, t) {
    let { node: r } = e;
    return [Jn(e), r.const ? 'const ' : '', 'enum ', t('id'), ' ', t('body')];
   }
   function Fo(e, t, r) {
    let { node: s } = e,
     n = [Vn(e)];
    ('TSConstructorType' === s.type || 'TSConstructSignatureDeclaration' === s.type) && n.push('new ');
    let i = Mn(e, t, r, !1, !0),
     a = [];
    return (
     'FunctionTypeAnnotation' === s.type
      ? a.push(
         (function (e) {
          let { node: t, parent: r } = e;
          return 'FunctionTypeAnnotation' === t.type && (Te(r) || !((('ObjectTypeProperty' === r.type || 'ObjectTypeInternalSlot' === r.type) && !r.variance && !r.optional && J(r, t)) || 'ObjectTypeCallProperty' === r.type || 'DeclareFunction' === e.getParentNode(2)?.type));
         })(e)
          ? ' => '
          : ': ',
         r('returnType'),
        )
      : a.push(oi(e, r, 'returnType')),
     _n(s, a) && (i = gs(i)),
     n.push(i, a),
     [gs(n), 'TSConstructSignatureDeclaration' === s.type || 'TSCallSignatureDeclaration' === s.type ? Aa(e, t) : '']
    );
   }
   function Ao(e) {
    let { node: t } = e;
    return 'HookTypeAnnotation' === t.type && 'DeclareHook' === e.getParentNode(2)?.type;
   }
   function wo(e, t, r) {
    return [r('objectType'), Un(e), '[', r('indexType'), ']'];
   }
   function So(e, t, r) {
    return ['infer ', r('typeParameter')];
   }
   function vo(e, t, r) {
    let s = !1;
    return gs(
     e.map(({ isFirst: e, previous: n, node: i, index: a }) => {
      let o = r();
      if (e) return o;
      let u = De(i),
       l = De(n);
      return l && u ? [' & ', s ? cs(o) : o] : (!l && !u) || Le(t.originalText, i) ? ('start' === t.experimentalOperatorPosition ? cs([Fs, '& ', o]) : cs([' &', Fs, o])) : (a > 1 && (s = !0), [' & ', a > 1 ? cs(o) : o]);
     }, 'types'),
    );
   }
   function Po(e) {
    switch (e) {
     case null:
      return '';
     case 'PlusOptional':
      return '+?';
     case 'MinusOptional':
      return '-?';
     case 'Optional':
      return '?';
    }
   }
   function ko(e, t) {
    return '+' === e || '-' === e ? e + t : t;
   }
   function Io(e, t, r) {
    let { node: s } = e;
    switch (s.type) {
     case 'MatchOrPattern':
      return (function (e, t, r) {
       let { node: s } = e,
        { parent: n } = e,
        i = 'MatchStatementCase' !== n.type && 'MatchExpressionCase' !== n.type && 'MatchArrayPattern' !== n.type && 'MatchObjectPatternProperty' !== n.type && !Le(t.originalText, s),
        a = (function (e) {
         return (
          !(!No(e) && 'MatchObjectPattern' !== e.type) ||
          ('MatchOrPattern' === e.type &&
           (function (e) {
            let { patterns: t } = e;
            if (t.some((e) => ot(e))) return !1;
            let r = t.find((e) => 'MatchObjectPattern' === e.type);
            return !!r && t.every((e) => e === r || No(e));
           })(e))
         );
        })(s),
        o = e.map(() => {
         let s = r();
         return (a || (s = hs(2, s)), On(e, s, t));
        }, 'patterns');
       if (a) return Ts(' | ', o);
       let u = [Es(['| ']), Ts([Fs, '| '], o)];
       return vn(e, t) ? gs([cs([Es([As]), u]), As]) : 'MatchArrayPattern' === n.type && n.elements.length > 1 ? gs([cs([Es(['(', As]), u]), As, Es(')')]) : gs(i ? cs(u) : u);
      })(e, t, r);
     case 'MatchAsPattern':
      return [r('pattern'), ' as ', r('target')];
     case 'MatchWildcardPattern':
      return ['_'];
     case 'MatchLiteralPattern':
      return r('literal');
     case 'MatchUnaryPattern':
      return [s.operator, r('argument')];
     case 'MatchIdentifierPattern':
      return r('id');
     case 'MatchMemberPattern': {
      let e = 'Identifier' === s.property.type ? ['.', r('property')] : ['[', cs([As, r('property')]), As, ']'];
      return gs([r('base'), e]);
     }
     case 'MatchBindingPattern':
      return [s.kind, ' ', r('id')];
     case 'MatchObjectPattern': {
      let t = e.map(r, 'properties');
      return (s.rest && t.push(r('rest')), gs(['{', cs([As, Ts([',', Fs], t)]), s.rest ? '' : Es(','), As, '}']));
     }
     case 'MatchArrayPattern': {
      let t = e.map(r, 'elements');
      return (s.rest && t.push(r('rest')), gs(['[', cs([As, Ts([',', Fs], t)]), s.rest ? '' : Es(','), As, ']']));
     }
     case 'MatchObjectPatternProperty':
      return s.shorthand ? r('pattern') : gs([r('key'), ':', cs([Fs, r('pattern')])]);
     case 'MatchRestPattern': {
      let e = ['...'];
      return (s.argument && e.push(r('argument')), e);
     }
    }
   }
   var No = G(['MatchWildcardPattern', 'MatchLiteralPattern', 'MatchUnaryPattern', 'MatchIdentifierPattern']);
   function Bo(e, t, r) {
    let { node: s } = e;
    return ['...', ...('TupleTypeSpreadElement' === s.type && s.label ? [r('label'), ': '] : []), r('typeAnnotation')];
   }
   function Oo(e, t, r) {
    let { node: s } = e;
    return [s.variance ? r('variance') : '', r('label'), s.optional ? '?' : '', ': ', r('elementType')];
   }
   function Lo(e, t, r) {
    let { node: s } = e,
     n = [Jn(e), 'type ', r('id'), r('typeParameters')];
    return [wi(e, t, r, n, ' =', 'TSTypeAliasDeclaration' === s.type ? 'typeAnnotation' : 'right'), t.semi ? ';' : ''];
   }
   function Mo(e, t, r, s) {
    let { node: n } = e;
    if (!n[s]) return '';
    if (!Array.isArray(n[s])) return r(s);
    let i = ve(e.grandparent),
     a = e.match(
      (e) => !(1 === e[s].length && De(e[s][0])),
      void 0,
      (e, t) => 'typeAnnotation' === t,
      (e) => 'Identifier' === e.type,
      Pi,
     );
    if (
     0 === n[s].length ||
     (!a &&
      (i ||
       (1 === n[s].length &&
        ('NullableTypeAnnotation' === n[s][0].type ||
         (function (e) {
          return !(!we(e) && !De(e)) || (!!dt(e) && ii(e));
         })(n[s][0])))))
    )
     return ['<', Ts(', ', e.map(r, s)), jo(e, t), '>'];
    let o =
     'TSTypeParameterInstantiation' === n.type
      ? ''
      : (function (e, t, r) {
           let { node: s } = e;
           return 1 === Qe(s).length && s.type.startsWith('TS') && !s[r][0].constraint && 'ArrowFunctionExpression' === e.parent.type && !(t.filepath && /\.ts$/u.test(t.filepath));
          })(e, t, s)
        ? ','
        : qe(t)
          ? Es(',')
          : '';
    return gs(['<', cs([As, Ts([',', Fs], e.map(r, s))]), o, As, '>']);
   }
   function jo(e, t) {
    let { node: r } = e;
    if (!ot(r, it.Dangling)) return '';
    let s = !ot(r, it.Line),
     n = Nn(e, t, { indent: !s });
    return s ? n : [n, Ss];
   }
   function _o(e, t, r) {
    let { node: s } = e,
     n = [s.const ? 'const ' : ''],
     i = 'TSTypeParameter' === s.type ? r('name') : s.name;
    if ((s.variance && n.push(r('variance')), s.in && n.push('in '), s.out && n.push('out '), n.push(i), s.bound && (s.usesExtendsBound && n.push(' extends '), n.push(oi(e, r, 'bound'))), s.constraint)) {
     let e = Symbol('constraint');
     n.push(' extends', gs(cs(Fs), { id: e }), ks, bs(r('constraint'), { groupId: e }));
    }
    if (s.default) {
     let e = Symbol('default');
     n.push(' =', gs(cs(Fs), { id: e }), ks, bs(r('default'), { groupId: e }));
    }
    return gs(n);
   }
   function Ro(e, t) {
    let { node: r } = e;
    return ['TSTypePredicate' === r.type && r.asserts ? 'asserts ' : 'TypePredicate' === r.type && r.kind ? `${r.kind} ` : '', t('parameterName'), r.typeAnnotation ? [' is ', oi(e, t)] : ''];
   }
   function Uo({ node: e }, t) {
    return ['typeof ', t('TSTypeQuery' === e.type ? 'exprName' : 'argument'), t('typeArguments')];
   }
   function $o(e, t, r) {
    let { node: s } = e;
    if (Z(s)) return s.type.slice(0, -14).toLowerCase();
    switch (s.type) {
     case 'ComponentDeclaration':
     case 'DeclareComponent':
     case 'ComponentTypeAnnotation':
      return xo(e, t, r);
     case 'ComponentParameter':
      return (function (e, t, r) {
       let { node: s } = e;
       return s.shorthand ? r('local') : [r('name'), ' as ', r('local')];
      })(e, 0, r);
     case 'ComponentTypeParameter':
      return (function (e, t, r) {
       let { node: s } = e,
        n = [];
       return (s.name && n.push(r('name'), s.optional ? '?: ' : ': '), n.push(r('typeAnnotation')), n);
      })(e, 0, r);
     case 'HookDeclaration':
      return (function (e, t, r) {
       let { node: s } = e,
        n = ['hook'];
       s.id && n.push(' ', r('id'));
       let i = Mn(e, t, r, !1, !0),
        a = qi(e, r),
        o = _n(s, a);
       return (n.push(gs([o ? gs(i) : i, a]), s.body ? ' ' : '', r('body')), n);
      })(e, t, r);
     case 'DeclareHook':
      return (function (e, t, r) {
       let { node: s } = e,
        n = [Jn(e), 'hook'];
       return (s.id && n.push(' ', r('id')), t.semi && n.push(';'), n);
      })(e, t, r);
     case 'HookTypeAnnotation':
      return (function (e, t, r) {
       let { node: s } = e,
        n = Mn(e, t, r, !1, !0),
        i = [Ao(e) ? ': ' : ' => ', r('returnType')];
       return gs([Ao(e) ? '' : 'hook ', _n(s, i) ? gs(n) : n, i]);
      })(e, t, r);
     case 'DeclareFunction':
      return [Jn(e), 'function ', r('id'), r('predicate'), t.semi ? ';' : ''];
     case 'DeclareModule':
      return ['declare module ', r('id'), ' ', r('body')];
     case 'DeclareModuleExports':
      return ['declare module.exports', oi(e, r), t.semi ? ';' : ''];
     case 'DeclareNamespace':
      return ['declare namespace ', r('id'), ' ', r('body')];
     case 'DeclareVariable':
      return [Jn(e), s.kind ?? 'var', ' ', r('id'), t.semi ? ';' : ''];
     case 'DeclareExportDeclaration':
     case 'DeclareExportAllDeclaration':
      return Qa(e, t, r);
     case 'DeclareOpaqueType':
     case 'OpaqueType':
      return (function (e, t, r) {
       let { node: s } = e,
        n = [Jn(e), 'opaque type ', r('id'), r('typeParameters')];
       if ((s.supertype && n.push(': ', r('supertype')), s.lowerBound || s.upperBound)) {
        let e = [];
        (s.lowerBound && e.push(cs([Fs, 'super ', r('lowerBound')])), s.upperBound && e.push(cs([Fs, 'extends ', r('upperBound')])), n.push(gs(e)));
       }
       return (s.impltype && n.push(' = ', r('impltype')), n.push(t.semi ? ';' : ''), n);
      })(e, t, r);
     case 'DeclareTypeAlias':
     case 'TypeAlias':
      return Lo(e, t, r);
     case 'IntersectionTypeAnnotation':
      return vo(e, t, r);
     case 'UnionTypeAnnotation':
      return ri(e, t, r);
     case 'ConditionalTypeAnnotation':
      return fo(e, t, r);
     case 'InferTypeAnnotation':
      return So(0, 0, r);
     case 'FunctionTypeAnnotation':
      return Fo(e, t, r);
     case 'TupleTypeAnnotation':
      return pi(e, t, r);
     case 'TupleTypeLabeledElement':
      return Oo(e, 0, r);
     case 'TupleTypeSpreadElement':
      return Bo(e, 0, r);
     case 'GenericTypeAnnotation':
      return [r('id'), Mo(e, t, r, 'typeParameters')];
     case 'IndexedAccessType':
     case 'OptionalIndexedAccessType':
      return wo(e, 0, r);
     case 'TypeAnnotation':
      return li(e, 0, r);
     case 'TypeParameter':
      return _o(e, 0, r);
     case 'TypeofTypeAnnotation':
      return Uo(e, r);
     case 'ExistsTypeAnnotation':
      return '*';
     case 'ArrayTypeAnnotation':
      return yo(r);
     case 'DeclareEnum':
     case 'EnumDeclaration':
      return Co(e, r);
     case 'EnumBooleanBody':
     case 'EnumNumberBody':
     case 'EnumBigIntBody':
     case 'EnumStringBody':
     case 'EnumSymbolBody':
      return (function (e, t, r) {
       let { node: s } = e;
       return ['EnumSymbolBody' === s.type || s.explicitType ? `of ${s.type.slice(4, -4).toLowerCase()} ` : '', bo(e, t, r)];
      })(e, t, r);
     case 'EnumBooleanMember':
     case 'EnumNumberMember':
     case 'EnumBigIntMember':
     case 'EnumStringMember':
     case 'EnumDefaultedMember':
      return To(e, r);
     case 'FunctionTypeParam': {
      let t = s.name ? r('name') : e.parent.this === s ? 'this' : '';
      return [t, Un(e), t ? ': ' : '', r('typeAnnotation')];
     }
     case 'DeclareClass':
     case 'DeclareInterface':
     case 'InterfaceDeclaration':
     case 'InterfaceTypeAnnotation':
      return Na(e, t, r);
     case 'ObjectTypeAnnotation':
      return Ca(e, t, r);
     case 'ClassImplements':
     case 'InterfaceExtends':
      return [r('id'), r('typeParameters')];
     case 'NullableTypeAnnotation':
      return ['?', r('typeAnnotation')];
     case 'Variance': {
      let { kind: e } = s;
      return (I('plus' === e || 'minus' === e), 'plus' === e ? '+' : '-');
     }
     case 'KeyofTypeAnnotation':
      return ['keyof ', r('argument')];
     case 'ObjectTypeCallProperty':
      return [s.static ? 'static ' : '', r('value'), Aa(e, t)];
     case 'ObjectTypeMappedTypeProperty':
      return (function (e, t, r) {
       let { node: s } = e;
       return [gs([s.variance ? r('variance') : '', '[', cs([r('keyTparam'), ' in ', r('sourceType')]), ']', Po(s.optional), ': ', r('propType')]), Aa(e, t)];
      })(e, t, r);
     case 'ObjectTypeIndexer':
      return [s.static ? 'static ' : '', s.variance ? r('variance') : '', '[', r('id'), s.id ? ': ' : '', r('key'), ']: ', r('value'), Aa(e, t)];
     case 'ObjectTypeProperty': {
      let n = '';
      return (s.proto ? (n = 'proto ') : s.static && (n = 'static '), [n, 'init' !== s.kind ? s.kind + ' ' : '', s.variance ? r('variance') : '', Mi(e, t, r), Un(e), be(s) ? '' : ': ', r('value'), Aa(e, t)]);
     }
     case 'ObjectTypeInternalSlot':
      return [s.static ? 'static ' : '', '[[', r('id'), ']]', Un(e), s.method ? '' : ': ', r('value'), Aa(e, t)];
     case 'ObjectTypeSpreadProperty':
      return oo(e, r);
     case 'QualifiedTypeofIdentifier':
     case 'QualifiedTypeIdentifier':
      return [r('qualification'), '.', r('id')];
     case 'NullLiteralTypeAnnotation':
      return 'null';
     case 'BooleanLiteralTypeAnnotation':
      return String(s.value);
     case 'StringLiteralTypeAnnotation':
      return ss(R(Y(s), t));
     case 'NumberLiteralTypeAnnotation':
      return Gn(Y(s));
     case 'BigIntLiteralTypeAnnotation':
      return Wa(Y(s));
     case 'TypeCastExpression':
      return ['(', r('expression'), oi(e, r), ')'];
     case 'TypePredicate':
      return Ro(e, r);
     case 'TypeOperator':
      return [s.operator, ' ', r('typeAnnotation')];
     case 'TypeParameterDeclaration':
     case 'TypeParameterInstantiation':
      return Mo(e, t, r, 'params');
     case 'InferredPredicate':
     case 'DeclaredPredicate':
      return ['predicate' !== e.key || 'DeclareFunction' === e.parent.type || e.parent.returnType ? ' ' : ': ', '%checks', ...('DeclaredPredicate' === s.type ? ['(', r('value'), ')'] : [])];
     case 'AsExpression':
     case 'AsConstExpression':
     case 'SatisfiesExpression':
      return go(e, 0, r);
     case 'MatchExpression':
     case 'MatchStatement':
      return (function (e, t, r) {
       let { node: s } = e;
       return [
        gs(['match (', cs([As, r('argument')]), As, ')']),
        ' {',
        s.cases.length > 0
         ? cs([
            Ss,
            Ts(
             Ss,
             e.map(({ node: e, isLast: s }) => [r(), !s && lt(e, t) ? Ss : ''], 'cases'),
            ),
           ])
         : '',
        Ss,
        '}',
       ];
      })(e, t, r);
     case 'MatchExpressionCase':
     case 'MatchStatementCase':
      return (function (e, t, r) {
       let { node: s } = e,
        n = ot(s, it.Dangling) ? [' ', Nn(e, t)] : [],
        i = 'MatchStatementCase' === s.type ? [' ', r('body')] : cs([Fs, r('body'), ',']);
       return [r('pattern'), s.guard ? gs([cs([Fs, 'if (', r('guard'), ')'])]) : '', gs([' =>', n, i])];
      })(e, t, r);
     case 'MatchOrPattern':
     case 'MatchAsPattern':
     case 'MatchWildcardPattern':
     case 'MatchLiteralPattern':
     case 'MatchUnaryPattern':
     case 'MatchIdentifierPattern':
     case 'MatchMemberPattern':
     case 'MatchBindingPattern':
     case 'MatchObjectPattern':
     case 'MatchObjectPatternProperty':
     case 'MatchRestPattern':
     case 'MatchArrayPattern':
      return Io(e, t, r);
    }
   }
   function qo(e, t, r) {
    let { node: s } = e;
    return [s.postfix ? '' : r, oi(e, t), s.postfix ? r : ''];
   }
   function Jo(e, t, r) {
    let { node: s } = e;
    if (s.type.startsWith('TS')) {
     if (re(s)) return s.type.slice(2, -7).toLowerCase();
     switch (s.type) {
      case 'TSThisType':
       return 'this';
      case 'TSTypeAssertion':
       return (function (e, t, r) {
        let { node: s } = e,
         n = !(le(s.expression) || pe(s.expression)),
         i = gs(['<', cs([As, r('typeAnnotation')]), As, '>']),
         a = [Es('('), cs([As, r('expression')]), As, Es(')')];
        return n
         ? xs([
            [i, r('expression')],
            [i, gs(a, { shouldBreak: !0 })],
            [i, r('expression')],
           ])
         : gs([i, r('expression')]);
       })(e, 0, r);
      case 'TSDeclareFunction':
       return _i(e, t, r);
      case 'TSExportAssignment':
       return ['export = ', r('expression'), t.semi ? ';' : ''];
      case 'TSModuleBlock':
       return ba(e, t, r);
      case 'TSInterfaceBody':
      case 'TSTypeLiteral':
       return Ca(e, t, r);
      case 'TSTypeAliasDeclaration':
       return Lo(e, t, r);
      case 'TSQualifiedName':
       return [r('left'), '.', r('right')];
      case 'TSAbstractMethodDefinition':
      case 'TSDeclareMethod':
       return _a(e, t, r);
      case 'TSAbstractAccessorProperty':
      case 'TSAbstractPropertyDefinition':
       return Ra(e, t, r);
      case 'TSInterfaceHeritage':
      case 'TSClassImplements':
      case 'TSInstantiationExpression':
       return [r('expression'), r('typeArguments')];
      case 'TSTemplateLiteralType':
       return Vs(e, t, r);
      case 'TSNamedTupleMember':
       return Oo(e, 0, r);
      case 'TSRestType':
       return Bo(e, 0, r);
      case 'TSOptionalType':
       return [r('typeAnnotation'), '?'];
      case 'TSInterfaceDeclaration':
       return Na(e, t, r);
      case 'TSTypeParameterDeclaration':
      case 'TSTypeParameterInstantiation':
       return Mo(e, t, r, 'params');
      case 'TSTypeParameter':
       return _o(e, 0, r);
      case 'TSAsExpression':
      case 'TSSatisfiesExpression':
       return go(e, 0, r);
      case 'TSArrayType':
       return yo(r);
      case 'TSPropertySignature':
       return [s.readonly ? 'readonly ' : '', Mi(e, t, r), Un(e), oi(e, r), Aa(e, t)];
      case 'TSParameterProperty':
       return [Hn(s), s.static ? 'static ' : '', s.override ? 'override ' : '', s.readonly ? 'readonly ' : '', r('parameter')];
      case 'TSTypeQuery':
       return Uo(e, r);
      case 'TSIndexSignature':
       return (function (e, t, r) {
        let { node: s } = e,
         n = s.parameters.length > 1 ? Es(qe(t) ? ',' : '') : '',
         i = gs([cs([As, Ts([', ', As], e.map(r, 'parameters'))]), n, As]);
        return ['body' === e.key && 'ClassBody' === e.parent.type && s.static ? 'static ' : '', s.readonly ? 'readonly ' : '', '[', s.parameters ? i : '', ']', oi(e, r), Aa(e, t)];
       })(e, t, r);
      case 'TSTypePredicate':
       return Ro(e, r);
      case 'TSNonNullExpression':
       return [r('expression'), '!'];
      case 'TSImportType':
       return [Ci(e, t, r), s.qualifier ? ['.', r('qualifier')] : '', Mo(e, t, r, 'typeArguments')];
      case 'TSLiteralType':
       return r('literal');
      case 'TSIndexedAccessType':
       return wo(e, 0, r);
      case 'TSTypeOperator':
       return [s.operator, ' ', r('typeAnnotation')];
      case 'TSMappedType':
       return (function (e, t, r) {
        let { node: s } = e,
         n = !1;
        if ('preserve' === t.objectWrap) {
         let e = $(s),
          r = e + 1 + Ha(t, e + 1, $(s.key)).search(/\S/u);
         It(t.originalText, e, r) && (n = !0);
        }
        return gs(['{', cs([t.bracketSpacing ? Fs : As, ot(s, it.Dangling) ? gs([Nn(e, t), Ss]) : '', gs([s.readonly ? [ko(s.readonly, 'readonly'), ' '] : '', '[', r('key'), ' in ', r('constraint'), s.nameType ? [' as ', r('nameType')] : '', ']', s.optional ? ko(s.optional, '?') : '', s.typeAnnotation ? ': ' : '', r('typeAnnotation')]), t.semi ? Es(';') : '']), t.bracketSpacing ? Fs : As, '}'], { shouldBreak: n });
       })(e, t, r);
      case 'TSMethodSignature':
       return (function (e, t, r) {
        let { node: s } = e,
         n = [],
         i = s.kind && 'method' !== s.kind ? `${s.kind} ` : '';
        n.push(Hn(s), i, s.computed ? '[' : '', r('key'), s.computed ? ']' : '', Un(e));
        let a = Mn(e, t, r, !1, !0),
         o = oi(e, r, 'returnType'),
         u = _n(s, o);
        return (n.push(u ? gs(a) : a), s.returnType && n.push(gs(o)), [gs(n), Aa(e, t)]);
       })(e, t, r);
      case 'TSNamespaceExportDeclaration':
       return ['export as namespace ', r('id'), t.semi ? ';' : ''];
      case 'TSEnumDeclaration':
       return Co(e, r);
      case 'TSEnumBody':
       return bo(e, t, r);
      case 'TSEnumMember':
       return To(e, r);
      case 'TSImportEqualsDeclaration':
       return ['import ', to(s, !1), r('id'), ' = ', r('moduleReference'), t.semi ? ';' : ''];
      case 'TSExternalModuleReference':
       return Ci(e, t, r);
      case 'TSModuleDeclaration':
       return (function (e, t, r) {
        let { node: s } = e;
        return [Jn(e), 'global' === s.kind ? '' : `${s.kind} `, r('id'), s.body ? [' ', gs(r('body'))] : t.semi ? ';' : ''];
       })(e, t, r);
      case 'TSConditionalType':
       return fo(e, t, r);
      case 'TSInferType':
       return So(0, 0, r);
      case 'TSIntersectionType':
       return vo(e, t, r);
      case 'TSUnionType':
       return ri(e, t, r);
      case 'TSFunctionType':
      case 'TSCallSignatureDeclaration':
      case 'TSConstructorType':
      case 'TSConstructSignatureDeclaration':
       return Fo(e, t, r);
      case 'TSTupleType':
       return pi(e, t, r);
      case 'TSTypeReference':
       return [r('typeName'), Mo(e, t, r, 'typeArguments')];
      case 'TSTypeAnnotation':
       return li(e, 0, r);
      case 'TSEmptyBodyFunctionExpression':
       return Ui(e, t, r);
      case 'TSJSDocAllType':
       return '*';
      case 'TSJSDocUnknownType':
       return '?';
      case 'TSJSDocNullableType':
       return qo(e, r, '?');
      case 'TSJSDocNonNullableType':
       return qo(e, r, '!');
      default:
       throw new Gi(s, 'TypeScript');
     }
    }
   }
   var Wo = G(['ClassMethod', 'ClassPrivateMethod', 'ClassProperty', 'ClassAccessorProperty', 'AccessorProperty', 'TSAbstractAccessorProperty', 'PropertyDefinition', 'TSAbstractPropertyDefinition', 'ClassPrivateProperty', 'MethodDefinition', 'TSAbstractMethodDefinition', 'TSDeclareMethod']);
   var Vo = function (e, t, r, s) {
     e.isRoot && t.__onHtmlBindingRoot?.(e.node, t);
     let { node: n } = e,
      i = oa(e)
       ? t.originalText.slice($(n), q(n))
       : (function (e, t, r, s) {
          for (let n of [ua, ia, $o, Jo, mo]) {
           let i = n(e, t, r, s);
           if (void 0 !== i) return i;
          }
         })(e, t, r, s);
     if (!i) return '';
     if (Wo(n)) return i;
     let a = k(n.decorators),
      o = (function (e, t, r) {
       let { node: s, parent: n } = e,
        { decorators: i } = s;
       if (!k(i) || fa(n) || oa(e)) return '';
       let a = 'ClassExpression' === s.type || 'ClassDeclaration' === s.type || da(s, t);
       return ['declaration' === e.key && ue(n) ? Ss : a ? ms : '', Ts(Fs, e.map(r, 'decorators')), Fs];
      })(e, t, r),
      u = 'ClassExpression' === n.type;
     if (a && !u) return is(i, (e) => gs([o, e]));
     let l = vn(e, t),
      p = Wi(e, t);
     return o || l || p ? is(i, (e) => [p ? ';' : '', l ? '(' : '', l && u && a ? [cs([Fs, o, e]), Fs] : [o, e], l ? ')' : '']) : i;
    },
    zo = { experimental_avoidAstMutation: !0 },
    Ho = {};
   n(Ho, { getVisitorKeys: () => Ko, massageAstNode: () => Zo, print: () => Go });
   var Xo = [[]],
    Ko = H({ JsonRoot: ['node'], ArrayExpression: ['elements'], ObjectExpression: ['properties'], ObjectProperty: ['key', 'value'], UnaryExpression: ['argument'], NullLiteral: Xo[0], BooleanLiteral: Xo[0], StringLiteral: Xo[0], NumericLiteral: Xo[0], Identifier: Xo[0], TemplateLiteral: ['quasis'], TemplateElement: Xo[0] });
   function Go(e, t, r) {
    let { node: s } = e;
    switch (s.type) {
     case 'JsonRoot':
      return [r('node'), Ss];
     case 'ArrayExpression': {
      if (0 === s.elements.length) return '[]';
      let t = e.map(() => (null === e.node ? 'null' : r()), 'elements');
      return ['[', cs([Ss, Ts([',', Ss], t)]), Ss, ']'];
     }
     case 'ObjectExpression':
      return 0 === s.properties.length ? '{}' : ['{', cs([Ss, Ts([',', Ss], e.map(r, 'properties'))]), Ss, '}'];
     case 'ObjectProperty':
      return [r('key'), ': ', r('value')];
     case 'UnaryExpression':
      return ['+' === s.operator ? '' : s.operator, r('argument')];
     case 'NullLiteral':
      return 'null';
     case 'BooleanLiteral':
      return s.value ? 'true' : 'false';
     case 'StringLiteral':
      return JSON.stringify(s.value);
     case 'NumericLiteral':
      return Yo(e) ? JSON.stringify(String(s.value)) : JSON.stringify(s.value);
     case 'Identifier':
      return Yo(e) ? JSON.stringify(s.name) : s.name;
     case 'TemplateLiteral':
      return r(['quasis', 0]);
     case 'TemplateElement':
      return JSON.stringify(s.value.cooked);
     default:
      throw new Gi(s, 'JSON');
    }
   }
   function Yo(e) {
    return 'key' === e.key && 'ObjectProperty' === e.parent.type;
   }
   var Qo = new Set(['start', 'end', 'extra', 'loc', 'comments', 'leadingComments', 'trailingComments', 'innerComments', 'errors', 'range', 'tokens']);
   function Zo(e, t) {
    let { type: r } = e;
    if ('ObjectProperty' !== r) {
     if ('UnaryExpression' === r && '+' === e.operator) return t.argument;
     if ('ArrayExpression' !== r) return 'TemplateLiteral' === r ? { type: 'StringLiteral', value: e.quasis[0].value.cooked } : void 0;
     for (let [r, s] of e.elements.entries()) null === s && t.elements.splice(r, 0, { type: 'NullLiteral' });
    } else {
     let { key: r } = e;
     'Identifier' === r.type ? (t.key = { type: 'StringLiteral', value: r.name }) : 'NumericLiteral' === r.type && (t.key = { type: 'StringLiteral', value: String(r.value) });
    }
   }
   Zo.ignoredProperties = Qo;
   var eu = {
     bracketSpacing: { category: 'Common', type: 'boolean', default: !0, description: 'Print spaces between brackets.', oppositeDescription: 'Do not print spaces between brackets.' },
     objectWrap: {
      category: 'Common',
      type: 'choice',
      default: 'preserve',
      description: 'How to wrap object literals.',
      choices: [
       { value: 'preserve', description: 'Keep as multi-line, if there is a newline between the opening brace and first property.' },
       { value: 'collapse', description: 'Fit to a single line when possible.' },
      ],
     },
     singleQuote: { category: 'Common', type: 'boolean', default: !1, description: 'Use single quotes instead of double quotes.' },
     proseWrap: {
      category: 'Common',
      type: 'choice',
      default: 'preserve',
      description: 'How to wrap prose.',
      choices: [
       { value: 'always', description: 'Wrap prose if it exceeds the print width.' },
       { value: 'never', description: 'Do not wrap prose.' },
       { value: 'preserve', description: 'Wrap prose as-is.' },
      ],
     },
     bracketSameLine: { category: 'Common', type: 'boolean', default: !1, description: 'Put > of opening tags on the last line instead of on a new line.' },
     singleAttributePerLine: { category: 'Common', type: 'boolean', default: !1, description: 'Enforce single attribute per line in HTML, Vue and JSX.' },
    },
    tu = 'JavaScript',
    ru = {
     arrowParens: {
      category: tu,
      type: 'choice',
      default: 'always',
      description: 'Include parentheses around a sole arrow function parameter.',
      choices: [
       { value: 'always', description: 'Always include parens. Example: `(x) => x`' },
       { value: 'avoid', description: 'Omit parens when possible. Example: `x => x`' },
      ],
     },
     bracketSameLine: eu.bracketSameLine,
     objectWrap: eu.objectWrap,
     bracketSpacing: eu.bracketSpacing,
     jsxBracketSameLine: { category: tu, type: 'boolean', description: 'Put > on the last line instead of at a new line.', deprecated: '2.4.0' },
     semi: { category: tu, type: 'boolean', default: !0, description: 'Print semicolons.', oppositeDescription: 'Do not print semicolons, except at the beginning of lines which may need them.' },
     experimentalOperatorPosition: {
      category: tu,
      type: 'choice',
      default: 'end',
      description: 'Where to print operators when binary expressions wrap lines.',
      choices: [
       { value: 'start', description: 'Print operators at the start of new lines.' },
       { value: 'end', description: 'Print operators at the end of previous lines.' },
      ],
     },
     experimentalTernaries: { category: tu, type: 'boolean', default: !1, description: 'Use curious ternaries, with the question mark after the condition.', oppositeDescription: 'Default behavior of ternaries; keep question marks on the same line as the consequent.' },
     singleQuote: eu.singleQuote,
     jsxSingleQuote: { category: tu, type: 'boolean', default: !1, description: 'Use single quotes in JSX.' },
     quoteProps: {
      category: tu,
      type: 'choice',
      default: 'as-needed',
      description: 'Change when properties in objects are quoted.',
      choices: [
       { value: 'as-needed', description: 'Only add quotes around object properties where required.' },
       { value: 'consistent', description: 'If at least one property in an object requires quotes, quote all properties.' },
       { value: 'preserve', description: 'Respect the input use of quotes in object properties.' },
      ],
     },
     trailingComma: {
      category: tu,
      type: 'choice',
      default: 'all',
      description: 'Print trailing commas wherever possible when multi-line.',
      choices: [
       { value: 'all', description: 'Trailing commas wherever possible (including function arguments).' },
       { value: 'es5', description: 'Trailing commas where valid in ES5 (objects, arrays, etc.)' },
       { value: 'none', description: 'No trailing commas.' },
      ],
     },
     singleAttributePerLine: eu.singleAttributePerLine,
    },
    su = { estree: a, 'estree-json': Ho },
    nu = [
     { name: 'JavaScript', type: 'programming', aceMode: 'javascript', extensions: ['.js', '._js', '.bones', '.cjs', '.es', '.es6', '.gs', '.jake', '.javascript', '.jsb', '.jscad', '.jsfl', '.jslib', '.jsm', '.jspre', '.jss', '.mjs', '.njs', '.pac', '.sjs', '.ssjs', '.xsjs', '.xsjslib', '.start.frag', '.end.frag', '.wxs'], filenames: ['Jakefile', 'start.frag', 'end.frag'], tmScope: 'source.js', aliases: ['js', 'node'], codemirrorMode: 'javascript', codemirrorMimeType: 'text/javascript', interpreters: ['chakra', 'd8', 'gjs', 'js', 'node', 'nodejs', 'qjs', 'rhino', 'v8', 'v8-shell', 'zx'], parsers: ['babel', 'acorn', 'espree', 'meriyah', 'babel-flow', 'babel-ts', 'flow', 'typescript'], vscodeLanguageIds: ['javascript', 'mongo'], linguistLanguageId: 183 },
     { name: 'Flow', type: 'programming', aceMode: 'javascript', extensions: ['.js.flow'], filenames: [], tmScope: 'source.js', aliases: [], codemirrorMode: 'javascript', codemirrorMimeType: 'text/javascript', interpreters: ['chakra', 'd8', 'gjs', 'js', 'node', 'nodejs', 'qjs', 'rhino', 'v8', 'v8-shell'], parsers: ['flow', 'babel-flow'], vscodeLanguageIds: ['javascript'], linguistLanguageId: 183 },
     { name: 'JSX', type: 'programming', aceMode: 'javascript', extensions: ['.jsx'], filenames: void 0, tmScope: 'source.js.jsx', aliases: void 0, codemirrorMode: 'jsx', codemirrorMimeType: 'text/jsx', interpreters: void 0, parsers: ['babel', 'babel-flow', 'babel-ts', 'flow', 'typescript', 'espree', 'meriyah'], vscodeLanguageIds: ['javascriptreact'], group: 'JavaScript', linguistLanguageId: 183 },
     { name: 'TypeScript', type: 'programming', aceMode: 'typescript', extensions: ['.ts', '.cts', '.mts'], tmScope: 'source.ts', aliases: ['ts'], codemirrorMode: 'javascript', codemirrorMimeType: 'application/typescript', interpreters: ['bun', 'deno', 'ts-node', 'tsx'], parsers: ['typescript', 'babel-ts'], vscodeLanguageIds: ['typescript'], linguistLanguageId: 378 },
     { name: 'TSX', type: 'programming', aceMode: 'tsx', extensions: ['.tsx'], tmScope: 'source.tsx', codemirrorMode: 'jsx', codemirrorMimeType: 'text/typescript-jsx', group: 'TypeScript', parsers: ['typescript', 'babel-ts'], vscodeLanguageIds: ['typescriptreact'], linguistLanguageId: 94901924 },
     { name: 'JSON.stringify', type: 'data', aceMode: 'json', extensions: ['.importmap'], filenames: ['package.json', 'package-lock.json', 'composer.json'], tmScope: 'source.json', aliases: ['geojson', 'jsonl', 'sarif', 'topojson'], codemirrorMode: 'javascript', codemirrorMimeType: 'application/json', parsers: ['json-stringify'], vscodeLanguageIds: ['json'], linguistLanguageId: 174 },
     { name: 'JSON', type: 'data', aceMode: 'json', extensions: ['.json', '.4DForm', '.4DProject', '.avsc', '.geojson', '.gltf', '.har', '.ice', '.JSON-tmLanguage', '.json.example', '.mcmeta', '.sarif', '.tact', '.tfstate', '.tfstate.backup', '.topojson', '.webapp', '.webmanifest', '.yy', '.yyp'], filenames: ['.all-contributorsrc', '.arcconfig', '.auto-changelog', '.c8rc', '.htmlhintrc', '.imgbotconfig', '.nycrc', '.tern-config', '.tern-project', '.watchmanconfig', '.babelrc', '.jscsrc', '.jshintrc', '.jslintrc', '.swcrc'], tmScope: 'source.json', aliases: ['geojson', 'jsonl', 'sarif', 'topojson'], codemirrorMode: 'javascript', codemirrorMimeType: 'application/json', parsers: ['json'], vscodeLanguageIds: ['json'], linguistLanguageId: 174 },
     { name: 'JSON with Comments', type: 'data', aceMode: 'javascript', extensions: ['.jsonc', '.code-snippets', '.code-workspace', '.sublime-build', '.sublime-color-scheme', '.sublime-commands', '.sublime-completions', '.sublime-keymap', '.sublime-macro', '.sublime-menu', '.sublime-mousemap', '.sublime-project', '.sublime-settings', '.sublime-theme', '.sublime-workspace', '.sublime_metrics', '.sublime_session'], filenames: [], tmScope: 'source.json.comments', aliases: ['jsonc'], codemirrorMode: 'javascript', codemirrorMimeType: 'text/javascript', group: 'JSON', parsers: ['jsonc'], vscodeLanguageIds: ['jsonc'], linguistLanguageId: 423 },
     { name: 'JSON5', type: 'data', aceMode: 'json5', extensions: ['.json5'], tmScope: 'source.js', codemirrorMode: 'javascript', codemirrorMimeType: 'application/json', parsers: ['json5'], vscodeLanguageIds: ['json5'], linguistLanguageId: 175 },
    ];
  },
  18652(e, t, r) {
   r.d(t, { A: () => i });
   var s = r(30758),
    n = { outline: { xmlns: 'http://www.w3.org/2000/svg', width: 24, height: 24, viewBox: '0 0 24 24', fill: 'none', stroke: 'currentColor', strokeWidth: 2, strokeLinecap: 'round', strokeLinejoin: 'round' }, filled: { xmlns: 'http://www.w3.org/2000/svg', width: 24, height: 24, viewBox: '0 0 24 24', fill: 'currentColor', stroke: 'none' } };
   const i = (e, t, r, i) => {
    const a = (0, s.forwardRef)(({ color: r = 'currentColor', size: a = 24, stroke: o = 2, title: u, className: l, children: p, ...c }, h) => (0, s.createElement)('svg', { ref: h, ...n[e], width: a, height: a, className: ['tabler-icon', `tabler-icon-${t}`, l].join(' '), ...('filled' === e ? { fill: r } : { strokeWidth: o, stroke: r }), ...c }, [u && (0, s.createElement)('title', { key: 'svg-title' }, u), ...i.map(([e, t]) => (0, s.createElement)(e, t)), ...(Array.isArray(p) ? p : [p])]));
    return ((a.displayName = `${r}`), a);
   };
  },
  30734(e, t, r) {
   r.d(t, { Ay: () => d });
   var s,
    n,
    i = Object.create,
    a = Object.defineProperty,
    o = Object.getOwnPropertyDescriptor,
    u = Object.getOwnPropertyNames,
    l = Object.getPrototypeOf,
    p = Object.prototype.hasOwnProperty,
    c = (e, t) => {
     for (var r in t) a(e, r, { get: t[r], enumerable: !0 });
    },
    h =
     ((s = (e, t) => {
      var r, s, n, i, a, o, u, l, p, c, h, d, f, m, y, D, g, x, E;
      ((f = /\/(?![*\/])(?:\[(?:[^\]\\\n\r\u2028\u2029]+|\\.)*\]|[^\/\\\n\r\u2028\u2029]+|\\.)*(\/[$_\u200C\u200D\p{ID_Continue}]*|\\)?/uy),
       (d = /--|\+\+|=>|\.{3}|\??\.(?!\d)|(?:&&|\|\||\?\?|[+\-%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2}|\/(?![\/*]))=?|[?~,:;[\](){}]/y),
       (r = /(\x23?)(?=[$_\p{ID_Start}\\])(?:[$_\u200C\u200D\p{ID_Continue}]+|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+/uy),
       (y = /(['"])(?:[^'"\\\n\r]+|(?!\1)['"]|\\(?:\r\n|[^]))*(\1)?/y),
       (h = /(?:0[xX][\da-fA-F](?:_?[\da-fA-F])*|0[oO][0-7](?:_?[0-7])*|0[bB][01](?:_?[01])*)n?|0n|[1-9](?:_?\d)*n|(?:(?:0(?!\d)|0\d*[89]\d*|[1-9](?:_?\d)*)(?:\.(?:\d(?:_?\d)*)?)?|\.\d(?:_?\d)*)(?:[eE][+-]?\d(?:_?\d)*)?|0[0-7]+/y),
       (D = /[`}](?:[^`\\$]+|\\[^]|\$(?!\{))*(`|\$\{)?/y),
       (E = /[\t\v\f\ufeff\p{Zs}]+/uy),
       (l = /\r?\n|[\r\u2028\u2029]/y),
       (p = /\/\*(?:[^*]+|\*(?!\/))*(\*\/)?/y),
       (m = /\/\/.*/y),
       (n = /[<>.:={}]|\/(?![\/*])/y),
       (s = /[$_\p{ID_Start}][$_\u200C\u200D\p{ID_Continue}-]*/uy),
       (i = /(['"])(?:[^'"]+|(?!\1)['"])*(\1)?/y),
       (a = /[^<>{}]+/y),
       (x = /^(?:[\/+-]|\.{3}|\?(?:InterpolationIn(?:JSX|Template)|NoLineTerminatorHere|NonExpressionParenEnd|UnaryIncDec))?$|[{}([,;<>=*%&|^!~?:]$/),
       (g = /^(?:=>|[;\]){}]|else|\?(?:NoLineTerminatorHere|NonExpressionParenEnd))?$/),
       (o = /^(?:await|case|default|delete|do|else|instanceof|new|return|throw|typeof|void|yield)$/),
       (u = /^(?:return|throw|yield)$/),
       (c = RegExp(l.source)),
       (t.exports = function* (e, { jsx: t = !1 } = {}) {
        var b, T, C, F, A, w, S, v, P, k, I, N, B, O;
        for ({ length: w } = e, F = 0, A = '', O = [{ tag: 'JS' }], b = [], I = 0, N = !1; F < w; ) {
         switch ((v = O[O.length - 1]).tag) {
          case 'JS':
          case 'JSNonExpressionParen':
          case 'InterpolationInTemplate':
          case 'InterpolationInJSX':
           if ('/' === e[F] && (x.test(A) || o.test(A)) && ((f.lastIndex = F), (S = f.exec(e)))) {
            ((F = f.lastIndex), (A = S[0]), (N = !0), yield { type: 'RegularExpressionLiteral', value: S[0], closed: void 0 !== S[1] && '\\' !== S[1] });
            continue;
           }
           if (((d.lastIndex = F), (S = d.exec(e)))) {
            switch (((B = S[0]), (P = d.lastIndex), (k = B), B)) {
             case '(':
              ('?NonExpressionParenKeyword' === A && O.push({ tag: 'JSNonExpressionParen', nesting: I }), I++, (N = !1));
              break;
             case ')':
              (I--, (N = !0), 'JSNonExpressionParen' === v.tag && I === v.nesting && (O.pop(), (k = '?NonExpressionParenEnd'), (N = !1)));
              break;
             case '{':
              ((d.lastIndex = 0), (C = !g.test(A) && (x.test(A) || o.test(A))), b.push(C), (N = !1));
              break;
             case '}':
              switch (v.tag) {
               case 'InterpolationInTemplate':
                if (b.length === v.nesting) {
                 ((D.lastIndex = F), (S = D.exec(e)), (F = D.lastIndex), (A = S[0]), '${' === S[1] ? ((A = '?InterpolationInTemplate'), (N = !1), yield { type: 'TemplateMiddle', value: S[0] }) : (O.pop(), (N = !0), yield { type: 'TemplateTail', value: S[0], closed: '`' === S[1] }));
                 continue;
                }
                break;
               case 'InterpolationInJSX':
                if (b.length === v.nesting) {
                 (O.pop(), (F += 1), (A = '}'), yield { type: 'JSXPunctuator', value: '}' });
                 continue;
                }
              }
              k = (N = b.pop()) ? '?ExpressionBraceEnd' : '}';
              break;
             case ']':
              N = !0;
              break;
             case '++':
             case '--':
              k = N ? '?PostfixIncDec' : '?UnaryIncDec';
              break;
             case '<':
              if (t && (x.test(A) || o.test(A))) {
               (O.push({ tag: 'JSXTag' }), (F += 1), (A = '<'), yield { type: 'JSXPunctuator', value: B });
               continue;
              }
              N = !1;
              break;
             default:
              N = !1;
            }
            ((F = P), (A = k), yield { type: 'Punctuator', value: B });
            continue;
           }
           if (((r.lastIndex = F), (S = r.exec(e)))) {
            switch (((F = r.lastIndex), (k = S[0]), S[0])) {
             case 'for':
             case 'if':
             case 'while':
             case 'with':
              '.' !== A && '?.' !== A && (k = '?NonExpressionParenKeyword');
            }
            ((A = k), (N = !o.test(S[0])), yield { type: '#' === S[1] ? 'PrivateIdentifier' : 'IdentifierName', value: S[0] });
            continue;
           }
           if (((y.lastIndex = F), (S = y.exec(e)))) {
            ((F = y.lastIndex), (A = S[0]), (N = !0), yield { type: 'StringLiteral', value: S[0], closed: void 0 !== S[2] });
            continue;
           }
           if (((h.lastIndex = F), (S = h.exec(e)))) {
            ((F = h.lastIndex), (A = S[0]), (N = !0), yield { type: 'NumericLiteral', value: S[0] });
            continue;
           }
           if (((D.lastIndex = F), (S = D.exec(e)))) {
            ((F = D.lastIndex), (A = S[0]), '${' === S[1] ? ((A = '?InterpolationInTemplate'), O.push({ tag: 'InterpolationInTemplate', nesting: b.length }), (N = !1), yield { type: 'TemplateHead', value: S[0] }) : ((N = !0), yield { type: 'NoSubstitutionTemplate', value: S[0], closed: '`' === S[1] }));
            continue;
           }
           break;
          case 'JSXTag':
          case 'JSXTagEnd':
           if (((n.lastIndex = F), (S = n.exec(e)))) {
            switch (((F = n.lastIndex), (k = S[0]), S[0])) {
             case '<':
              O.push({ tag: 'JSXTag' });
              break;
             case '>':
              (O.pop(), '/' === A || 'JSXTagEnd' === v.tag ? ((k = '?JSX'), (N = !0)) : O.push({ tag: 'JSXChildren' }));
              break;
             case '{':
              (O.push({ tag: 'InterpolationInJSX', nesting: b.length }), (k = '?InterpolationInJSX'), (N = !1));
              break;
             case '/':
              '<' === A && (O.pop(), 'JSXChildren' === O[O.length - 1].tag && O.pop(), O.push({ tag: 'JSXTagEnd' }));
            }
            ((A = k), yield { type: 'JSXPunctuator', value: S[0] });
            continue;
           }
           if (((s.lastIndex = F), (S = s.exec(e)))) {
            ((F = s.lastIndex), (A = S[0]), yield { type: 'JSXIdentifier', value: S[0] });
            continue;
           }
           if (((i.lastIndex = F), (S = i.exec(e)))) {
            ((F = i.lastIndex), (A = S[0]), yield { type: 'JSXString', value: S[0], closed: void 0 !== S[2] });
            continue;
           }
           break;
          case 'JSXChildren':
           if (((a.lastIndex = F), (S = a.exec(e)))) {
            ((F = a.lastIndex), (A = S[0]), yield { type: 'JSXText', value: S[0] });
            continue;
           }
           switch (e[F]) {
            case '<':
             (O.push({ tag: 'JSXTag' }), F++, (A = '<'), yield { type: 'JSXPunctuator', value: '<' });
             continue;
            case '{':
             (O.push({ tag: 'InterpolationInJSX', nesting: b.length }), F++, (A = '?InterpolationInJSX'), (N = !1), yield { type: 'JSXPunctuator', value: '{' });
             continue;
           }
         }
         ((E.lastIndex = F), (S = E.exec(e)) ? ((F = E.lastIndex), yield { type: 'WhiteSpace', value: S[0] }) : ((l.lastIndex = F), (S = l.exec(e)) ? ((F = l.lastIndex), (N = !1), u.test(A) && (A = '?NoLineTerminatorHere'), yield { type: 'LineTerminatorSequence', value: S[0] }) : ((p.lastIndex = F), (S = p.exec(e)) ? ((F = p.lastIndex), c.test(S[0]) && ((N = !1), u.test(A) && (A = '?NoLineTerminatorHere')), yield { type: 'MultiLineComment', value: S[0], closed: void 0 !== S[1] }) : ((m.lastIndex = F), (S = m.exec(e)) ? ((F = m.lastIndex), (N = !1), yield { type: 'SingleLineComment', value: S[0] }) : ((F += (T = String.fromCodePoint(e.codePointAt(F))).length), (A = T), (N = !1), yield { type: v.tag.startsWith('JSX') ? 'JSXInvalid' : 'Invalid', value: T })))));
        }
       }));
     }),
     () => (n || s((n = { exports: {} }).exports, n), n.exports)),
    d = {};
   c(d, { __debug: () => Ys, check: () => Ks, doc: () => Ts, format: () => Xs, formatWithCursor: () => Hs, getSupportInfo: () => Gs, util: () => Ss, version: () => ws });
   var f =
     (e, t) =>
     (r, s, ...n) =>
      1 | r && null == s ? void 0 : (t.call(s) ?? s[e]).apply(s, n),
    m =
     String.prototype.replaceAll ??
     function (e, t) {
      return e.global ? this.replace(e, t) : this.split(e).join(t);
     },
    y = f('replaceAll', function () {
     if ('string' == typeof this) return m;
    }),
    D = class {
     diff(e, t, r = {}) {
      let s;
      'function' == typeof r ? ((s = r), (r = {})) : 'callback' in r && (s = r.callback);
      let n = this.castInput(e, r),
       i = this.castInput(t, r),
       a = this.removeEmpty(this.tokenize(n, r)),
       o = this.removeEmpty(this.tokenize(i, r));
      return this.diffWithOptionsObj(a, o, r, s);
     }
     diffWithOptionsObj(e, t, r, s) {
      var n;
      let i = (e) => (
        (e = this.postProcess(e, r)),
        s
         ? void setTimeout(function () {
            s(e);
           }, 0)
         : e
       ),
       a = t.length,
       o = e.length,
       u = 1,
       l = a + o;
      null != r.maxEditLength && (l = Math.min(l, r.maxEditLength));
      let p = null !== (n = r.timeout) && void 0 !== n ? n : 1 / 0,
       c = Date.now() + p,
       h = [{ oldPos: -1, lastComponent: void 0 }],
       d = this.extractCommon(h[0], t, e, 0, r);
      if (h[0].oldPos + 1 >= o && d + 1 >= a) return i(this.buildValues(h[0].lastComponent, t, e));
      let f = -1 / 0,
       m = 1 / 0,
       y = () => {
        for (let s = Math.max(f, -u); s <= Math.min(m, u); s += 2) {
         let n,
          u = h[s - 1],
          l = h[s + 1];
         u && (h[s - 1] = void 0);
         let p = !1;
         if (l) {
          let e = l.oldPos - s;
          p = l && 0 <= e && e < a;
         }
         let c = u && u.oldPos + 1 < o;
         if (p || c) {
          if (((n = !c || (p && u.oldPos < l.oldPos) ? this.addToPath(l, !0, !1, 0, r) : this.addToPath(u, !1, !0, 1, r)), (d = this.extractCommon(n, t, e, s, r)), n.oldPos + 1 >= o && d + 1 >= a)) return i(this.buildValues(n.lastComponent, t, e)) || !0;
          ((h[s] = n), n.oldPos + 1 >= o && (m = Math.min(m, s - 1)), d + 1 >= a && (f = Math.max(f, s + 1)));
         } else h[s] = void 0;
        }
        u++;
       };
      if (s)
       !(function e() {
        setTimeout(function () {
         if (u > l || Date.now() > c) return s(void 0);
         y() || e();
        }, 0);
       })();
      else
       for (; u <= l && Date.now() <= c; ) {
        let e = y();
        if (e) return e;
       }
     }
     addToPath(e, t, r, s, n) {
      let i = e.lastComponent;
      return i && !n.oneChangePerToken && i.added === t && i.removed === r ? { oldPos: e.oldPos + s, lastComponent: { count: i.count + 1, added: t, removed: r, previousComponent: i.previousComponent } } : { oldPos: e.oldPos + s, lastComponent: { count: 1, added: t, removed: r, previousComponent: i } };
     }
     extractCommon(e, t, r, s, n) {
      let i = t.length,
       a = r.length,
       o = e.oldPos,
       u = o - s,
       l = 0;
      for (; u + 1 < i && o + 1 < a && this.equals(r[o + 1], t[u + 1], n); ) (u++, o++, l++, n.oneChangePerToken && (e.lastComponent = { count: 1, previousComponent: e.lastComponent, added: !1, removed: !1 }));
      return (l && !n.oneChangePerToken && (e.lastComponent = { count: l, previousComponent: e.lastComponent, added: !1, removed: !1 }), (e.oldPos = o), u);
     }
     equals(e, t, r) {
      return r.comparator ? r.comparator(e, t) : e === t || (!!r.ignoreCase && e.toLowerCase() === t.toLowerCase());
     }
     removeEmpty(e) {
      let t = [];
      for (let r = 0; r < e.length; r++) e[r] && t.push(e[r]);
      return t;
     }
     castInput(e, t) {
      return e;
     }
     tokenize(e, t) {
      return Array.from(e);
     }
     join(e) {
      return e.join('');
     }
     postProcess(e, t) {
      return e;
     }
     get useLongestToken() {
      return !1;
     }
     buildValues(e, t, r) {
      let s,
       n = [];
      for (; e; ) (n.push(e), (s = e.previousComponent), delete e.previousComponent, (e = s));
      n.reverse();
      let i = n.length,
       a = 0,
       o = 0,
       u = 0;
      for (; a < i; a++) {
       let e = n[a];
       if (e.removed) ((e.value = this.join(r.slice(u, u + e.count))), (u += e.count));
       else {
        if (!e.added && this.useLongestToken) {
         let s = t.slice(o, o + e.count);
         ((s = s.map(function (e, t) {
          let s = r[u + t];
          return s.length > e.length ? s : e;
         })),
          (e.value = this.join(s)));
        } else e.value = this.join(t.slice(o, o + e.count));
        ((o += e.count), e.added || (u += e.count));
       }
      }
      return n;
     }
    },
    g = new (class extends D {
     tokenize(e) {
      return e.slice();
     }
     join(e) {
      return e;
     }
     removeEmpty(e) {
      return e;
     }
    })();
   var x = () => {},
    E = 'crlf',
    b = '\n',
    T = b;
   function C(e) {
    return 'cr' === e ? '\r' : e === E ? '\r\n' : T;
   }
   var F = new Map([
    [b, /\n/gu],
    ['\r', /\r/gu],
    ['\r\n', /\r\n/gu],
   ]);
   function A(e, t) {
    let r = F.get(t);
    return e.match(r)?.length ?? 0;
   }
   var w = /\r\n?/gu;
   function S(e) {
    return this[e < 0 ? this.length + e : e];
   }
   var v = f('at', function () {
     if (Array.isArray(this) || 'string' == typeof this) return S;
    }),
    P = 'string',
    k = 'array',
    I = 'cursor',
    N = 'indent',
    B = 'align',
    O = 'trim',
    L = 'group',
    M = 'fill',
    j = 'if-break',
    _ = 'indent-if-break',
    R = 'line-suffix',
    U = 'line-suffix-boundary',
    $ = 'line',
    q = 'label',
    J = 'break-parent',
    W = new Set([I, N, B, O, L, M, j, _, R, U, $, q, J]);
   var V = function (e) {
    if ('string' == typeof e) return P;
    if (Array.isArray(e)) return k;
    if (!e) return;
    let { type: t } = e;
    return W.has(t) ? t : void 0;
   };
   function z(e) {
    let t = null === e ? 'null' : typeof e;
    if ('string' !== t && 'object' !== t) return `Unexpected doc '${t}', \nExpected it to be 'string' or 'object'.`;
    if (V(e)) throw new Error('doc is valid.');
    let r = Object.prototype.toString.call(e);
    if ('[object Object]' !== r) return `Unexpected doc '${r}'.`;
    let s = ((e) => new Intl.ListFormat('en-US', { type: 'disjunction' }).format(e))([...W].map((e) => `'${e}'`));
    return `Unexpected doc.type '${e.type}'.\nExpected it to be ${s}.`;
   }
   var H = class extends Error {
     name = 'InvalidDocError';
     constructor(e) {
      (super(z(e)), (this.doc = e));
     }
    },
    X = H,
    K = {};
   var G = function (e, t, r, s) {
    let n = [e];
    for (; n.length > 0; ) {
     let e = n.pop();
     if (e === K) {
      r(n.pop());
      continue;
     }
     r && n.push(e, K);
     let i = V(e);
     if (!i) throw new X(e);
     if (!1 !== t?.(e))
      switch (i) {
       case k:
       case M: {
        let t = i === k ? e : e.parts;
        for (let e = t.length - 1; e >= 0; --e) n.push(t[e]);
        break;
       }
       case j:
        n.push(e.flatContents, e.breakContents);
        break;
       case L:
        if (s && e.expandedStates) for (let t = e.expandedStates.length - 1; t >= 0; --t) n.push(e.expandedStates[t]);
        else n.push(e.contents);
        break;
       case B:
       case N:
       case _:
       case q:
       case R:
        n.push(e.contents);
        break;
       case P:
       case I:
       case O:
       case U:
       case $:
       case J:
        break;
       default:
        throw new X(e);
      }
    }
   };
   function Y(e, t) {
    if ('string' == typeof e) return t(e);
    let r = new Map();
    return s(e);
    function s(e) {
     if (r.has(e)) return r.get(e);
     let n = (function (e) {
      switch (V(e)) {
       case k:
        return t(e.map(s));
       case M:
        return t({ ...e, parts: e.parts.map(s) });
       case j:
        return t({ ...e, breakContents: s(e.breakContents), flatContents: s(e.flatContents) });
       case L: {
        let { expandedStates: r, contents: n } = e;
        return (r ? ((r = r.map(s)), (n = r[0])) : (n = s(n)), t({ ...e, contents: n, expandedStates: r }));
       }
       case B:
       case N:
       case _:
       case q:
       case R:
        return t({ ...e, contents: s(e.contents) });
       case P:
       case I:
       case O:
       case U:
       case $:
       case J:
        return t(e);
       default:
        throw new X(e);
      }
     })(e);
     return (r.set(e, n), n);
    }
   }
   function Q(e, t, r) {
    let s = r,
     n = !1;
    return (
     G(e, function (e) {
      if (n) return !1;
      let r = t(e);
      void 0 !== r && ((n = !0), (s = r));
     }),
     s
    );
   }
   function Z(e) {
    if ((e.type === L && e.break) || (e.type === $ && e.hard) || e.type === J) return !0;
   }
   function ee(e) {
    if (e.length > 0) {
     let t = v(0, e, -1);
     !t.expandedStates && !t.break && (t.break = 'propagated');
    }
    return null;
   }
   function te(e) {
    return e.type !== $ || e.hard ? (e.type === j ? e.flatContents : e) : e.soft ? '' : ' ';
   }
   function re(e) {
    for (e = [...e]; e.length >= 2 && v(0, e, -2).type === $ && v(0, e, -1).type === J; ) e.length -= 2;
    if (e.length > 0) {
     let t = se(v(0, e, -1));
     e[e.length - 1] = t;
    }
    return e;
   }
   function se(e) {
    switch (V(e)) {
     case N:
     case _:
     case L:
     case R:
     case q: {
      let t = se(e.contents);
      return { ...e, contents: t };
     }
     case j:
      return { ...e, breakContents: se(e.breakContents), flatContents: se(e.flatContents) };
     case M:
      return { ...e, parts: re(e.parts) };
     case k:
      return re(e);
     case P:
      return (function (e) {
       let t = e.length;
       for (; t > 0 && ('\r' === e[t - 1] || '\n' === e[t - 1]); ) t--;
       return t < e.length ? e.slice(0, t) : e;
      })(e);
     case B:
     case I:
     case O:
     case U:
     case $:
     case J:
      break;
     default:
      throw new X(e);
    }
    return e;
   }
   function ne(e) {
    return se(
     (function (e) {
      return Y(e, (e) =>
       (function (e) {
        switch (V(e)) {
         case M:
          if (e.parts.every((e) => '' === e)) return '';
          break;
         case L:
          if (!(e.contents || e.id || e.break || e.expandedStates)) return '';
          if (e.contents.type === L && e.contents.id === e.id && e.contents.break === e.break && e.contents.expandedStates === e.expandedStates) return e.contents;
          break;
         case B:
         case N:
         case _:
         case R:
          if (!e.contents) return '';
          break;
         case j:
          if (!e.flatContents && !e.breakContents) return '';
          break;
         case k: {
          let t = [];
          for (let r of e) {
           if (!r) continue;
           let [e, ...s] = Array.isArray(r) ? r : [r];
           ('string' == typeof e && 'string' == typeof v(0, t, -1) ? (t[t.length - 1] += e) : t.push(e), t.push(...s));
          }
          return 0 === t.length ? '' : 1 === t.length ? t[0] : t;
         }
         case P:
         case I:
         case O:
         case U:
         case $:
         case q:
         case J:
          break;
         default:
          throw new X(e);
        }
        return e;
       })(e),
      );
     })(e),
    );
   }
   function ie(e) {
    if (e.type === $) return !0;
   }
   function ae(e, t) {
    return e.type === q ? { ...e, contents: t(e.contents) } : t(e);
   }
   var oe = x,
    ue = x,
    le = x,
    pe = x;
   function ce(e) {
    return (oe(e), { type: N, contents: e });
   }
   function he(e, t) {
    return (pe(e), oe(t), { type: B, contents: t, n: e });
   }
   function de(e) {
    return he({ type: 'root' }, e);
   }
   function fe(e, t, r) {
    oe(e);
    let s = e;
    if (t > 0) {
     for (let e = 0; e < Math.floor(t / r); ++e) s = ce(s);
     ((s = he(t % r, s)), (s = he(Number.NEGATIVE_INFINITY, s)));
    }
    return s;
   }
   var me = { type: J },
    ye = { type: I };
   function De(e, t = {}) {
    return (oe(e), ue(t.expandedStates, !0), { type: L, id: t.id, contents: e, break: !!t.shouldBreak, expandedStates: t.expandedStates });
   }
   function ge(e, t) {
    (oe(e), ue(t));
    let r = [];
    for (let s = 0; s < t.length; s++) (0 !== s && r.push(e), r.push(t[s]));
    return r;
   }
   var xe = { type: $ },
    Ee = { type: $, soft: !0 },
    be = { type: $, hard: !0 },
    Te = [be, me],
    Ce = { type: $, hard: !0, literal: !0 },
    Fe = [Ce, me];
   function Ae(e) {
    return (oe(e), { type: R, contents: e });
   }
   var we = { type: U },
    Se = { type: O };
   function ve(e) {
    if (!e) return '';
    if (Array.isArray(e)) {
     let t = [];
     for (let r of e)
      if (Array.isArray(r)) t.push(...ve(r));
      else {
       let e = ve(r);
       '' !== e && t.push(e);
      }
     return t;
    }
    return e.type === j ? { ...e, breakContents: ve(e.breakContents), flatContents: ve(e.flatContents) } : e.type === L ? { ...e, contents: ve(e.contents), expandedStates: e.expandedStates?.map(ve) } : e.type === M ? { type: 'fill', parts: e.parts.map(ve) } : e.contents ? { ...e, contents: ve(e.contents) } : e;
   }
   function Pe(e) {
    return 12288 === e || (e >= 65281 && e <= 65376) || (e >= 65504 && e <= 65510);
   }
   function ke(e) {
    return (e >= 4352 && e <= 4447) || 8986 === e || 8987 === e || 9001 === e || 9002 === e || (e >= 9193 && e <= 9196) || 9200 === e || 9203 === e || 9725 === e || 9726 === e || 9748 === e || 9749 === e || (e >= 9776 && e <= 9783) || (e >= 9800 && e <= 9811) || 9855 === e || (e >= 9866 && e <= 9871) || 9875 === e || 9889 === e || 9898 === e || 9899 === e || 9917 === e || 9918 === e || 9924 === e || 9925 === e || 9934 === e || 9940 === e || 9962 === e || 9970 === e || 9971 === e || 9973 === e || 9978 === e || 9981 === e || 9989 === e || 9994 === e || 9995 === e || 10024 === e || 10060 === e || 10062 === e || (e >= 10067 && e <= 10069) || 10071 === e || (e >= 10133 && e <= 10135) || 10160 === e || 10175 === e || 11035 === e || 11036 === e || 11088 === e || 11093 === e || (e >= 11904 && e <= 11929) || (e >= 11931 && e <= 12019) || (e >= 12032 && e <= 12245) || (e >= 12272 && e <= 12287) || (e >= 12289 && e <= 12350) || (e >= 12353 && e <= 12438) || (e >= 12441 && e <= 12543) || (e >= 12549 && e <= 12591) || (e >= 12593 && e <= 12686) || (e >= 12688 && e <= 12773) || (e >= 12783 && e <= 12830) || (e >= 12832 && e <= 12871) || (e >= 12880 && e <= 42124) || (e >= 42128 && e <= 42182) || (e >= 43360 && e <= 43388) || (e >= 44032 && e <= 55203) || (e >= 63744 && e <= 64255) || (e >= 65040 && e <= 65049) || (e >= 65072 && e <= 65106) || (e >= 65108 && e <= 65126) || (e >= 65128 && e <= 65131) || (e >= 94176 && e <= 94180) || (e >= 94192 && e <= 94198) || (e >= 94208 && e <= 101589) || (e >= 101631 && e <= 101662) || (e >= 101760 && e <= 101874) || (e >= 110576 && e <= 110579) || (e >= 110581 && e <= 110587) || 110589 === e || 110590 === e || (e >= 110592 && e <= 110882) || 110898 === e || (e >= 110928 && e <= 110930) || 110933 === e || (e >= 110948 && e <= 110951) || (e >= 110960 && e <= 111355) || (e >= 119552 && e <= 119638) || (e >= 119648 && e <= 119670) || 126980 === e || 127183 === e || 127374 === e || (e >= 127377 && e <= 127386) || (e >= 127488 && e <= 127490) || (e >= 127504 && e <= 127547) || (e >= 127552 && e <= 127560) || 127568 === e || 127569 === e || (e >= 127584 && e <= 127589) || (e >= 127744 && e <= 127776) || (e >= 127789 && e <= 127797) || (e >= 127799 && e <= 127868) || (e >= 127870 && e <= 127891) || (e >= 127904 && e <= 127946) || (e >= 127951 && e <= 127955) || (e >= 127968 && e <= 127984) || 127988 === e || (e >= 127992 && e <= 128062) || 128064 === e || (e >= 128066 && e <= 128252) || (e >= 128255 && e <= 128317) || (e >= 128331 && e <= 128334) || (e >= 128336 && e <= 128359) || 128378 === e || 128405 === e || 128406 === e || 128420 === e || (e >= 128507 && e <= 128591) || (e >= 128640 && e <= 128709) || 128716 === e || (e >= 128720 && e <= 128722) || (e >= 128725 && e <= 128728) || (e >= 128732 && e <= 128735) || 128747 === e || 128748 === e || (e >= 128756 && e <= 128764) || (e >= 128992 && e <= 129003) || 129008 === e || (e >= 129292 && e <= 129338) || (e >= 129340 && e <= 129349) || (e >= 129351 && e <= 129535) || (e >= 129648 && e <= 129660) || (e >= 129664 && e <= 129674) || (e >= 129678 && e <= 129734) || 129736 === e || (e >= 129741 && e <= 129756) || (e >= 129759 && e <= 129770) || (e >= 129775 && e <= 129784) || (e >= 131072 && e <= 196605) || (e >= 196608 && e <= 262141);
   }
   var Ie = /[^\x20-\x7F]/u,
    Ne = new Set('\xa9\xae\u203c\u2049\u2122\u2139\u2194\u2195\u2196\u2197\u2198\u2199\u21a9\u21aa\u2328\u23cf\u23f1\u23f2\u23f8\u23f9\u23fa\u25aa\u25ab\u25b6\u25c0\u25fb\u25fc\u2600\u2601\u2602\u2603\u2604\u260e\u2611\u2618\u261d\u2620\u2622\u2623\u2626\u262a\u262e\u262f\u2638\u2639\u263a\u2640\u2642\u265f\u2660\u2663\u2665\u2666\u2668\u267b\u267e\u2692\u2694\u2695\u2696\u2697\u2699\u269b\u269c\u26a0\u26a7\u26b0\u26b1\u26c8\u26cf\u26d1\u26d3\u26e9\u26f1\u26f7\u26f8\u26f9\u2702\u2708\u2709\u270c\u270d\u270f\u2712\u2714\u2716\u271d\u2721\u2733\u2734\u2744\u2747\u2763\u2764\u27a1\u2934\u2935\u2b05\u2b06\u2b07');
   var Be = function (e) {
     if (!e) return 0;
     if (!Ie.test(e)) return e.length;
     e = e.replace(/[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E-\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED8\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])|\uD83E(?:[\uDD1D\uDEEF]\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE]|[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFC-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFE])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE]|\uDEEF\u200D\uD83D\uDC69\uD83C[\uDFFB-\uDFFE])))?))?|\uDD75(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3C-\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE8A\uDE8E-\uDEC2\uDEC6\uDEC8\uDECD-\uDEDC\uDEDF-\uDEEA\uDEEF]|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC30\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE])|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3\uDE70]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF]|\uDEEF\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g, (e) => (Ne.has(e) ? ' ' : '  '));
     let t = 0;
     for (let r of e) {
      let e = r.codePointAt(0);
      e <= 31 || (e >= 127 && e <= 159) || (e >= 768 && e <= 879) || (e >= 65024 && e <= 65039) || (t += Pe(e) || ke(e) ? 2 : 1);
     }
     return t;
    },
    Oe = { type: 0 },
    Le = { type: 1 },
    Me = {
     value: '',
     length: 0,
     queue: [],
     get root() {
      return Me;
     },
    };
   function je(e, t, r) {
    let s = 1 === t.type ? e.queue.slice(0, -1) : [...e.queue, t],
     n = '',
     i = 0,
     a = 0,
     o = 0;
    for (let d of s)
     switch (d.type) {
      case 0:
       (p(), r.useTabs ? u(1) : l(r.tabWidth));
       break;
      case 3: {
       let { string: e } = d;
       (p(), (n += e), (i += e.length));
       break;
      }
      case 2: {
       let { width: e } = d;
       ((a += 1), (o += e));
       break;
      }
      default:
       throw new Error(`Unexpected indent comment '${d.type}'.`);
     }
    return (c(), { ...e, value: n, length: i, queue: s });
    function u(e) {
     ((n += '\t'.repeat(e)), (i += r.tabWidth * e));
    }
    function l(e) {
     ((n += ' '.repeat(e)), (i += e));
    }
    function p() {
     r.useTabs ? (a > 0 && u(a), h()) : c();
    }
    function c() {
     (o > 0 && l(o), h());
    }
    function h() {
     ((a = 0), (o = 0));
    }
   }
   function _e(e, t, r) {
    if (!t) return e;
    if ('root' === t.type) return { ...e, root: e };
    if (t === Number.NEGATIVE_INFINITY) return e.root;
    let s;
    return ((s = 'number' == typeof t ? (t < 0 ? Le : { type: 2, width: t }) : { type: 3, string: t }), je(e, s, r));
   }
   function Re(e, t) {
    return je(e, Oe, t);
   }
   function Ue(e) {
    let t = (function (e) {
     let t = 0;
     for (let r = e.length - 1; r >= 0; r--) {
      let s = e[r];
      if (' ' !== s && '\t' !== s) break;
      t++;
     }
     return t;
    })(e);
    return { text: 0 === t ? e : e.slice(0, e.length - t), count: t };
   }
   var $e = Symbol('MODE_BREAK'),
    qe = Symbol('MODE_FLAT'),
    Je = Symbol('DOC_FILL_PRINTED_LENGTH');
   function We(e, t, r, s, n, i) {
    if (r === Number.POSITIVE_INFINITY) return !0;
    let a = t.length,
     o = !1,
     u = [e],
     l = '';
    for (; r >= 0; ) {
     if (0 === u.length) {
      if (0 === a) return !0;
      u.push(t[--a]);
      continue;
     }
     let { mode: e, doc: p } = u.pop(),
      c = V(p);
     switch (c) {
      case P:
       p && (o && ((l += ' '), (r -= 1), (o = !1)), (l += p), (r -= Be(p)));
       break;
      case k:
      case M: {
       let t = c === k ? p : p.parts,
        r = p[Je] ?? 0;
       for (let s = t.length - 1; s >= r; s--) u.push({ mode: e, doc: t[s] });
       break;
      }
      case N:
      case B:
      case _:
      case q:
       u.push({ mode: e, doc: p.contents });
       break;
      case O: {
       let { text: e, count: t } = Ue(l);
       ((l = e), (r += t));
       break;
      }
      case L: {
       if (i && p.break) return !1;
       let t = p.break ? $e : e,
        r = p.expandedStates && t === $e ? v(0, p.expandedStates, -1) : p.contents;
       u.push({ mode: t, doc: r });
       break;
      }
      case j: {
       let t = (p.groupId ? n[p.groupId] || qe : e) === $e ? p.breakContents : p.flatContents;
       t && u.push({ mode: e, doc: t });
       break;
      }
      case $:
       if (e === $e || p.hard) return !0;
       p.soft || (o = !0);
       break;
      case R:
       s = !0;
       break;
      case U:
       if (s) return !1;
     }
    }
    return !1;
   }
   function Ve(e, t) {
    let r = Object.create(null),
     s = t.printWidth,
     n = C(t.endOfLine),
     i = 0,
     a = [{ indent: Me, mode: $e, doc: e }],
     o = '',
     u = !1,
     l = [],
     p = [],
     c = [],
     h = [],
     d = 0;
    for (
     (function (e) {
      let t = new Set(),
       r = [];
      G(
       e,
       function (e) {
        if ((e.type === J && ee(r), e.type === L)) {
         if ((r.push(e), t.has(e))) return !1;
         t.add(e);
        }
       },
       function (e) {
        e.type === L && r.pop().break && ee(r);
       },
       !0,
      );
     })(e);
     a.length > 0;
    ) {
     let { indent: e, mode: c, doc: h } = a.pop();
     switch (V(h)) {
      case P: {
       let e = '\n' !== n ? y(0, h, '\n', n) : h;
       e && ((o += e), a.length > 0 && (i += Be(e)));
       break;
      }
      case k:
       for (let t = h.length - 1; t >= 0; t--) a.push({ indent: e, mode: c, doc: h[t] });
       break;
      case I:
       if (p.length >= 2) throw new Error("There are too many 'cursor' in doc.");
       p.push(d + o.length);
       break;
      case N:
       a.push({ indent: Re(e, t), mode: c, doc: h.contents });
       break;
      case B:
       a.push({ indent: _e(e, h.n, t), mode: c, doc: h.contents });
       break;
      case O:
       g();
       break;
      case L:
       switch (c) {
        case qe:
         if (!u) {
          a.push({ indent: e, mode: h.break ? $e : qe, doc: h.contents });
          break;
         }
        case $e: {
         u = !1;
         let t = { indent: e, mode: qe, doc: h.contents },
          n = s - i,
          o = l.length > 0;
         if (!h.break && We(t, a, n, o, r)) a.push(t);
         else if (h.expandedStates) {
          let t = v(0, h.expandedStates, -1);
          if (h.break) {
           a.push({ indent: e, mode: $e, doc: t });
           break;
          }
          for (let s = 1; s < h.expandedStates.length + 1; s++) {
           if (s >= h.expandedStates.length) {
            a.push({ indent: e, mode: $e, doc: t });
            break;
           }
           {
            let t = h.expandedStates[s],
             i = { indent: e, mode: qe, doc: t };
            if (We(i, a, n, o, r)) {
             a.push(i);
             break;
            }
           }
          }
         } else a.push({ indent: e, mode: $e, doc: h.contents });
         break;
        }
       }
       h.id && (r[h.id] = v(0, a, -1).mode);
       break;
      case M: {
       let t = s - i,
        n = h[Je] ?? 0,
        { parts: o } = h,
        u = o.length - n;
       if (0 === u) break;
       let p = o[n + 0],
        d = o[n + 1],
        f = { indent: e, mode: qe, doc: p },
        m = { indent: e, mode: $e, doc: p },
        y = We(f, [], t, l.length > 0, r, !0);
       if (1 === u) {
        y ? a.push(f) : a.push(m);
        break;
       }
       let D = { indent: e, mode: qe, doc: d },
        g = { indent: e, mode: $e, doc: d };
       if (2 === u) {
        y ? a.push(D, f) : a.push(g, m);
        break;
       }
       let x = o[n + 2],
        E = { indent: e, mode: c, doc: { ...h, [Je]: n + 2 } },
        b = We({ indent: e, mode: qe, doc: [p, d, x] }, [], t, l.length > 0, r, !0);
       (a.push(E), b ? a.push(D, f) : y ? a.push(g, f) : a.push(g, m));
       break;
      }
      case j:
      case _: {
       let t = h.groupId ? r[h.groupId] : c;
       if (t === $e) {
        let t = h.type === j ? h.breakContents : h.negate ? h.contents : ce(h.contents);
        t && a.push({ indent: e, mode: c, doc: t });
       }
       if (t === qe) {
        let t = h.type === j ? h.flatContents : h.negate ? ce(h.contents) : h.contents;
        t && a.push({ indent: e, mode: c, doc: t });
       }
       break;
      }
      case R:
       l.push({ indent: e, mode: c, doc: h.contents });
       break;
      case U:
       l.length > 0 && a.push({ indent: e, mode: c, doc: be });
       break;
      case $:
       switch (c) {
        case qe:
         if (!h.hard) {
          h.soft || ((o += ' '), (i += 1));
          break;
         }
         u = !0;
        case $e:
         if (l.length > 0) {
          (a.push({ indent: e, mode: c, doc: h }, ...l.reverse()), (l.length = 0));
          break;
         }
         h.literal ? ((o += n), (i = 0), e.root && (e.root.value && (o += e.root.value), (i = e.root.length))) : (g(), (o += n + e.value), (i = e.length));
       }
       break;
      case q:
       a.push({ indent: e, mode: c, doc: h.contents });
       break;
      case J:
       break;
      default:
       throw new X(h);
     }
     0 === a.length && l.length > 0 && (a.push(...l.reverse()), (l.length = 0));
    }
    let f = c.join('') + o,
     m = [...h, ...p];
    if (2 !== m.length) return { formatted: f };
    let D = m[0];
    return { formatted: f, cursorNodeStart: D, cursorNodeText: f.slice(D, v(0, m, -1)) };
    function g() {
     let { text: e, count: t } = Ue(o);
     (e && (c.push(e), (d += e.length)), (o = ''), (i -= t), p.length > 0 && (h.push(...p.map((e) => Math.min(e, d))), (p.length = 0)));
    }
   }
   var ze = function (e, t, r = 0) {
     let s = 0;
     for (let n = r; n < e.length; ++n) '\t' === e[n] ? (s = s + t - (s % t)) : s++;
     return s;
    },
    He = class {
     constructor(e) {
      this.stack = [e];
     }
     get key() {
      let { stack: e, siblings: t } = this;
      return v(0, e, null === t ? -2 : -4) ?? null;
     }
     get index() {
      return null === this.siblings ? null : v(0, this.stack, -2);
     }
     get node() {
      return v(0, this.stack, -1);
     }
     get parent() {
      return this.getNode(1);
     }
     get grandparent() {
      return this.getNode(2);
     }
     get isInArray() {
      return null !== this.siblings;
     }
     get siblings() {
      let { stack: e } = this,
       t = v(0, e, -3);
      return Array.isArray(t) ? t : null;
     }
     get next() {
      let { siblings: e } = this;
      return null === e ? null : e[this.index + 1];
     }
     get previous() {
      let { siblings: e } = this;
      return null === e ? null : e[this.index - 1];
     }
     get isFirst() {
      return 0 === this.index;
     }
     get isLast() {
      let { siblings: e, index: t } = this;
      return null !== e && t === e.length - 1;
     }
     get isRoot() {
      return 1 === this.stack.length;
     }
     get root() {
      return this.stack[0];
     }
     get ancestors() {
      return [...this.#e()];
     }
     getName() {
      let { stack: e } = this,
       { length: t } = e;
      return t > 1 ? v(0, e, -2) : null;
     }
     getValue() {
      return v(0, this.stack, -1);
     }
     getNode(e = 0) {
      let t = this.#t(e);
      return -1 === t ? null : this.stack[t];
     }
     getParentNode(e = 0) {
      return this.getNode(e + 1);
     }
     #t(e) {
      let { stack: t } = this;
      for (let r = t.length - 1; r >= 0; r -= 2) if (!Array.isArray(t[r]) && --e < 0) return r;
      return -1;
     }
     call(e, ...t) {
      let { stack: r } = this,
       { length: s } = r,
       n = v(0, r, -1);
      for (let i of t) ((n = n?.[i]), r.push(i, n));
      try {
       return e(this);
      } finally {
       r.length = s;
      }
     }
     callParent(e, t = 0) {
      let r = this.#t(t + 1),
       s = this.stack.splice(r + 1);
      try {
       return e(this);
      } finally {
       this.stack.push(...s);
      }
     }
     each(e, ...t) {
      let { stack: r } = this,
       { length: s } = r,
       n = v(0, r, -1);
      for (let i of t) ((n = n[i]), r.push(i, n));
      try {
       for (let t = 0; t < n.length; ++t) (r.push(t, n[t]), e(this, t, n), (r.length -= 2));
      } finally {
       r.length = s;
      }
     }
     map(e, ...t) {
      let r = [];
      return (
       this.each(
        (t, s, n) => {
         r[s] = e(t, s, n);
        },
        ...t,
       ),
       r
      );
     }
     match(...e) {
      let t = this.stack.length - 1,
       r = null,
       s = this.stack[t--];
      for (let n of e) {
       if (void 0 === s) return !1;
       let e = null;
       if (('number' == typeof r && ((e = r), (r = this.stack[t--]), (s = this.stack[t--])), n && !n(s, r, e))) return !1;
       ((r = this.stack[t--]), (s = this.stack[t--]));
      }
      return !0;
     }
     findAncestor(e) {
      for (let t of this.#e()) if (e(t)) return t;
     }
     hasAncestor(e) {
      for (let t of this.#e()) if (e(t)) return !0;
      return !1;
     }
     *#e() {
      let { stack: e } = this;
      for (let t = e.length - 3; t >= 0; t -= 2) {
       let r = e[t];
       Array.isArray(r) || (yield r);
      }
     }
    };
   var Xe = function (e) {
    return null !== e && 'object' == typeof e;
   };
   function Ke(e) {
    return (t, r, s) => {
     let n = !!s?.backwards;
     if (!1 === r) return !1;
     let { length: i } = t,
      a = r;
     for (; a >= 0 && a < i; ) {
      let r = t.charAt(a);
      if (e instanceof RegExp) {
       if (!e.test(r)) return a;
      } else if (!e.includes(r)) return a;
      n ? a-- : a++;
     }
     return (-1 === a || a === i) && a;
    };
   }
   var Ge = Ke(/\s/u),
    Ye = Ke(' \t'),
    Qe = Ke(',; \t'),
    Ze = Ke(/[^\n\r]/u),
    et = (e) => '\n' === e || '\r' === e || '\u2028' === e || '\u2029' === e;
   var tt = function (e, t, r) {
    let s = !!r?.backwards;
    if (!1 === t) return !1;
    let n = e.charAt(t);
    if (s) {
     if ('\r' === e.charAt(t - 1) && '\n' === n) return t - 2;
     if (et(n)) return t - 1;
    } else {
     if ('\r' === n && '\n' === e.charAt(t + 1)) return t + 2;
     if (et(n)) return t + 1;
    }
    return t;
   };
   var rt = function (e, t, r = {}) {
    let s = Ye(e, r.backwards ? t - 1 : t, r);
    return s !== tt(e, s, r);
   };
   var st = function (e) {
    return Array.isArray(e) && e.length > 0;
   };
   function* nt(e, t) {
    let { getVisitorKeys: r, filter: s = () => !0 } = t,
     n = (e) => Xe(e) && s(e);
    for (let i of r(e)) {
     let t = e[i];
     if (Array.isArray(t)) for (let e of t) n(e) && (yield e);
     else n(t) && (yield t);
    }
   }
   var it = function e(t, r, s) {
    let { cache: n } = s;
    if (n.has(t)) return n.get(t);
    let { filter: i } = s;
    if (!i) return [];
    let a,
     o = (s.getChildren?.(t, s) ?? [...nt(t, { getVisitorKeys: s.getVisitorKeys })]).flatMap((n) => (a ?? (a = [t, ...r]), i(n, a) ? [n] : e(n, a, s))),
     { locStart: u, locEnd: l } = s;
    return (o.sort((e, t) => u(e) - u(t) || l(e) - l(t)), n.set(t, o), o);
   };
   function at(e, t) {
    ((e.comments ?? (e.comments = [])).push(t),
     (t.printed = !1),
     (t.nodeDescription = (function (e) {
      let t = e.type || e.kind || '(unknown type)',
       r = String(e.name || (e.id && ('object' == typeof e.id ? e.id.name : e.id)) || (e.key && ('object' == typeof e.key ? e.key.name : e.key)) || (e.value && ('object' == typeof e.value ? '' : String(e.value))) || e.operator || '');
      return (r.length > 20 && (r = r.slice(0, 19) + '\u2026'), t + (r ? ' ' + r : ''));
     })(e)));
   }
   function ot(e, t) {
    ((t.leading = !0), (t.trailing = !1), at(e, t));
   }
   function ut(e, t, r) {
    ((t.leading = !1), (t.trailing = !1), r && (t.marker = r), at(e, t));
   }
   function lt(e, t) {
    ((t.leading = !1), (t.trailing = !0), at(e, t));
   }
   var pt = new WeakMap();
   function ct(e, t, r, s, n = []) {
    let i,
     a,
     { locStart: o, locEnd: u } = r,
     l = o(t),
     p = u(t),
     c = it(e, n, { cache: pt, locStart: o, locEnd: u, getVisitorKeys: r.getVisitorKeys, filter: r.printer.canAttachComment, getChildren: r.printer.getCommentChildNodes }),
     h = 0,
     d = c.length;
    for (; h < d; ) {
     let e = (h + d) >> 1,
      s = c[e],
      f = o(s),
      m = u(s);
     if (f <= l && p <= m) return ct(s, t, r, s, [s, ...n]);
     if (m <= l) ((i = s), (h = e + 1));
     else {
      if (!(p <= f)) throw new Error('Comment location overlaps with node location');
      ((a = s), (d = e));
     }
    }
    if ('TemplateLiteral' === s?.type) {
     let { quasis: e } = s,
      n = Dt(e, t, r);
     (i && Dt(e, i, r) !== n && (i = null), a && Dt(e, a, r) !== n && (a = null));
    }
    return { enclosingNode: s, precedingNode: i, followingNode: a };
   }
   var ht = () => !1;
   var dt = (e) => !/[\S\n\u2028\u2029]/u.test(e);
   function ft(e, t, r, s) {
    let { comment: n, precedingNode: i } = r[s],
     { locStart: a, locEnd: o } = t,
     u = a(n);
    if (i)
     for (let l = s - 1; l >= 0; l--) {
      let { comment: t, precedingNode: s } = r[l];
      if (s !== i || !dt(e.slice(o(t), u))) break;
      u = a(t);
     }
    return rt(e, u, { backwards: !0 });
   }
   function mt(e, t, r, s) {
    let { comment: n, followingNode: i } = r[s],
     { locStart: a, locEnd: o } = t,
     u = o(n);
    if (i)
     for (let l = s + 1; l < r.length; l++) {
      let { comment: t, followingNode: s } = r[l];
      if (s !== i || !dt(e.slice(u, a(t)))) break;
      u = o(t);
     }
    return rt(e, u);
   }
   function yt(e, t) {
    let r = e.length;
    if (0 === r) return;
    let s,
     { precedingNode: n, followingNode: i } = e[0],
     a = t.locStart(i);
    for (s = r; s > 0; --s) {
     let { comment: r, precedingNode: o, followingNode: u } = e[s - 1];
     (x(o, n), x(u, i));
     let l = t.originalText.slice(t.locEnd(r), a);
     if (!(t.printer.isGap?.(l, t) ?? /^[\s(]*$/u.test(l))) break;
     a = t.locStart(r);
    }
    for (let [o, { comment: u }] of e.entries()) o < s ? lt(n, u) : ot(i, u);
    for (let o of [n, i]) o.comments && o.comments.length > 1 && o.comments.sort((e, r) => t.locStart(e) - t.locStart(r));
    e.length = 0;
   }
   function Dt(e, t, r) {
    let s = r.locStart(t) - 1;
    for (let n = 1; n < e.length; ++n) if (s < r.locStart(e[n])) return n - 1;
    return 0;
   }
   var gt = function (e, t) {
    let r = t - 1;
    return ((r = Ye(e, r, { backwards: !0 })), (r = tt(e, r, { backwards: !0 })), (r = Ye(e, r, { backwards: !0 })), r !== tt(e, r, { backwards: !0 }));
   };
   function xt(e, t) {
    return ((e.node.printed = !0), t.printer.printComment(e, t));
   }
   function Et(e, t) {
    let r = e.node;
    if (!r) return {};
    let s = t[Symbol.for('printedComments')];
    if (0 === (r.comments || []).filter((e) => !s.has(e)).length) return { leading: '', trailing: '' };
    let n,
     i = [],
     a = [];
    return (
     e.each(() => {
      let r = e.node;
      if (s?.has(r)) return;
      let { leading: o, trailing: u } = r;
      o
       ? i.push(
          (function (e, t) {
           let r = e.node,
            s = [xt(e, t)],
            { printer: n, originalText: i, locStart: a, locEnd: o } = t;
           if (n.isBlockComment?.(r)) {
            let e = rt(i, o(r)) ? (rt(i, a(r), { backwards: !0 }) ? Te : xe) : ' ';
            s.push(e);
           } else s.push(Te);
           let u = tt(i, Ye(i, o(r)));
           return (!1 !== u && rt(i, u) && s.push(Te), s);
          })(e, t),
         )
       : u &&
         ((n = (function (e, t, r) {
          let s = e.node,
           n = xt(e, t),
           { printer: i, originalText: a, locStart: o } = t,
           u = i.isBlockComment?.(s);
          if ((r?.hasLineSuffix && !r?.isBlock) || rt(a, o(s), { backwards: !0 })) {
           let e = gt(a, o(s));
           return { doc: Ae([Te, e ? Te : '', n]), isBlock: u, hasLineSuffix: !0 };
          }
          return !u || r?.hasLineSuffix ? { doc: [Ae([' ', n]), me], isBlock: u, hasLineSuffix: !0 } : { doc: [' ', n], isBlock: u, hasLineSuffix: !1 };
         })(e, t, n)),
         a.push(n.doc));
     }, 'comments'),
     { leading: i, trailing: a }
    );
   }
   var bt = class extends Error {
     name = 'ConfigError';
    },
    Tt = class extends Error {
     name = 'UndefinedParserError';
    },
    Ct = {
     checkIgnorePragma: { category: 'Special', type: 'boolean', default: !1, description: "Check whether the file's first docblock comment contains '@noprettier' or '@noformat' to determine if it should be formatted.", cliCategory: 'Other' },
     cursorOffset: { category: 'Special', type: 'int', default: -1, range: { start: -1, end: 1 / 0, step: 1 }, description: 'Print (to stderr) where a cursor at the given position would move to after formatting.', cliCategory: 'Editor' },
     endOfLine: {
      category: 'Global',
      type: 'choice',
      default: 'lf',
      description: 'Which end of line characters to apply.',
      choices: [
       { value: 'lf', description: 'Line Feed only (\\n), common on Linux and macOS as well as inside git repos' },
       { value: 'crlf', description: 'Carriage Return + Line Feed characters (\\r\\n), common on Windows' },
       { value: 'cr', description: 'Carriage Return character only (\\r), used very rarely' },
       { value: 'auto', description: "Maintain existing\n(mixed values within one file are normalised by looking at what's used after the first line)" },
      ],
     },
     filepath: { category: 'Special', type: 'path', description: 'Specify the input filepath. This will be used to do parser inference.', cliName: 'stdin-filepath', cliCategory: 'Other', cliDescription: 'Path to the file to pretend that stdin comes from.' },
     insertPragma: { category: 'Special', type: 'boolean', default: !1, description: "Insert @format pragma into file's first docblock comment.", cliCategory: 'Other' },
     parser: {
      category: 'Global',
      type: 'choice',
      default: void 0,
      description: 'Which parser to use.',
      exception: (e) => 'string' == typeof e || 'function' == typeof e,
      choices: [
       { value: 'flow', description: 'Flow' },
       { value: 'babel', description: 'JavaScript' },
       { value: 'babel-flow', description: 'Flow' },
       { value: 'babel-ts', description: 'TypeScript' },
       { value: 'typescript', description: 'TypeScript' },
       { value: 'acorn', description: 'JavaScript' },
       { value: 'espree', description: 'JavaScript' },
       { value: 'meriyah', description: 'JavaScript' },
       { value: 'css', description: 'CSS' },
       { value: 'less', description: 'Less' },
       { value: 'scss', description: 'SCSS' },
       { value: 'json', description: 'JSON' },
       { value: 'json5', description: 'JSON5' },
       { value: 'jsonc', description: 'JSON with Comments' },
       { value: 'json-stringify', description: 'JSON.stringify' },
       { value: 'graphql', description: 'GraphQL' },
       { value: 'markdown', description: 'Markdown' },
       { value: 'mdx', description: 'MDX' },
       { value: 'vue', description: 'Vue' },
       { value: 'yaml', description: 'YAML' },
       { value: 'glimmer', description: 'Ember / Handlebars' },
       { value: 'html', description: 'HTML' },
       { value: 'angular', description: 'Angular' },
       { value: 'lwc', description: 'Lightning Web Components' },
       { value: 'mjml', description: 'MJML' },
      ],
     },
     plugins: { type: 'path', array: !0, default: [{ value: [] }], category: 'Global', description: 'Add a plugin. Multiple plugins can be passed as separate `--plugin`s.', exception: (e) => 'string' == typeof e || 'object' == typeof e, cliName: 'plugin', cliCategory: 'Config' },
     printWidth: { category: 'Global', type: 'int', default: 80, description: 'The line length where Prettier will try wrap.', range: { start: 0, end: 1 / 0, step: 1 } },
     rangeEnd: { category: 'Special', type: 'int', default: 1 / 0, range: { start: 0, end: 1 / 0, step: 1 }, description: 'Format code ending at a given character offset (exclusive).\nThe range will extend forwards to the end of the selected statement.', cliCategory: 'Editor' },
     rangeStart: { category: 'Special', type: 'int', default: 0, range: { start: 0, end: 1 / 0, step: 1 }, description: 'Format code starting at a given character offset.\nThe range will extend backwards to the start of the first line containing the selected statement.', cliCategory: 'Editor' },
     requirePragma: { category: 'Special', type: 'boolean', default: !1, description: "Require either '@prettier' or '@format' to be present in the file's first docblock comment in order for it to be formatted.", cliCategory: 'Other' },
     tabWidth: { type: 'int', category: 'Global', default: 2, description: 'Number of spaces per indentation level.', range: { start: 0, end: 1 / 0, step: 1 } },
     useTabs: { category: 'Global', type: 'boolean', default: !1, description: 'Indent with tabs instead of spaces.' },
     embeddedLanguageFormatting: {
      category: 'Global',
      type: 'choice',
      default: 'auto',
      description: 'Control how Prettier formats quoted code embedded in the file.',
      choices: [
       { value: 'auto', description: 'Format embedded code if Prettier can automatically identify it.' },
       { value: 'off', description: 'Never automatically format embedded code.' },
      ],
     },
    };
   function Ft({ plugins: e = [], showDeprecated: t = !1 } = {}) {
    let r = e.flatMap((e) => e.languages ?? []),
     s = [];
    for (let n of (function (e) {
     let t = [];
     for (let [r, s] of Object.entries(e)) {
      let e = { name: r, ...s };
      (Array.isArray(e.default) && (e.default = v(0, e.default, -1).value), t.push(e));
     }
     return t;
    })(Object.assign({}, ...e.map(({ options: e }) => e), Ct)))
     (!t && n.deprecated) || (Array.isArray(n.choices) && (t || (n.choices = n.choices.filter((e) => !e.deprecated)), 'parser' === n.name && (n.choices = [...n.choices, ...At(n.choices, r, e)])), (n.pluginDefaults = Object.fromEntries(e.filter((e) => void 0 !== e.defaultOptions?.[n.name]).map((e) => [e.name, e.defaultOptions[n.name]]))), s.push(n));
    return { languages: r, options: s };
   }
   function* At(e, t, r) {
    let s = new Set(e.map((e) => e.value));
    for (let n of t)
     if (n.parsers)
      for (let e of n.parsers)
       if (!s.has(e)) {
        s.add(e);
        let t = r.find((t) => t.parsers && Object.prototype.hasOwnProperty.call(t.parsers, e)),
         i = n.name;
        (t?.name && (i += ` (plugin: ${t.name})`), yield { value: e, description: i });
       }
   }
   var wt =
     Array.prototype.toReversed ??
     function () {
      return [...this].reverse();
     },
    St = f('toReversed', function () {
     if (Array.isArray(this)) return wt;
    });
   var vt = (function () {
    let e = globalThis,
     t = e.Deno?.build?.os;
    return 'string' == typeof t ? 'windows' === t : (e.navigator?.platform?.startsWith('Win') ?? e.process?.platform?.startsWith('win') ?? !1);
   })();
   function Pt(e) {
    if ('file:' !== (e = e instanceof URL ? e : new URL(e)).protocol) throw new TypeError(`URL must be a file URL: received "${e.protocol}"`);
    return e;
   }
   function kt(e) {
    return vt
     ? (function (e) {
        e = Pt(e);
        let t = decodeURIComponent(e.pathname.replace(/\//g, '\\').replace(/%(?![0-9A-Fa-f]{2})/g, '%25')).replace(/^\\*([A-Za-z]:)(\\|$)/, '$1\\');
        return ('' !== e.hostname && (t = `\\\\${e.hostname}${t}`), t);
       })(e)
     : (function (e) {
        return ((e = Pt(e)), decodeURIComponent(e.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, '%25')));
       })(e);
   }
   function It(e, t) {
    if (!t) return;
    let r = ((e) => String(e).split(/[/\\]/u).pop())(t).toLowerCase();
    return e.find(({ filenames: e }) => e?.some((e) => e.toLowerCase() === r)) ?? e.find(({ extensions: e }) => e?.some((e) => r.endsWith(e)));
   }
   function Nt(e, t) {
    if (t) {
     if (((e) => String(e).startsWith('file:'))(t))
      try {
       t = kt(t);
      } catch {
       return;
      }
     if ('string' == typeof t) return e.find(({ isSupported: e }) => e?.({ filepath: t }));
    }
   }
   var Bt = function (e, t) {
     let r = St(0, e.plugins).flatMap((e) => e.languages ?? []);
     return (
      (function (e, t) {
       if (t) return e.find(({ name: e }) => e.toLowerCase() === t) ?? e.find(({ aliases: e }) => e?.includes(t)) ?? e.find(({ extensions: e }) => e?.includes(`.${t}`));
      })(r, t.language) ??
      It(r, t.physicalFile) ??
      It(r, t.file) ??
      Nt(r, t.physicalFile) ??
      Nt(r, t.file) ??
      undefined
     )?.parsers[0];
    },
    Ot = {
     key: (e) => (/^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(e) ? e : JSON.stringify(e)),
     value(e) {
      if (null === e || 'object' != typeof e) return JSON.stringify(e);
      if (Array.isArray(e)) return `[${e.map((e) => Ot.value(e)).join(', ')}]`;
      let t = Object.keys(e);
      return 0 === t.length ? '{}' : `{ ${t.map((t) => `${Ot.key(t)}: ${Ot.value(e[t])}`).join(', ')} }`;
     },
     pair: ({ key: e, value: t }) => Ot.value({ [e]: t }),
    },
    Lt = new Proxy(String, { get: () => Lt }),
    Mt = Lt,
    jt = () => Lt,
    _t = Symbol.for('vnopts.VALUE_NOT_EXIST'),
    Rt = Symbol.for('vnopts.VALUE_UNCHANGED'),
    Ut = ' '.repeat(2);
   function $t(e, t, r, s) {
    return [`Invalid ${Mt.red(s.key(e))} value.`, `Expected ${Mt.blue(r)},`, `but received ${t === _t ? Mt.gray('nothing') : Mt.red(s.value(t))}.`].join(' ');
   }
   function qt({ text: e, list: t }, r) {
    let s = [];
    return (e && s.push(`- ${Mt.blue(e)}`), t && s.push([`- ${Mt.blue(t.title)}:`].concat(t.values.map((e) => qt(e, r - Ut.length).replace(/^|\n/g, `$&${Ut}`))).join('\n')), Jt(s, r));
   }
   function Jt(e, t) {
    if (1 === e.length) return e[0];
    let [r, s] = e,
     [n, i] = e.map((e) => e.split('\n', 1)[0].length);
    return n > t && n > i ? s : r;
   }
   var Wt = [],
    Vt = [];
   function zt(e, t, r) {
    if (e === t) return 0;
    let s = r?.maxDistance,
     n = e;
    e.length > t.length && ((e = t), (t = n));
    let i = e.length,
     a = t.length;
    for (; i > 0 && e.charCodeAt(~-i) === t.charCodeAt(~-a); ) (i--, a--);
    let o = 0;
    for (; o < i && e.charCodeAt(o) === t.charCodeAt(o); ) o++;
    if (((i -= o), (a -= o), void 0 !== s && a - i > s)) return s;
    if (0 === i) return void 0 !== s && a > s ? s : a;
    let u,
     l,
     p,
     c,
     h = 0,
     d = 0;
    for (; h < i; ) ((Vt[h] = e.charCodeAt(o + h)), (Wt[h] = ++h));
    for (; d < a; ) {
     for (u = t.charCodeAt(o + d), p = d++, l = d, h = 0; h < i; h++) ((c = u === Vt[h] ? p : p + 1), (p = Wt[h]), (l = Wt[h] = p > l ? (c > l ? l + 1 : c) : c > p ? p + 1 : c));
     if (void 0 !== s) {
      let e = l;
      for (h = 0; h < i; h++) Wt[h] < e && (e = Wt[h]);
      if (e > s) return s;
     }
    }
    return ((Wt.length = i), (Vt.length = i), void 0 !== s && l > s ? s : l);
   }
   var Ht = (e, t, { descriptor: r, logger: s, schemas: n }) => {
     let i = [`Ignored unknown option ${Mt.yellow(r.pair({ key: e, value: t }))}.`],
      a = (function (e, t, r) {
       if (!Array.isArray(t) || 0 === t.length) return;
       let s = r?.maxDistance,
        n = e.length;
       for (let u of t) if (u === e) return u;
       if (0 === s) return;
       let i,
        a = Number.POSITIVE_INFINITY,
        o = new Set();
       for (let u of t) {
        if (o.has(u)) continue;
        o.add(u);
        let t = Math.abs(u.length - n);
        if (t >= a || (void 0 !== s && t > s)) continue;
        let r = Number.isFinite(a) ? (void 0 === s ? a : Math.min(a, s)) : s,
         l = void 0 === r ? zt(e, u) : zt(e, u, { maxDistance: r });
        if (void 0 !== s && l > s) continue;
        let p = l;
        if ((void 0 !== r && l === r && r === s && (p = zt(e, u)), p < a && ((a = p), (i = u), 0 === a))) break;
       }
       return void 0 !== s && a > s ? void 0 : i;
      })(e, Object.keys(n), { maxDistance: 3 });
     (a && i.push(`Did you mean ${Mt.blue(r.key(a))}?`), s.warn(i.join(' ')));
    },
    Xt = ['default', 'expected', 'validate', 'deprecated', 'forward', 'redirect', 'overlap', 'preprocess', 'postprocess'];
   var Kt = class {
    static create(e) {
     return (function (e, t) {
      let r = new e(t),
       s = Object.create(r);
      for (let n of Xt) n in t && (s[n] = Gt(t[n], r, Kt.prototype[n].length));
      return s;
     })(this, e);
    }
    constructor(e) {
     this.name = e.name;
    }
    default(e) {}
    expected(e) {
     return 'nothing';
    }
    validate(e, t) {
     return !1;
    }
    deprecated(e, t) {
     return !1;
    }
    forward(e, t) {}
    redirect(e, t) {}
    overlap(e, t, r) {
     return e;
    }
    preprocess(e, t) {
     return e;
    }
    postprocess(e, t) {
     return Rt;
    }
   };
   function Gt(e, t, r) {
    return 'function' == typeof e ? (...s) => e(...s.slice(0, r - 1), t, ...s.slice(r - 1)) : () => e;
   }
   var Yt = class extends Kt {
     constructor(e) {
      (super(e), (this._sourceName = e.sourceName));
     }
     expected(e) {
      return e.schemas[this._sourceName].expected(e);
     }
     validate(e, t) {
      return t.schemas[this._sourceName].validate(e, t);
     }
     redirect(e, t) {
      return this._sourceName;
     }
    },
    Qt = class extends Kt {
     expected() {
      return 'anything';
     }
     validate() {
      return !0;
     }
    },
    Zt = class extends Kt {
     constructor({ valueSchema: e, name: t = e.name, ...r }) {
      (super({ ...r, name: t }), (this._valueSchema = e));
     }
     expected(e) {
      let { text: t, list: r } = e.normalizeExpectedResult(this._valueSchema.expected(e));
      return { text: t && `an array of ${t}`, list: r && { title: 'an array of the following values', values: [{ list: r }] } };
     }
     validate(e, t) {
      if (!Array.isArray(e)) return !1;
      let r = [];
      for (let s of e) {
       let e = t.normalizeValidateResult(this._valueSchema.validate(s, t), s);
       !0 !== e && r.push(e.value);
      }
      return 0 === r.length || { value: r };
     }
     deprecated(e, t) {
      let r = [];
      for (let s of e) {
       let e = t.normalizeDeprecatedResult(this._valueSchema.deprecated(s, t), s);
       !1 !== e && r.push(...e.map(({ value: e }) => ({ value: [e] })));
      }
      return r;
     }
     forward(e, t) {
      let r = [];
      for (let s of e) {
       let e = t.normalizeForwardResult(this._valueSchema.forward(s, t), s);
       r.push(...e.map(er));
      }
      return r;
     }
     redirect(e, t) {
      let r = [],
       s = [];
      for (let n of e) {
       let e = t.normalizeRedirectResult(this._valueSchema.redirect(n, t), n);
       ('remain' in e && r.push(e.remain), s.push(...e.redirect.map(er)));
      }
      return 0 === r.length ? { redirect: s } : { redirect: s, remain: r };
     }
     overlap(e, t) {
      return e.concat(t);
     }
    };
   function er({ from: e, to: t }) {
    return { from: [e], to: t };
   }
   var tr = class extends Kt {
    expected() {
     return 'true or false';
    }
    validate(e) {
     return 'boolean' == typeof e;
    }
   };
   function rr(e, t) {
    let r = Object.create(null);
    for (let s of e) {
     let e = s[t];
     if (r[e]) throw new Error(`Duplicate ${t} ${JSON.stringify(e)}`);
     r[e] = s;
    }
    return r;
   }
   function sr(e, t) {
    if (e === t) return 0;
    let r = typeof e,
     s = typeof t,
     n = ['undefined', 'object', 'boolean', 'number', 'string'];
    return r !== s ? n.indexOf(r) - n.indexOf(s) : 'string' !== r ? Number(e) - Number(t) : e.localeCompare(t);
   }
   function nr(e) {
    return void 0 === e ? {} : e;
   }
   function ir(e) {
    if ('string' == typeof e) return { text: e };
    let { text: t, list: r } = e;
    return (
     (function (e, t) {
      if (!e) throw new Error(t);
     })(void 0 !== (t || r), 'Unexpected `expected` result, there should be at least one field.'),
     r ? { text: t, list: { title: r.title, values: r.values.map(ir) } } : { text: t }
    );
   }
   function ar(e, t) {
    return !0 === e || (!1 === e ? { value: t } : e);
   }
   function or(e, t, r = !1) {
    return !1 !== e && (!0 === e ? !!r || [{ value: t }] : 'value' in e ? [e] : 0 !== e.length && e);
   }
   function ur(e, t) {
    return 'string' == typeof e || 'key' in e ? { from: t, to: e } : 'from' in e ? { from: e.from, to: e.to } : { from: t, to: e.to };
   }
   function lr(e, t) {
    return void 0 === e ? [] : Array.isArray(e) ? e.map((e) => ur(e, t)) : [ur(e, t)];
   }
   function pr(e, t) {
    let r = lr('object' == typeof e && 'redirect' in e ? e.redirect : e, t);
    return 0 === r.length ? { remain: t, redirect: r } : 'object' == typeof e && 'remain' in e ? { remain: e.remain, redirect: r } : { redirect: r };
   }
   var cr,
    hr = class extends Kt {
     constructor(e) {
      (super(e),
       (this._choices = (function (e, t) {
        let r = new Map();
        for (let s of e) {
         let e = s[t];
         if (r.has(e)) throw new Error(`Duplicate ${t} ${JSON.stringify(e)}`);
         r.set(e, s);
        }
        return r;
       })(
        e.choices.map((e) => (e && 'object' == typeof e ? e : { value: e })),
        'value',
       )));
     }
     expected({ descriptor: e }) {
      let t = Array.from(this._choices.keys())
        .map((e) => this._choices.get(e))
        .filter(({ hidden: e }) => !e)
        .map((e) => e.value)
        .sort(sr)
        .map(e.value),
       r = t.slice(0, -2),
       s = t.slice(-2);
      return { text: r.concat(s.join(' or ')).join(', '), list: { title: 'one of the following values', values: t } };
     }
     validate(e) {
      return this._choices.has(e);
     }
     deprecated(e) {
      let t = this._choices.get(e);
      return !(!t || !t.deprecated) && { value: e };
     }
     forward(e) {
      let t = this._choices.get(e);
      return t ? t.forward : void 0;
     }
     redirect(e) {
      let t = this._choices.get(e);
      return t ? t.redirect : void 0;
     }
    },
    dr = class extends Kt {
     expected() {
      return 'a number';
     }
     validate(e, t) {
      return 'number' == typeof e;
     }
    },
    fr = class extends dr {
     expected() {
      return 'an integer';
     }
     validate(e, t) {
      return (
       !0 === t.normalizeValidateResult(super.validate(e, t), e) &&
       (function (e) {
        return e === Math.floor(e);
       })(e)
      );
     }
    },
    mr = class extends Kt {
     expected() {
      return 'a string';
     }
     validate(e) {
      return 'string' == typeof e;
     }
    },
    yr = Ot,
    Dr = Ht,
    gr = (e, t, r) => {
     let { text: s, list: n } = r.normalizeExpectedResult(r.schemas[e].expected(r)),
      i = [];
     return (s && i.push($t(e, t, s, r.descriptor)), n && i.push([$t(e, t, n.title, r.descriptor)].concat(n.values.map((e) => qt(e, r.loggerPrintWidth))).join('\n')), Jt(i, r.loggerPrintWidth));
    },
    xr = (e, t, { descriptor: r }) => {
     let s = [`${Mt.yellow('string' == typeof e ? r.key(e) : r.pair(e))} is deprecated`];
     return (t && s.push(`we now treat it as ${Mt.blue('string' == typeof t ? r.key(t) : r.pair(t))}`), s.join('; ') + '.');
    },
    Er = class {
     constructor(e, t) {
      let { logger: r = console, loggerPrintWidth: s = 80, descriptor: n = yr, unknown: i = Dr, invalid: a = gr, deprecated: o = xr, missing: u = () => !1, required: l = () => !1, preprocess: p = (e) => e, postprocess: c = () => Rt } = t || {};
      ((this._utils = { descriptor: n, logger: r || { warn: () => {} }, loggerPrintWidth: s, schemas: rr(e, 'name'), normalizeDefaultResult: nr, normalizeExpectedResult: ir, normalizeDeprecatedResult: or, normalizeForwardResult: lr, normalizeRedirectResult: pr, normalizeValidateResult: ar }),
       (this._unknownHandler = i),
       (this._invalidHandler = (function (e) {
        return (...t) => {
         let r = e(...t);
         return 'string' == typeof r ? new Error(r) : r;
        };
       })(a)),
       (this._deprecatedHandler = o),
       (this._identifyMissing = (e, t) => !(e in t) || u(e, t)),
       (this._identifyRequired = l),
       (this._preprocess = p),
       (this._postprocess = c),
       this.cleanHistory());
     }
     cleanHistory() {
      this._hasDeprecationWarned = (function () {
       let e = Object.create(null);
       return (t) => {
        let r = JSON.stringify(t);
        return !!e[r] || ((e[r] = !0), !1);
       };
      })();
     }
     normalize(e) {
      let t = {},
       r = [this._preprocess(e, this._utils)],
       s = () => {
        for (; 0 !== r.length; ) {
         let e = r.shift(),
          s = this._applyNormalization(e, t);
         r.push(...s);
        }
       };
      s();
      for (let n of Object.keys(this._utils.schemas)) {
       let e = this._utils.schemas[n];
       if (!(n in t)) {
        let t = nr(e.default(this._utils));
        'value' in t && r.push({ [n]: t.value });
       }
      }
      s();
      for (let n of Object.keys(this._utils.schemas)) {
       if (!(n in t)) continue;
       let e = this._utils.schemas[n],
        r = t[n],
        s = e.postprocess(r, this._utils);
       s !== Rt && (this._applyValidation(s, n, e), (t[n] = s));
      }
      return (this._applyPostprocess(t), this._applyRequiredCheck(t), t);
     }
     _applyNormalization(e, t) {
      let r = [],
       { knownKeys: s, unknownKeys: n } = this._partitionOptionKeys(e);
      for (let i of s) {
       let s = this._utils.schemas[i],
        n = s.preprocess(e[i], this._utils);
       this._applyValidation(n, i, s);
       let a = ({ from: e, to: t }) => {
         r.push('string' == typeof t ? { [t]: e } : { [t.key]: t.value });
        },
        o = ({ value: e, redirectTo: t }) => {
         let r = or(s.deprecated(e, this._utils), n, !0);
         if (!1 !== r)
          if (!0 === r) this._hasDeprecationWarned(i) || this._utils.logger.warn(this._deprecatedHandler(i, t, this._utils));
          else
           for (let { value: s } of r) {
            let e = { key: i, value: s };
            if (!this._hasDeprecationWarned(e)) {
             let r = 'string' == typeof t ? { key: t, value: s } : t;
             this._utils.logger.warn(this._deprecatedHandler(e, r, this._utils));
            }
           }
        };
       lr(s.forward(n, this._utils), n).forEach(a);
       let u = pr(s.redirect(n, this._utils), n);
       if ((u.redirect.forEach(a), 'remain' in u)) {
        let e = u.remain;
        ((t[i] = i in t ? s.overlap(t[i], e, this._utils) : e), o({ value: e }));
       }
       for (let { from: e, to: t } of u.redirect) o({ value: e, redirectTo: t });
      }
      for (let i of n) {
       let s = e[i];
       this._applyUnknownHandler(i, s, t, (e, t) => {
        r.push({ [e]: t });
       });
      }
      return r;
     }
     _applyRequiredCheck(e) {
      for (let t of Object.keys(this._utils.schemas)) if (this._identifyMissing(t, e) && this._identifyRequired(t)) throw this._invalidHandler(t, _t, this._utils);
     }
     _partitionOptionKeys(e) {
      let [t, r] = (function (e, t) {
       let r = [],
        s = [];
       for (let n of e) t(n) ? r.push(n) : s.push(n);
       return [r, s];
      })(
       Object.keys(e).filter((t) => !this._identifyMissing(t, e)),
       (e) => e in this._utils.schemas,
      );
      return { knownKeys: t, unknownKeys: r };
     }
     _applyValidation(e, t, r) {
      let s = ar(r.validate(e, this._utils), e);
      if (!0 !== s) throw this._invalidHandler(t, s.value, this._utils);
     }
     _applyUnknownHandler(e, t, r, s) {
      let n = this._unknownHandler(e, t, this._utils);
      if (n)
       for (let i of Object.keys(n)) {
        if (this._identifyMissing(i, n)) continue;
        let e = n[i];
        i in this._utils.schemas ? s(i, e) : (r[i] = e);
       }
     }
     _applyPostprocess(e) {
      let t = this._postprocess(e, this._utils);
      if (t !== Rt) {
       if (t.delete) for (let r of t.delete) delete e[r];
       if (t.override) {
        let { knownKeys: r, unknownKeys: s } = this._partitionOptionKeys(t.override);
        for (let n of r) {
         let r = t.override[n];
         (this._applyValidation(r, n, this._utils.schemas[n]), (e[n] = r));
        }
        for (let n of s) {
         let r = t.override[n];
         this._applyUnknownHandler(n, r, e, (t, r) => {
          let s = this._utils.schemas[t];
          (this._applyValidation(r, t, s), (e[t] = r));
         });
        }
       }
      }
     }
    };
   function br(e, { isCLI: t, optionInfos: r, FlagSchema: s }) {
    let n,
     { name: i } = e,
     a = { name: i },
     o = {};
    switch (e.type) {
     case 'int':
      ((n = fr), t && (a.preprocess = Number));
      break;
     case 'string':
     case 'path':
      n = mr;
      break;
     case 'choice':
      ((n = hr), (a.choices = e.choices.map((t) => (t?.redirect ? { ...t, redirect: { to: { key: e.name, value: t.redirect } } } : t))));
      break;
     case 'boolean':
      n = tr;
      break;
     case 'flag':
      ((n = s), (a.flags = r.flatMap((e) => [e.alias, e.description && e.name, e.oppositeDescription && `no-${e.name}`].filter(Boolean))));
      break;
     default:
      throw new Error(`Unexpected type ${e.type}`);
    }
    if ((e.exception ? (a.validate = (t, r, s) => e.exception(t) || r.validate(t, s)) : (a.validate = (e, t, r) => void 0 === e || t.validate(e, r)), e.redirect && (o.redirect = (t) => (t ? { to: 'string' == typeof e.redirect ? e.redirect : { key: e.redirect.option, value: e.redirect.value } } : void 0)), e.deprecated && (o.deprecated = !0), t && !e.array)) {
     let e = a.preprocess || ((e) => e);
     a.preprocess = (t, r, s) => r.preprocess(e(Array.isArray(t) ? v(0, t, -1) : t), s);
    }
    return e.array ? Zt.create({ ...(t ? { preprocess: (e) => (Array.isArray(e) ? e : [e]) } : {}), ...o, valueSchema: n.create(a) }) : n.create({ ...a, ...o });
   }
   var Tr = function (e, t, { logger: r = !1, isCLI: s = !1, passThrough: n = !1, FlagSchema: i, descriptor: a } = {}) {
     if (s) {
      if (!i) throw new Error("'FlagSchema' option is required.");
      if (!a) throw new Error("'descriptor' option is required.");
     } else a = Ot;
     let o = n
       ? Array.isArray(n)
         ? (e, t) => (n.includes(e) ? { [e]: t } : void 0)
         : (e, t) => ({ [e]: t })
       : (e, t, r) => {
          let { _: s, ...n } = r.schemas;
          return Ht(e, t, { ...r, schemas: n });
         },
      u = (function (e, { isCLI: t, FlagSchema: r }) {
       let s = [];
       t && s.push(Qt.create({ name: '_' }));
       for (let n of e) (s.push(br(n, { isCLI: t, optionInfos: e, FlagSchema: r })), n.alias && t && s.push(Yt.create({ name: n.alias, sourceName: n.name })));
       return s;
      })(t, { isCLI: s, FlagSchema: i }),
      l = new Er(u, { logger: r, unknown: o, descriptor: a }),
      p = !1 !== r;
     p && cr && (l._hasDeprecationWarned = cr);
     let c = l.normalize(e);
     return (p && (cr = l._hasDeprecationWarned), c);
    },
    Cr =
     Array.prototype.findLast ??
     function (e) {
      for (let t = this.length - 1; t >= 0; t--) {
       let r = this[t];
       if (e(r, t, this)) return r;
      }
     },
    Fr = f('findLast', function () {
     if (Array.isArray(this)) return Cr;
    }),
    Ar = Symbol.for('PRETTIER_IS_FRONT_MATTER'),
    wr = [];
   var Sr = function (e) {
     return !!e?.[Ar];
    },
    vr = new Set(['yaml', 'toml']),
    Pr = ({ node: e }) => Sr(e) && vr.has(e.language);
   async function kr(e, t, r, s) {
    let { node: n } = r,
     { language: i } = n;
    if (!vr.has(i)) return;
    let a,
     o = n.value.trim();
    if (o) {
     let t = 'yaml' === i ? i : Bt(s, { language: i });
     if (!t) return;
     a = o ? await e(o, { parser: t }) : '';
    } else a = o;
    return de([n.startDelimiter, n.explicitLanguage ?? '', Te, a, a ? Te : '', n.endDelimiter]);
   }
   var Ir = function (e, t) {
    return (Pr({ node: e }) && (delete t.end, delete t.raw, delete t.value), t);
   };
   var Nr = function ({ node: e }) {
     return e.raw;
    },
    Br = new Set(['tokens', 'comments', 'parent', 'enclosingNode', 'precedingNode', 'followingNode']),
    Or = (e) => Object.keys(e).filter((e) => !Br.has(e));
   var Lr = function (e, t) {
    let r = e ? (t) => e(t, Br) : Or;
    return t ? new Proxy(r, { apply: (e, t, r) => (Sr(r[0]) ? wr : Reflect.apply(e, t, r)) }) : r;
   };
   function Mr(e, t) {
    if (!t) throw new Error('parserName is required.');
    let r = Fr(0, e, (e) => e.parsers && Object.prototype.hasOwnProperty.call(e.parsers, t));
    if (r) return r;
    let s = `Couldn't resolve parser "${t}".`;
    throw ((s += ' Plugins must be explicitly added to the standalone bundle.'), new bt(s));
   }
   function jr({ plugins: e, parser: t }) {
    return _r(Mr(e, t), t);
   }
   function _r(e, t) {
    let r = e.parsers[t];
    return 'function' == typeof r ? r() : r;
   }
   async function Rr(e, t) {
    let r = e.printers[t];
    return (function (e) {
     if (Ur.has(e)) return Ur.get(e);
     let { features: t, getVisitorKeys: r, embed: s, massageAstNode: n, print: i, ...a } = e;
     t = (function (e) {
      return { experimental_avoidAstMutation: !1, ...e, experimental_frontMatterSupport: qr(e?.experimental_frontMatterSupport) };
     })(t);
     let o = t.experimental_frontMatterSupport;
     r = Lr(r, o.massageAstNode || o.embed || o.print);
     let u = n;
     n && o.massageAstNode && (u = new Proxy(n, { apply: (e, t, r) => (Ir(...r), Reflect.apply(e, t, r)) }));
     let l = s;
     if (s) {
      let e;
      l = new Proxy(s, { get: (t, n, i) => ('getVisitorKeys' === n ? (e ?? (e = s.getVisitorKeys ? Lr(s.getVisitorKeys, o.massageAstNode || o.embed) : r), e) : Reflect.get(t, n, i)), apply: (e, t, r) => (o.embed && Pr(...r) ? kr : Reflect.apply(e, t, r)) });
     }
     let p = i;
     o.print &&
      (p = new Proxy(i, {
       apply(e, t, r) {
        let [s] = r;
        return Sr(s.node) ? Nr(s) : Reflect.apply(e, t, r);
       },
      }));
     let c = { features: t, getVisitorKeys: r, embed: l, massageAstNode: u, print: p, ...a };
     return (Ur.set(e, c), c);
    })('function' == typeof r ? await r() : r);
   }
   var Ur = new WeakMap();
   Symbol('PRINTER_NORMALIZED_MARK');
   var $r = Object.fromEntries(['clean', 'embed', 'print'].map((e) => [e, !1]));
   function qr(e) {
    return { ...$r, ...e };
   }
   var Jr = { astFormat: 'estree', printer: {}, originalText: void 0, locStart: null, locEnd: null, getVisitorKeys: null };
   var Wr = async function (e, t = {}) {
     let r = { ...e };
     if (!r.parser) {
      if (!r.filepath) throw new Tt("No parser and no file path given, couldn't infer a parser.");
      if (((r.parser = Bt(r, { physicalFile: r.filepath })), !r.parser)) throw new Tt(`No parser could be inferred for file "${r.filepath}".`);
     }
     let s = Ft({ plugins: e.plugins, showDeprecated: !0 }).options,
      n = { ...Jr, ...Object.fromEntries(s.filter((e) => void 0 !== e.default).map((e) => [e.name, e.default])) },
      i = Mr(r.plugins, r.parser),
      a = await _r(i, r.parser);
     ((r.astFormat = a.astFormat), (r.locEnd = a.locEnd), (r.locStart = a.locStart));
     let o = i.printers?.[a.astFormat]
       ? i
       : (function (e, t) {
          if (!t) throw new Error('astFormat is required.');
          let r = Fr(0, e, (e) => e.printers && Object.prototype.hasOwnProperty.call(e.printers, t));
          if (r) return r;
          let s = `Couldn't find plugin for AST format "${t}".`;
          throw ((s += ' Plugins must be explicitly added to the standalone bundle.'), new bt(s));
         })(r.plugins, a.astFormat),
      u = await Rr(o, a.astFormat);
     ((r.printer = u), (r.getVisitorKeys = u.getVisitorKeys));
     let l = { ...n, ...(o.defaultOptions ? Object.fromEntries(Object.entries(o.defaultOptions).filter(([, e]) => void 0 !== e)) : {}) };
     for (let [p, c] of Object.entries(l)) (null === r[p] || void 0 === r[p]) && (r[p] = c);
     return ('json' === r.parser && (r.trailingComma = 'none'), Tr(r, s, { passThrough: Object.keys(Jr), ...t }));
    },
    Vr =
     (((e, t, r) => {
      ((r = null != e ? i(l(e)) : {}),
       ((e, t, r, s) => {
        if ((t && 'object' == typeof t) || 'function' == typeof t) for (let n of u(t)) !p.call(e, n) && n !== r && a(e, n, { get: () => t[n], enumerable: !(s = o(t, n)) || s.enumerable });
       })(!t && e && e.__esModule ? r : a(r, 'default', { value: e, enumerable: !0 }), e));
     })(h(), 1),
     '\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u0870-\u0887\u0889-\u088f\u08a0-\u08c9\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c5c\u0c5d\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cdc-\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u1711\u171f-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4c\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c8a\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7dc\ua7f1-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc'),
    zr = '\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u0897-\u089f\u08ca-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3c\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0cf3\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ece\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u180f-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf-\u1add\u1ae0-\u1aeb\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1dff\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\u30fb\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f\uff65';
   (new RegExp('[' + Vr + ']'), new RegExp('[' + Vr + zr + ']'));
   Vr = zr = null;
   var Hr = ['implements', 'interface', 'let', 'package', 'private', 'protected', 'public', 'static', 'yield'],
    Xr = ['eval', 'arguments'],
    Kr = (new Set(['break', 'case', 'catch', 'continue', 'debugger', 'default', 'do', 'else', 'finally', 'for', 'function', 'if', 'return', 'switch', 'throw', 'try', 'var', 'const', 'while', 'with', 'new', 'this', 'super', 'class', 'extends', 'export', 'import', 'null', 'true', 'false', 'in', 'instanceof', 'typeof', 'void', 'delete']), new Set(Hr), new Set(Xr), (e, t) => (r) => e(t(r)));
   function Gr(e) {
    return { keyword: e.cyan, capitalized: e.yellow, jsxIdentifier: e.yellow, punctuator: e.yellow, number: e.magenta, string: e.green, regex: e.magenta, comment: e.gray, invalid: Kr(Kr(e.white, e.bgRed), e.bold), gutter: e.gray, marker: Kr(e.red, e.bold), message: Kr(e.red, e.bold), reset: e.reset };
   }
   (Gr(jt()), Gr(jt()));
   var Yr = /\r\n|[\n\r\u2028\u2029]/;
   function Qr(e, t, r = {}) {
    let s = new Proxy({}, { get: () => (e) => e }),
     n = e.split(Yr),
     {
      start: i,
      end: a,
      markerLines: o,
     } = (function (e, t, r) {
      let s = Object.assign({ column: 0, line: -1 }, e.start),
       n = Object.assign({}, s, e.end),
       { linesAbove: i = 2, linesBelow: a = 3 } = r || {},
       o = s.line,
       u = s.column,
       l = n.line,
       p = n.column,
       c = Math.max(o - (i + 1), 0),
       h = Math.min(t.length, l + a);
      (-1 === o && (c = 0), -1 === l && (h = t.length));
      let d = l - o,
       f = {};
      if (d)
       for (let m = 0; m <= d; m++) {
        let e = m + o;
        if (u)
         if (0 === m) {
          let r = t[e - 1].length;
          f[e] = [u, r - u + 1];
         } else if (m === d) f[e] = [0, p];
         else {
          let r = t[e - m].length;
          f[e] = [0, r];
         }
        else f[e] = !0;
       }
      else f[o] = u === p ? !u || [u, 0] : [u, p - u];
      return { start: c, end: h, markerLines: f };
     })(t, n, r),
     u = t.start && 'number' == typeof t.start.column,
     l = String(a).length,
     p = e
      .split(Yr, a)
      .slice(i, a)
      .map((e, t) => {
       let n = i + 1 + t,
        a = ` ${` ${n}`.slice(-l)} |`,
        u = o[n],
        p = !o[n + 1];
       if (u) {
        let t = '';
        if (Array.isArray(u)) {
         let n = e.slice(0, Math.max(u[0] - 1, 0)).replace(/[^\t]/g, ' '),
          i = u[1] || 1;
         ((t = ['\n ', s.gutter(a.replace(/\d/g, ' ')), ' ', n, s.marker('^').repeat(i)].join('')), p && r.message && (t += ' ' + s.message(r.message)));
        }
        return [s.marker('>'), s.gutter(a), e.length > 0 ? ` ${e}` : '', t].join('');
       }
       return ` ${s.gutter(a)}${e.length > 0 ? ` ${e}` : ''}`;
      })
      .join('\n');
    return (r.message && !u && (p = `${' '.repeat(l + 1)}${r.message}\n${p}`), p);
   }
   var Zr = async function (e, t) {
    let r,
     s = await jr(t),
     n = s.preprocess ? await s.preprocess(e, t) : e;
    t.originalText = n;
    try {
     r = await s.parse(n, t, t);
    } catch (i) {
     !(function (e, t) {
      let { loc: r } = e;
      if (r) {
       let s = Qr(t, r, { highlightCode: !0 });
       throw ((e.message += '\n' + s), (e.codeFrame = s), e);
      }
      throw e;
     })(i, e);
    }
    return { text: n, ast: r };
   };
   async function es(e, t, r, s, n) {
    if ('auto' !== r.embeddedLanguageFormatting) return;
    let { printer: i } = r,
     { embed: a } = i;
    if (!a) return;
    if (a.length > 2) throw new Error('printer.embed has too many parameters. The API changed in Prettier v3. Please update your plugin. See https://prettier.io/docs/plugins#optional-embed');
    let { hasPrettierIgnore: o } = i,
     { getVisitorKeys: u } = a,
     l = [];
    !(function t() {
     let { node: s } = e;
     if (null === s || 'object' != typeof s || o?.(e)) return;
     for (let r of u(s)) Array.isArray(s[r]) ? e.each(t, r) : e.call(t, r);
     let i = a(e, r);
     if (i) {
      if ('function' == typeof i) return void l.push({ print: i, node: s, pathStack: [...e.stack] });
      n.set(s, i);
     }
    })();
    let p = e.stack;
    for (let { print: d, node: f, pathStack: m } of l)
     try {
      e.stack = m;
      let s = await d(c, t, e, r);
      s && n.set(f, s);
     } catch (h) {
      if (globalThis.PRETTIER_DEBUG) throw h;
     }
    function c(e, t) {
     return (async function (e, t, r, s) {
      let n = await Wr({ ...r, ...t, parentParser: r.parser, originalText: e, cursorOffset: void 0, rangeStart: void 0, rangeEnd: void 0 }, { passThrough: !0 }),
       { ast: i } = await Zr(e, n),
       a = await s(i, n);
      return ne(a);
     })(e, t, r, s);
    }
    e.stack = p;
   }
   var ts = function (e, t, r, s) {
    let { originalText: n, [Symbol.for('comments')]: i, locStart: a, locEnd: o, [Symbol.for('printedComments')]: u } = t,
     { node: l } = e,
     p = a(l),
     c = o(l);
    for (let d of i) a(d) >= p && o(d) <= c && u.add(d);
    let { printPrettierIgnored: h } = t.printer;
    return h ? h(e, t, r, s) : n.slice(p, c);
   };
   async function rs(e, t) {
    ({ ast: e } = await ns(e, t));
    let r = new Map(),
     s = new He(e),
     n = x,
     i = new Map();
    await es(s, o, t, rs, i);
    let a = await ss(s, t, o, void 0, i);
    if (
     ((function (e) {
      let { [Symbol.for('comments')]: t, [Symbol.for('printedComments')]: r } = e;
      for (let s of t) {
       if (!s.printed && !r.has(s)) throw new Error('Comment "' + s.value.trim() + '" was not printed. Please report this error!');
       delete s.printed;
      }
     })(t),
     t.cursorOffset >= 0)
    ) {
     if (t.nodeAfterCursor && !t.nodeBeforeCursor) return [ye, a];
     if (t.nodeBeforeCursor && !t.nodeAfterCursor) return [a, ye];
    }
    return a;
    function o(e, t) {
     return void 0 === e || e === s ? u(t) : Array.isArray(e) ? s.call(() => u(t), ...e) : s.call(() => u(t), e);
    }
    function u(e) {
     n(s);
     let a = s.node;
     if (null == a) return '';
     let u = Xe(a) && void 0 === e;
     if (u && r.has(a)) return r.get(a);
     let l = ss(s, t, o, e, i);
     return (u && r.set(a, l), l);
    }
   }
   function ss(e, t, r, s, n) {
    let i,
     { node: a } = e,
     { printer: o } = t;
    switch (((i = o.hasPrettierIgnore?.(e) ? ts(e, t, r, s) : n.has(a) ? n.get(a) : o.print(e, t, r, s)), a)) {
     case t.cursorNode:
      i = ae(i, (e) => [ye, e, ye]);
      break;
     case t.nodeBeforeCursor:
      i = ae(i, (e) => [e, ye]);
      break;
     case t.nodeAfterCursor:
      i = ae(i, (e) => [ye, e]);
    }
    return (
     o.printComment &&
      !o.willPrintOwnComments?.(e, t) &&
      (i = (function (e, t, r) {
       let { leading: s, trailing: n } = Et(e, r);
       return s || n ? ae(t, (e) => [s, e, n]) : t;
      })(e, i, t)),
     i
    );
   }
   async function ns(e, t) {
    let r = e.comments ?? [];
    ((t[Symbol.for('comments')] = r),
     (t[Symbol.for('printedComments')] = new Set()),
     (function (e, t) {
      let { comments: r } = e;
      if ((delete e.comments, !st(r) || !t.printer.canAttachComment)) return;
      let s = [],
       {
        printer: {
         features: { experimental_avoidAstMutation: n },
         handleComments: i = {},
        },
        originalText: a,
       } = t,
       { ownLine: o = ht, endOfLine: u = ht, remaining: l = ht } = i,
       p = r.map((s, n) => ({ ...ct(e, s, t), comment: s, text: a, options: t, ast: e, isLastComment: r.length - 1 === n }));
      for (let [c, h] of p.entries()) {
       let e,
        { comment: t, precedingNode: r, enclosingNode: i, followingNode: a, text: d, options: f, ast: m, isLastComment: y } = h;
       if ((n ? (e = [h]) : ((t.enclosingNode = i), (t.precedingNode = r), (t.followingNode = a), (e = [t, d, f, m, y])), ft(d, f, p, c))) ((t.placement = 'ownLine'), o(...e) || (a ? ot(a, t) : r ? lt(r, t) : ut(i || m, t)));
       else if (mt(d, f, p, c)) ((t.placement = 'endOfLine'), u(...e) || (r ? lt(r, t) : a ? ot(a, t) : ut(i || m, t)));
       else if (((t.placement = 'remaining'), !l(...e)))
        if (r && a) {
         let e = s.length;
         (e > 0 && s[e - 1].followingNode !== a && yt(s, f), s.push(h));
        } else r ? lt(r, t) : a ? ot(a, t) : ut(i || m, t);
      }
      if ((yt(s, t), !n)) for (let c of r) (delete c.precedingNode, delete c.enclosingNode, delete c.followingNode);
     })(e, t));
    let {
     printer: { preprocess: s },
    } = t;
    return { ast: (e = s ? await s(e, t) : e), comments: r };
   }
   var is = function (e, t) {
    let { cursorOffset: r, locStart: s, locEnd: n, getVisitorKeys: i } = t,
     a = (e) => s(e) <= r && n(e) >= r,
     o = e,
     u = [e];
    for (let d of (function* (e, t) {
     let r = [e];
     for (let s = 0; s < r.length; s++) {
      let e = r[s];
      for (let s of nt(e, t)) (yield s, r.push(s));
     }
    })(e, { getVisitorKeys: i, filter: a }))
     (u.push(d), (o = d));
    if (
     (function (e, t) {
      return nt(e, t).next().done;
     })(o, { getVisitorKeys: i })
    )
     return { cursorNode: o };
    let l,
     p,
     c = -1,
     h = Number.POSITIVE_INFINITY;
    for (; u.length > 0 && (void 0 === l || void 0 === p); ) {
     o = u.pop();
     let e = void 0 !== l,
      t = void 0 !== p;
     for (let a of nt(o, { getVisitorKeys: i })) {
      if (!e) {
       let e = n(a);
       e <= r && e > c && ((l = a), (c = e));
      }
      if (!t) {
       let e = s(a);
       e >= r && e < h && ((p = a), (h = e));
      }
     }
    }
    return { nodeBeforeCursor: l, nodeAfterCursor: p };
   };
   var as = function (e, t) {
     let { printer: r } = t,
      s = r.massageAstNode;
     if (!s) return e;
     let { getVisitorKeys: n } = r,
      { ignoredProperties: i } = s;
     return (function e(t, r) {
      if (!Xe(t)) return t;
      if (Array.isArray(t)) return t.map((t) => e(t, r)).filter(Boolean);
      let a = {},
       o = new Set(n(t));
      for (let s in t) !Object.prototype.hasOwnProperty.call(t, s) || i?.has(s) || (o.has(s) ? (a[s] = e(t[s], t)) : (a[s] = t[s]));
      let u = s(t, a, r);
      if (null !== u) return u ?? a;
     })(e);
    },
    os =
     Array.prototype.findLastIndex ??
     function (e) {
      for (let t = this.length - 1; t >= 0; t--) {
       if (e(this[t], t, this)) return t;
      }
      return -1;
     },
    us = f('findLastIndex', function () {
     if (Array.isArray(this)) return os;
    });
   function ls(e) {
    let t = us(0, e, (e) => 'Program' !== e.type && 'File' !== e.type);
    return -1 === t ? e : e.slice(0, t + 1);
   }
   function ps(e, t, r, s, n = [], i) {
    let { locStart: a, locEnd: o } = r,
     u = a(e),
     l = o(e);
    if (t > l || t < u || ('rangeEnd' === i && t === u) || ('rangeStart' === i && t === l)) return;
    let p = [e, ...n],
     c = it(e, p, { cache: pt, locStart: a, locEnd: o, getVisitorKeys: r.getVisitorKeys, filter: r.printer.canAttachComment, getChildren: r.printer.getCommentChildNodes });
    for (let h of c) {
     let e = ps(h, t, r, s, p, i);
     if (e) return e;
    }
    return s(e, n[0]) ? p : void 0;
   }
   var cs = new Set(['JsonRoot', 'ObjectExpression', 'ArrayExpression', 'StringLiteral', 'NumericLiteral', 'BooleanLiteral', 'NullLiteral', 'UnaryExpression', 'TemplateLiteral']),
    hs = new Set(['OperationDefinition', 'FragmentDefinition', 'VariableDefinition', 'TypeExtensionDefinition', 'ObjectTypeDefinition', 'FieldDefinition', 'DirectiveDefinition', 'EnumTypeDefinition', 'EnumValueDefinition', 'InputValueDefinition', 'InputObjectTypeDefinition', 'SchemaDefinition', 'OperationTypeDefinition', 'InterfaceTypeDefinition', 'UnionTypeDefinition', 'ScalarTypeDefinition']);
   function ds(e, t, r) {
    if (!t) return !1;
    switch (e.parser) {
     case 'flow':
     case 'hermes':
     case 'babel':
     case 'babel-flow':
     case 'babel-ts':
     case 'typescript':
     case 'acorn':
     case 'espree':
     case 'meriyah':
     case 'oxc':
     case 'oxc-ts':
     case '__babel_estree':
      return (function (e, t) {
       return 'DeclareExportDeclaration' !== t && 'TypeParameterDeclaration' !== e && ('Directive' === e || 'TypeAlias' === e || 'TSExportAssignment' === e || e.startsWith('Declare') || e.startsWith('TSDeclare') || e.endsWith('Statement') || e.endsWith('Declaration'));
      })(t.type, r?.type);
     case 'json':
     case 'json5':
     case 'jsonc':
     case 'json-stringify':
      return cs.has(t.type);
     case 'graphql':
      return hs.has(t.kind);
     case 'vue':
      return 'root' !== t.tag;
    }
    return !1;
   }
   function fs(e, t, r) {
    let { rangeStart: s, rangeEnd: n, locStart: i, locEnd: a } = t;
    x(n > s);
    let o = e.slice(s, n).search(/\S/u),
     u = -1 === o;
    if (!u) for (s += o; n > s && !/\S/u.test(e[n - 1]); --n);
    let l = ps(r, s, t, (e, r) => ds(t, e, r), [], 'rangeStart');
    if (!l) return;
    let p,
     c,
     h = u ? l : ps(r, n, t, (e) => ds(t, e), [], 'rangeEnd');
    if (h) {
     if ((({ parser: e }) => 'json' === e || 'json5' === e || 'jsonc' === e || 'json-stringify' === e)(t)) {
      let e = (function (e, t) {
       return ((t = new Set(t)), e.find((e) => cs.has(e.type) && t.has(e)));
      })(l, h);
      ((p = e), (c = e));
     } else
      [p, c] = (function (e, t, { locStart: r, locEnd: s }) {
       let [n, ...i] = e,
        [a, ...o] = t;
       if (n === a) return [n, a];
       let u = r(n);
       for (let p of ls(o)) {
        if (!(r(p) >= u)) break;
        a = p;
       }
       let l = s(a);
       for (let p of ls(i)) {
        if (!(s(p) <= l)) break;
        if (((n = p), n === a)) break;
       }
       return [n, a];
      })(l, h, t);
     return [Math.min(i(p), i(c)), Math.max(a(p), a(c))];
    }
   }
   var ms = Symbol('cursor');
   async function ys(e, t, r = 0) {
    if (!e || 0 === e.trim().length) return { formatted: '', cursorOffset: -1, comments: [] };
    let { ast: s, text: n } = await Zr(e, t);
    t.cursorOffset >= 0 && (t = { ...t, ...is(s, t) });
    let i = await rs(s, t);
    r > 0 && (i = fe([Te, i], r, t.tabWidth));
    let a = Ve(i, t);
    if (r > 0) {
     let e = a.formatted.trim();
     (void 0 !== a.cursorNodeStart && ((a.cursorNodeStart -= a.formatted.indexOf(e)), a.cursorNodeStart < 0 && ((a.cursorNodeStart = 0), (a.cursorNodeText = a.cursorNodeText.trimStart())), a.cursorNodeStart + a.cursorNodeText.length > e.length && (a.cursorNodeText = a.cursorNodeText.trimEnd())), (a.formatted = e + C(t.endOfLine)));
    }
    let o = t[Symbol.for('comments')];
    if (t.cursorOffset >= 0) {
     let e, r, s, i;
     if ((t.cursorNode || t.nodeBeforeCursor || t.nodeAfterCursor) && a.cursorNodeText)
      if (((s = a.cursorNodeStart), (i = a.cursorNodeText), t.cursorNode)) ((e = t.locStart(t.cursorNode)), (r = n.slice(e, t.locEnd(t.cursorNode))));
      else {
       if (!t.nodeBeforeCursor && !t.nodeAfterCursor) throw new Error('Cursor location must contain at least one of cursorNode, nodeBeforeCursor, nodeAfterCursor');
       e = t.nodeBeforeCursor ? t.locEnd(t.nodeBeforeCursor) : 0;
       let s = t.nodeAfterCursor ? t.locStart(t.nodeAfterCursor) : n.length;
       r = n.slice(e, s);
      }
     else ((e = 0), (r = n), (s = 0), (i = a.formatted));
     let u = t.cursorOffset - e;
     if (r === i) return { formatted: a.formatted, cursorOffset: s + u, comments: o };
     let l = r.split('');
     l.splice(u, 0, ms);
     let p = (function (e, t, r) {
       return g.diff(e, t, r);
      })(l, i.split('')),
      c = s;
     for (let t of p)
      if (t.removed) {
       if (t.value.includes(ms)) break;
      } else c += t.count;
     return { formatted: a.formatted, cursorOffset: c, comments: o };
    }
    return { formatted: a.formatted, cursorOffset: -1, comments: o };
   }
   function Ds(e, t, r) {
    return 'number' != typeof t || Number.isNaN(t) || t < 0 || t > e.length ? r : t;
   }
   function gs(e, t) {
    let { cursorOffset: r, rangeStart: s, rangeEnd: n } = t;
    return ((r = Ds(e, r, -1)), (s = Ds(e, s, 0)), (n = Ds(e, n, e.length)), { ...t, cursorOffset: r, rangeStart: s, rangeEnd: n });
   }
   function xs(e, t) {
    let { cursorOffset: r, rangeStart: s, rangeEnd: n, endOfLine: i } = gs(e, t),
     a = '\ufeff' === e.charAt(0);
    if (
     (a && ((e = e.slice(1)), r--, s--, n--),
     'auto' === i &&
      (i = (function (e) {
       let t = e.indexOf('\r');
       return -1 !== t ? (e.charAt(t + 1) === b ? E : 'cr') : 'lf';
      })(e)),
     e.includes('\r'))
    ) {
     let t = (t) => A(e.slice(0, Math.max(t, 0)), '\r\n');
     ((r -= t(r)),
      (s -= t(s)),
      (n -= t(n)),
      (e = (function (e) {
       return y(0, e, w, b);
      })(e)));
    }
    return { hasBOM: a, text: e, options: gs(e, { ...t, cursorOffset: r, rangeStart: s, rangeEnd: n, endOfLine: i }) };
   }
   async function Es(e, t) {
    let r = await jr(t);
    return !r.hasPragma || r.hasPragma(e);
   }
   async function bs(e, t) {
    let r,
     { hasBOM: s, text: n, options: i } = xs(e, await Wr(t));
    return (i.rangeStart >= i.rangeEnd && '' !== n) ||
     (i.requirePragma && !(await Es(n, i))) ||
     (i.checkIgnorePragma &&
      (await (async function (e, t) {
       return (await jr(t)).hasIgnorePragma?.(e);
      })(n, i)))
     ? { formatted: e, cursorOffset: t.cursorOffset, comments: [] }
     : (i.rangeStart > 0 || i.rangeEnd < n.length
        ? (r = await (async function (e, t) {
           let { ast: r, text: s } = await Zr(e, t),
            [n, i] = fs(s, t, r) ?? [0, 0],
            a = s.slice(n, i),
            o = Math.min(n, s.lastIndexOf('\n', n) + 1),
            u = s.slice(o, n).match(/^\s*/u)[0],
            l = ze(u, t.tabWidth),
            p = await ys(a, { ...t, rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: t.cursorOffset > n && t.cursorOffset <= i ? t.cursorOffset - n : -1, endOfLine: 'lf' }, l),
            c = p.formatted.trimEnd(),
            { cursorOffset: h } = t;
           h > i ? (h += c.length - a.length) : p.cursorOffset >= 0 && (h = p.cursorOffset + n);
           let d = s.slice(0, n) + c + s.slice(i);
           if ('lf' !== t.endOfLine) {
            let e = C(t.endOfLine);
            (h >= 0 && '\r\n' === e && (h += A(d.slice(0, h), '\n')), (d = y(0, d, '\n', e)));
           }
           return { formatted: d, cursorOffset: h, comments: p.comments };
          })(n, i))
        : (!i.requirePragma && i.insertPragma && i.printer.insertPragma && !(await Es(n, i)) && (n = i.printer.insertPragma(n)), (r = await ys(n, i))),
       s && ((r.formatted = '\ufeff' + r.formatted), r.cursorOffset >= 0 && r.cursorOffset++),
       r);
   }
   var Ts = {};
   c(Ts, { builders: () => Cs, printer: () => Fs, utils: () => As });
   var Cs = {
     join: ge,
     line: xe,
     softline: Ee,
     hardline: Te,
     literalline: Fe,
     group: De,
     conditionalGroup: function (e, t) {
      return De(e[0], { ...t, expandedStates: e });
     },
     fill: function (e) {
      return (le(e), { type: M, parts: e });
     },
     lineSuffix: Ae,
     lineSuffixBoundary: we,
     cursor: ye,
     breakParent: me,
     ifBreak: function (e, t = '', r = {}) {
      return (oe(e), '' !== t && oe(t), { type: j, breakContents: e, flatContents: t, groupId: r.groupId });
     },
     trim: Se,
     indent: ce,
     indentIfBreak: function (e, t) {
      return (oe(e), { type: _, contents: e, groupId: t.groupId, negate: t.negate });
     },
     align: he,
     addAlignmentToDoc: fe,
     markAsRoot: de,
     dedentToRoot: function (e) {
      return he(Number.NEGATIVE_INFINITY, e);
     },
     dedent: function (e) {
      return he(-1, e);
     },
     hardlineWithoutBreakParent: be,
     literallineWithoutBreakParent: Ce,
     label: function (e, t) {
      return (oe(t), e ? { type: q, label: e, contents: t } : t);
     },
     concat: (e) => e,
    },
    Fs = { printDocToString: Ve },
    As = {
     willBreak: function (e) {
      return Q(e, Z, !1);
     },
     traverseDoc: G,
     findInDoc: Q,
     mapDoc: Y,
     removeLines: function (e) {
      return Y(e, te);
     },
     stripTrailingHardline: ne,
     replaceEndOfLine: function (e, t = Fe) {
      return Y(e, (e) => ('string' == typeof e ? ge(t, e.split('\n')) : e));
     },
     canBreak: function (e) {
      return Q(e, ie, !1);
     },
    },
    ws = '3.8.1',
    Ss = {};
   c(Ss, { addDanglingComment: () => ut, addLeadingComment: () => ot, addTrailingComment: () => lt, getAlignmentSize: () => ze, getIndentSize: () => Ns, getMaxContinuousCount: () => Bs, getNextNonSpaceNonCommentCharacter: () => Os, getNextNonSpaceNonCommentCharacterIndex: () => qs, getPreferredQuote: () => Rs, getStringWidth: () => Be, hasNewline: () => rt, hasNewlineInRange: () => Us, hasSpaces: () => $s, isNextLineEmpty: () => Vs, isNextLineEmptyAfterIndex: () => Is, isPreviousLineEmpty: () => Js, makeString: () => Ws, skip: () => Ke, skipEverythingButNewLine: () => Ze, skipInlineComment: () => vs, skipNewline: () => tt, skipSpaces: () => Ye, skipToLineEnd: () => Qe, skipTrailingComment: () => Ps, skipWhitespace: () => Ge });
   var vs = function (e, t) {
    if (!1 === t) return !1;
    if ('/' === e.charAt(t) && '*' === e.charAt(t + 1)) for (let r = t + 2; r < e.length; ++r) if ('*' === e.charAt(r) && '/' === e.charAt(r + 1)) return r + 2;
    return t;
   };
   var Ps = function (e, t) {
    return !1 !== t && ('/' === e.charAt(t) && '/' === e.charAt(t + 1) ? Ze(e, t) : t);
   };
   var ks = function (e, t) {
    let r = null,
     s = t;
    for (; s !== r; ) ((r = s), (s = Ye(e, s)), (s = vs(e, s)), (s = Ps(e, s)), (s = tt(e, s)));
    return s;
   };
   var Is = function (e, t) {
    let r = null,
     s = t;
    for (; s !== r; ) ((r = s), (s = Qe(e, s)), (s = vs(e, s)), (s = Ye(e, s)));
    return ((s = Ps(e, s)), (s = tt(e, s)), !1 !== s && rt(e, s));
   };
   var Ns = function (e, t) {
    let r = e.lastIndexOf('\n');
    return -1 === r ? 0 : ze(e.slice(r + 1).match(/^[\t ]*/u)[0], t);
   };
   var Bs = function (e, t) {
    let r = e.matchAll(
     new RegExp(
      `(?:${(function (e) {
       if ('string' != typeof e) throw new TypeError('Expected a string');
       return e.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&').replace(/-/g, '\\x2d');
      })(t)})+`,
      'gu',
     ),
    );
    return (r.reduce || (r = [...r]), r.reduce((e, [t]) => Math.max(e, t.length), 0) / t.length);
   };
   var Os = function (e, t) {
     let r = ks(e, t);
     return !1 === r ? '' : e.charAt(r);
    },
    Ls = Object.freeze({ character: "'", codePoint: 39 }),
    Ms = Object.freeze({ character: '"', codePoint: 34 }),
    js = Object.freeze({ preferred: Ls, alternate: Ms }),
    _s = Object.freeze({ preferred: Ms, alternate: Ls });
   var Rs = function (e, t) {
    let { preferred: r, alternate: s } = !0 === t || "'" === t ? js : _s,
     { length: n } = e,
     i = 0,
     a = 0;
    for (let o = 0; o < n; o++) {
     let t = e.charCodeAt(o);
     t === r.codePoint ? i++ : t === s.codePoint && a++;
    }
    return (i > a ? s : r).character;
   };
   var Us = function (e, t, r) {
    for (let s = t; s < r; ++s) if ('\n' === e.charAt(s)) return !0;
    return !1;
   };
   var $s = function (e, t, r = {}) {
    return Ye(e, r.backwards ? t - 1 : t, r) !== t;
   };
   function qs(e, t) {
    return 2 === arguments.length || 'number' == typeof t
     ? ks(e, t)
     : (function (e, t, r) {
        return ks(e, r(t));
       })(...arguments);
   }
   function Js(e, t) {
    return 2 === arguments.length || 'number' == typeof t
     ? gt(e, t)
     : (function (e, t, r) {
        return gt(e, r(t));
       })(...arguments);
   }
   function Ws(e, t, r) {
    let s = '"' === t ? "'" : '"',
     n = y(0, e, /\\(.)|(["'])/gsu, (e, n, i) => (n === s ? n : i === t ? '\\' + i : i || (r && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/u.test(n) ? n : '\\' + n)));
    return t + n + t;
   }
   function Vs(e, t) {
    return 2 === arguments.length || 'number' == typeof t
     ? Is(e, t)
     : (function (e, t, r) {
        return Is(e, r(t));
       })(...arguments);
   }
   function zs(e, t = 1) {
    return async (...r) => {
     let s = r[t] ?? {},
      n = s.plugins ?? [];
     return ((r[t] = { ...s, plugins: Array.isArray(n) ? n : Object.values(n) }), e(...r));
    };
   }
   var Hs = zs(bs);
   async function Xs(e, t) {
    let { formatted: r } = await Hs(e, { ...t, cursorOffset: -1 });
    return r;
   }
   async function Ks(e, t) {
    return (await Xs(e, t)) === e;
   }
   var Gs = zs(Ft, 0),
    Ys = {
     parse: zs(async function (e, t, r) {
      let { text: s, options: n } = xs(e, await Wr(t)),
       i = await Zr(s, n);
      return (r && (r.preprocessForPrint && (i.ast = await ns(i.ast, n)), r.massage && (i.ast = as(i.ast, n))), i);
     }),
     formatAST: zs(async function (e, t) {
      return ((t = await Wr(t)), Ve(await rs(e, t), t));
     }),
     formatDoc: zs(async function (e, t) {
      let r = (function (e) {
        let t = Object.create(null),
         r = new Set();
        return (function e(t, r, n) {
         if ('string' == typeof t) return JSON.stringify(t);
         if (Array.isArray(t)) {
          let r = t.map(e).filter(Boolean);
          return 1 === r.length ? r[0] : `[${r.join(', ')}]`;
         }
         if (t.type === $) {
          let e = n?.[r + 1]?.type === J;
          return t.literal ? (e ? 'literalline' : 'literallineWithoutBreakParent') : t.hard ? (e ? 'hardline' : 'hardlineWithoutBreakParent') : t.soft ? 'softline' : 'line';
         }
         if (t.type === J) return n?.[r - 1]?.type === $ && n[r - 1].hard ? void 0 : 'breakParent';
         if (t.type === O) return 'trim';
         if (t.type === N) return 'indent(' + e(t.contents) + ')';
         if (t.type === B) return t.n === Number.NEGATIVE_INFINITY ? 'dedentToRoot(' + e(t.contents) + ')' : t.n < 0 ? 'dedent(' + e(t.contents) + ')' : 'root' === t.n.type ? 'markAsRoot(' + e(t.contents) + ')' : 'align(' + JSON.stringify(t.n) + ', ' + e(t.contents) + ')';
         if (t.type === j) return 'ifBreak(' + e(t.breakContents) + (t.flatContents ? ', ' + e(t.flatContents) : '') + (t.groupId ? (t.flatContents ? '' : ', ""') + `, { groupId: ${s(t.groupId)} }` : '') + ')';
         if (t.type === _) {
          let r = [];
          (t.negate && r.push('negate: true'), t.groupId && r.push(`groupId: ${s(t.groupId)}`));
          let n = r.length > 0 ? `, { ${r.join(', ')} }` : '';
          return `indentIfBreak(${e(t.contents)}${n})`;
         }
         if (t.type === L) {
          let r = [];
          (t.break && 'propagated' !== t.break && r.push('shouldBreak: true'), t.id && r.push(`id: ${s(t.id)}`));
          let n = r.length > 0 ? `, { ${r.join(', ')} }` : '';
          return t.expandedStates ? `conditionalGroup([${t.expandedStates.map((t) => e(t)).join(',')}]${n})` : `group(${e(t.contents)}${n})`;
         }
         if (t.type === M) return `fill([${t.parts.map((t) => e(t)).join(', ')}])`;
         if (t.type === R) return 'lineSuffix(' + e(t.contents) + ')';
         if (t.type === U) return 'lineSuffixBoundary';
         if (t.type === q) return `label(${JSON.stringify(t.label)}, ${e(t.contents)})`;
         if (t.type === I) return 'cursor';
         throw new Error('Unknown doc type ' + t.type);
        })(ve(e));
        function s(e) {
         if ('symbol' != typeof e) return JSON.stringify(String(e));
         if (e in t) return t[e];
         let s = e.description || 'symbol';
         for (let n = 0; ; n++) {
          let i = s + (n > 0 ? ` #${n}` : '');
          if (!r.has(i)) return (r.add(i), (t[e] = `Symbol.for(${JSON.stringify(i)})`));
         }
        }
       })(e),
       { formatted: s } = await bs(r, { ...t, parser: '__js_expression' });
      return s;
     }),
     printToDoc: zs(async function (e, t) {
      t = await Wr(t);
      let { ast: r } = await Zr(e, t);
      return (t.cursorOffset >= 0 && (t = { ...t, ...is(r, t) }), rs(r, t));
     }),
     printDocToString: zs(async function (e, t) {
      return Ve(e, await Wr(t));
     }),
    };
  },
  68148(e, t, r) {
   r.d(t, { A: () => i });
   var s = Object.defineProperty,
    n = (e, t) => {
     for (var r in t) s(e, r, { get: t[r], enumerable: !0 });
    },
    i = {};
   n(i, { parsers: () => bs });
   var a = {};
   function o(e, t) {
    if (null == e) return {};
    var r = {};
    for (var s in e)
     if ({}.hasOwnProperty.call(e, s)) {
      if (-1 !== t.indexOf(s)) continue;
      r[s] = e[s];
     }
    return r;
   }
   n(a, { __babel_estree: () => ps, __js_expression: () => os, __ts_expression: () => us, __vue_event_binding: () => is, __vue_expression: () => os, __vue_ts_event_binding: () => as, __vue_ts_expression: () => us, babel: () => is, 'babel-flow': () => ls, 'babel-ts': () => as });
   var u = class {
     line;
     column;
     index;
     constructor(e, t, r) {
      ((this.line = e), (this.column = t), (this.index = r));
     }
    },
    l = class {
     start;
     end;
     filename;
     identifierName;
     constructor(e, t) {
      ((this.start = e), (this.end = t));
     }
    };
   function p(e, t) {
    let { line: r, column: s, index: n } = e;
    return new u(r, s + t, n + t);
   }
   var c = 'BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED',
    h = { ImportMetaOutsideModule: { message: 'import.meta may appear only with \'sourceType: "module"\'', code: c }, ImportOutsideModule: { message: "'import' and 'export' may appear only with 'sourceType: \"module\"'", code: c } },
    d = { ArrayPattern: 'array destructuring pattern', AssignmentExpression: 'assignment expression', AssignmentPattern: 'assignment expression', ArrowFunctionExpression: 'arrow function expression', ConditionalExpression: 'conditional expression', CatchClause: 'catch clause', ForOfStatement: 'for-of statement', ForInStatement: 'for-in statement', ForStatement: 'for-loop', FormalParameters: 'function parameter list', Identifier: 'identifier', ImportSpecifier: 'import specifier', ImportDefaultSpecifier: 'import default specifier', ImportNamespaceSpecifier: 'import namespace specifier', ObjectPattern: 'object destructuring pattern', ParenthesizedExpression: 'parenthesized expression', RestElement: 'rest element', UpdateExpression: { true: 'prefix operation', false: 'postfix operation' }, VariableDeclarator: 'variable declaration', YieldExpression: 'yield expression' },
    f = (e) => ('UpdateExpression' === e.type ? d.UpdateExpression[`${e.prefix}`] : d[e.type]),
    m = { AccessorIsGenerator: ({ kind: e }) => `A ${e}ter cannot be a generator.`, ArgumentsInClass: "'arguments' is only allowed in functions and class methods.", AsyncFunctionInSingleStatementContext: 'Async functions can only be declared at the top level or inside a block.', AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.", AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.", AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.", AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.", BadGetterArity: "A 'get' accessor must not have any formal parameters.", BadSetterArity: "A 'set' accessor must have exactly one formal parameter.", BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.", ConstructorClassField: "Classes may not have a field named 'constructor'.", ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.", ConstructorIsAccessor: 'Class constructor may not be an accessor.', ConstructorIsAsync: "Constructor can't be an async function.", ConstructorIsGenerator: "Constructor can't be a generator.", DeclarationMissingInitializer: ({ kind: e }) => `Missing initializer in ${e} declaration.`, DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.", DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.", DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.", DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?", DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.", DecoratorSemicolon: 'Decorators must not be followed by a semicolon.', DecoratorStaticBlock: "Decorators can't be used with a static block.", DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.', DeletePrivateField: 'Deleting a private field is not allowed.', DestructureNamedImport: 'ES2015 named imports do not destructure. Use another statement for destructuring after the import.', DuplicateConstructor: 'Duplicate constructor in the same class.', DuplicateDefaultExport: 'Only one default export allowed per module.', DuplicateExport: ({ exportName: e }) => `\`${e}\` has already been exported. Exported identifiers must be unique.`, DuplicateProto: 'Redefinition of __proto__ property.', DuplicateRegExpFlags: 'Duplicate regular expression flag.', ElementAfterRest: 'Rest element must be last element.', EscapedCharNotAnIdentifier: 'Invalid Unicode escape.', ExportBindingIsString: ({ localName: e, exportName: t }) => `A string literal cannot be used as an exported binding without \`from\`.\n- Did you mean \`export { '${e}' as '${t}' } from 'some-module'\`?`, ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.", ForInOfLoopInitializer: ({ type: e }) => `'${'ForInStatement' === e ? 'for-in' : 'for-of'}' loop variable declaration may not have an initializer.`, ForInUsing: "For-in loop may not start with 'using' declaration.", ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.", ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.", GeneratorInSingleStatementContext: 'Generators can only be declared at the top level or inside a block.', IllegalBreakContinue: ({ type: e }) => `Unsyntactic ${'BreakStatement' === e ? 'break' : 'continue'}.`, IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.", IllegalReturn: "'return' outside of function.", ImportAttributesUseAssert: 'The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedImportAssert` parser plugin to suppress this error.', ImportBindingIsString: ({ importName: e }) => `A string literal cannot be used as an imported binding.\n- Did you mean \`import { "${e}" as foo }\`?`, ImportCallArity: '`import()` requires exactly one or two arguments.', ImportCallNotNewExpression: 'Cannot use new with import(...).', ImportCallSpreadArgument: '`...` is not allowed in `import()`.', ImportJSONBindingNotDefault: 'A JSON module can only be imported with `default`.', ImportReflectionHasAssertion: '`import module x` cannot have assertions.', ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.', IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.", InvalidBigIntLiteral: 'Invalid BigIntLiteral.', InvalidCodePoint: 'Code point out of bounds.', InvalidCoverDiscardElement: "'void' must be followed by an expression when not used in a binding position.", InvalidCoverInitializedName: 'Invalid shorthand property initializer.', InvalidDecimal: 'Invalid decimal.', InvalidDigit: ({ radix: e }) => `Expected number in radix ${e}.`, InvalidEscapeSequence: 'Bad character escape sequence.', InvalidEscapeSequenceTemplate: 'Invalid escape sequence in template.', InvalidEscapedReservedWord: ({ reservedWord: e }) => `Escape sequence in keyword ${e}.`, InvalidIdentifier: ({ identifierName: e }) => `Invalid identifier ${e}.`, InvalidLhs: ({ ancestor: e }) => `Invalid left-hand side in ${f(e)}.`, InvalidLhsBinding: ({ ancestor: e }) => `Binding invalid left-hand side in ${f(e)}.`, InvalidLhsOptionalChaining: ({ ancestor: e }) => `Invalid optional chaining in the left-hand side of ${f(e)}.`, InvalidNumber: 'Invalid number.', InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.", InvalidOrUnexpectedToken: ({ unexpected: e }) => `Unexpected character '${e}'.`, InvalidParenthesizedAssignment: 'Invalid parenthesized assignment pattern.', InvalidPrivateFieldResolution: ({ identifierName: e }) => `Private name #${e} is not defined.`, InvalidPropertyBindingPattern: 'Binding member expression.', InvalidRecordProperty: 'Only properties and spread elements are allowed in record definitions.', InvalidRestAssignmentPattern: "Invalid rest operator's argument.", LabelRedeclaration: ({ labelName: e }) => `Label '${e}' is already declared.`, LetInLexicalBinding: "'let' is disallowed as a lexically bound name.", LineTerminatorBeforeArrow: "No line break is allowed before '=>'.", MalformedRegExpFlags: 'Invalid regular expression flag.', MissingClassName: 'A class name is required.', MissingEqInAssignment: "Only '=' operator can be used for specifying default value.", MissingSemicolon: 'Missing semicolon.', MissingPlugin: ({ missingPlugin: e }) => `This experimental syntax requires enabling the parser plugin: ${e.map((e) => JSON.stringify(e)).join(', ')}.`, MissingOneOfPlugins: ({ missingPlugin: e }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${e.map((e) => JSON.stringify(e)).join(', ')}.`, MissingUnicodeEscape: 'Expecting Unicode escape sequence \\uXXXX.', MixingCoalesceWithLogical: 'Nullish coalescing operator(??) requires parens when mixing with logical operators.', ModuleAttributeDifferentFromType: 'The only accepted module attribute is `type`.', ModuleAttributeInvalidValue: 'Only string literals are allowed as module attribute values.', ModuleAttributesWithDuplicateKeys: ({ key: e }) => `Duplicate key "${e}" is not allowed in module attributes.`, ModuleExportNameHasLoneSurrogate: ({ surrogateCharCode: e }) => `An export name cannot include a lone surrogate, found '\\u${e.toString(16)}'.`, ModuleExportUndefined: ({ localName: e }) => `Export '${e}' is not defined.`, MultipleDefaultsInSwitch: 'Multiple default clauses.', NewlineAfterThrow: 'Illegal newline after throw.', NoCatchOrFinally: 'Missing catch or finally clause.', NumberIdentifier: 'Identifier directly after number.', NumericSeparatorInEscapeSequence: 'Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.', ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.", OptionalChainingNoNew: 'Constructors in/after an Optional Chain are not allowed.', OptionalChainingNoTemplate: 'Tagged Template Literals are not allowed in optionalChain.', OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.", ParamDupe: 'Argument name clash.', PatternHasAccessor: "Object pattern can't contain getter or setter.", PatternHasMethod: "Object pattern can't contain methods.", PrivateInExpectedIn: ({ identifierName: e }) => `Private names are only allowed in property accesses (\`obj.#${e}\`) or in \`in\` expressions (\`#${e} in obj\`).`, PrivateNameRedeclaration: ({ identifierName: e }) => `Duplicate private name #${e}.`, RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", RecordNoProto: "'__proto__' is not allowed in Record expressions.", RestTrailingComma: 'Unexpected trailing comma after rest element.', SloppyFunction: 'In non-strict mode code, functions can only be declared at top level or inside a block.', SloppyFunctionAnnexB: 'In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.', SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.', StaticPrototype: 'Classes may not have static property named prototype.', SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?", SuperPrivateField: "Private fields can't be accessed on super.", TrailingDecorator: 'Decorators must be attached to a class element.', TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", UnexpectedArgumentPlaceholder: 'Unexpected argument placeholder.', UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.', UnexpectedDigitAfterHash: 'Unexpected digit after hash token.', UnexpectedImportExport: "'import' and 'export' may only appear at the top level.", UnexpectedKeyword: ({ keyword: e }) => `Unexpected keyword '${e}'.`, UnexpectedLeadingDecorator: 'Leading decorators must be attached to a class declaration.', UnexpectedLexicalDeclaration: 'Lexical declaration cannot appear in a single-statement context.', UnexpectedNewTarget: '`new.target` can only be used in functions or class properties.', UnexpectedNumericSeparator: 'A numeric separator is only allowed between two digits.', UnexpectedPrivateField: 'Unexpected private name.', UnexpectedReservedWord: ({ reservedWord: e }) => `Unexpected reserved word '${e}'.`, UnexpectedSuper: "'super' is only allowed in object methods and classes.", UnexpectedToken: ({ expected: e, unexpected: t }) => `Unexpected token${t ? ` '${t}'.` : ''}${e ? `, expected "${e}"` : ''}`, UnexpectedTokenUnaryExponentiation: 'Illegal expression. Wrap left hand side or entire exponentiation in parentheses.', UnexpectedUsingDeclaration: 'Using declaration cannot appear in the top level when source type is `script` or in the bare case statement.', UnexpectedVoidPattern: 'Unexpected void binding.', UnsupportedBind: 'Binding should be performed on object property.', UnsupportedDecoratorExport: 'A decorated export must export a class declaration.', UnsupportedDefaultExport: 'Only expressions, functions or classes are allowed as the `default` export.', UnsupportedImport: '`import` can only be used in `import()` or `import.meta`.', UnsupportedMetaProperty: ({ target: e, onlyValidPropertyName: t }) => `The only valid meta property for ${e} is ${e}.${t}.`, UnsupportedParameterDecorator: 'Decorators cannot be used to decorate parameters.', UnsupportedPropertyDecorator: 'Decorators cannot be used to decorate object literal properties.', UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).", UnterminatedComment: 'Unterminated comment.', UnterminatedRegExp: 'Unterminated regular expression.', UnterminatedString: 'Unterminated string constant.', UnterminatedTemplate: 'Unterminated template.', UsingDeclarationExport: 'Using declaration cannot be exported.', UsingDeclarationHasBindingPattern: 'Using declaration cannot have destructuring patterns.', VarRedeclaration: ({ identifierName: e }) => `Identifier '${e}' has already been declared.`, VoidPatternCatchClauseParam: 'A void binding can not be the catch clause parameter. Use `try { ... } catch { ... }` if you want to discard the caught error.', VoidPatternInitializer: 'A void binding may not have an initializer.', YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.", YieldInParameter: 'Yield expression is not allowed in formal parameters.', YieldNotInGeneratorFunction: "'yield' is only allowed within generator functions.", ZeroDigitNumericSeparator: 'Numeric separator can not be used after leading 0.' },
    y = { ParseExpressionEmptyInput: 'Unexpected parseExpression() input: The input is empty or contains only comments.', ParseExpressionExpectsEOF: ({ unexpected: e }) => `Unexpected parseExpression() input: The input should contain exactly one expression, but the first expression is followed by the unexpected character \`${String.fromCodePoint(e)}\`.` },
    D = new Set(['ArrowFunctionExpression', 'AssignmentExpression', 'ConditionalExpression', 'YieldExpression']),
    g = Object.assign({ PipeBodyIsTighter: 'Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.', PipeTopicRequiresHackPipes: 'Topic references are only supported when using the `"proposal": "hack"` version of the pipeline proposal.', PipeTopicUnbound: 'Topic reference is unbound; it must be inside a pipe body.', PipeTopicUnconfiguredToken: ({ token: e }) => `Invalid topic token ${e}. In order to use ${e} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${e}" }.`, PipeTopicUnused: 'Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.', PipeUnparenthesizedBody: ({ type: e }) => `Hack-style pipe body cannot be an unparenthesized ${f({ type: e })}; please wrap it in parentheses.` }, {}),
    x = ['message'];
   function E(e, t, r) {
    Object.defineProperty(e, t, { enumerable: !1, configurable: !0, value: r });
   }
   function b({ toMessage: e, code: t, reasonCode: r, syntaxPlugin: s }) {
    let n = 'MissingPlugin' === r || 'MissingOneOfPlugins' === r;
    return function i(a, o) {
     let l = new SyntaxError();
     return (
      (l.code = t),
      (l.reasonCode = r),
      (l.loc = a),
      (l.pos = a.index),
      (l.syntaxPlugin = s),
      n && (l.missingPlugin = o.missingPlugin),
      E(l, 'clone', function (e = {}) {
       let { line: t, column: r, index: s } = e.loc ?? a;
       return i(new u(t, r, s), Object.assign({}, o, e.details));
      }),
      E(l, 'details', o),
      Object.defineProperty(l, 'message', {
       configurable: !0,
       get() {
        let t = `${e(o)} (${a.line}:${a.column})`;
        return ((this.message = t), t);
       },
       set(e) {
        Object.defineProperty(this, 'message', { value: e, writable: !0 });
       },
      }),
      l
     );
    };
   }
   function T(e, t) {
    if (Array.isArray(e)) return (t) => T(t, e[0]);
    let r = {};
    for (let s of Object.keys(e)) {
     let n = e[s],
      i = 'string' == typeof n ? { message: () => n } : 'function' == typeof n ? { message: n } : n,
      { message: a } = i,
      u = o(i, x),
      l = 'string' == typeof a ? () => a : a;
     r[s] = b(Object.assign({ code: 'BABEL_PARSER_SYNTAX_ERROR', reasonCode: s, toMessage: l }, t ? { syntaxPlugin: t } : {}, u));
    }
    return r;
   }
   var C = Object.assign({}, T(h), T(m), T({ StrictDelete: 'Deleting local variable in strict mode.', StrictEvalArguments: ({ referenceName: e }) => `Assigning to '${e}' in strict mode.`, StrictEvalArgumentsBinding: ({ bindingName: e }) => `Binding '${e}' in strict mode.`, StrictFunction: 'In strict mode code, functions can only be declared at top level or inside a block.', StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.", StrictOctalLiteral: 'Legacy octal literals are not allowed in strict mode.', StrictWith: "'with' in strict mode." }), T(y), T`pipelineOperator`(g));
   var { defineProperty: F } = Object,
    A = (e, t) => {
     e && F(e, t, { enumerable: !1, value: e[t] });
    };
   function w(e) {
    return (A(e.loc.start, 'index'), A(e.loc.end, 'index'), e);
   }
   var S = class {
     constructor(e, t) {
      ((this.token = e), (this.preserveSpace = !!t));
     }
     token;
     preserveSpace;
    },
    v = { brace: new S('{'), j_oTag: new S('<tag'), j_cTag: new S('</tag'), j_expr: new S('<tag>...</tag>', !0) },
    P = !0,
    k = !0,
    I = !0,
    N = !0,
    B = !0,
    O = class {
     label;
     keyword;
     beforeExpr;
     startsExpr;
     rightAssociative;
     isLoop;
     isAssign;
     prefix;
     postfix;
     binop;
     constructor(e, t = {}) {
      ((this.label = e), (this.keyword = t.keyword), (this.beforeExpr = !!t.beforeExpr), (this.startsExpr = !!t.startsExpr), (this.rightAssociative = !!t.rightAssociative), (this.isLoop = !!t.isLoop), (this.isAssign = !!t.isAssign), (this.prefix = !!t.prefix), (this.postfix = !!t.postfix), (this.binop = null != t.binop ? t.binop : null));
     }
    },
    L = new Map();
   function M(e, t = {}) {
    t.keyword = e;
    let r = V(e, t);
    return (L.set(e, r), r);
   }
   function j(e, t) {
    return V(e, { beforeExpr: P, binop: t });
   }
   var _ = -1,
    R = [],
    U = [],
    $ = [],
    q = [],
    J = [],
    W = [];
   function V(e, t = {}) {
    return (++_, U.push(e), $.push(t.binop ?? -1), q.push(t.beforeExpr ?? !1), J.push(t.startsExpr ?? !1), W.push(t.prefix ?? !1), R.push(new O(e, t)), _);
   }
   function z(e, t = {}) {
    return (++_, L.set(e, _), U.push(e), $.push(t.binop ?? -1), q.push(t.beforeExpr ?? !1), J.push(t.startsExpr ?? !1), W.push(t.prefix ?? !1), R.push(new O('name', t)), _);
   }
   var H = { bracketL: V('[', { beforeExpr: P, startsExpr: k }), bracketHashL: V('#[', { beforeExpr: P, startsExpr: k }), bracketBarL: V('[|', { beforeExpr: P, startsExpr: k }), bracketR: V(']'), bracketBarR: V('|]'), braceL: V('{', { beforeExpr: P, startsExpr: k }), braceBarL: V('{|', { beforeExpr: P, startsExpr: k }), braceHashL: V('#{', { beforeExpr: P, startsExpr: k }), braceR: V('}'), braceBarR: V('|}'), parenL: V('(', { beforeExpr: P, startsExpr: k }), parenR: V(')'), comma: V(',', { beforeExpr: P }), semi: V(';', { beforeExpr: P }), colon: V(':', { beforeExpr: P }), doubleColon: V('::', { beforeExpr: P }), dot: V('.'), question: V('?', { beforeExpr: P }), questionDot: V('?.'), arrow: V('=>', { beforeExpr: P }), template: V('template'), ellipsis: V('...', { beforeExpr: P }), backQuote: V('`', { startsExpr: k }), dollarBraceL: V('${', { beforeExpr: P, startsExpr: k }), templateTail: V('...`', { startsExpr: k }), templateNonTail: V('...${', { beforeExpr: P, startsExpr: k }), at: V('@'), hash: V('#', { startsExpr: k }), interpreterDirective: V('#!...'), eq: V('=', { beforeExpr: P, isAssign: N }), assign: V('_=', { beforeExpr: P, isAssign: N }), slashAssign: V('_=', { beforeExpr: P, isAssign: N }), xorAssign: V('_=', { beforeExpr: P, isAssign: N }), moduloAssign: V('_=', { beforeExpr: P, isAssign: N }), incDec: V('++/--', { prefix: B, postfix: !0, startsExpr: k }), bang: V('!', { beforeExpr: P, prefix: B, startsExpr: k }), tilde: V('~', { beforeExpr: P, prefix: B, startsExpr: k }), doubleCaret: V('^^', { startsExpr: k }), doubleAt: V('@@', { startsExpr: k }), pipeline: j('|>', 0), nullishCoalescing: j('??', 1), logicalOR: j('||', 1), logicalAND: j('&&', 2), bitwiseOR: j('|', 3), bitwiseXOR: j('^', 4), bitwiseAND: j('&', 5), equality: j('==/!=/===/!==', 6), lt: j('</>/<=/>=', 7), gt: j('</>/<=/>=', 7), relational: j('</>/<=/>=', 7), bitShift: j('<</>>/>>>', 8), bitShiftL: j('<</>>/>>>', 8), bitShiftR: j('<</>>/>>>', 8), plusMin: V('+/-', { beforeExpr: P, binop: 9, prefix: B, startsExpr: k }), modulo: V('%', { binop: 10, startsExpr: k }), star: V('*', { binop: 10 }), slash: j('/', 10), exponent: V('**', { beforeExpr: P, binop: 11, rightAssociative: !0 }), _in: M('in', { beforeExpr: P, binop: 7 }), _instanceof: M('instanceof', { beforeExpr: P, binop: 7 }), _break: M('break'), _case: M('case', { beforeExpr: P }), _catch: M('catch'), _continue: M('continue'), _debugger: M('debugger'), _default: M('default', { beforeExpr: P }), _else: M('else', { beforeExpr: P }), _finally: M('finally'), _function: M('function', { startsExpr: k }), _if: M('if'), _return: M('return', { beforeExpr: P }), _switch: M('switch'), _throw: M('throw', { beforeExpr: P, prefix: B, startsExpr: k }), _try: M('try'), _var: M('var'), _const: M('const'), _with: M('with'), _new: M('new', { beforeExpr: P, startsExpr: k }), _this: M('this', { startsExpr: k }), _super: M('super', { startsExpr: k }), _class: M('class', { startsExpr: k }), _extends: M('extends', { beforeExpr: P }), _export: M('export'), _import: M('import', { startsExpr: k }), _null: M('null', { startsExpr: k }), _true: M('true', { startsExpr: k }), _false: M('false', { startsExpr: k }), _typeof: M('typeof', { beforeExpr: P, prefix: B, startsExpr: k }), _void: M('void', { beforeExpr: P, prefix: B, startsExpr: k }), _delete: M('delete', { beforeExpr: P, prefix: B, startsExpr: k }), _do: M('do', { isLoop: I, beforeExpr: P }), _for: M('for', { isLoop: I }), _while: M('while', { isLoop: I }), _as: z('as', { startsExpr: k }), _assert: z('assert', { startsExpr: k }), _async: z('async', { startsExpr: k }), _await: z('await', { startsExpr: k }), _defer: z('defer', { startsExpr: k }), _from: z('from', { startsExpr: k }), _get: z('get', { startsExpr: k }), _let: z('let', { startsExpr: k }), _meta: z('meta', { startsExpr: k }), _of: z('of', { startsExpr: k }), _sent: z('sent', { startsExpr: k }), _set: z('set', { startsExpr: k }), _source: z('source', { startsExpr: k }), _static: z('static', { startsExpr: k }), _using: z('using', { startsExpr: k }), _yield: z('yield', { startsExpr: k }), _asserts: z('asserts', { startsExpr: k }), _checks: z('checks', { startsExpr: k }), _exports: z('exports', { startsExpr: k }), _global: z('global', { startsExpr: k }), _implements: z('implements', { startsExpr: k }), _intrinsic: z('intrinsic', { startsExpr: k }), _infer: z('infer', { startsExpr: k }), _is: z('is', { startsExpr: k }), _mixins: z('mixins', { startsExpr: k }), _proto: z('proto', { startsExpr: k }), _require: z('require', { startsExpr: k }), _satisfies: z('satisfies', { startsExpr: k }), _keyof: z('keyof', { startsExpr: k }), _readonly: z('readonly', { startsExpr: k }), _unique: z('unique', { startsExpr: k }), _abstract: z('abstract', { startsExpr: k }), _declare: z('declare', { startsExpr: k }), _enum: z('enum', { startsExpr: k }), _module: z('module', { startsExpr: k }), _namespace: z('namespace', { startsExpr: k }), _interface: z('interface', { startsExpr: k }), _type: z('type', { startsExpr: k }), _opaque: z('opaque', { startsExpr: k }), name: V('name', { startsExpr: k }), placeholder: V('%%', { startsExpr: k }), string: V('string', { startsExpr: k }), num: V('num', { startsExpr: k }), bigint: V('bigint', { startsExpr: k }), decimal: V('decimal', { startsExpr: k }), regexp: V('regexp', { startsExpr: k }), privateName: V('#name', { startsExpr: k }), eof: V('eof'), jsxName: V('jsxName'), jsxText: V('jsxText', { beforeExpr: P }), jsxTagStart: V('jsxTagStart', { startsExpr: k }), jsxTagEnd: V('jsxTagEnd') };
   function X(e) {
    return e >= 93 && e <= 133;
   }
   function K(e) {
    return e >= 58 && e <= 133;
   }
   function G(e) {
    return e >= 58 && e <= 137;
   }
   function Y(e) {
    return J[e];
   }
   function Q(e) {
    return e >= 129 && e <= 131;
   }
   function Z(e) {
    return e >= 58 && e <= 92;
   }
   function ee(e) {
    return U[e];
   }
   function te(e) {
    return $[e];
   }
   function re(e) {
    return e >= 24 && e <= 25;
   }
   function se(e) {
    return R[e];
   }
   var ne = '\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u0870-\u0887\u0889-\u088f\u08a0-\u08c9\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c5c\u0c5d\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cdc-\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d04-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u1711\u171f-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4c\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c8a\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31bf\u31f0-\u31ff\u3400-\u4dbf\u4e00-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7dc\ua7f1-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab69\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc',
    ie = '\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u0897-\u089f\u08ca-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b55-\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3c\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0cf3\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d81-\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ece\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u180f-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1abf-\u1add\u1ae0-\u1aeb\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1dff\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\u30fb\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua82c\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f\uff65',
    ae = new RegExp('[' + ne + ']'),
    oe = new RegExp('[' + ne + ie + ']');
   ne = ie = null;
   var ue = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 7, 25, 39, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 5, 57, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 24, 43, 261, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 33, 24, 3, 24, 45, 74, 6, 0, 67, 12, 65, 1, 2, 0, 15, 4, 10, 7381, 42, 31, 98, 114, 8702, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 208, 30, 2, 2, 2, 1, 2, 6, 3, 4, 10, 1, 225, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4381, 3, 5773, 3, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 8489],
    le = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 78, 5, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 199, 7, 137, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 55, 9, 266, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 233, 0, 3, 0, 8, 1, 6, 0, 475, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
   function pe(e, t) {
    let r = 65536;
    for (let s = 0, n = t.length; s < n; s += 2) {
     if (((r += t[s]), r > e)) return !1;
     if (((r += t[s + 1]), r >= e)) return !0;
    }
    return !1;
   }
   function ce(e) {
    return e < 65 ? 36 === e : e <= 90 || (e < 97 ? 95 === e : e <= 122 || (e <= 65535 ? e >= 170 && ae.test(String.fromCharCode(e)) : pe(e, ue)));
   }
   function he(e) {
    return e < 48 ? 36 === e : e < 58 || (!(e < 65) && (e <= 90 || (e < 97 ? 95 === e : e <= 122 || (e <= 65535 ? e >= 170 && oe.test(String.fromCharCode(e)) : pe(e, ue) || pe(e, le)))));
   }
   var de = ['implements', 'interface', 'let', 'package', 'private', 'protected', 'public', 'static', 'yield'],
    fe = ['eval', 'arguments'],
    me = new Set(['break', 'case', 'catch', 'continue', 'debugger', 'default', 'do', 'else', 'finally', 'for', 'function', 'if', 'return', 'switch', 'throw', 'try', 'var', 'const', 'while', 'with', 'new', 'this', 'super', 'class', 'extends', 'export', 'import', 'null', 'true', 'false', 'in', 'instanceof', 'typeof', 'void', 'delete']),
    ye = new Set(de),
    De = new Set(fe);
   function ge(e, t) {
    return (t && 'await' === e) || 'enum' === e;
   }
   function xe(e, t) {
    return ge(e, t) || ye.has(e);
   }
   function Ee(e) {
    return De.has(e);
   }
   function be(e, t) {
    return xe(e, t) || Ee(e);
   }
   var Te = new Set(['break', 'case', 'catch', 'continue', 'debugger', 'default', 'do', 'else', 'finally', 'for', 'function', 'if', 'return', 'switch', 'throw', 'try', 'var', 'const', 'while', 'with', 'new', 'this', 'super', 'class', 'extends', 'export', 'import', 'null', 'true', 'false', 'in', 'instanceof', 'typeof', 'void', 'delete', 'implements', 'interface', 'let', 'package', 'private', 'protected', 'public', 'static', 'yield', 'eval', 'arguments', 'enum', 'await']);
   var Ce = class {
     flags = 0;
     names = new Map();
     firstLexicalName = '';
     constructor(e) {
      this.flags = e;
     }
    },
    Fe = class {
     parser;
     scopeStack = [];
     inModule;
     undefinedExports = new Map();
     constructor(e, t) {
      ((this.parser = e), (this.inModule = t));
     }
     get inTopLevel() {
      return (1 & this.currentScope().flags) > 0;
     }
     get inFunction() {
      return (2 & this.currentVarScopeFlags()) > 0;
     }
     get allowSuper() {
      return (16 & this.currentThisScopeFlags()) > 0;
     }
     get allowDirectSuper() {
      return (32 & this.currentThisScopeFlags()) > 0;
     }
     get allowNewTarget() {
      return (512 & this.currentThisScopeFlags()) > 0;
     }
     get inClass() {
      return (64 & this.currentThisScopeFlags()) > 0;
     }
     get inClassAndNotInNonArrowFunction() {
      let e = this.currentThisScopeFlags();
      return (64 & e) > 0 && 0 == (2 & e);
     }
     get inStaticBlock() {
      for (let e = this.scopeStack.length - 1; ; e--) {
       let { flags: t } = this.scopeStack[e];
       if (128 & t) return !0;
       if (1731 & t) return !1;
      }
     }
     get inNonArrowFunction() {
      return (2 & this.currentThisScopeFlags()) > 0;
     }
     get inBareCaseStatement() {
      return (256 & this.currentScope().flags) > 0;
     }
     get treatFunctionsAsVar() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
     }
     createScope(e) {
      return new Ce(e);
     }
     enter(e) {
      this.scopeStack.push(this.createScope(e));
     }
     exit() {
      return this.scopeStack.pop().flags;
     }
     treatFunctionsAsVarInScope(e) {
      return !!(130 & e.flags || (!this.parser.inModule && 1 & e.flags));
     }
     declareName(e, t, r) {
      let s = this.currentScope();
      if (8 & t || 16 & t) {
       this.checkRedeclarationInScope(s, e, t, r);
       let n = s.names.get(e) || 0;
       (16 & t ? (n |= 4) : (s.firstLexicalName || (s.firstLexicalName = e), (n |= 2)), s.names.set(e, n), 8 & t && this.maybeExportDefined(s, e));
      } else if (4 & t) for (let n = this.scopeStack.length - 1; n >= 0 && ((s = this.scopeStack[n]), this.checkRedeclarationInScope(s, e, t, r), s.names.set(e, 1 | (s.names.get(e) || 0)), this.maybeExportDefined(s, e), !(1667 & s.flags)); --n);
      this.parser.inModule && 1 & s.flags && this.undefinedExports.delete(e);
     }
     maybeExportDefined(e, t) {
      this.parser.inModule && 1 & e.flags && this.undefinedExports.delete(t);
     }
     checkRedeclarationInScope(e, t, r, s) {
      this.isRedeclaredInScope(e, t, r) && this.parser.raise(C.VarRedeclaration, s, { identifierName: t });
     }
     isRedeclaredInScope(e, t, r) {
      if (!(1 & r)) return !1;
      if (8 & r) return e.names.has(t);
      let s = e.names.get(t) || 0;
      return 16 & r ? (2 & s) > 0 || (!this.treatFunctionsAsVarInScope(e) && (1 & s) > 0) : ((2 & s) > 0 && !(8 & e.flags && e.firstLexicalName === t)) || (!this.treatFunctionsAsVarInScope(e) && (4 & s) > 0);
     }
     checkLocalExport(e) {
      let { name: t } = e;
      this.scopeStack[0].names.has(t) || this.undefinedExports.set(t, e.loc.start);
     }
     currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
     }
     currentVarScopeFlags() {
      for (let e = this.scopeStack.length - 1; ; e--) {
       let { flags: t } = this.scopeStack[e];
       if (1667 & t) return t;
      }
     }
     currentThisScopeFlags() {
      for (let e = this.scopeStack.length - 1; ; e--) {
       let { flags: t } = this.scopeStack[e];
       if (1731 & t && !(4 & t)) return t;
      }
     }
    },
    Ae = class extends Ce {
     declareFunctions = new Set();
    },
    we = class extends Fe {
     createScope(e) {
      return new Ae(e);
     }
     declareName(e, t, r) {
      let s = this.currentScope();
      if (2048 & t) return (this.checkRedeclarationInScope(s, e, t, r), this.maybeExportDefined(s, e), void s.declareFunctions.add(e));
      super.declareName(e, t, r);
     }
     isRedeclaredInScope(e, t, r) {
      if (super.isRedeclaredInScope(e, t, r)) return !0;
      if (2048 & r && !e.declareFunctions.has(t)) {
       let r = e.names.get(t);
       return (4 & r) > 0 || (2 & r) > 0;
      }
      return !1;
     }
     checkLocalExport(e) {
      this.scopeStack[0].declareFunctions.has(e.name) || super.checkLocalExport(e);
     }
    },
    Se = new Set(['_', 'any', 'bool', 'boolean', 'empty', 'extends', 'false', 'interface', 'mixed', 'null', 'number', 'static', 'string', 'true', 'typeof', 'void']),
    ve = T`flow`({ AmbiguousConditionalArrow: 'Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.', AmbiguousDeclareModuleKind: 'Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.', AssignReservedType: ({ reservedType: e }) => `Cannot overwrite reserved type ${e}.`, DeclareClassElement: 'The `declare` modifier can only appear on class fields.', DeclareClassFieldInitializer: 'Initializers are not allowed in fields with the `declare` modifier.', DuplicateDeclareModuleExports: 'Duplicate `declare module.exports` statement.', EnumBooleanMemberNotInitialized: ({ memberName: e, enumName: t }) => `Boolean enum members need to be initialized. Use either \`${e} = true,\` or \`${e} = false,\` in enum \`${t}\`.`, EnumDuplicateMemberName: ({ memberName: e, enumName: t }) => `Enum member names need to be unique, but the name \`${e}\` has already been used before in enum \`${t}\`.`, EnumInconsistentMemberValues: ({ enumName: e }) => `Enum \`${e}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`, EnumInvalidExplicitType: ({ invalidEnumType: e, enumName: t }) => `Enum type \`${e}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${t}\`.`, EnumInvalidExplicitTypeUnknownSupplied: ({ enumName: e }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${e}\`.`, EnumInvalidMemberInitializerPrimaryType: ({ enumName: e, memberName: t, explicitType: r }) => `Enum \`${e}\` has type \`${r}\`, so the initializer of \`${t}\` needs to be a ${r} literal.`, EnumInvalidMemberInitializerSymbolType: ({ enumName: e, memberName: t }) => `Symbol enum members cannot be initialized. Use \`${t},\` in enum \`${e}\`.`, EnumInvalidMemberInitializerUnknownType: ({ enumName: e, memberName: t }) => `The enum member initializer for \`${t}\` needs to be a literal (either a boolean, number, or string) in enum \`${e}\`.`, EnumInvalidMemberName: ({ enumName: e, memberName: t, suggestion: r }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${t}\`, consider using \`${r}\`, in enum \`${e}\`.`, EnumNumberMemberNotInitialized: ({ enumName: e, memberName: t }) => `Number enum members need to be initialized, e.g. \`${t} = 1\` in enum \`${e}\`.`, EnumStringMemberInconsistentlyInitialized: ({ enumName: e }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${e}\`.`, GetterMayNotHaveThisParam: 'A getter cannot have a `this` parameter.', ImportReflectionHasImportType: 'An `import module` declaration can not use `type` or `typeof` keyword.', ImportTypeShorthandOnlyInPureImport: 'The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.', InexactInsideExact: 'Explicit inexact syntax cannot appear inside an explicit exact object type.', InexactInsideNonObject: 'Explicit inexact syntax cannot appear in class or interface definitions.', InexactVariance: 'Explicit inexact syntax cannot have variance.', InvalidNonTypeImportInDeclareModule: 'Imports within a `declare module` body must always be `import type` or `import typeof`.', MissingTypeParamDefault: 'Type parameter declaration needs a default, since a preceding type parameter declaration has a default.', NestedDeclareModule: '`declare module` cannot be used inside another `declare module`.', NestedFlowComment: 'Cannot have a flow comment inside another flow comment.', PatternIsOptional: Object.assign({ message: 'A binding pattern parameter cannot be optional in an implementation signature.' }, {}), SetterMayNotHaveThisParam: 'A setter cannot have a `this` parameter.', SpreadVariance: 'Spread properties cannot have variance.', ThisParamAnnotationRequired: 'A type annotation is required for the `this` parameter.', ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.", ThisParamMayNotBeOptional: 'The `this` parameter cannot be optional.', ThisParamMustBeFirst: 'The `this` parameter must be the first function parameter.', ThisParamNoDefault: 'The `this` parameter may not have a default value.', TypeBeforeInitializer: 'Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.', TypeCastInPattern: 'The type cast expression is expected to be wrapped with parenthesis.', UnexpectedExplicitInexactInObject: 'Explicit inexact syntax must appear at the end of an inexact object.', UnexpectedReservedType: ({ reservedType: e }) => `Unexpected reserved type ${e}.`, UnexpectedReservedUnderscore: '`_` is only allowed as a type argument to call or new.', UnexpectedSpaceBetweenModuloChecks: 'Spaces between `%` and `checks` are not allowed here.', UnexpectedSpreadType: 'Spread operator cannot appear in class or interface definitions.', UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".', UnexpectedTokenAfterTypeParameter: 'Expected an arrow function after this type parameter declaration.', UnexpectedTypeParameterBeforeAsyncArrowFunction: 'Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.', UnsupportedDeclareExportKind: ({ unsupportedExportKind: e, suggestion: t }) => `\`declare export ${e}\` is not supported. Use \`${t}\` instead.`, UnsupportedStatementInDeclareModule: 'Only declares and type imports are allowed inside declare module.', UnterminatedFlowComment: 'Unterminated flow-comment.' });
   function Pe(e) {
    return 'type' === e.importKind || 'typeof' === e.importKind;
   }
   var ke = { const: 'declare export var', let: 'declare export var', type: 'export type', interface: 'export interface' };
   var Ie = /\*?\s*@((?:no)?flow)\b/,
    Ne = new RegExp(/\r\n|[\r\n\u2028\u2029]/.source, 'g');
   function Be(e) {
    switch (e) {
     case 10:
     case 13:
     case 8232:
     case 8233:
      return !0;
     default:
      return !1;
    }
   }
   function Oe(e, t, r) {
    for (let s = t; s < r; s++) if (Be(e.charCodeAt(s))) return !0;
    return !1;
   }
   var Le = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g,
    Me = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g;
   function je(e) {
    switch (e) {
     case 9:
     case 11:
     case 12:
     case 32:
     case 160:
     case 5760:
     case 8192:
     case 8193:
     case 8194:
     case 8195:
     case 8196:
     case 8197:
     case 8198:
     case 8199:
     case 8200:
     case 8201:
     case 8202:
     case 8239:
     case 8287:
     case 12288:
     case 65279:
      return !0;
     default:
      return !1;
    }
   }
   var _e = T`jsx`({ AttributeIsEmpty: 'JSX attributes must only be assigned a non-empty expression.', MissingClosingTagElement: ({ openingTagName: e }) => `Expected corresponding JSX closing tag for <${e}>.`, MissingClosingTagFragment: 'Expected corresponding JSX closing tag for <>.', UnexpectedSequenceExpression: 'Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?', UnexpectedToken: ({ unexpected: e, HTMLEntity: t }) => `Unexpected token \`${e}\`. Did you mean \`${t}\` or \`{'${e}'}\`?`, UnsupportedJsxValue: 'JSX value should be either an expression or a quoted JSX text.', UnterminatedJsxContent: 'Unterminated JSX contents.', UnwrappedAdjacentJSXElements: 'Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?' });
   function Re(e) {
    return !!e && ('JSXOpeningFragment' === e.type || 'JSXClosingFragment' === e.type);
   }
   function Ue(e) {
    if ('JSXIdentifier' === e.type) return e.name;
    if ('JSXNamespacedName' === e.type) return e.namespace.name + ':' + e.name.name;
    if ('JSXMemberExpression' === e.type) return Ue(e.object) + '.' + Ue(e.property);
    throw new Error('Node had unexpected type: ' + e.type);
   }
   var $e = class extends Ce {
     tsNames = new Map();
    },
    qe = class extends Fe {
     importsStack = [];
     createScope(e) {
      return (this.importsStack.push(new Set()), new $e(e));
     }
     enter(e) {
      (1024 === e && this.importsStack.push(new Set()), super.enter(e));
     }
     exit() {
      let e = super.exit();
      return (1024 === e && this.importsStack.pop(), e);
     }
     hasImport(e, t) {
      let r = this.importsStack.length;
      if (this.importsStack[r - 1].has(e)) return !0;
      if (!t && r > 1) for (let s = 0; s < r - 1; s++) if (this.importsStack[s].has(e)) return !0;
      return !1;
     }
     declareName(e, t, r) {
      if (4096 & t) return (this.hasImport(e, !0) && this.parser.raise(C.VarRedeclaration, r, { identifierName: e }), void this.importsStack[this.importsStack.length - 1].add(e));
      let s = this.currentScope(),
       n = s.tsNames.get(e) || 0;
      if (1024 & t) return (this.maybeExportDefined(s, e), void s.tsNames.set(e, 16 | n));
      (super.declareName(e, t, r), 2 & t && (1 & t || (this.checkRedeclarationInScope(s, e, t, r), this.maybeExportDefined(s, e)), (n |= 1)), 256 & t && (n |= 2), 512 & t && (n |= 4), 128 & t && (n |= 8), n && s.tsNames.set(e, n));
     }
     isRedeclaredInScope(e, t, r) {
      let s = e.tsNames.get(t);
      if ((2 & s) > 0) {
       if (256 & r) {
        return !!(512 & r) !== (4 & s) > 0;
       }
       return !0;
      }
      return 128 & r && (8 & s) > 0 ? !!(2 & e.names.get(t)) && !!(1 & r) : !!(2 & r && (1 & s) > 0) || super.isRedeclaredInScope(e, t, r);
     }
     checkLocalExport(e) {
      let { name: t } = e;
      if (!this.hasImport(t)) {
       for (let e = this.scopeStack.length - 1; e >= 0; e--) {
        let r = this.scopeStack[e].tsNames.get(t);
        if ((1 & r) > 0 || (16 & r) > 0) return;
       }
       super.checkLocalExport(e);
      }
     }
    },
    Je = class {
     stacks = [];
     enter(e) {
      this.stacks.push(e);
     }
     exit() {
      this.stacks.pop();
     }
     currentFlags() {
      return this.stacks[this.stacks.length - 1];
     }
     get hasAwait() {
      return (2 & this.currentFlags()) > 0;
     }
     get hasYield() {
      return (1 & this.currentFlags()) > 0;
     }
     get hasReturn() {
      return (4 & this.currentFlags()) > 0;
     }
     get hasIn() {
      return (8 & this.currentFlags()) > 0;
     }
    };
   function We(e, t) {
    return (e ? 2 : 0) | (t ? 1 : 0);
   }
   var Ve = class {
    sawUnambiguousESM = !1;
    ambiguousScriptDifferentAst = !1;
    sourceToOffsetPos(e) {
     return e + this.startIndex;
    }
    offsetToSourcePos(e) {
     return e - this.startIndex;
    }
    hasPlugin(e) {
     if ('string' == typeof e) return this.plugins.has(e);
     {
      let [t, r] = e;
      if (!this.hasPlugin(t)) return !1;
      let s = this.plugins.get(t);
      for (let e of Object.keys(r)) if (s?.[e] !== r[e]) return !1;
      return !0;
     }
    }
    getPluginOption(e, t) {
     return this.plugins.get(e)?.[t];
    }
   };
   function ze(e, t) {
    void 0 === e.trailingComments ? (e.trailingComments = t) : e.trailingComments.unshift(...t);
   }
   function He(e, t) {
    void 0 === e.innerComments ? (e.innerComments = t) : e.innerComments.unshift(...t);
   }
   function Xe(e, t, r) {
    let s = null,
     n = t.length;
    for (; null === s && n > 0; ) s = t[--n];
    null === s || s.start > r.start ? He(e, r.comments) : ze(s, r.comments);
   }
   var Ke = class extends Ve {
     addComment(e) {
      this.filename && (e.loc.filename = this.filename);
      let { commentsLen: t } = this.state;
      (this.comments.length !== t && (this.comments.length = t), this.comments.push(e), this.state.commentsLen++);
     }
     processComment(e) {
      let { commentStack: t } = this.state,
       r = t.length;
      if (0 === r) return;
      let s = r - 1,
       n = t[s];
      n.start === e.end && ((n.leadingNode = e), s--);
      let { start: i } = e;
      for (; s >= 0; s--) {
       let r = t[s],
        n = r.end;
       if (!(n > i)) {
        n === i && (r.trailingNode = e);
        break;
       }
       ((r.containingNode = e), this.finalizeComment(r), t.splice(s, 1));
      }
     }
     finalizeComment(e) {
      let { comments: t } = e;
      if (null !== e.leadingNode || null !== e.trailingNode)
       (null !== e.leadingNode && ze(e.leadingNode, t),
        null !== e.trailingNode &&
         (function (e, t) {
          void 0 === e.leadingComments ? (e.leadingComments = t) : e.leadingComments.unshift(...t);
         })(e.trailingNode, t));
      else {
       let r = e.containingNode,
        s = e.start;
       if (44 === this.input.charCodeAt(this.offsetToSourcePos(s) - 1))
        switch (r.type) {
         case 'ObjectExpression':
         case 'ObjectPattern':
         case 'RecordExpression':
          Xe(r, r.properties, e);
          break;
         case 'CallExpression':
         case 'OptionalCallExpression':
          Xe(r, r.arguments, e);
          break;
         case 'ImportExpression':
          Xe(r, [r.source, r.options ?? null], e);
          break;
         case 'FunctionDeclaration':
         case 'FunctionExpression':
         case 'ArrowFunctionExpression':
         case 'ObjectMethod':
         case 'ClassMethod':
         case 'ClassPrivateMethod':
          Xe(r, r.params, e);
          break;
         case 'ArrayExpression':
         case 'ArrayPattern':
         case 'TupleExpression':
          Xe(r, r.elements, e);
          break;
         case 'ExportNamedDeclaration':
         case 'ImportDeclaration':
          Xe(r, r.specifiers, e);
          break;
         case 'TSEnumDeclaration':
         default:
          He(r, t);
          break;
         case 'TSEnumBody':
          Xe(r, r.members, e);
        }
       else He(r, t);
      }
     }
     finalizeRemainingComments() {
      let { commentStack: e } = this.state;
      for (let t = e.length - 1; t >= 0; t--) this.finalizeComment(e[t]);
      this.state.commentStack = [];
     }
     resetPreviousNodeTrailingComments(e) {
      let { commentStack: t } = this.state,
       { length: r } = t;
      if (0 === r) return;
      let s = t[r - 1];
      s.leadingNode === e && (s.leadingNode = null);
     }
     takeSurroundingComments(e, t, r) {
      let { commentStack: s } = this.state,
       n = s.length;
      if (0 === n) return;
      let i = n - 1;
      for (; i >= 0; i--) {
       let n = s[i],
        a = n.end;
       if (n.start === r) n.leadingNode = e;
       else if (a === t) n.trailingNode = e;
       else if (a < t) break;
      }
     }
    },
    Ge = class e {
     flags = 1024;
     get strict() {
      return (1 & this.flags) > 0;
     }
     set strict(e) {
      e ? (this.flags |= 1) : (this.flags &= -2);
     }
     startIndex;
     curLine;
     lineStart;
     startLoc;
     endLoc;
     init({ strictMode: e, sourceType: t, startIndex: r, startLine: s, startColumn: n }) {
      ((this.strict = !1 !== e && (!0 === e || 'module' === t)), (this.startIndex = r), (this.curLine = s), (this.lineStart = -n), (this.startLoc = this.endLoc = new u(s, n, r)));
     }
     errors = [];
     potentialArrowAt = -1;
     noArrowAt = [];
     noArrowParamsConversionAt = [];
     get maybeInArrowParameters() {
      return (2 & this.flags) > 0;
     }
     set maybeInArrowParameters(e) {
      e ? (this.flags |= 2) : (this.flags &= -3);
     }
     get inType() {
      return (4 & this.flags) > 0;
     }
     set inType(e) {
      e ? (this.flags |= 4) : (this.flags &= -5);
     }
     get noAnonFunctionType() {
      return (8 & this.flags) > 0;
     }
     set noAnonFunctionType(e) {
      e ? (this.flags |= 8) : (this.flags &= -9);
     }
     get hasFlowComment() {
      return (16 & this.flags) > 0;
     }
     set hasFlowComment(e) {
      e ? (this.flags |= 16) : (this.flags &= -17);
     }
     get isAmbientContext() {
      return (32 & this.flags) > 0;
     }
     set isAmbientContext(e) {
      e ? (this.flags |= 32) : (this.flags &= -33);
     }
     get inAbstractClass() {
      return (64 & this.flags) > 0;
     }
     set inAbstractClass(e) {
      e ? (this.flags |= 64) : (this.flags &= -65);
     }
     get inDisallowConditionalTypesContext() {
      return (128 & this.flags) > 0;
     }
     set inDisallowConditionalTypesContext(e) {
      e ? (this.flags |= 128) : (this.flags &= -129);
     }
     topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null };
     get soloAwait() {
      return (256 & this.flags) > 0;
     }
     set soloAwait(e) {
      e ? (this.flags |= 256) : (this.flags &= -257);
     }
     get inFSharpPipelineDirectBody() {
      return (512 & this.flags) > 0;
     }
     set inFSharpPipelineDirectBody(e) {
      e ? (this.flags |= 512) : (this.flags &= -513);
     }
     labels = [];
     commentsLen = 0;
     commentStack = [];
     pos = 0;
     type = 140;
     value = null;
     start = 0;
     end = 0;
     lastTokEndLoc = null;
     lastTokStartLoc = null;
     context = [v.brace];
     get canStartJSXElement() {
      return (1024 & this.flags) > 0;
     }
     set canStartJSXElement(e) {
      e ? (this.flags |= 1024) : (this.flags &= -1025);
     }
     get containsEsc() {
      return (2048 & this.flags) > 0;
     }
     set containsEsc(e) {
      e ? (this.flags |= 2048) : (this.flags &= -2049);
     }
     firstInvalidTemplateEscapePos = null;
     get hasTopLevelAwait() {
      return (4096 & this.flags) > 0;
     }
     set hasTopLevelAwait(e) {
      e ? (this.flags |= 4096) : (this.flags &= -4097);
     }
     strictErrors = new Map();
     tokensLength = 0;
     curPosition() {
      return new u(this.curLine, this.pos - this.lineStart, this.pos + this.startIndex);
     }
     clone() {
      let t = new e();
      return ((t.flags = this.flags), (t.startIndex = this.startIndex), (t.curLine = this.curLine), (t.lineStart = this.lineStart), (t.startLoc = this.startLoc), (t.endLoc = this.endLoc), (t.errors = this.errors.slice()), (t.potentialArrowAt = this.potentialArrowAt), (t.noArrowAt = this.noArrowAt.slice()), (t.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice()), (t.topicContext = this.topicContext), (t.labels = this.labels.slice()), (t.commentsLen = this.commentsLen), (t.commentStack = this.commentStack.slice()), (t.pos = this.pos), (t.type = this.type), (t.value = this.value), (t.start = this.start), (t.end = this.end), (t.lastTokEndLoc = this.lastTokEndLoc), (t.lastTokStartLoc = this.lastTokStartLoc), (t.context = this.context.slice()), (t.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos), (t.strictErrors = this.strictErrors), (t.tokensLength = this.tokensLength), t);
     }
    },
    Ye = function (e) {
     return e >= 48 && e <= 57;
    },
    Qe = { decBinOct: new Set([46, 66, 69, 79, 95, 98, 101, 111]), hex: new Set([46, 88, 95, 120]) },
    Ze = { bin: (e) => 48 === e || 49 === e, oct: (e) => e >= 48 && e <= 55, dec: (e) => e >= 48 && e <= 57, hex: (e) => (e >= 48 && e <= 57) || (e >= 65 && e <= 70) || (e >= 97 && e <= 102) };
   function et(e, t, r, s, n, i) {
    let a = r,
     o = s,
     u = n,
     l = '',
     p = null,
     c = r,
     { length: h } = t;
    for (;;) {
     if (r >= h) {
      (i.unterminated(a, o, u), (l += t.slice(c, r)));
      break;
     }
     let d = t.charCodeAt(r);
     if (tt(e, d, t, r)) {
      l += t.slice(c, r);
      break;
     }
     if (92 === d) {
      l += t.slice(c, r);
      let a = rt(t, r, s, n, 'template' === e, i);
      (null !== a.ch || p ? (l += a.ch) : (p = { pos: r, lineStart: s, curLine: n }), ({ pos: r, lineStart: s, curLine: n } = a), (c = r));
     } else 8232 === d || 8233 === d ? (++n, (s = ++r)) : 10 === d || 13 === d ? ('template' === e ? ((l += t.slice(c, r) + '\n'), ++r, 13 === d && 10 === t.charCodeAt(r) && ++r, ++n, (c = s = r)) : i.unterminated(a, o, u)) : ++r;
    }
    return { pos: r, str: l, firstInvalidLoc: p, lineStart: s, curLine: n };
   }
   function tt(e, t, r, s) {
    return 'template' === e ? 96 === t || (36 === t && 123 === r.charCodeAt(s + 1)) : t === ('double' === e ? 34 : 39);
   }
   function rt(e, t, r, s, n, i) {
    let a = !n;
    t++;
    let o = (e) => ({ pos: t, ch: e, lineStart: r, curLine: s }),
     u = e.charCodeAt(t++);
    switch (u) {
     case 110:
      return o('\n');
     case 114:
      return o('\r');
     case 120: {
      let n;
      return (({ code: n, pos: t } = st(e, t, r, s, 2, !1, a, i)), o(null === n ? null : String.fromCharCode(n)));
     }
     case 117: {
      let n;
      return (({ code: n, pos: t } = it(e, t, r, s, a, i)), o(null === n ? null : String.fromCodePoint(n)));
     }
     case 116:
      return o('\t');
     case 98:
      return o('\b');
     case 118:
      return o('\v');
     case 102:
      return o('\f');
     case 13:
      10 === e.charCodeAt(t) && ++t;
     case 10:
      ((r = t), ++s);
     case 8232:
     case 8233:
      return o('');
     case 56:
     case 57:
      if (n) return o(null);
      i.strictNumericEscape(t - 1, r, s);
     default:
      if (u >= 48 && u <= 55) {
       let a = t - 1,
        u = /^[0-7]+/.exec(e.slice(a, t + 2))[0],
        l = parseInt(u, 8);
       (l > 255 && ((u = u.slice(0, -1)), (l = parseInt(u, 8))), (t += u.length - 1));
       let p = e.charCodeAt(t);
       if ('0' !== u || 56 === p || 57 === p) {
        if (n) return o(null);
        i.strictNumericEscape(a, r, s);
       }
       return o(String.fromCharCode(l));
      }
      return o(String.fromCharCode(u));
    }
   }
   function st(e, t, r, s, n, i, a, o) {
    let u,
     l = t;
    return (({ n: u, pos: t } = nt(e, t, r, s, 16, n, i, !1, o, !a)), null === u && (a ? o.invalidEscapeSequence(l, r, s) : (t = l - 1)), { code: u, pos: t });
   }
   function nt(e, t, r, s, n, i, a, o, u, l) {
    let p = t,
     c = 16 === n ? Qe.hex : Qe.decBinOct,
     h = 16 === n ? Ze.hex : 10 === n ? Ze.dec : 8 === n ? Ze.oct : Ze.bin,
     d = !1,
     f = 0;
    for (let m = 0, y = i ?? 1 / 0; m < y; ++m) {
     let i,
      p = e.charCodeAt(t);
     if (95 !== p || 'bail' === o) {
      if (((i = p >= 97 ? p - 97 + 10 : p >= 65 ? p - 65 + 10 : Ye(p) ? p - 48 : 1 / 0), i >= n)) {
       if (i <= 9 && l) return { n: null, pos: t };
       if (i <= 9 && u.invalidDigit(t, r, s, n)) i = 0;
       else {
        if (!a) break;
        ((i = 0), (d = !0));
       }
      }
      (++t, (f = f * n + i));
     } else {
      let n = e.charCodeAt(t - 1),
       i = e.charCodeAt(t + 1);
      if (o) {
       if (Number.isNaN(i) || !h(i) || c.has(n) || c.has(i)) {
        if (l) return { n: null, pos: t };
        u.unexpectedNumericSeparator(t, r, s);
       }
      } else {
       if (l) return { n: null, pos: t };
       u.numericSeparatorInEscapeSequence(t, r, s);
      }
      ++t;
     }
    }
    return t === p || (null != i && t - p !== i) || d ? { n: null, pos: t } : { n: f, pos: t };
   }
   function it(e, t, r, s, n, i) {
    let a;
    if (123 === e.charCodeAt(t)) {
     if ((++t, ({ code: a, pos: t } = st(e, t, r, s, e.indexOf('}', t) - t, !0, n, i)), ++t, null !== a && a > 1114111)) {
      if (!n) return { code: null, pos: t };
      i.invalidCodePoint(t, r, s);
     }
    } else ({ code: a, pos: t } = st(e, t, r, s, 4, !1, n, i));
    return { code: a, pos: t };
   }
   function at(e, t, r) {
    return new u(r, e - t, e);
   }
   var ot = new Set([103, 109, 115, 105, 121, 117, 100, 118]),
    ut = class {
     constructor(e) {
      let t = e.startIndex || 0;
      ((this.type = e.type), (this.value = e.value), (this.start = t + e.start), (this.end = t + e.end), (this.loc = new l(e.startLoc, e.endLoc)));
     }
    },
    lt = class extends Ke {
     isLookahead;
     tokens = [];
     constructor(e, t) {
      (super(), (this.state = new Ge()), this.state.init(e), (this.input = t), (this.length = t.length), (this.comments = []), (this.isLookahead = !1));
     }
     pushToken(e) {
      ((this.tokens.length = this.state.tokensLength), this.tokens.push(e), ++this.state.tokensLength);
     }
     next() {
      (this.checkKeywordEscapes(), 256 & this.optionFlags && this.pushToken(new ut(this.state)), (this.state.lastTokEndLoc = this.state.endLoc), (this.state.lastTokStartLoc = this.state.startLoc), this.nextToken());
     }
     eat(e) {
      return !!this.match(e) && (this.next(), !0);
     }
     match(e) {
      return this.state.type === e;
     }
     createLookaheadState(e) {
      return { pos: e.pos, value: null, type: e.type, start: e.start, end: e.end, context: [this.curContext()], inType: e.inType, startLoc: e.startLoc, lastTokEndLoc: e.lastTokEndLoc, curLine: e.curLine, lineStart: e.lineStart, curPosition: e.curPosition };
     }
     lookahead() {
      let e = this.state;
      ((this.state = this.createLookaheadState(e)), (this.isLookahead = !0), this.nextToken(), (this.isLookahead = !1));
      let t = this.state;
      return ((this.state = e), t);
     }
     nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos);
     }
     nextTokenStartSince(e) {
      return ((Le.lastIndex = e), Le.test(this.input) ? Le.lastIndex : e);
     }
     lookaheadCharCode() {
      return this.lookaheadCharCodeSince(this.state.pos);
     }
     lookaheadCharCodeSince(e) {
      return this.input.charCodeAt(this.nextTokenStartSince(e));
     }
     nextTokenInLineStart() {
      return this.nextTokenInLineStartSince(this.state.pos);
     }
     nextTokenInLineStartSince(e) {
      return ((Me.lastIndex = e), Me.test(this.input) ? Me.lastIndex : e);
     }
     lookaheadInLineCharCode() {
      return this.input.charCodeAt(this.nextTokenInLineStart());
     }
     codePointAtPos(e) {
      let t = this.input.charCodeAt(e);
      if (55296 == (64512 & t) && ++e < this.input.length) {
       let r = this.input.charCodeAt(e);
       56320 == (64512 & r) && (t = 65536 + ((1023 & t) << 10) + (1023 & r));
      }
      return t;
     }
     setStrict(e) {
      ((this.state.strict = e), e && (this.state.strictErrors.forEach(([e, t]) => this.raise(e, t)), this.state.strictErrors.clear()));
     }
     curContext() {
      return this.state.context[this.state.context.length - 1];
     }
     nextToken() {
      (this.skipSpace(), (this.state.start = this.state.pos), this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length ? this.finishToken(140) : this.getTokenFromCode(this.codePointAtPos(this.state.pos)));
     }
     skipBlockComment(e) {
      let t;
      this.isLookahead || (t = this.state.curPosition());
      let r = this.state.pos,
       s = this.input.indexOf(e, r + 2);
      if (-1 === s) throw this.raise(C.UnterminatedComment, this.state.curPosition());
      for (this.state.pos = s + e.length, Ne.lastIndex = r + 2; Ne.test(this.input) && Ne.lastIndex <= s; ) (++this.state.curLine, (this.state.lineStart = Ne.lastIndex));
      if (this.isLookahead) return;
      let n = { type: 'CommentBlock', value: this.input.slice(r + 2, s), start: this.sourceToOffsetPos(r), end: this.sourceToOffsetPos(s + e.length), loc: new l(t, this.state.curPosition()) };
      return (256 & this.optionFlags && this.pushToken(n), n);
     }
     skipLineComment(e) {
      let t,
       r = this.state.pos;
      this.isLookahead || (t = this.state.curPosition());
      let s = this.input.charCodeAt((this.state.pos += e));
      if (this.state.pos < this.length) for (; !Be(s) && ++this.state.pos < this.length; ) s = this.input.charCodeAt(this.state.pos);
      if (this.isLookahead) return;
      let n = this.state.pos,
       i = { type: 'CommentLine', value: this.input.slice(r + e, n), start: this.sourceToOffsetPos(r), end: this.sourceToOffsetPos(n), loc: new l(t, this.state.curPosition()) };
      return (256 & this.optionFlags && this.pushToken(i), i);
     }
     skipSpace() {
      let e = this.state.pos,
       t = 4096 & this.optionFlags ? [] : null;
      e: for (; this.state.pos < this.length; ) {
       let r = this.input.charCodeAt(this.state.pos);
       switch (r) {
        case 32:
        case 160:
        case 9:
         ++this.state.pos;
         break;
        case 13:
         10 === this.input.charCodeAt(this.state.pos + 1) && ++this.state.pos;
        case 10:
        case 8232:
        case 8233:
         (++this.state.pos, ++this.state.curLine, (this.state.lineStart = this.state.pos));
         break;
        case 47:
         switch (this.input.charCodeAt(this.state.pos + 1)) {
          case 42: {
           let e = this.skipBlockComment('*/');
           void 0 !== e && (this.addComment(e), t?.push(e));
           break;
          }
          case 47: {
           let e = this.skipLineComment(2);
           void 0 !== e && (this.addComment(e), t?.push(e));
           break;
          }
          default:
           break e;
         }
         break;
        default:
         if (je(r)) ++this.state.pos;
         else if (45 === r && !this.inModule && 8192 & this.optionFlags) {
          let r = this.state.pos;
          if (45 !== this.input.charCodeAt(r + 1) || 62 !== this.input.charCodeAt(r + 2) || !(0 === e || this.state.lineStart > e)) break e;
          {
           let e = this.skipLineComment(3);
           void 0 !== e && (this.addComment(e), t?.push(e));
          }
         } else {
          if (60 !== r || this.inModule || !(8192 & this.optionFlags)) break e;
          {
           let e = this.state.pos;
           if (33 !== this.input.charCodeAt(e + 1) || 45 !== this.input.charCodeAt(e + 2) || 45 !== this.input.charCodeAt(e + 3)) break e;
           {
            let e = this.skipLineComment(4);
            void 0 !== e && (this.addComment(e), t?.push(e));
           }
          }
         }
       }
      }
      if (t?.length > 0) {
       let r = this.state.pos,
        s = { start: this.sourceToOffsetPos(e), end: this.sourceToOffsetPos(r), comments: t, leadingNode: null, trailingNode: null, containingNode: null };
       this.state.commentStack.push(s);
      }
     }
     finishToken(e, t) {
      ((this.state.end = this.state.pos), (this.state.endLoc = this.state.curPosition()));
      let r = this.state.type;
      ((this.state.type = e), (this.state.value = t), this.isLookahead || this.updateContext(r));
     }
     replaceToken(e) {
      ((this.state.type = e), this.updateContext());
     }
     readToken_numberSign() {
      if (0 === this.state.pos && this.readToken_interpreter()) return;
      let e = this.state.pos + 1,
       t = this.codePointAtPos(e);
      if (t >= 48 && t <= 57) throw this.raise(C.UnexpectedDigitAfterHash, this.state.curPosition());
      ce(t) ? (++this.state.pos, this.finishToken(139, this.readWord1(t))) : 92 === t ? (++this.state.pos, this.finishToken(139, this.readWord1())) : this.finishOp(27, 1);
     }
     readToken_dot() {
      let e = this.input.charCodeAt(this.state.pos + 1);
      e >= 48 && e <= 57 ? this.readNumber(!0) : 46 === e && 46 === this.input.charCodeAt(this.state.pos + 2) ? ((this.state.pos += 3), this.finishToken(21)) : (++this.state.pos, this.finishToken(16));
     }
     readToken_slash() {
      61 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(31, 2) : this.finishOp(56, 1);
     }
     readToken_interpreter() {
      if (0 !== this.state.pos || this.length < 2) return !1;
      let e = this.input.charCodeAt(this.state.pos + 1);
      if (33 !== e) return !1;
      let t = this.state.pos;
      for (this.state.pos += 1; !Be(e) && ++this.state.pos < this.length; ) e = this.input.charCodeAt(this.state.pos);
      let r = this.input.slice(t + 2, this.state.pos);
      return (this.finishToken(28, r), !0);
     }
     readToken_mult_modulo(e) {
      let t = 42 === e ? 55 : 54,
       r = 1,
       s = this.input.charCodeAt(this.state.pos + 1);
      (42 === e && 42 === s && (r++, (s = this.input.charCodeAt(this.state.pos + 2)), (t = 57)), 61 === s && !this.state.inType && (r++, (t = 37 === e ? 33 : 30)), this.finishOp(t, r));
     }
     readToken_pipe_amp(e) {
      let t = this.input.charCodeAt(this.state.pos + 1);
      t !== e ? (124 !== e || 62 !== t ? (61 !== t ? this.finishOp(124 === e ? 43 : 45, 1) : this.finishOp(30, 2)) : this.finishOp(39, 2)) : 61 === this.input.charCodeAt(this.state.pos + 2) ? this.finishOp(30, 3) : this.finishOp(124 === e ? 41 : 42, 2);
     }
     readToken_caret() {
      let e = this.input.charCodeAt(this.state.pos + 1);
      61 !== e || this.state.inType ? (94 === e && this.hasPlugin(['pipelineOperator', { proposal: 'hack', topicToken: '^^' }]) ? (this.finishOp(37, 2), 94 === this.input.codePointAt(this.state.pos) && this.unexpected()) : this.finishOp(44, 1)) : this.finishOp(32, 2);
     }
     readToken_atSign() {
      64 === this.input.charCodeAt(this.state.pos + 1) && this.hasPlugin(['pipelineOperator', { proposal: 'hack', topicToken: '@@' }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
     }
     readToken_plus_min(e) {
      let t = this.input.charCodeAt(this.state.pos + 1);
      t !== e ? (61 === t ? this.finishOp(30, 2) : this.finishOp(53, 1)) : this.finishOp(34, 2);
     }
     readToken_lt() {
      let { pos: e } = this.state,
       t = this.input.charCodeAt(e + 1);
      if (60 === t) return 61 === this.input.charCodeAt(e + 2) ? void this.finishOp(30, 3) : void this.finishOp(51, 2);
      61 !== t ? this.finishOp(47, 1) : this.finishOp(49, 2);
     }
     readToken_gt() {
      let { pos: e } = this.state,
       t = this.input.charCodeAt(e + 1);
      if (62 === t) {
       let t = 62 === this.input.charCodeAt(e + 2) ? 3 : 2;
       return 61 === this.input.charCodeAt(e + t) ? void this.finishOp(30, t + 1) : void this.finishOp(52, t);
      }
      61 !== t ? this.finishOp(48, 1) : this.finishOp(49, 2);
     }
     readToken_eq_excl(e) {
      let t = this.input.charCodeAt(this.state.pos + 1);
      if (61 !== t) return 61 === e && 62 === t ? ((this.state.pos += 2), void this.finishToken(19)) : void this.finishOp(61 === e ? 29 : 35, 1);
      this.finishOp(46, 61 === this.input.charCodeAt(this.state.pos + 2) ? 3 : 2);
     }
     readToken_question() {
      let e = this.input.charCodeAt(this.state.pos + 1),
       t = this.input.charCodeAt(this.state.pos + 2);
      63 === e ? (61 === t ? this.finishOp(30, 3) : this.finishOp(40, 2)) : 46 !== e || (t >= 48 && t <= 57) ? (++this.state.pos, this.finishToken(17)) : ((this.state.pos += 2), this.finishToken(18));
     }
     getTokenFromCode(e) {
      switch (e) {
       case 46:
        return void this.readToken_dot();
       case 40:
        return (++this.state.pos, void this.finishToken(10));
       case 41:
        return (++this.state.pos, void this.finishToken(11));
       case 59:
        return (++this.state.pos, void this.finishToken(13));
       case 44:
        return (++this.state.pos, void this.finishToken(12));
       case 91:
        return (++this.state.pos, void this.finishToken(0));
       case 93:
        return (++this.state.pos, void this.finishToken(3));
       case 123:
        return (++this.state.pos, void this.finishToken(5));
       case 125:
        return (++this.state.pos, void this.finishToken(8));
       case 58:
        return void (this.hasPlugin('functionBind') && 58 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(15, 2) : (++this.state.pos, this.finishToken(14)));
       case 63:
        return void this.readToken_question();
       case 96:
        return void this.readTemplateToken();
       case 48: {
        let e = this.input.charCodeAt(this.state.pos + 1);
        if (120 === e || 88 === e) return void this.readRadixNumber(16);
        if (111 === e || 79 === e) return void this.readRadixNumber(8);
        if (98 === e || 66 === e) return void this.readRadixNumber(2);
       }
       case 49:
       case 50:
       case 51:
       case 52:
       case 53:
       case 54:
       case 55:
       case 56:
       case 57:
        return void this.readNumber(!1);
       case 34:
       case 39:
        return void this.readString(e);
       case 47:
        return void this.readToken_slash();
       case 37:
       case 42:
        return void this.readToken_mult_modulo(e);
       case 124:
       case 38:
        return void this.readToken_pipe_amp(e);
       case 94:
        return void this.readToken_caret();
       case 43:
       case 45:
        return void this.readToken_plus_min(e);
       case 60:
        return void this.readToken_lt();
       case 62:
        return void this.readToken_gt();
       case 61:
       case 33:
        return void this.readToken_eq_excl(e);
       case 126:
        return void this.finishOp(36, 1);
       case 64:
        return void this.readToken_atSign();
       case 35:
        return void this.readToken_numberSign();
       case 92:
        return void this.readWord();
       default:
        if (ce(e)) return void this.readWord(e);
      }
      throw this.raise(C.InvalidOrUnexpectedToken, this.state.curPosition(), { unexpected: String.fromCodePoint(e) });
     }
     finishOp(e, t) {
      let r = this.input.slice(this.state.pos, this.state.pos + t);
      ((this.state.pos += t), this.finishToken(e, r));
     }
     readRegexp() {
      let e,
       t,
       r = this.state.startLoc,
       s = this.state.start + 1,
       { pos: n } = this.state;
      for (; ; ++n) {
       if (n >= this.length) throw this.raise(C.UnterminatedRegExp, p(r, 1));
       let s = this.input.charCodeAt(n);
       if (Be(s)) throw this.raise(C.UnterminatedRegExp, p(r, 1));
       if (e) e = !1;
       else {
        if (91 === s) t = !0;
        else if (93 === s && t) t = !1;
        else if (47 === s && !t) break;
        e = 92 === s;
       }
      }
      let i = this.input.slice(s, n);
      ++n;
      let a = '',
       o = () => p(r, n + 2 - s);
      for (; n < this.length; ) {
       let e = this.codePointAtPos(n),
        t = String.fromCharCode(e);
       if (ot.has(e)) (118 === e ? a.includes('u') && this.raise(C.IncompatibleRegExpUVFlags, o()) : 117 === e && a.includes('v') && this.raise(C.IncompatibleRegExpUVFlags, o()), a.includes(t) && this.raise(C.DuplicateRegExpFlags, o()));
       else {
        if (!he(e) && 92 !== e) break;
        this.raise(C.MalformedRegExpFlags, o());
       }
       (++n, (a += t));
      }
      ((this.state.pos = n), this.finishToken(138, { pattern: i, flags: a }));
     }
     readInt(e, t, r = !1, s = !0) {
      let { n: n, pos: i } = nt(this.input, this.state.pos, this.state.lineStart, this.state.curLine, e, t, r, s, this.errorHandlers_readInt, !1);
      return ((this.state.pos = i), n);
     }
     readRadixNumber(e) {
      let t = this.state.pos,
       r = this.state.curPosition(),
       s = !1;
      this.state.pos += 2;
      let n = this.readInt(e);
      null == n && this.raise(C.InvalidDigit, p(r, 2), { radix: e });
      let i = this.input.charCodeAt(this.state.pos);
      if (110 === i) (++this.state.pos, (s = !0));
      else if (109 === i) throw this.raise(C.InvalidDecimal, r);
      if (ce(this.codePointAtPos(this.state.pos))) throw this.raise(C.NumberIdentifier, this.state.curPosition());
      if (s) {
       let e = this.input.slice(t, this.state.pos).replace(/[_n]/g, '');
       this.finishToken(136, e);
      } else this.finishToken(135, n);
     }
     readNumber(e) {
      let t = this.state.pos,
       r = this.state.curPosition(),
       s = !1,
       n = !1,
       i = !1;
      !e && null === this.readInt(10) && this.raise(C.InvalidNumber, this.state.curPosition());
      let a = this.state.pos - t >= 2 && 48 === this.input.charCodeAt(t);
      if (a) {
       let e = this.input.slice(t, this.state.pos);
       if ((this.recordStrictModeErrors(C.StrictOctalLiteral, r), !this.state.strict)) {
        let t = e.indexOf('_');
        t > 0 && this.raise(C.ZeroDigitNumericSeparator, p(r, t));
       }
       i = a && !/[89]/.test(e);
      }
      let o = this.input.charCodeAt(this.state.pos);
      if ((46 === o && !i && (++this.state.pos, this.readInt(10), (s = !0), (o = this.input.charCodeAt(this.state.pos))), (69 === o || 101 === o) && !i && ((o = this.input.charCodeAt(++this.state.pos)), (43 === o || 45 === o) && ++this.state.pos, null === this.readInt(10) && this.raise(C.InvalidOrMissingExponent, r), (s = !0), (o = this.input.charCodeAt(this.state.pos))), 110 === o && ((s || a) && this.raise(C.InvalidBigIntLiteral, r), ++this.state.pos, (n = !0)), ce(this.codePointAtPos(this.state.pos)))) throw this.raise(C.NumberIdentifier, this.state.curPosition());
      let u = this.input.slice(t, this.state.pos).replace(/[_mn]/g, '');
      if (n) return void this.finishToken(136, u);
      let l = i ? parseInt(u, 8) : parseFloat(u);
      this.finishToken(135, l);
     }
     readCodePoint(e) {
      let { code: t, pos: r } = it(this.input, this.state.pos, this.state.lineStart, this.state.curLine, e, this.errorHandlers_readCodePoint);
      return ((this.state.pos = r), t);
     }
     readString(e) {
      let { str: t, pos: r, curLine: s, lineStart: n } = et(34 === e ? 'double' : 'single', this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
      ((this.state.pos = r + 1), (this.state.lineStart = n), (this.state.curLine = s), this.finishToken(134, t));
     }
     readTemplateContinuation() {
      (this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken());
     }
     readTemplateToken() {
      let e = this.input[this.state.pos],
       { str: t, firstInvalidLoc: r, pos: s, curLine: n, lineStart: i } = et('template', this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
      ((this.state.pos = s + 1), (this.state.lineStart = i), (this.state.curLine = n), r && (this.state.firstInvalidTemplateEscapePos = new u(r.curLine, r.pos - r.lineStart, this.sourceToOffsetPos(r.pos))), 96 === this.input.codePointAt(s) ? this.finishToken(24, r ? null : e + t + '`') : (this.state.pos++, this.finishToken(25, r ? null : e + t + '${')));
     }
     recordStrictModeErrors(e, t) {
      let r = t.index;
      this.state.strict && !this.state.strictErrors.has(r) ? this.raise(e, t) : this.state.strictErrors.set(r, [e, t]);
     }
     readWord1(e) {
      this.state.containsEsc = !1;
      let t = '',
       r = this.state.pos,
       s = this.state.pos;
      for (void 0 !== e && (this.state.pos += e <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
       let e = this.codePointAtPos(this.state.pos);
       if (he(e)) this.state.pos += e <= 65535 ? 1 : 2;
       else {
        if (92 !== e) break;
        {
         ((this.state.containsEsc = !0), (t += this.input.slice(s, this.state.pos)));
         let e = this.state.curPosition(),
          n = this.state.pos === r ? ce : he;
         if (117 !== this.input.charCodeAt(++this.state.pos)) {
          (this.raise(C.MissingUnicodeEscape, this.state.curPosition()), (s = this.state.pos - 1));
          continue;
         }
         ++this.state.pos;
         let i = this.readCodePoint(!0);
         (null !== i && (n(i) || this.raise(C.EscapedCharNotAnIdentifier, e), (t += String.fromCodePoint(i))), (s = this.state.pos));
        }
       }
      }
      return t + this.input.slice(s, this.state.pos);
     }
     readWord(e) {
      let t = this.readWord1(e),
       r = L.get(t);
      void 0 !== r ? this.finishToken(r, ee(r)) : this.finishToken(132, t);
     }
     checkKeywordEscapes() {
      let { type: e } = this.state;
      Z(e) && this.state.containsEsc && this.raise(C.InvalidEscapedReservedWord, this.state.startLoc, { reservedWord: ee(e) });
     }
     raise(e, t, r = {}) {
      let s = e(t instanceof u ? t : t.loc.start, r);
      if (!(2048 & this.optionFlags)) throw s;
      return (this.isLookahead || this.state.errors.push(s), s);
     }
     raiseOverwrite(e, t, r = {}) {
      let s = t instanceof u ? t : t.loc.start,
       n = s.index,
       i = this.state.errors;
      for (let a = i.length - 1; a >= 0; a--) {
       let t = i[a];
       if (t.loc.index === n) return (i[a] = e(s, r));
       if (t.loc.index < n) break;
      }
      return this.raise(e, t, r);
     }
     updateContext(e) {}
     unexpected(e, t) {
      throw this.raise(C.UnexpectedToken, e ?? this.state.startLoc, { expected: t ? ee(t) : null });
     }
     expectPlugin(e, t) {
      if (this.hasPlugin(e)) return !0;
      throw this.raise(C.MissingPlugin, t ?? this.state.startLoc, { missingPlugin: [e] });
     }
     expectOnePlugin(e) {
      if (!e.some((e) => this.hasPlugin(e))) throw this.raise(C.MissingOneOfPlugins, this.state.startLoc, { missingPlugin: e });
     }
     errorBuilder(e) {
      return (t, r, s) => {
       this.raise(e, at(t, r, s));
      };
     }
     errorHandlers_readInt = { invalidDigit: (e, t, r, s) => !!(2048 & this.optionFlags) && (this.raise(C.InvalidDigit, at(e, t, r), { radix: s }), !0), numericSeparatorInEscapeSequence: this.errorBuilder(C.NumericSeparatorInEscapeSequence), unexpectedNumericSeparator: this.errorBuilder(C.UnexpectedNumericSeparator) };
     errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, { invalidEscapeSequence: this.errorBuilder(C.InvalidEscapeSequence), invalidCodePoint: this.errorBuilder(C.InvalidCodePoint) });
     errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
      strictNumericEscape: (e, t, r) => {
       this.recordStrictModeErrors(C.StrictNumericEscape, at(e, t, r));
      },
      unterminated: (e, t, r) => {
       throw this.raise(C.UnterminatedString, at(e - 1, t, r));
      },
     });
     errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
      strictNumericEscape: this.errorBuilder(C.StrictNumericEscape),
      unterminated: (e, t, r) => {
       throw this.raise(C.UnterminatedTemplate, at(e, t, r));
      },
     });
    },
    pt = class {
     privateNames = new Set();
     loneAccessors = new Map();
     undefinedPrivateNames = new Map();
    },
    ct = class {
     parser;
     stack = [];
     undefinedPrivateNames = new Map();
     constructor(e) {
      this.parser = e;
     }
     current() {
      return this.stack[this.stack.length - 1];
     }
     enter() {
      this.stack.push(new pt());
     }
     exit() {
      let e = this.stack.pop(),
       t = this.current();
      for (let [r, s] of Array.from(e.undefinedPrivateNames)) t ? t.undefinedPrivateNames.has(r) || t.undefinedPrivateNames.set(r, s) : this.parser.raise(C.InvalidPrivateFieldResolution, s, { identifierName: r });
     }
     declarePrivateName(e, t, r) {
      let { privateNames: s, loneAccessors: n, undefinedPrivateNames: i } = this.current(),
       a = s.has(e);
      if (3 & t) {
       let r = a && n.get(e);
       if (r) {
        ((a = (3 & r) === (3 & t) || (4 & r) !== (4 & t)), a || n.delete(e));
       } else a || n.set(e, t);
      }
      (a && this.parser.raise(C.PrivateNameRedeclaration, r, { identifierName: e }), s.add(e), i.delete(e));
     }
     usePrivateName(e, t) {
      let r;
      for (r of this.stack) if (r.privateNames.has(e)) return;
      r ? r.undefinedPrivateNames.set(e, t) : this.parser.raise(C.InvalidPrivateFieldResolution, t, { identifierName: e });
     }
    },
    ht = class {
     constructor(e = 0) {
      this.type = e;
     }
     canBeArrowParameterDeclaration() {
      return 2 === this.type || 1 === this.type;
     }
     isCertainlyParameterDeclaration() {
      return 3 === this.type;
     }
    },
    dt = class extends ht {
     declarationErrors = new Map();
     constructor(e) {
      super(e);
     }
     recordDeclarationError(e, t) {
      let r = t.index;
      this.declarationErrors.set(r, [e, t]);
     }
     clearDeclarationError(e) {
      this.declarationErrors.delete(e);
     }
     iterateErrors(e) {
      this.declarationErrors.forEach(e);
     }
    },
    ft = class {
     parser;
     stack = [new ht()];
     constructor(e) {
      this.parser = e;
     }
     enter(e) {
      this.stack.push(e);
     }
     exit() {
      this.stack.pop();
     }
     recordParameterInitializerError(e, t) {
      let r = t.loc.start,
       { stack: s } = this,
       n = s.length - 1,
       i = s[n];
      for (; !i.isCertainlyParameterDeclaration(); ) {
       if (!i.canBeArrowParameterDeclaration()) return;
       (i.recordDeclarationError(e, r), (i = s[--n]));
      }
      this.parser.raise(e, r);
     }
     recordArrowParameterBindingError(e, t) {
      let { stack: r } = this,
       s = r[r.length - 1],
       n = t.loc.start;
      if (s.isCertainlyParameterDeclaration()) this.parser.raise(e, n);
      else {
       if (!s.canBeArrowParameterDeclaration()) return;
       s.recordDeclarationError(e, n);
      }
     }
     recordAsyncArrowParametersError(e) {
      let { stack: t } = this,
       r = t.length - 1,
       s = t[r];
      for (; s.canBeArrowParameterDeclaration(); ) (2 === s.type && s.recordDeclarationError(C.AwaitBindingIdentifier, e), (s = t[--r]));
     }
     validateAsPattern() {
      let { stack: e } = this,
       t = e[e.length - 1];
      t.canBeArrowParameterDeclaration() &&
       t.iterateErrors(([t, r]) => {
        this.parser.raise(t, r);
        let s = e.length - 2,
         n = e[s];
        for (; n.canBeArrowParameterDeclaration(); ) (n.clearDeclarationError(r.index), (n = e[--s]));
       });
     }
    };
   function mt() {
    return new ht();
   }
   var yt = class extends lt {
     addExtra(e, t, r, s = !0) {
      if (!e) return;
      let { extra: n } = e;
      (null == n && ((n = {}), (e.extra = n)), s ? (n[t] = r) : Object.defineProperty(n, t, { enumerable: s, value: r }));
     }
     isContextual(e) {
      return this.state.type === e && !this.state.containsEsc;
     }
     isUnparsedContextual(e, t) {
      if (this.input.startsWith(t, e)) {
       let r = this.input.charCodeAt(e + t.length);
       return !(he(r) || 55296 == (64512 & r));
      }
      return !1;
     }
     isLookaheadContextual(e) {
      let t = this.nextTokenStart();
      return this.isUnparsedContextual(t, e);
     }
     eatContextual(e) {
      return !!this.isContextual(e) && (this.next(), !0);
     }
     expectContextual(e, t) {
      if (!this.eatContextual(e)) {
       if (null != t) throw this.raise(t, this.state.startLoc);
       this.unexpected(null, e);
      }
     }
     canInsertSemicolon() {
      return this.match(140) || this.match(8) || this.hasPrecedingLineBreak();
     }
     hasPrecedingLineBreak() {
      return Oe(this.input, this.offsetToSourcePos(this.state.lastTokEndLoc.index), this.state.start);
     }
     hasFollowingLineBreak() {
      return Oe(this.input, this.state.end, this.nextTokenStart());
     }
     isLineTerminator() {
      return this.eat(13) || this.canInsertSemicolon();
     }
     semicolon(e = !0) {
      (e ? this.isLineTerminator() : this.eat(13)) || this.raise(C.MissingSemicolon, this.state.lastTokEndLoc);
     }
     expect(e, t) {
      this.eat(e) || this.unexpected(t, e);
     }
     tryParse(e, t = this.state.clone()) {
      let r = { node: null };
      try {
       let s = e((e = null) => {
        throw ((r.node = e), r);
       });
       if (this.state.errors.length > t.errors.length) {
        let e = this.state;
        return ((this.state = t), (this.state.tokensLength = e.tokensLength), { node: s, error: e.errors[t.errors.length], thrown: !1, aborted: !1, failState: e });
       }
       return { node: s, error: null, thrown: !1, aborted: !1, failState: null };
      } catch (s) {
       let e = this.state;
       if (((this.state = t), s instanceof SyntaxError)) return { node: null, error: s, thrown: !0, aborted: !1, failState: e };
       if (s === r) return { node: r.node, error: null, thrown: !1, aborted: !0, failState: e };
       throw s;
      }
     }
     checkExpressionErrors(e, t) {
      if (!e) return !1;
      let { shorthandAssignLoc: r, doubleProtoLoc: s, privateKeyLoc: n, optionalParametersLoc: i, voidPatternLoc: a } = e;
      if (!t) return !!(r || s || i || n || a);
      (null != r && this.raise(C.InvalidCoverInitializedName, r), null != s && this.raise(C.DuplicateProto, s), null != n && this.raise(C.UnexpectedPrivateField, n), null != i && this.unexpected(i), null != a && this.raise(C.InvalidCoverDiscardElement, a));
     }
     isLiteralPropertyName() {
      return G(this.state.type);
     }
     isPrivateName(e) {
      return 'PrivateName' === e.type;
     }
     getPrivateNameSV(e) {
      return e.id.name;
     }
     hasPropertyAsPrivateName(e) {
      return ('MemberExpression' === e.type || 'OptionalMemberExpression' === e.type) && this.isPrivateName(e.property);
     }
     isObjectProperty(e) {
      return 'ObjectProperty' === e.type;
     }
     isObjectMethod(e) {
      return 'ObjectMethod' === e.type;
     }
     initializeScopes(e = 'module' === this.options.sourceType) {
      let t = this.state.labels;
      this.state.labels = [];
      let r = this.exportedIdentifiers;
      this.exportedIdentifiers = new Set();
      let s = this.inModule;
      this.inModule = e;
      let n = this.scope,
       i = this.getScopeHandler();
      this.scope = new i(this, e);
      let a = this.prodParam;
      this.prodParam = new Je();
      let o = this.classScope;
      this.classScope = new ct(this);
      let u = this.expressionScope;
      return (
       (this.expressionScope = new ft(this)),
       () => {
        ((this.state.labels = t), (this.exportedIdentifiers = r), (this.inModule = s), (this.scope = n), (this.prodParam = a), (this.classScope = o), (this.expressionScope = u));
       }
      );
     }
     enterInitialScopes() {
      let e = 0;
      ((this.inModule || 1 & this.optionFlags) && (e |= 2), 32 & this.optionFlags && (e |= 1));
      let t = !this.inModule && 'commonjs' === this.options.sourceType;
      ((t || 2 & this.optionFlags) && (e |= 4), this.prodParam.enter(e));
      let r = t ? 514 : 1;
      (4 & this.optionFlags && (r |= 512), 16 & this.optionFlags && (r |= 48), this.scope.enter(r));
     }
     checkDestructuringPrivate(e) {
      let { privateKeyLoc: t } = e;
      null !== t && this.expectPlugin('destructuringPrivate', t);
     }
    },
    Dt = class {
     shorthandAssignLoc = null;
     doubleProtoLoc = null;
     privateKeyLoc = null;
     optionalParametersLoc = null;
     voidPatternLoc = null;
    },
    gt = class {
     constructor(e, t, r) {
      ((this.start = t), (this.end = 0), (this.loc = new l(r)), 128 & e?.optionFlags && (this.range = [t, 0]), e?.filename && (this.loc.filename = e.filename));
     }
     type = '';
    },
    xt = gt.prototype,
    Et = class extends yt {
     startNode() {
      let e = this.state.startLoc;
      return new gt(this, e.index, e);
     }
     startNodeAt(e) {
      return new gt(this, e.index, e);
     }
     startNodeAtNode(e) {
      return this.startNodeAt(e.loc.start);
     }
     finishNode(e, t) {
      return this.finishNodeAt(e, t, this.state.lastTokEndLoc);
     }
     finishNodeAt(e, t, r) {
      return ((e.type = t), (e.end = r.index), (e.loc.end = r), 128 & this.optionFlags && (e.range[1] = r.index), 4096 & this.optionFlags && this.processComment(e), e);
     }
     resetStartLocation(e, t) {
      ((e.start = t.index), (e.loc.start = t), 128 & this.optionFlags && (e.range[0] = t.index));
     }
     resetEndLocation(e, t = this.state.lastTokEndLoc) {
      ((e.end = t.index), (e.loc.end = t), 128 & this.optionFlags && (e.range[1] = t.index));
     }
     resetStartLocationFromNode(e, t) {
      this.resetStartLocation(e, t.loc.start);
     }
     castNodeTo(e, t) {
      return ((e.type = t), e);
     }
     cloneIdentifier(e) {
      let { type: t, start: r, end: s, loc: n, range: i, name: a } = e,
       o = Object.create(xt);
      return ((o.type = t), (o.start = r), (o.end = s), (o.loc = n), (o.range = i), (o.name = a), e.extra && (o.extra = e.extra), o);
     }
     cloneStringLiteral(e) {
      let { type: t, start: r, end: s, loc: n, range: i, extra: a } = e,
       o = Object.create(xt);
      return ((o.type = t), (o.start = r), (o.end = s), (o.loc = n), (o.range = i), (o.extra = a), (o.value = e.value), o);
     }
    },
    bt = (e) => ('ParenthesizedExpression' === e.type ? bt(e.expression) : e),
    Tt = class extends Et {
     toAssignable(e, t = !1) {
      let r;
      switch ((('ParenthesizedExpression' === e.type || e.extra?.parenthesized) && ((r = bt(e)), t ? ('Identifier' === r.type ? this.expressionScope.recordArrowParameterBindingError(C.InvalidParenthesizedAssignment, e) : 'CallExpression' !== r.type && 'MemberExpression' !== r.type && !this.isOptionalMemberExpression(r) && this.raise(C.InvalidParenthesizedAssignment, e)) : this.raise(C.InvalidParenthesizedAssignment, e)), e.type)) {
       case 'Identifier':
       case 'ObjectPattern':
       case 'ArrayPattern':
       case 'AssignmentPattern':
       case 'RestElement':
       case 'VoidPattern':
        break;
       case 'ObjectExpression':
        this.castNodeTo(e, 'ObjectPattern');
        for (let r = 0, s = e.properties.length, n = s - 1; r < s; r++) {
         let s = e.properties[r],
          i = r === n;
         (this.toAssignableObjectExpressionProp(s, i, t), i && 'RestElement' === s.type && e.extra?.trailingCommaLoc && this.raise(C.RestTrailingComma, e.extra.trailingCommaLoc));
        }
        break;
       case 'ObjectProperty': {
        let { key: r, value: s } = e;
        (this.isPrivateName(r) && this.classScope.usePrivateName(this.getPrivateNameSV(r), r.loc.start), this.toAssignable(s, t));
        break;
       }
       case 'SpreadElement':
        throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
       case 'ArrayExpression':
        (this.castNodeTo(e, 'ArrayPattern'), this.toAssignableList(e.elements, e.extra?.trailingCommaLoc, t));
        break;
       case 'AssignmentExpression':
        ('=' !== e.operator && this.raise(C.MissingEqInAssignment, e.left.loc.end), this.castNodeTo(e, 'AssignmentPattern'), delete e.operator, 'VoidPattern' === e.left.type && this.raise(C.VoidPatternInitializer, e.left), this.toAssignable(e.left, t));
        break;
       case 'ParenthesizedExpression':
        this.toAssignable(r, t);
      }
     }
     toAssignableObjectExpressionProp(e, t, r) {
      if ('ObjectMethod' === e.type) this.raise('get' === e.kind || 'set' === e.kind ? C.PatternHasAccessor : C.PatternHasMethod, e.key);
      else if ('SpreadElement' === e.type) {
       this.castNodeTo(e, 'RestElement');
       let s = e.argument;
       (this.checkToRestConversion(s, !1), this.toAssignable(s, r), t || this.raise(C.RestTrailingComma, e));
      } else this.toAssignable(e, r);
     }
     toAssignableList(e, t, r) {
      let s = e.length - 1;
      for (let n = 0; n <= s; n++) {
       let i = e[n];
       i && (this.toAssignableListItem(e, n, r), 'RestElement' === i.type && (n < s ? this.raise(C.RestTrailingComma, i) : t && this.raise(C.RestTrailingComma, t)));
      }
     }
     toAssignableListItem(e, t, r) {
      let s = e[t];
      if ('SpreadElement' === s.type) {
       this.castNodeTo(s, 'RestElement');
       let e = s.argument;
       (this.checkToRestConversion(e, !0), this.toAssignable(e, r));
      } else this.toAssignable(s, r);
     }
     isAssignable(e, t) {
      switch (e.type) {
       case 'Identifier':
       case 'ObjectPattern':
       case 'ArrayPattern':
       case 'AssignmentPattern':
       case 'RestElement':
       case 'VoidPattern':
        return !0;
       case 'ObjectExpression': {
        let t = e.properties.length - 1;
        return e.properties.every((e, r) => 'ObjectMethod' !== e.type && (r === t || 'SpreadElement' !== e.type) && this.isAssignable(e));
       }
       case 'ObjectProperty':
        return this.isAssignable(e.value);
       case 'SpreadElement':
        return this.isAssignable(e.argument);
       case 'ArrayExpression':
        return e.elements.every((e) => null === e || this.isAssignable(e));
       case 'AssignmentExpression':
        return '=' === e.operator;
       case 'ParenthesizedExpression':
        return this.isAssignable(e.expression);
       case 'MemberExpression':
       case 'OptionalMemberExpression':
        return !t;
       default:
        return !1;
      }
     }
     toReferencedList(e, t) {
      return e;
     }
     toReferencedListDeep(e, t) {
      this.toReferencedList(e, t);
      for (let r of e) 'ArrayExpression' === r?.type && this.toReferencedListDeep(r.elements);
     }
     parseSpread(e) {
      let t = this.startNode();
      return (this.next(), (t.argument = this.parseMaybeAssignAllowIn(e, void 0)), this.finishNode(t, 'SpreadElement'));
     }
     parseRestBinding() {
      let e = this.startNode();
      this.next();
      let t = this.parseBindingAtom();
      return ('VoidPattern' === t.type && this.raise(C.UnexpectedVoidPattern, t), (e.argument = t), this.finishNode(e, 'RestElement'));
     }
     parseBindingAtom() {
      switch (this.state.type) {
       case 0: {
        let e = this.startNode();
        return (this.next(), (e.elements = this.parseBindingList(3, 93, 1)), this.finishNode(e, 'ArrayPattern'));
       }
       case 5:
        return this.parseObjectLike(8, !0);
       case 88:
        return this.parseVoidPattern(null);
      }
      return this.parseIdentifier();
     }
     parseBindingList(e, t, r) {
      let s = 1 & r,
       n = [],
       i = !0;
      for (; !this.eat(e); )
       if ((i ? (i = !1) : this.expect(12), s && this.match(12))) n.push(null);
       else {
        if (this.eat(e)) break;
        if (this.match(21)) {
         let s = this.parseRestBinding();
         if ((2 & r && (s = this.parseFunctionParamType(s)), n.push(s), !this.checkCommaAfterRest(t))) {
          this.expect(e);
          break;
         }
        } else {
         let e = [];
         if (2 & r) for (this.match(26) && this.hasPlugin('decorators') && this.raise(C.UnsupportedParameterDecorator, this.state.startLoc); this.match(26); ) e.push(this.parseDecorator());
         n.push(this.parseBindingElement(r, e));
        }
       }
      return n;
     }
     parseBindingRestProperty(e) {
      return (this.next(), this.hasPlugin('discardBinding') && this.match(88) ? ((e.argument = this.parseVoidPattern(null)), this.raise(C.UnexpectedVoidPattern, e.argument)) : (e.argument = this.parseIdentifier()), this.checkCommaAfterRest(125), this.finishNode(e, 'RestElement'));
     }
     parseBindingProperty() {
      let { type: e, startLoc: t } = this.state;
      if (21 === e) return this.parseBindingRestProperty(this.startNode());
      let r = this.startNode();
      return (139 === e ? (this.expectPlugin('destructuringPrivate', t), this.classScope.usePrivateName(this.state.value, t), (r.key = this.parsePrivateName())) : this.parsePropertyName(r), (r.method = !1), this.parseObjPropValue(r, t, !1, !1, !0, !1));
     }
     parseBindingElement(e, t) {
      let r = this.parseMaybeDefault();
      return (2 & e && this.parseFunctionParamType(r), t.length && ((r.decorators = t), this.resetStartLocationFromNode(r, t[0])), this.parseMaybeDefault(r.loc.start, r));
     }
     parseFunctionParamType(e) {
      return e;
     }
     parseMaybeDefault(e, t) {
      if ((e ?? (e = this.state.startLoc), (t = t ?? this.parseBindingAtom()), !this.eat(29))) return t;
      let r = this.startNodeAt(e);
      return ('VoidPattern' === t.type && this.raise(C.VoidPatternInitializer, t), (r.left = t), (r.right = this.parseMaybeAssignAllowIn()), this.finishNode(r, 'AssignmentPattern'));
     }
     isValidLVal(e, t, r, s) {
      switch (e) {
       case 'AssignmentPattern':
        return 'left';
       case 'RestElement':
        return 'argument';
       case 'ObjectProperty':
        return 'value';
       case 'ParenthesizedExpression':
        return 'expression';
       case 'ArrayPattern':
        return 'elements';
       case 'ObjectPattern':
        return 'properties';
       case 'VoidPattern':
        return !0;
       case 'CallExpression':
        if (!t && !this.state.strict && 8192 & this.optionFlags) return !0;
      }
      return !1;
     }
     isOptionalMemberExpression(e) {
      return 'OptionalMemberExpression' === e.type;
     }
     checkLVal(e, t, r = 64, s = !1, n = !1, i = !1, a = !1) {
      let o = e.type;
      if (this.isObjectMethod(e)) return;
      let u = this.isOptionalMemberExpression(e);
      if (u || 'MemberExpression' === o) return (u && (this.expectPlugin('optionalChainingAssign', e.loc.start), 'AssignmentExpression' !== t.type && this.raise(C.InvalidLhsOptionalChaining, e, { ancestor: t })), void (64 !== r && this.raise(C.InvalidPropertyBindingPattern, e)));
      if ('Identifier' === o) {
       this.checkIdentifier(e, r, n);
       let { name: t } = e;
       return void (s && (s.has(t) ? this.raise(C.ParamDupe, e) : s.add(t)));
      }
      'VoidPattern' === o && 'CatchClause' === t.type && this.raise(C.VoidPatternCatchClauseParam, e);
      let l = bt(e);
      a || (a = 'CallExpression' === l.type && ('Import' === l.callee.type || 'Super' === l.callee.type));
      let p,
       c,
       h = this.isValidLVal(o, a, !(i || e.extra?.parenthesized) && 'AssignmentExpression' === t.type, r);
      if (!0 === h) return;
      if (!1 === h) {
       let s = 64 === r ? C.InvalidLhs : C.InvalidLhsBinding;
       return void this.raise(s, e, { ancestor: t });
      }
      'string' == typeof h ? ((p = h), (c = 'ParenthesizedExpression' === o)) : ([p, c] = h);
      let d = 'ArrayPattern' === o || 'ObjectPattern' === o ? { type: o } : t,
       f = e[p];
      if (Array.isArray(f)) for (let m of f) m && this.checkLVal(m, d, r, s, n, c, !0);
      else f && this.checkLVal(f, d, r, s, n, c, a);
     }
     checkIdentifier(e, t, r = !1) {
      (this.state.strict && (r ? be(e.name, this.inModule) : Ee(e.name)) && (64 === t ? this.raise(C.StrictEvalArguments, e, { referenceName: e.name }) : this.raise(C.StrictEvalArgumentsBinding, e, { bindingName: e.name })), 8192 & t && 'let' === e.name && this.raise(C.LetInLexicalBinding, e), 64 & t || this.declareNameFromIdentifier(e, t));
     }
     declareNameFromIdentifier(e, t) {
      this.scope.declareName(e.name, t, e.loc.start);
     }
     checkToRestConversion(e, t) {
      switch (e.type) {
       case 'ParenthesizedExpression':
        this.checkToRestConversion(e.expression, t);
        break;
       case 'Identifier':
       case 'MemberExpression':
        break;
       case 'ArrayExpression':
       case 'ObjectExpression':
        if (t) break;
       default:
        this.raise(C.InvalidRestAssignmentPattern, e);
      }
     }
     checkCommaAfterRest(e) {
      return !!this.match(12) && (this.raise(this.lookaheadCharCode() === e ? C.RestTrailingComma : C.ElementAfterRest, this.state.startLoc), !0);
     }
    },
    Ct = /in(?:stanceof)?|as|satisfies/y;
   function Ft(e) {
    if (!e) throw new Error('Assert fail');
   }
   var At = T`typescript`({ AbstractMethodHasImplementation: ({ methodName: e }) => `Method '${e}' cannot have an implementation because it is marked abstract.`, AbstractPropertyHasInitializer: ({ propertyName: e }) => `Property '${e}' cannot have an initializer because it is marked abstract.`, AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.", AccessorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.", AccessorCannotHaveTypeParameters: 'An accessor cannot have type parameters.', ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.", ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.", ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.", ConstructorHasTypeParameters: 'Type parameters cannot appear on a constructor declaration.', DeclareAccessor: ({ kind: e }) => `'declare' is not allowed in ${e}ters.`, DeclareClassFieldHasInitializer: 'Initializers are not allowed in ambient contexts.', DeclareFunctionHasImplementation: 'An implementation cannot be declared in ambient contexts.', DuplicateAccessibilityModifier: ({ modifier: e }) => `Accessibility modifier already seen: '${e}'.`, DuplicateModifier: ({ modifier: e }) => `Duplicate modifier: '${e}'.`, EmptyHeritageClauseType: ({ token: e }) => `'${e}' list cannot be empty.`, EmptyTypeArguments: 'Type argument list cannot be empty.', EmptyTypeParameters: 'Type parameter list cannot be empty.', ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.", ImportAliasHasImportType: "An import alias can not use 'import type'.", ImportReflectionHasImportType: 'An `import module` declaration can not use `type` modifier', IncompatibleModifiers: ({ modifiers: e }) => `'${e[0]}' modifier cannot be used with '${e[1]}' modifier.`, IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.", IndexSignatureHasAccessibility: ({ modifier: e }) => `Index signatures cannot have an accessibility modifier ('${e}').`, IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.", IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.", IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.", InitializerNotAllowedInAmbientContext: 'Initializers are not allowed in ambient contexts.', InvalidHeritageClauseType: ({ token: e }) => `'${e}' list can only include identifiers or qualified-names with optional type arguments.`, InvalidModifierOnAwaitUsingDeclaration: (e) => `'${e}' modifier cannot appear on an await using declaration.`, InvalidModifierOnTypeMember: ({ modifier: e }) => `'${e}' modifier cannot appear on a type member.`, InvalidModifierOnTypeParameter: ({ modifier: e }) => `'${e}' modifier cannot appear on a type parameter.`, InvalidModifierOnTypeParameterPositions: ({ modifier: e }) => `'${e}' modifier can only appear on a type parameter of a class, interface or type alias.`, InvalidModifierOnUsingDeclaration: (e) => `'${e}' modifier cannot appear on a using declaration.`, InvalidModifiersOrder: ({ orderedModifiers: e }) => `'${e[0]}' modifier must precede '${e[1]}' modifier.`, InvalidPropertyAccessAfterInstantiationExpression: 'Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.', InvalidTupleMemberLabel: 'Tuple members must be labeled with a simple identifier.', MissingInterfaceName: "'interface' declarations must be followed by an identifier.", NonAbstractClassHasAbstractMethod: 'Abstract methods can only appear within an abstract class.', NonClassMethodPropertyHasAbstractModifier: "'abstract' modifier can only appear on a class, method, or property declaration.", OptionalTypeBeforeRequired: 'A required element cannot follow an optional element.', OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.", PatternIsOptional: 'A binding pattern parameter cannot be optional in an implementation signature.', PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.", PrivateElementHasAccessibility: ({ modifier: e }) => `Private elements cannot have an accessibility modifier ('${e}').`, ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.", ReservedArrowTypeParam: 'This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.', ReservedTypeAssertion: 'This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.', SetAccessorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.", SetAccessorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.", SetAccessorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.", SingleTypeParameterWithoutTrailingComma: ({ typeParameterName: e }) => `Single type parameter ${e} should have a trailing comma. Example usage: <${e},>.`, StaticBlockCannotHaveModifier: 'Static class blocks cannot have any modifier.', TupleOptionalAfterType: 'A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).', TypeAnnotationAfterAssign: 'Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.', TypeImportCannotSpecifyDefaultAndNamed: 'A type-only import can specify a default import or named bindings, but not both.', TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.", TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.", UnexpectedParameterModifier: 'A parameter property is only allowed in a constructor implementation.', UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.", UnexpectedTypeAnnotation: 'Did not expect a type annotation here.', UnexpectedTypeCastInParameter: 'Unexpected type cast in parameter position.', UnsupportedImportTypeArgument: 'Argument in a type import must be a string literal.', UnsupportedParameterPropertyKind: 'A parameter property may not be declared using a binding pattern.', UnsupportedSignatureParameterKind: ({ type: e }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${e}.`, UsingDeclarationInAmbientContext: (e) => `'${e}' declarations are not allowed in ambient contexts.` });
   function wt(e) {
    return 'private' === e || 'public' === e || 'protected' === e;
   }
   function St(e) {
    return 'in' === e || 'out' === e;
   }
   function vt(e) {
    if (e.extra?.parenthesized) return !1;
    switch (e.type) {
     case 'Identifier':
      return !0;
     case 'MemberExpression':
      return !e.computed && vt(e.object);
     case 'TSInstantiationExpression':
      return vt(e.expression);
     default:
      return !1;
    }
   }
   function Pt(e) {
    if ('MemberExpression' !== e.type) return !1;
    let { computed: t, property: r } = e;
    return (!t || 'StringLiteral' === r.type || !('TemplateLiteral' !== r.type || r.expressions.length > 0)) && Nt(e.object);
   }
   function kt(e, t) {
    let { type: r } = e;
    if (e.extra?.parenthesized) return !1;
    if (t) {
     if ('Literal' === r) {
      let { value: t } = e;
      if ('string' == typeof t || 'boolean' == typeof t) return !0;
     }
    } else if ('StringLiteral' === r || 'BooleanLiteral' === r) return !0;
    return !!(
     It(e, t) ||
     (function (e, t) {
      if ('UnaryExpression' === e.type) {
       let { operator: r, argument: s } = e;
       if ('-' === r && It(s, t)) return !0;
      }
      return !1;
     })(e, t) ||
     ('TemplateLiteral' === r && 0 === e.expressions.length) ||
     Pt(e)
    );
   }
   function It(e, t) {
    return t ? 'Literal' === e.type && ('number' == typeof e.value || 'bigint' in e) : 'NumericLiteral' === e.type || 'BigIntLiteral' === e.type;
   }
   function Nt(e) {
    return 'Identifier' === e.type || ('MemberExpression' === e.type && !e.computed && Nt(e.object));
   }
   var Bt = T`placeholders`({ ClassNameIsRequired: 'A class name is required.', UnexpectedSpace: 'Unexpected space in placeholder.' }),
    Ot = ['fsharp', 'hack'],
    Lt = ['^^', '@@', '^', '%', '#'];
   var Mt = {
     estree: (e) =>
      class extends e {
       parse() {
        let e = w(super.parse());
        return (256 & this.optionFlags && (e.tokens = e.tokens.map(w)), e);
       }
       parseRegExpLiteral({ pattern: e, flags: t }) {
        let r = null;
        try {
         r = new RegExp(e, t);
        } catch {}
        let s = this.estreeParseLiteral(r);
        return ((s.regex = { pattern: e, flags: t }), s);
       }
       parseBigIntLiteral(e) {
        let t;
        try {
         t = BigInt(e);
        } catch {
         t = null;
        }
        let r = this.estreeParseLiteral(t);
        return ((r.bigint = String(r.value || e)), r);
       }
       parseDecimalLiteral(e) {
        let t = this.estreeParseLiteral(null);
        return ((t.decimal = String(t.value || e)), t);
       }
       estreeParseLiteral(e) {
        return this.parseLiteral(e, 'Literal');
       }
       parseStringLiteral(e) {
        return this.estreeParseLiteral(e);
       }
       parseNumericLiteral(e) {
        return this.estreeParseLiteral(e);
       }
       parseNullLiteral() {
        return this.estreeParseLiteral(null);
       }
       parseBooleanLiteral(e) {
        return this.estreeParseLiteral(e);
       }
       estreeParseChainExpression(e, t) {
        let r = this.startNodeAtNode(e);
        return ((r.expression = e), this.finishNodeAt(r, 'ChainExpression', t));
       }
       directiveToStmt(e) {
        let t = e.value;
        (delete e.value, this.castNodeTo(t, 'Literal'), (t.raw = t.extra.raw), (t.value = t.extra.expressionValue));
        let r = this.castNodeTo(e, 'ExpressionStatement');
        return ((r.expression = t), (r.directive = t.extra.rawValue), delete t.extra, r);
       }
       fillOptionalPropertiesForTSESLint(e) {}
       cloneEstreeStringLiteral(e) {
        let { start: t, end: r, loc: s, range: n, raw: i, value: a } = e,
         o = Object.create(e.constructor.prototype);
        return ((o.type = 'Literal'), (o.start = t), (o.end = r), (o.loc = s), (o.range = n), (o.raw = i), (o.value = a), o);
       }
       initFunction(e, t) {
        (super.initFunction(e, t), (e.expression = !1));
       }
       checkDeclaration(e) {
        null != e && this.isObjectProperty(e) ? this.checkDeclaration(e.value) : super.checkDeclaration(e);
       }
       getObjectOrClassMethodParams(e) {
        return e.value.params;
       }
       isValidDirective(e) {
        return 'ExpressionStatement' === e.type && 'Literal' === e.expression.type && 'string' == typeof e.expression.value && !e.expression.extra?.parenthesized;
       }
       parseBlockBody(e, t, r, s, n) {
        super.parseBlockBody(e, t, r, s, n);
        let i = e.directives.map((e) => this.directiveToStmt(e));
        ((e.body = i.concat(e.body)), delete e.directives);
       }
       parsePrivateName() {
        let e = super.parsePrivateName();
        return this.convertPrivateNameToPrivateIdentifier(e);
       }
       convertPrivateNameToPrivateIdentifier(e) {
        let t = super.getPrivateNameSV(e);
        return (delete e.id, (e.name = t), this.castNodeTo(e, 'PrivateIdentifier'));
       }
       isPrivateName(e) {
        return 'PrivateIdentifier' === e.type;
       }
       getPrivateNameSV(e) {
        return e.name;
       }
       parseLiteral(e, t) {
        let r = super.parseLiteral(e, t);
        return ((r.raw = r.extra.raw), delete r.extra, r);
       }
       parseFunctionBody(e, t, r = !1) {
        (super.parseFunctionBody(e, t, r), (e.expression = 'BlockStatement' !== e.body.type));
       }
       parseMethod(e, t, r, s, n, i, a = !1) {
        let o = this.startNode();
        ((o.kind = e.kind), (o = super.parseMethod(o, t, r, s, n, i, a)), delete o.kind);
        let { typeParameters: u } = e;
        u && (delete e.typeParameters, (o.typeParameters = u), this.resetStartLocationFromNode(o, u));
        let l = this.castNodeTo(o, this.hasPlugin('typescript') && !o.body ? 'TSEmptyBodyFunctionExpression' : 'FunctionExpression');
        return ((e.value = l), 'ClassPrivateMethod' === i && (e.computed = !1), this.hasPlugin('typescript') && e.abstract ? (delete e.abstract, this.finishNode(e, 'TSAbstractMethodDefinition')) : 'ObjectMethod' === i ? ('method' === e.kind && (e.kind = 'init'), (e.shorthand = !1), this.finishNode(e, 'Property')) : this.finishNode(e, 'MethodDefinition'));
       }
       nameIsConstructor(e) {
        return 'Literal' === e.type ? 'constructor' === e.value : super.nameIsConstructor(e);
       }
       parseClassProperty(...e) {
        let t = super.parseClassProperty(...e);
        return (t.abstract && this.hasPlugin('typescript') ? (delete t.abstract, this.castNodeTo(t, 'TSAbstractPropertyDefinition')) : this.castNodeTo(t, 'PropertyDefinition'), t);
       }
       parseClassPrivateProperty(...e) {
        let t = super.parseClassPrivateProperty(...e);
        return (t.abstract && this.hasPlugin('typescript') ? this.castNodeTo(t, 'TSAbstractPropertyDefinition') : this.castNodeTo(t, 'PropertyDefinition'), (t.computed = !1), t);
       }
       parseClassAccessorProperty(e) {
        let t = super.parseClassAccessorProperty(e);
        return (t.abstract && this.hasPlugin('typescript') ? (delete t.abstract, this.castNodeTo(t, 'TSAbstractAccessorProperty')) : this.castNodeTo(t, 'AccessorProperty'), t);
       }
       parseObjectProperty(e, t, r, s) {
        let n = super.parseObjectProperty(e, t, r, s);
        return (n && ((n.kind = 'init'), this.castNodeTo(n, 'Property')), n);
       }
       finishObjectProperty(e) {
        return ((e.kind = 'init'), this.finishNode(e, 'Property'));
       }
       isValidLVal(e, t, r, s) {
        return 'Property' === e ? 'value' : super.isValidLVal(e, t, r, s);
       }
       isAssignable(e, t) {
        return null != e && this.isObjectProperty(e) ? this.isAssignable(e.value, t) : super.isAssignable(e, t);
       }
       toAssignable(e, t = !1) {
        if (null != e && this.isObjectProperty(e)) {
         let { key: r, value: s } = e;
         (this.isPrivateName(r) && this.classScope.usePrivateName(this.getPrivateNameSV(r), r.loc.start), this.toAssignable(s, t));
        } else super.toAssignable(e, t);
       }
       toAssignableObjectExpressionProp(e, t, r) {
        'Property' !== e.type || ('get' !== e.kind && 'set' !== e.kind) ? ('Property' === e.type && e.method ? this.raise(C.PatternHasMethod, e.key) : super.toAssignableObjectExpressionProp(e, t, r)) : this.raise(C.PatternHasAccessor, e.key);
       }
       finishCallExpression(e, t) {
        let r = super.finishCallExpression(e, t);
        return ('Import' === r.callee.type ? (this.castNodeTo(r, 'ImportExpression'), (r.source = r.arguments[0]), (r.options = r.arguments[1] ?? null), delete r.arguments, delete r.callee) : 'OptionalCallExpression' === r.type ? this.castNodeTo(r, 'CallExpression') : (r.optional = !1), r);
       }
       toReferencedArguments(e) {
        'ImportExpression' !== e.type && super.toReferencedArguments(e);
       }
       parseExport(e, t) {
        let r = this.state.lastTokStartLoc,
         s = super.parseExport(e, t);
        switch (s.type) {
         case 'ExportAllDeclaration':
          s.exported = null;
          break;
         case 'ExportNamedDeclaration':
          1 === s.specifiers.length && 'ExportNamespaceSpecifier' === s.specifiers[0].type && (this.castNodeTo(s, 'ExportAllDeclaration'), (s.exported = s.specifiers[0].exported), delete s.specifiers);
         case 'ExportDefaultDeclaration': {
          let { declaration: e } = s;
          'ClassDeclaration' === e?.type && e.decorators?.length > 0 && e.start === s.start && this.resetStartLocation(s, r);
         }
        }
        return s;
       }
       stopParseSubscript(e, t) {
        let r = super.stopParseSubscript(e, t);
        return t.optionalChainMember ? this.estreeParseChainExpression(r, e.loc.end) : r;
       }
       parseMember(e, t, r, s, n) {
        let i = super.parseMember(e, t, r, s, n);
        return ('OptionalMemberExpression' === i.type ? this.castNodeTo(i, 'MemberExpression') : (i.optional = !1), i);
       }
       isOptionalMemberExpression(e) {
        return 'ChainExpression' === e.type ? 'MemberExpression' === e.expression.type : super.isOptionalMemberExpression(e);
       }
       hasPropertyAsPrivateName(e) {
        return ('ChainExpression' === e.type && (e = e.expression), super.hasPropertyAsPrivateName(e));
       }
       isObjectProperty(e) {
        return 'Property' === e.type && 'init' === e.kind && !e.method;
       }
       isObjectMethod(e) {
        return 'Property' === e.type && (e.method || 'get' === e.kind || 'set' === e.kind);
       }
       castNodeTo(e, t) {
        let r = super.castNodeTo(e, t);
        return (this.fillOptionalPropertiesForTSESLint(r), r);
       }
       cloneIdentifier(e) {
        let t = super.cloneIdentifier(e);
        return (this.fillOptionalPropertiesForTSESLint(t), t);
       }
       cloneStringLiteral(e) {
        return 'Literal' === e.type ? this.cloneEstreeStringLiteral(e) : super.cloneStringLiteral(e);
       }
       finishNodeAt(e, t, r) {
        return w(super.finishNodeAt(e, t, r));
       }
       finishNode(e, t) {
        let r = super.finishNode(e, t);
        return (this.fillOptionalPropertiesForTSESLint(r), r);
       }
       resetStartLocation(e, t) {
        (super.resetStartLocation(e, t), w(e));
       }
       resetEndLocation(e, t = this.state.lastTokEndLoc) {
        (super.resetEndLocation(e, t), w(e));
       }
      },
     jsx: (e) =>
      class extends e {
       jsxReadToken() {
        let e = '',
         t = this.state.pos;
        for (;;) {
         if (this.state.pos >= this.length) throw this.raise(_e.UnterminatedJsxContent, this.state.startLoc);
         let r = this.input.charCodeAt(this.state.pos);
         switch (r) {
          case 60:
          case 123:
           return this.state.pos === this.state.start ? void (60 === r && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(143)) : super.getTokenFromCode(r)) : ((e += this.input.slice(t, this.state.pos)), void this.finishToken(142, e));
          case 38:
           ((e += this.input.slice(t, this.state.pos)), (e += this.jsxReadEntity()), (t = this.state.pos));
           break;
          case 62:
          case 125:
           this.raise(_e.UnexpectedToken, this.state.curPosition(), { unexpected: this.input[this.state.pos], HTMLEntity: 125 === r ? '&rbrace;' : '&gt;' });
          default:
           Be(r) ? ((e += this.input.slice(t, this.state.pos)), (e += this.jsxReadNewLine(!0)), (t = this.state.pos)) : ++this.state.pos;
         }
        }
       }
       jsxReadNewLine(e) {
        let t,
         r = this.input.charCodeAt(this.state.pos);
        return (++this.state.pos, 13 === r && 10 === this.input.charCodeAt(this.state.pos) ? (++this.state.pos, (t = e ? '\n' : '\r\n')) : (t = String.fromCharCode(r)), ++this.state.curLine, (this.state.lineStart = this.state.pos), t);
       }
       jsxReadString(e) {
        let t = '',
         r = ++this.state.pos;
        for (;;) {
         if (this.state.pos >= this.length) throw this.raise(C.UnterminatedString, this.state.startLoc);
         let s = this.input.charCodeAt(this.state.pos);
         if (s === e) break;
         38 === s ? ((t += this.input.slice(r, this.state.pos)), (t += this.jsxReadEntity()), (r = this.state.pos)) : Be(s) ? ((t += this.input.slice(r, this.state.pos)), (t += this.jsxReadNewLine(!1)), (r = this.state.pos)) : ++this.state.pos;
        }
        ((t += this.input.slice(r, this.state.pos++)), this.finishToken(134, t));
       }
       jsxReadEntity() {
        let e = ++this.state.pos;
        if (35 === this.codePointAtPos(this.state.pos)) {
         ++this.state.pos;
         let e = 10;
         120 === this.codePointAtPos(this.state.pos) && ((e = 16), ++this.state.pos);
         let t = this.readInt(e, void 0, !1, 'bail');
         if (null !== t && 59 === this.codePointAtPos(this.state.pos)) return (++this.state.pos, String.fromCodePoint(t));
        } else {
         let t = 0,
          r = !1;
         for (; t++ < 10 && this.state.pos < this.length && !(r = 59 === this.codePointAtPos(this.state.pos)); ) ++this.state.pos;
         if (r) {
          let t;
          this.input.slice(e, this.state.pos);
          if ((++this.state.pos, t)) return t;
         }
        }
        return ((this.state.pos = e), '&');
       }
       jsxReadWord() {
        let e,
         t = this.state.pos;
        do {
         e = this.input.charCodeAt(++this.state.pos);
        } while (he(e) || 45 === e);
        this.finishToken(141, this.input.slice(t, this.state.pos));
       }
       jsxParseIdentifier() {
        let e = this.startNode();
        return (this.match(141) ? (e.name = this.state.value) : Z(this.state.type) ? (e.name = ee(this.state.type)) : this.unexpected(), this.next(), this.finishNode(e, 'JSXIdentifier'));
       }
       jsxParseNamespacedName() {
        let e = this.state.startLoc,
         t = this.jsxParseIdentifier();
        if (!this.eat(14)) return t;
        let r = this.startNodeAt(e);
        return ((r.namespace = t), (r.name = this.jsxParseIdentifier()), this.finishNode(r, 'JSXNamespacedName'));
       }
       jsxParseElementName() {
        let e = this.state.startLoc,
         t = this.jsxParseNamespacedName();
        if ('JSXNamespacedName' === t.type) return t;
        for (; this.eat(16); ) {
         let r = this.startNodeAt(e);
         ((r.object = t), (r.property = this.jsxParseIdentifier()), (t = this.finishNode(r, 'JSXMemberExpression')));
        }
        return t;
       }
       jsxParseAttributeValue() {
        let e;
        switch (this.state.type) {
         case 5:
          return ((e = this.startNode()), this.setContext(v.brace), this.next(), (e = this.jsxParseExpressionContainer(e, v.j_oTag)), 'JSXEmptyExpression' === e.expression.type && this.raise(_e.AttributeIsEmpty, e), e);
         case 143:
         case 134:
          return this.parseExprAtom();
         default:
          throw this.raise(_e.UnsupportedJsxValue, this.state.startLoc);
        }
       }
       jsxParseEmptyExpression() {
        let e = this.startNodeAt(this.state.lastTokEndLoc);
        return this.finishNodeAt(e, 'JSXEmptyExpression', this.state.startLoc);
       }
       jsxParseSpreadChild(e) {
        return (this.next(), (e.expression = this.parseExpression()), this.setContext(v.j_expr), (this.state.canStartJSXElement = !0), this.expect(8), this.finishNode(e, 'JSXSpreadChild'));
       }
       jsxParseExpressionContainer(e, t) {
        if (this.match(8)) e.expression = this.jsxParseEmptyExpression();
        else {
         let t = this.parseExpression();
         ('SequenceExpression' === t.type && !t.extra?.parenthesized && this.raise(_e.UnexpectedSequenceExpression, t.expressions[1]), (e.expression = t));
        }
        return (this.setContext(t), (this.state.canStartJSXElement = !0), this.expect(8), this.finishNode(e, 'JSXExpressionContainer'));
       }
       jsxParseAttribute() {
        let e = this.startNode();
        return this.match(5) ? (this.setContext(v.brace), this.next(), this.expect(21), (e.argument = this.parseMaybeAssignAllowIn()), this.setContext(v.j_oTag), (this.state.canStartJSXElement = !0), this.expect(8), this.finishNode(e, 'JSXSpreadAttribute')) : ((e.name = this.jsxParseNamespacedName()), (e.value = this.eat(29) ? this.jsxParseAttributeValue() : null), this.finishNode(e, 'JSXAttribute'));
       }
       jsxParseOpeningElementAt(e) {
        let t = this.startNodeAt(e);
        return this.eat(144) ? this.finishNode(t, 'JSXOpeningFragment') : ((t.name = this.jsxParseElementName()), this.jsxParseOpeningElementAfterName(t));
       }
       jsxParseOpeningElementAfterName(e) {
        let t = [];
        for (; !this.match(56) && !this.match(144); ) t.push(this.jsxParseAttribute());
        return ((e.attributes = t), (e.selfClosing = this.eat(56)), this.expect(144), this.finishNode(e, 'JSXOpeningElement'));
       }
       jsxParseClosingElementAt(e) {
        let t = this.startNodeAt(e);
        return this.eat(144) ? this.finishNode(t, 'JSXClosingFragment') : ((t.name = this.jsxParseElementName()), this.expect(144), this.finishNode(t, 'JSXClosingElement'));
       }
       jsxParseElementAt(e) {
        let t = this.startNodeAt(e),
         r = [],
         s = this.jsxParseOpeningElementAt(e),
         n = null;
        if (!s.selfClosing) {
         e: for (;;)
          switch (this.state.type) {
           case 143:
            if (((e = this.state.startLoc), this.next(), this.eat(56))) {
             n = this.jsxParseClosingElementAt(e);
             break e;
            }
            r.push(this.jsxParseElementAt(e));
            break;
           case 142:
            r.push(this.parseLiteral(this.state.value, 'JSXText'));
            break;
           case 5: {
            let e = this.startNode();
            (this.setContext(v.brace), this.next(), this.match(21) ? r.push(this.jsxParseSpreadChild(e)) : r.push(this.jsxParseExpressionContainer(e, v.j_expr)));
            break;
           }
           default:
            this.unexpected();
          }
         Re(s) && !Re(n) && null !== n ? this.raise(_e.MissingClosingTagFragment, n) : ((!Re(s) && Re(n)) || (!Re(s) && !Re(n) && Ue(n.name) !== Ue(s.name))) && this.raise(_e.MissingClosingTagElement, n, { openingTagName: Ue(s.name) });
        }
        if ((Re(s) ? ((t.openingFragment = s), (t.closingFragment = n)) : ((t.openingElement = s), (t.closingElement = n)), (t.children = r), this.match(47))) throw this.raise(_e.UnwrappedAdjacentJSXElements, this.state.startLoc);
        return Re(s) ? this.finishNode(t, 'JSXFragment') : this.finishNode(t, 'JSXElement');
       }
       jsxParseElement() {
        let e = this.state.startLoc;
        return (this.next(), this.jsxParseElementAt(e));
       }
       setContext(e) {
        let { context: t } = this.state;
        t[t.length - 1] = e;
       }
       parseExprAtom(e) {
        return this.match(143) ? this.jsxParseElement() : this.match(47) && 33 !== this.input.charCodeAt(this.state.pos) ? (this.replaceToken(143), this.jsxParseElement()) : super.parseExprAtom(e);
       }
       skipSpace() {
        this.curContext().preserveSpace || super.skipSpace();
       }
       getTokenFromCode(e) {
        let t = this.curContext();
        if (t !== v.j_expr) {
         if (t === v.j_oTag || t === v.j_cTag) {
          if (ce(e)) return void this.jsxReadWord();
          if (62 === e) return (++this.state.pos, void this.finishToken(144));
          if ((34 === e || 39 === e) && t === v.j_oTag) return void this.jsxReadString(e);
         }
         if (60 === e && this.state.canStartJSXElement && 33 !== this.input.charCodeAt(this.state.pos + 1)) return (++this.state.pos, void this.finishToken(143));
         super.getTokenFromCode(e);
        } else this.jsxReadToken();
       }
       updateContext(e) {
        let { context: t, type: r } = this.state;
        if (56 === r && 143 === e) (t.splice(-2, 2, v.j_cTag), (this.state.canStartJSXElement = !1));
        else if (143 === r) t.push(v.j_oTag);
        else if (144 === r) {
         let r = t[t.length - 1];
         (r === v.j_oTag && 56 === e) || r === v.j_cTag ? (t.pop(), (this.state.canStartJSXElement = t[t.length - 1] === v.j_expr)) : (this.setContext(v.j_expr), (this.state.canStartJSXElement = !0));
        } else
         this.state.canStartJSXElement = (function (e) {
          return q[e];
         })(r);
       }
      },
     flow: (e) =>
      class extends e {
       flowPragma = void 0;
       getScopeHandler() {
        return we;
       }
       shouldParseTypes() {
        return this.getPluginOption('flow', 'all') || 'flow' === this.flowPragma;
       }
       finishToken(e, t) {
        (134 !== e && 13 !== e && 28 !== e && void 0 === this.flowPragma && (this.flowPragma = null), super.finishToken(e, t));
       }
       addComment(e) {
        if (void 0 === this.flowPragma) {
         let t = Ie.exec(e.value);
         if (t)
          if ('flow' === t[1]) this.flowPragma = 'flow';
          else {
           if ('noflow' !== t[1]) throw new Error('Unexpected flow pragma');
           this.flowPragma = 'noflow';
          }
        }
        super.addComment(e);
       }
       flowParseTypeInitialiser(e) {
        let t = this.state.inType;
        ((this.state.inType = !0), this.expect(e || 14));
        let r = this.flowParseType();
        return ((this.state.inType = t), r);
       }
       flowParsePredicate() {
        let e = this.startNode(),
         t = this.state.startLoc;
        return (this.next(), this.expectContextual(110), this.state.lastTokStartLoc.index > t.index + 1 && this.raise(ve.UnexpectedSpaceBetweenModuloChecks, t), this.eat(10) ? ((e.value = super.parseExpression()), this.expect(11), this.finishNode(e, 'DeclaredPredicate')) : this.finishNode(e, 'InferredPredicate'));
       }
       flowParseTypeAndPredicateInitialiser() {
        let e = this.state.inType;
        ((this.state.inType = !0), this.expect(14));
        let t = null,
         r = null;
        return (this.match(54) ? ((this.state.inType = e), (r = this.flowParsePredicate())) : ((t = this.flowParseType()), (this.state.inType = e), this.match(54) && (r = this.flowParsePredicate())), [t, r]);
       }
       flowParseDeclareClass(e) {
        return (this.next(), this.flowParseInterfaceish(e, !0), this.finishNode(e, 'DeclareClass'));
       }
       flowParseDeclareFunction(e) {
        this.next();
        let t = (e.id = this.parseIdentifier()),
         r = this.startNode(),
         s = this.startNode();
        (this.match(47) ? (r.typeParameters = this.flowParseTypeParameterDeclaration()) : (r.typeParameters = null), this.expect(10));
        let n = this.flowParseFunctionTypeParams();
        return ((r.params = n.params), (r.rest = n.rest), (r.this = n._this), this.expect(11), ([r.returnType, e.predicate] = this.flowParseTypeAndPredicateInitialiser()), (s.typeAnnotation = this.finishNode(r, 'FunctionTypeAnnotation')), (t.typeAnnotation = this.finishNode(s, 'TypeAnnotation')), this.resetEndLocation(t), this.semicolon(), this.scope.declareName(e.id.name, 2048, e.id.loc.start), this.finishNode(e, 'DeclareFunction'));
       }
       flowParseDeclare(e, t) {
        if (this.match(80)) return this.flowParseDeclareClass(e);
        if (this.match(68)) return this.flowParseDeclareFunction(e);
        if (this.match(74)) return this.flowParseDeclareVariable(e);
        if (this.eatContextual(127)) return this.match(16) ? this.flowParseDeclareModuleExports(e) : (t && this.raise(ve.NestedDeclareModule, this.state.lastTokStartLoc), this.flowParseDeclareModule(e));
        if (this.isContextual(130)) return this.flowParseDeclareTypeAlias(e);
        if (this.isContextual(131)) return this.flowParseDeclareOpaqueType(e);
        if (this.isContextual(129)) return this.flowParseDeclareInterface(e);
        if (this.match(82)) return this.flowParseDeclareExportDeclaration(e, t);
        throw this.unexpected();
       }
       flowParseDeclareVariable(e) {
        return (this.next(), (e.id = this.flowParseTypeAnnotatableIdentifier(!0)), this.scope.declareName(e.id.name, 5, e.id.loc.start), this.semicolon(), this.finishNode(e, 'DeclareVariable'));
       }
       flowParseDeclareModule(e) {
        (this.scope.enter(0), this.match(134) ? (e.id = super.parseExprAtom()) : (e.id = this.parseIdentifier()));
        let t = (e.body = this.startNode()),
         r = (t.body = []);
        for (this.expect(5); !this.match(8); ) {
         let e = this.startNode();
         this.match(83) ? (this.next(), !this.isContextual(130) && !this.match(87) && this.raise(ve.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc), r.push(super.parseImport(e))) : (this.expectContextual(125, ve.UnsupportedStatementInDeclareModule), r.push(this.flowParseDeclare(e, !0)));
        }
        (this.scope.exit(), this.expect(8), this.finishNode(t, 'BlockStatement'));
        let s = null,
         n = !1;
        return (
         r.forEach((e) => {
          !(function (e) {
           return 'DeclareExportAllDeclaration' === e.type || ('DeclareExportDeclaration' === e.type && (!e.declaration || ('TypeAlias' !== e.declaration.type && 'InterfaceDeclaration' !== e.declaration.type)));
          })(e)
           ? 'DeclareModuleExports' === e.type && (n && this.raise(ve.DuplicateDeclareModuleExports, e), 'ES' === s && this.raise(ve.AmbiguousDeclareModuleKind, e), (s = 'CommonJS'), (n = !0))
           : ('CommonJS' === s && this.raise(ve.AmbiguousDeclareModuleKind, e), (s = 'ES'));
         }),
         (e.kind = s || 'CommonJS'),
         this.finishNode(e, 'DeclareModule')
        );
       }
       flowParseDeclareExportDeclaration(e, t) {
        if ((this.expect(82), this.eat(65))) return (this.match(68) || this.match(80) ? (e.declaration = this.flowParseDeclare(this.startNode())) : ((e.declaration = this.flowParseType()), this.semicolon()), (e.default = !0), this.finishNode(e, 'DeclareExportDeclaration'));
        if (this.match(75) || this.isLet() || ((this.isContextual(130) || this.isContextual(129)) && !t)) {
         let e = this.state.value;
         throw this.raise(ve.UnsupportedDeclareExportKind, this.state.startLoc, { unsupportedExportKind: e, suggestion: ke[e] });
        }
        if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131)) return ((e.declaration = this.flowParseDeclare(this.startNode())), (e.default = !1), this.finishNode(e, 'DeclareExportDeclaration'));
        if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131)) return 'ExportNamedDeclaration' === (e = this.parseExport(e, null)).type ? ((e.default = !1), delete e.exportKind, this.castNodeTo(e, 'DeclareExportDeclaration')) : this.castNodeTo(e, 'DeclareExportAllDeclaration');
        throw this.unexpected();
       }
       flowParseDeclareModuleExports(e) {
        return (this.next(), this.expectContextual(111), (e.typeAnnotation = this.flowParseTypeAnnotation()), this.semicolon(), this.finishNode(e, 'DeclareModuleExports'));
       }
       flowParseDeclareTypeAlias(e) {
        this.next();
        let t = this.flowParseTypeAlias(e);
        return (this.castNodeTo(t, 'DeclareTypeAlias'), t);
       }
       flowParseDeclareOpaqueType(e) {
        this.next();
        let t = this.flowParseOpaqueType(e, !0);
        return (this.castNodeTo(t, 'DeclareOpaqueType'), t);
       }
       flowParseDeclareInterface(e) {
        return (this.next(), this.flowParseInterfaceish(e, !1), this.finishNode(e, 'DeclareInterface'));
       }
       flowParseInterfaceish(e, t) {
        if (((e.id = this.flowParseRestrictedIdentifier(!t, !0)), this.scope.declareName(e.id.name, t ? 17 : 8201, e.id.loc.start), this.match(47) ? (e.typeParameters = this.flowParseTypeParameterDeclaration()) : (e.typeParameters = null), (e.extends = []), this.eat(81)))
         do {
          e.extends.push(this.flowParseInterfaceExtends());
         } while (!t && this.eat(12));
        if (t) {
         if (((e.implements = []), (e.mixins = []), this.eatContextual(117)))
          do {
           e.mixins.push(this.flowParseInterfaceExtends());
          } while (this.eat(12));
         if (this.eatContextual(113))
          do {
           e.implements.push(this.flowParseInterfaceExtends());
          } while (this.eat(12));
        }
        e.body = this.flowParseObjectType({ allowStatic: t, allowExact: !1, allowSpread: !1, allowProto: t, allowInexact: !1 });
       }
       flowParseInterfaceExtends() {
        let e = this.startNode();
        return ((e.id = this.flowParseQualifiedTypeIdentifier()), this.match(47) ? (e.typeParameters = this.flowParseTypeParameterInstantiation()) : (e.typeParameters = null), this.finishNode(e, 'InterfaceExtends'));
       }
       flowParseInterface(e) {
        return (this.flowParseInterfaceish(e, !1), this.finishNode(e, 'InterfaceDeclaration'));
       }
       checkNotUnderscore(e) {
        '_' === e && this.raise(ve.UnexpectedReservedUnderscore, this.state.startLoc);
       }
       checkReservedType(e, t, r) {
        Se.has(e) && this.raise(r ? ve.AssignReservedType : ve.UnexpectedReservedType, t, { reservedType: e });
       }
       flowParseRestrictedIdentifier(e, t) {
        return (this.checkReservedType(this.state.value, this.state.startLoc, t), this.parseIdentifier(e));
       }
       flowParseTypeAlias(e) {
        return ((e.id = this.flowParseRestrictedIdentifier(!1, !0)), this.scope.declareName(e.id.name, 8201, e.id.loc.start), this.match(47) ? (e.typeParameters = this.flowParseTypeParameterDeclaration()) : (e.typeParameters = null), (e.right = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(e, 'TypeAlias'));
       }
       flowParseOpaqueType(e, t) {
        return (this.expectContextual(130), (e.id = this.flowParseRestrictedIdentifier(!0, !0)), this.scope.declareName(e.id.name, 8201, e.id.loc.start), this.match(47) ? (e.typeParameters = this.flowParseTypeParameterDeclaration()) : (e.typeParameters = null), (e.supertype = null), this.match(14) && (e.supertype = this.flowParseTypeInitialiser(14)), (e.impltype = null), t || (e.impltype = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(e, 'OpaqueType'));
       }
       flowParseTypeParameter(e = !1) {
        let t = this.state.startLoc,
         r = this.startNode(),
         s = this.flowParseVariance(),
         n = this.flowParseTypeAnnotatableIdentifier();
        return ((r.name = n.name), (r.variance = s), (r.bound = n.typeAnnotation), this.match(29) ? (this.eat(29), (r.default = this.flowParseType())) : e && this.raise(ve.MissingTypeParamDefault, t), this.finishNode(r, 'TypeParameter'));
       }
       flowParseTypeParameterDeclaration() {
        let e = this.state.inType,
         t = this.startNode();
        ((t.params = []), (this.state.inType = !0), this.match(47) || this.match(143) ? this.next() : this.unexpected());
        let r = !1;
        do {
         let e = this.flowParseTypeParameter(r);
         (t.params.push(e), e.default && (r = !0), this.match(48) || this.expect(12));
        } while (!this.match(48));
        return (this.expect(48), (this.state.inType = e), this.finishNode(t, 'TypeParameterDeclaration'));
       }
       flowInTopLevelContext(e) {
        if (this.curContext() === v.brace) return e();
        {
         let t = this.state.context;
         this.state.context = [t[0]];
         try {
          return e();
         } finally {
          this.state.context = t;
         }
        }
       }
       flowParseTypeParameterInstantiationInExpression() {
        if (47 === this.reScan_lt()) return this.flowParseTypeParameterInstantiation();
       }
       flowParseTypeParameterInstantiation() {
        let e = this.startNode(),
         t = this.state.inType;
        return (
         (this.state.inType = !0),
         (e.params = []),
         this.flowInTopLevelContext(() => {
          this.expect(47);
          let t = this.state.noAnonFunctionType;
          for (this.state.noAnonFunctionType = !1; !this.match(48); ) (e.params.push(this.flowParseType()), this.match(48) || this.expect(12));
          this.state.noAnonFunctionType = t;
         }),
         (this.state.inType = t),
         !this.state.inType && this.curContext() === v.brace && this.reScan_lt_gt(),
         this.expect(48),
         this.finishNode(e, 'TypeParameterInstantiation')
        );
       }
       flowParseTypeParameterInstantiationCallOrNew() {
        if (47 !== this.reScan_lt()) return null;
        let e = this.startNode(),
         t = this.state.inType;
        for (e.params = [], this.state.inType = !0, this.expect(47); !this.match(48); ) (e.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12));
        return (this.expect(48), (this.state.inType = t), this.finishNode(e, 'TypeParameterInstantiation'));
       }
       flowParseInterfaceType() {
        let e = this.startNode();
        if ((this.expectContextual(129), (e.extends = []), this.eat(81)))
         do {
          e.extends.push(this.flowParseInterfaceExtends());
         } while (this.eat(12));
        return ((e.body = this.flowParseObjectType({ allowStatic: !1, allowExact: !1, allowSpread: !1, allowProto: !1, allowInexact: !1 })), this.finishNode(e, 'InterfaceTypeAnnotation'));
       }
       flowParseObjectPropertyKey() {
        return this.match(135) || this.match(134) ? super.parseExprAtom() : this.parseIdentifier(!0);
       }
       flowParseObjectTypeIndexer(e, t, r) {
        return ((e.static = t), 14 === this.lookahead().type ? ((e.id = this.flowParseObjectPropertyKey()), (e.key = this.flowParseTypeInitialiser())) : ((e.id = null), (e.key = this.flowParseType())), this.expect(3), (e.value = this.flowParseTypeInitialiser()), (e.variance = r), this.finishNode(e, 'ObjectTypeIndexer'));
       }
       flowParseObjectTypeInternalSlot(e, t) {
        return ((e.static = t), (e.id = this.flowParseObjectPropertyKey()), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? ((e.method = !0), (e.optional = !1), (e.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e.loc.start)))) : ((e.method = !1), this.eat(17) && (e.optional = !0), (e.value = this.flowParseTypeInitialiser())), this.finishNode(e, 'ObjectTypeInternalSlot'));
       }
       flowParseObjectTypeMethodish(e) {
        for (e.params = [], e.rest = null, e.typeParameters = null, e.this = null, this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), this.match(78) && ((e.this = this.flowParseFunctionTypeParam(!0)), (e.this.name = null), this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); ) (e.params.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12));
        return (this.eat(21) && (e.rest = this.flowParseFunctionTypeParam(!1)), this.expect(11), (e.returnType = this.flowParseTypeInitialiser()), this.finishNode(e, 'FunctionTypeAnnotation'));
       }
       flowParseObjectTypeCallProperty(e, t) {
        let r = this.startNode();
        return ((e.static = t), (e.value = this.flowParseObjectTypeMethodish(r)), this.finishNode(e, 'ObjectTypeCallProperty'));
       }
       flowParseObjectType({ allowStatic: e, allowExact: t, allowSpread: r, allowProto: s, allowInexact: n }) {
        let i = this.state.inType;
        this.state.inType = !0;
        let a = this.startNode();
        ((a.callProperties = []), (a.properties = []), (a.indexers = []), (a.internalSlots = []));
        let o,
         u,
         l = !1;
        for (t && this.match(6) ? (this.expect(6), (o = 9), (u = !0)) : (this.expect(5), (o = 8), (u = !1)), a.exact = u; !this.match(o); ) {
         let t = !1,
          i = null,
          o = null,
          p = this.startNode();
         if (s && this.isContextual(118)) {
          let t = this.lookahead();
          14 !== t.type && 17 !== t.type && (this.next(), (i = this.state.startLoc), (e = !1));
         }
         if (e && this.isContextual(106)) {
          let e = this.lookahead();
          14 !== e.type && 17 !== e.type && (this.next(), (t = !0));
         }
         let c = this.flowParseVariance();
         if (this.eat(0)) (null != i && this.unexpected(i), this.eat(0) ? (c && this.unexpected(c.loc.start), a.internalSlots.push(this.flowParseObjectTypeInternalSlot(p, t))) : a.indexers.push(this.flowParseObjectTypeIndexer(p, t, c)));
         else if (this.match(10) || this.match(47)) (null != i && this.unexpected(i), c && this.unexpected(c.loc.start), a.callProperties.push(this.flowParseObjectTypeCallProperty(p, t)));
         else {
          let e = 'init';
          if (this.isContextual(99) || this.isContextual(104)) {
           G(this.lookahead().type) && ((e = this.state.value), this.next());
          }
          let s = this.flowParseObjectTypeProperty(p, t, i, c, e, r, n ?? !u);
          null === s ? ((l = !0), (o = this.state.lastTokStartLoc)) : a.properties.push(s);
         }
         (this.flowObjectTypeSemicolon(), o && !this.match(8) && !this.match(9) && this.raise(ve.UnexpectedExplicitInexactInObject, o));
        }
        (this.expect(o), r && (a.inexact = l));
        let p = this.finishNode(a, 'ObjectTypeAnnotation');
        return ((this.state.inType = i), p);
       }
       flowParseObjectTypeProperty(e, t, r, s, n, i, a) {
        if (this.eat(21)) return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (i ? a || this.raise(ve.InexactInsideExact, this.state.lastTokStartLoc) : this.raise(ve.InexactInsideNonObject, this.state.lastTokStartLoc), s && this.raise(ve.InexactVariance, s), null) : (i || this.raise(ve.UnexpectedSpreadType, this.state.lastTokStartLoc), null != r && this.unexpected(r), s && this.raise(ve.SpreadVariance, s), (e.argument = this.flowParseType()), this.finishNode(e, 'ObjectTypeSpreadProperty'));
        {
         ((e.key = this.flowParseObjectPropertyKey()), (e.static = t), (e.proto = null != r), (e.kind = n));
         let a = !1;
         return (this.match(47) || this.match(10) ? ((e.method = !0), null != r && this.unexpected(r), s && this.unexpected(s.loc.start), (e.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e.loc.start))), ('get' === n || 'set' === n) && this.flowCheckGetterSetterParams(e), !i && 'constructor' === e.key.name && e.value.this && this.raise(ve.ThisParamBannedInConstructor, e.value.this)) : ('init' !== n && this.unexpected(), (e.method = !1), this.eat(17) && (a = !0), (e.value = this.flowParseTypeInitialiser()), (e.variance = s)), (e.optional = a), this.finishNode(e, 'ObjectTypeProperty'));
        }
       }
       flowCheckGetterSetterParams(e) {
        let t = 'get' === e.kind ? 0 : 1,
         r = e.value.params.length + (e.value.rest ? 1 : 0);
        (e.value.this && this.raise('get' === e.kind ? ve.GetterMayNotHaveThisParam : ve.SetterMayNotHaveThisParam, e.value.this), r !== t && this.raise('get' === e.kind ? C.BadGetterArity : C.BadSetterArity, e), 'set' === e.kind && e.value.rest && this.raise(C.BadSetterRestParameter, e));
       }
       flowObjectTypeSemicolon() {
        !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
       }
       flowParseQualifiedTypeIdentifier(e, t) {
        e ?? (e = this.state.startLoc);
        let r = t || this.flowParseRestrictedIdentifier(!0);
        for (; this.eat(16); ) {
         let t = this.startNodeAt(e);
         ((t.qualification = r), (t.id = this.flowParseRestrictedIdentifier(!0)), (r = this.finishNode(t, 'QualifiedTypeIdentifier')));
        }
        return r;
       }
       flowParseGenericType(e, t) {
        let r = this.startNodeAt(e);
        return ((r.typeParameters = null), (r.id = this.flowParseQualifiedTypeIdentifier(e, t)), this.match(47) && (r.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(r, 'GenericTypeAnnotation'));
       }
       flowParseTypeofType() {
        let e = this.startNode();
        return (this.expect(87), (e.argument = this.flowParsePrimaryType()), this.finishNode(e, 'TypeofTypeAnnotation'));
       }
       flowParseTupleType() {
        let e = this.startNode();
        for (e.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (e.types.push(this.flowParseType()), !this.match(3)); ) this.expect(12);
        return (this.expect(3), this.finishNode(e, 'TupleTypeAnnotation'));
       }
       flowParseFunctionTypeParam(e) {
        let t = null,
         r = !1,
         s = null,
         n = this.startNode(),
         i = this.lookahead(),
         a = 78 === this.state.type;
        return (14 === i.type || 17 === i.type ? (a && !e && this.raise(ve.ThisParamMustBeFirst, n), (t = this.parseIdentifier(a)), this.eat(17) && ((r = !0), a && this.raise(ve.ThisParamMayNotBeOptional, n)), (s = this.flowParseTypeInitialiser())) : (s = this.flowParseType()), (n.name = t), (n.optional = r), (n.typeAnnotation = s), this.finishNode(n, 'FunctionTypeParam'));
       }
       reinterpretTypeAsFunctionTypeParam(e) {
        let t = this.startNodeAt(e.loc.start);
        return ((t.name = null), (t.optional = !1), (t.typeAnnotation = e), this.finishNode(t, 'FunctionTypeParam'));
       }
       flowParseFunctionTypeParams(e = []) {
        let t = null,
         r = null;
        for (this.match(78) && ((r = this.flowParseFunctionTypeParam(!0)), (r.name = null), this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); ) (e.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12));
        return (this.eat(21) && (t = this.flowParseFunctionTypeParam(!1)), { params: e, rest: t, _this: r });
       }
       flowIdentToTypeAnnotation(e, t, r) {
        switch (r.name) {
         case 'any':
          return this.finishNode(t, 'AnyTypeAnnotation');
         case 'bool':
         case 'boolean':
          return this.finishNode(t, 'BooleanTypeAnnotation');
         case 'mixed':
          return this.finishNode(t, 'MixedTypeAnnotation');
         case 'empty':
          return this.finishNode(t, 'EmptyTypeAnnotation');
         case 'number':
          return this.finishNode(t, 'NumberTypeAnnotation');
         case 'string':
          return this.finishNode(t, 'StringTypeAnnotation');
         case 'symbol':
          return this.finishNode(t, 'SymbolTypeAnnotation');
         default:
          return (this.checkNotUnderscore(r.name), this.flowParseGenericType(e, r));
        }
       }
       flowParsePrimaryType() {
        let e,
         t,
         r = this.state.startLoc,
         s = this.startNode(),
         n = !1,
         i = this.state.noAnonFunctionType;
        switch (this.state.type) {
         case 5:
          return this.flowParseObjectType({ allowStatic: !1, allowExact: !1, allowSpread: !0, allowProto: !1, allowInexact: !0 });
         case 6:
          return this.flowParseObjectType({ allowStatic: !1, allowExact: !0, allowSpread: !0, allowProto: !1, allowInexact: !1 });
         case 0:
          return ((this.state.noAnonFunctionType = !1), (t = this.flowParseTupleType()), (this.state.noAnonFunctionType = i), t);
         case 47: {
          let t = this.startNode();
          return ((t.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), (e = this.flowParseFunctionTypeParams()), (t.params = e.params), (t.rest = e.rest), (t.this = e._this), this.expect(11), this.expect(19), (t.returnType = this.flowParseType()), this.finishNode(t, 'FunctionTypeAnnotation'));
         }
         case 10: {
          let r = this.startNode();
          if ((this.next(), !this.match(11) && !this.match(21)))
           if (X(this.state.type) || this.match(78)) {
            let e = this.lookahead().type;
            n = 17 !== e && 14 !== e;
           } else n = !0;
          if (n) {
           if (((this.state.noAnonFunctionType = !1), (t = this.flowParseType()), (this.state.noAnonFunctionType = i), this.state.noAnonFunctionType || !(this.match(12) || (this.match(11) && 19 === this.lookahead().type)))) return (this.expect(11), t);
           this.eat(12);
          }
          return ((e = t ? this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(t)]) : this.flowParseFunctionTypeParams()), (r.params = e.params), (r.rest = e.rest), (r.this = e._this), this.expect(11), this.expect(19), (r.returnType = this.flowParseType()), (r.typeParameters = null), this.finishNode(r, 'FunctionTypeAnnotation'));
         }
         case 134:
          return this.parseLiteral(this.state.value, 'StringLiteralTypeAnnotation');
         case 85:
         case 86:
          return ((s.value = this.match(85)), this.next(), this.finishNode(s, 'BooleanLiteralTypeAnnotation'));
         case 53:
          if ('-' === this.state.value) {
           if ((this.next(), this.match(135))) return this.parseLiteralAtNode(-this.state.value, 'NumberLiteralTypeAnnotation', s);
           if (this.match(136)) return this.parseLiteralAtNode(-this.state.value, 'BigIntLiteralTypeAnnotation', s);
           throw this.raise(ve.UnexpectedSubtractionOperand, this.state.startLoc);
          }
          throw this.unexpected();
         case 135:
          return this.parseLiteral(this.state.value, 'NumberLiteralTypeAnnotation');
         case 136:
          return this.parseLiteral(this.state.value, 'BigIntLiteralTypeAnnotation');
         case 88:
          return (this.next(), this.finishNode(s, 'VoidTypeAnnotation'));
         case 84:
          return (this.next(), this.finishNode(s, 'NullLiteralTypeAnnotation'));
         case 78:
          return (this.next(), this.finishNode(s, 'ThisTypeAnnotation'));
         case 55:
          return (this.next(), this.finishNode(s, 'ExistsTypeAnnotation'));
         case 87:
          return this.flowParseTypeofType();
         default:
          if (Z(this.state.type)) {
           let e = ee(this.state.type);
           return (this.next(), super.createIdentifier(s, e));
          }
          if (X(this.state.type)) return this.isContextual(129) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(r, s, this.parseIdentifier());
        }
        throw this.unexpected();
       }
       flowParsePostfixType() {
        let e = this.state.startLoc,
         t = this.flowParsePrimaryType(),
         r = !1;
        for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
         let s = this.startNodeAt(e),
          n = this.eat(18);
         ((r = r || n), this.expect(0), !n && this.match(3) ? ((s.elementType = t), this.next(), (t = this.finishNode(s, 'ArrayTypeAnnotation'))) : ((s.objectType = t), (s.indexType = this.flowParseType()), this.expect(3), r ? ((s.optional = n), (t = this.finishNode(s, 'OptionalIndexedAccessType'))) : (t = this.finishNode(s, 'IndexedAccessType'))));
        }
        return t;
       }
       flowParsePrefixType() {
        let e = this.startNode();
        return this.eat(17) ? ((e.typeAnnotation = this.flowParsePrefixType()), this.finishNode(e, 'NullableTypeAnnotation')) : this.flowParsePostfixType();
       }
       flowParseAnonFunctionWithoutParens() {
        let e = this.flowParsePrefixType();
        if (!this.state.noAnonFunctionType && this.eat(19)) {
         let t = this.startNodeAt(e.loc.start);
         return ((t.params = [this.reinterpretTypeAsFunctionTypeParam(e)]), (t.rest = null), (t.this = null), (t.returnType = this.flowParseType()), (t.typeParameters = null), this.finishNode(t, 'FunctionTypeAnnotation'));
        }
        return e;
       }
       flowParseIntersectionType() {
        let e = this.startNode();
        this.eat(45);
        let t = this.flowParseAnonFunctionWithoutParens();
        for (e.types = [t]; this.eat(45); ) e.types.push(this.flowParseAnonFunctionWithoutParens());
        return 1 === e.types.length ? t : this.finishNode(e, 'IntersectionTypeAnnotation');
       }
       flowParseUnionType() {
        let e = this.startNode();
        this.eat(43);
        let t = this.flowParseIntersectionType();
        for (e.types = [t]; this.eat(43); ) e.types.push(this.flowParseIntersectionType());
        return 1 === e.types.length ? t : this.finishNode(e, 'UnionTypeAnnotation');
       }
       flowParseType() {
        let e = this.state.inType;
        this.state.inType = !0;
        let t = this.flowParseUnionType();
        return ((this.state.inType = e), t);
       }
       flowParseTypeOrImplicitInstantiation() {
        if (132 === this.state.type && '_' === this.state.value) {
         let e = this.state.startLoc,
          t = this.parseIdentifier();
         return this.flowParseGenericType(e, t);
        }
        return this.flowParseType();
       }
       flowParseTypeAnnotation() {
        let e = this.startNode();
        return ((e.typeAnnotation = this.flowParseTypeInitialiser()), this.finishNode(e, 'TypeAnnotation'));
       }
       flowParseTypeAnnotatableIdentifier(e) {
        let t = e ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
        return (this.match(14) && ((t.typeAnnotation = this.flowParseTypeAnnotation()), this.resetEndLocation(t)), t);
       }
       typeCastToParameter(e) {
        return ((e.expression.typeAnnotation = e.typeAnnotation), this.resetEndLocation(e.expression, e.typeAnnotation.loc.end), e.expression);
       }
       flowParseVariance() {
        let e = null;
        return this.match(53) ? ((e = this.startNode()), '+' === this.state.value ? (e.kind = 'plus') : (e.kind = 'minus'), this.next(), this.finishNode(e, 'Variance')) : e;
       }
       parseFunctionBody(e, t, r = !1) {
        t ? this.forwardNoArrowParamsConversionAt(e, () => super.parseFunctionBody(e, !0, r)) : super.parseFunctionBody(e, !1, r);
       }
       parseFunctionBodyAndFinish(e, t, r = !1) {
        if (this.match(14)) {
         let t = this.startNode();
         (([t.typeAnnotation, e.predicate] = this.flowParseTypeAndPredicateInitialiser()), (e.returnType = t.typeAnnotation ? this.finishNode(t, 'TypeAnnotation') : null));
        }
        return super.parseFunctionBodyAndFinish(e, t, r);
       }
       parseStatementLike(e) {
        if (this.state.strict && this.isContextual(129)) {
         if (K(this.lookahead().type)) {
          let e = this.startNode();
          return (this.next(), this.flowParseInterface(e));
         }
        } else if (this.isContextual(126)) {
         let e = this.startNode();
         return (this.next(), this.flowParseEnumDeclaration(e));
        }
        let t = super.parseStatementLike(e);
        return (void 0 === this.flowPragma && !this.isValidDirective(t) && (this.flowPragma = null), t);
       }
       parseExpressionStatement(e, t, r) {
        if ('Identifier' === t.type)
         if ('declare' === t.name) {
          if (this.match(80) || X(this.state.type) || this.match(68) || this.match(74) || this.match(82)) return this.flowParseDeclare(e);
         } else if (X(this.state.type)) {
          if ('interface' === t.name) return this.flowParseInterface(e);
          if ('type' === t.name) return this.flowParseTypeAlias(e);
          if ('opaque' === t.name) return this.flowParseOpaqueType(e, !1);
         }
        return super.parseExpressionStatement(e, t, r);
       }
       shouldParseExportDeclaration() {
        let { type: e } = this.state;
        return 126 === e || Q(e) ? !this.state.containsEsc : super.shouldParseExportDeclaration();
       }
       isExportDefaultSpecifier() {
        let { type: e } = this.state;
        return 126 === e || Q(e) ? this.state.containsEsc : super.isExportDefaultSpecifier();
       }
       parseExportDefaultExpression() {
        if (this.isContextual(126)) {
         let e = this.startNode();
         return (this.next(), this.flowParseEnumDeclaration(e));
        }
        return super.parseExportDefaultExpression();
       }
       parseConditional(e, t, r) {
        if (!this.match(17)) return e;
        if (this.state.maybeInArrowParameters) {
         let t = this.lookaheadCharCode();
         if (44 === t || 61 === t || 58 === t || 41 === t) return (this.setOptionalParametersError(r), e);
        }
        this.expect(17);
        let s = this.state.clone(),
         n = this.state.noArrowAt,
         i = this.startNodeAt(t),
         { consequent: a, failed: o } = this.tryParseConditionalConsequent(),
         [u, l] = this.getArrowLikeExpressions(a);
        if (o || l.length > 0) {
         let e = [...n];
         if (l.length > 0) {
          ((this.state = s), (this.state.noArrowAt = e));
          for (let t = 0; t < l.length; t++) e.push(l[t].start);
          (({ consequent: a, failed: o } = this.tryParseConditionalConsequent()), ([u, l] = this.getArrowLikeExpressions(a)));
         }
         (o && u.length > 1 && this.raise(ve.AmbiguousConditionalArrow, s.startLoc), o && 1 === u.length && ((this.state = s), e.push(u[0].start), (this.state.noArrowAt = e), ({ consequent: a, failed: o } = this.tryParseConditionalConsequent())));
        }
        return (this.getArrowLikeExpressions(a, !0), (this.state.noArrowAt = n), this.expect(14), (i.test = e), (i.consequent = a), (i.alternate = this.forwardNoArrowParamsConversionAt(i, () => this.parseMaybeAssign(void 0, void 0))), this.finishNode(i, 'ConditionalExpression'));
       }
       tryParseConditionalConsequent() {
        this.state.noArrowParamsConversionAt.push(this.state.start);
        let e = this.parseMaybeAssignAllowIn(),
         t = !this.match(14);
        return (this.state.noArrowParamsConversionAt.pop(), { consequent: e, failed: t });
       }
       getArrowLikeExpressions(e, t) {
        let r = [e],
         s = [];
        for (; 0 !== r.length; ) {
         let e = r.pop();
         'ArrowFunctionExpression' === e.type && 'BlockStatement' !== e.body.type ? (e.typeParameters || !e.returnType ? this.finishArrowValidation(e) : s.push(e), r.push(e.body)) : 'ConditionalExpression' === e.type && (r.push(e.consequent), r.push(e.alternate));
        }
        return t
         ? (s.forEach((e) => this.finishArrowValidation(e)), [s, []])
         : (function (e, t) {
            let r = [],
             s = [];
            for (let n = 0; n < e.length; n++) (t(e[n], n, e) ? r : s).push(e[n]);
            return [r, s];
           })(s, (e) => e.params.every((e) => this.isAssignable(e, !0)));
       }
       finishArrowValidation(e) {
        (this.toAssignableList(e.params, e.extra?.trailingCommaLoc, !1), this.scope.enter(518), super.checkParams(e, !1, !0), this.scope.exit());
       }
       forwardNoArrowParamsConversionAt(e, t) {
        let r;
        return (this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(e.start)) ? (this.state.noArrowParamsConversionAt.push(this.state.start), (r = t()), this.state.noArrowParamsConversionAt.pop()) : (r = t()), r);
       }
       parseParenItem(e, t) {
        let r = super.parseParenItem(e, t);
        if ((this.eat(17) && ((r.optional = !0), this.resetEndLocation(e)), this.match(14))) {
         let e = this.startNodeAt(t);
         return ((e.expression = r), (e.typeAnnotation = this.flowParseTypeAnnotation()), this.finishNode(e, 'TypeCastExpression'));
        }
        return r;
       }
       assertModuleNodeAllowed(e) {
        ('ImportDeclaration' === e.type && ('type' === e.importKind || 'typeof' === e.importKind)) || ('ExportNamedDeclaration' === e.type && 'type' === e.exportKind) || ('ExportAllDeclaration' === e.type && 'type' === e.exportKind) || super.assertModuleNodeAllowed(e);
       }
       parseExportDeclaration(e) {
        if (this.isContextual(130)) {
         e.exportKind = 'type';
         let t = this.startNode();
         return (this.next(), this.match(5) ? ((e.specifiers = this.parseExportSpecifiers(!0)), super.parseExportFrom(e), null) : this.flowParseTypeAlias(t));
        }
        if (this.isContextual(131)) {
         e.exportKind = 'type';
         let t = this.startNode();
         return (this.next(), this.flowParseOpaqueType(t, !1));
        }
        if (this.isContextual(129)) {
         e.exportKind = 'type';
         let t = this.startNode();
         return (this.next(), this.flowParseInterface(t));
        }
        if (this.isContextual(126)) {
         e.exportKind = 'value';
         let t = this.startNode();
         return (this.next(), this.flowParseEnumDeclaration(t));
        }
        return super.parseExportDeclaration(e);
       }
       eatExportStar(e) {
        return !!super.eatExportStar(e) || (!(!this.isContextual(130) || 55 !== this.lookahead().type) && ((e.exportKind = 'type'), this.next(), this.next(), !0));
       }
       maybeParseExportNamespaceSpecifier(e) {
        let { startLoc: t } = this.state,
         r = super.maybeParseExportNamespaceSpecifier(e);
        return (r && 'type' === e.exportKind && this.unexpected(t), r);
       }
       parseClassId(e, t, r) {
        (super.parseClassId(e, t, r), this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration()));
       }
       parseClassMember(e, t, r) {
        let { startLoc: s } = this.state;
        if (this.isContextual(125)) {
         if (super.parseClassMemberFromModifier(e, t)) return;
         t.declare = !0;
        }
        (super.parseClassMember(e, t, r), t.declare && ('ClassProperty' !== t.type && 'ClassPrivateProperty' !== t.type && 'PropertyDefinition' !== t.type ? this.raise(ve.DeclareClassElement, s) : t.value && this.raise(ve.DeclareClassFieldInitializer, t.value)));
       }
       isIterator(e) {
        return 'iterator' === e || 'asyncIterator' === e;
       }
       readIterator() {
        let e = super.readWord1(),
         t = '@@' + e;
        ((!this.isIterator(e) || !this.state.inType) && this.raise(C.InvalidIdentifier, this.state.curPosition(), { identifierName: t }), this.finishToken(132, t));
       }
       getTokenFromCode(e) {
        let t = this.input.charCodeAt(this.state.pos + 1);
        123 === e && 124 === t
         ? this.finishOp(6, 2)
         : !this.state.inType || (62 !== e && 60 !== e)
           ? this.state.inType && 63 === e
             ? 46 === t
               ? this.finishOp(18, 2)
               : this.finishOp(17, 1)
             : (function (e, t, r) {
                  return 64 === e && 64 === t && ce(r);
                 })(e, t, this.input.charCodeAt(this.state.pos + 2))
               ? ((this.state.pos += 2), this.readIterator())
               : super.getTokenFromCode(e)
           : this.finishOp(62 === e ? 48 : 47, 1);
       }
       isAssignable(e, t) {
        return 'TypeCastExpression' === e.type ? this.isAssignable(e.expression, t) : super.isAssignable(e, t);
       }
       toAssignable(e, t = !1) {
        (!t && 'AssignmentExpression' === e.type && 'TypeCastExpression' === e.left.type && (e.left = this.typeCastToParameter(e.left)), super.toAssignable(e, t));
       }
       toAssignableList(e, t, r) {
        for (let s = 0; s < e.length; s++) {
         let t = e[s];
         'TypeCastExpression' === t?.type && (e[s] = this.typeCastToParameter(t));
        }
        super.toAssignableList(e, t, r);
       }
       toReferencedList(e, t) {
        for (let r = 0; r < e.length; r++) {
         let s = e[r];
         s && 'TypeCastExpression' === s.type && !s.extra?.parenthesized && (e.length > 1 || !t) && this.raise(ve.TypeCastInPattern, s.typeAnnotation);
        }
        return e;
       }
       parseArrayLike(e, t, r) {
        let s = super.parseArrayLike(e, t, r);
        return (null != r && !this.state.maybeInArrowParameters && this.toReferencedList(s.elements), s);
       }
       isValidLVal(e, t, r, s) {
        return 'TypeCastExpression' === e || super.isValidLVal(e, t, r, s);
       }
       parseClassProperty(e) {
        return (this.match(14) && (e.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(e));
       }
       parseClassPrivateProperty(e) {
        return (this.match(14) && (e.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(e));
       }
       isClassMethod() {
        return this.match(47) || super.isClassMethod();
       }
       isClassProperty() {
        return this.match(14) || super.isClassProperty();
       }
       isNonstaticConstructor(e) {
        return !this.match(14) && super.isNonstaticConstructor(e);
       }
       pushClassMethod(e, t, r, s, n, i) {
        if ((t.variance && this.unexpected(t.variance.loc.start), delete t.variance, this.match(47) && (t.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(e, t, r, s, n, i), t.params && n)) {
         let e = t.params;
         e.length > 0 && this.isThisParam(e[0]) && this.raise(ve.ThisParamBannedInConstructor, t);
        } else if ('MethodDefinition' === t.type && n && t.value.params) {
         let e = t.value.params;
         e.length > 0 && this.isThisParam(e[0]) && this.raise(ve.ThisParamBannedInConstructor, t);
        }
       }
       pushClassPrivateMethod(e, t, r, s) {
        (t.variance && this.unexpected(t.variance.loc.start), delete t.variance, this.match(47) && (t.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(e, t, r, s));
       }
       parseClassSuper(e) {
        if ((super.parseClassSuper(e), e.superClass && (this.match(47) || this.match(51)) && (e.superTypeArguments = this.flowParseTypeParameterInstantiationInExpression()), this.isContextual(113))) {
         this.next();
         let t = (e.implements = []);
         do {
          let e = this.startNode();
          ((e.id = this.flowParseRestrictedIdentifier(!0)), this.match(47) ? (e.typeParameters = this.flowParseTypeParameterInstantiation()) : (e.typeParameters = null), t.push(this.finishNode(e, 'ClassImplements')));
         } while (this.eat(12));
        }
       }
       checkGetterSetterParams(e) {
        super.checkGetterSetterParams(e);
        let t = this.getObjectOrClassMethodParams(e);
        if (t.length > 0) {
         let r = t[0];
         this.isThisParam(r) && 'get' === e.kind ? this.raise(ve.GetterMayNotHaveThisParam, r) : this.isThisParam(r) && this.raise(ve.SetterMayNotHaveThisParam, r);
        }
       }
       parsePropertyNamePrefixOperator(e) {
        e.variance = this.flowParseVariance();
       }
       parseObjPropValue(e, t, r, s, n, i, a) {
        let o;
        (e.variance && this.unexpected(e.variance.loc.start), delete e.variance, this.match(47) && !i && ((o = this.flowParseTypeParameterDeclaration()), this.match(10) || this.unexpected()));
        let u = super.parseObjPropValue(e, t, r, s, n, i, a);
        return (o && ((u.value || u).typeParameters = o), u);
       }
       parseFunctionParamType(e) {
        return (this.eat(17) && ('Identifier' !== e.type && this.raise(ve.PatternIsOptional, e), this.isThisParam(e) && this.raise(ve.ThisParamMayNotBeOptional, e), (e.optional = !0)), this.match(14) ? (e.typeAnnotation = this.flowParseTypeAnnotation()) : this.isThisParam(e) && this.raise(ve.ThisParamAnnotationRequired, e), this.match(29) && this.isThisParam(e) && this.raise(ve.ThisParamNoDefault, e), this.resetEndLocation(e), e);
       }
       parseMaybeDefault(e, t) {
        let r = super.parseMaybeDefault(e, t);
        return ('AssignmentPattern' === r.type && r.typeAnnotation && r.right.start < r.typeAnnotation.start && this.raise(ve.TypeBeforeInitializer, r.typeAnnotation), r);
       }
       checkImportReflection(e) {
        (super.checkImportReflection(e), e.module && 'value' !== e.importKind && this.raise(ve.ImportReflectionHasImportType, e.specifiers[0].loc.start));
       }
       parseImportSpecifierLocal(e, t, r) {
        ((t.local = Pe(e) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier()), e.specifiers.push(this.finishImportSpecifier(t, r)));
       }
       isPotentialImportPhase(e) {
        if (super.isPotentialImportPhase(e)) return !0;
        if (this.isContextual(130)) {
         if (!e) return !0;
         let t = this.lookaheadCharCode();
         return 123 === t || 42 === t;
        }
        return !e && this.isContextual(87);
       }
       applyImportPhase(e, t, r, s) {
        if ((super.applyImportPhase(e, t, r, s), t)) {
         if (!r && this.match(65)) return;
         e.exportKind = 'type' === r ? r : 'value';
        } else ('type' === r && this.match(55) && this.unexpected(), (e.importKind = 'type' === r || 'typeof' === r ? r : 'value'));
       }
       parseImportSpecifier(e, t, r, s, n) {
        let i = e.imported,
         a = null;
        'Identifier' === i.type && ('type' === i.name ? (a = 'type') : 'typeof' === i.name && (a = 'typeof'));
        let o = !1;
        if (this.isContextual(93) && !this.isLookaheadContextual('as')) {
         let t = this.parseIdentifier(!0);
         null === a || K(this.state.type) ? ((e.imported = i), (e.importKind = null), (e.local = this.parseIdentifier())) : ((e.imported = t), (e.importKind = a), (e.local = this.cloneIdentifier(t)));
        } else {
         if (null !== a && K(this.state.type)) ((e.imported = this.parseIdentifier(!0)), (e.importKind = a));
         else {
          if (t) throw this.raise(C.ImportBindingIsString, e, { importName: i.value });
          ((e.imported = i), (e.importKind = null));
         }
         this.eatContextual(93) ? (e.local = this.parseIdentifier()) : ((o = !0), (e.local = this.cloneIdentifier(e.imported)));
        }
        let u = Pe(e);
        return (r && u && this.raise(ve.ImportTypeShorthandOnlyInPureImport, e), (r || u) && this.checkReservedType(e.local.name, e.local.loc.start, !0), o && !r && !u && this.checkReservedWord(e.local.name, e.loc.start, !0, !0), this.finishImportSpecifier(e, 'ImportSpecifier'));
       }
       parseBindingAtom() {
        return 78 === this.state.type ? this.parseIdentifier(!0) : super.parseBindingAtom();
       }
       parseFunctionParams(e, t) {
        let r = e.kind;
        ('get' !== r && 'set' !== r && this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(e, t));
       }
       parseVarId(e, t) {
        (super.parseVarId(e, t), this.match(14) && ((e.id.typeAnnotation = this.flowParseTypeAnnotation()), this.resetEndLocation(e.id)));
       }
       parseAsyncArrowFromCallExpression(e, t) {
        if (this.match(14)) {
         let t = this.state.noAnonFunctionType;
         ((this.state.noAnonFunctionType = !0), (e.returnType = this.flowParseTypeAnnotation()), (this.state.noAnonFunctionType = t));
        }
        return super.parseAsyncArrowFromCallExpression(e, t);
       }
       shouldParseAsyncArrow() {
        return this.match(14) || super.shouldParseAsyncArrow();
       }
       parseMaybeAssign(e, t) {
        let r,
         s = null;
        if (this.hasPlugin('jsx') && (this.match(143) || this.match(47))) {
         if (((s = this.state.clone()), (r = this.tryParse(() => super.parseMaybeAssign(e, t), s)), !r.error)) return r.node;
         let { context: n } = this.state,
          i = n[n.length - 1];
         (i === v.j_oTag || i === v.j_expr) && n.pop();
        }
        if (r?.error || this.match(47)) {
         s = s || this.state.clone();
         let n,
          i = this.tryParse((r) => {
           n = this.flowParseTypeParameterDeclaration();
           let s = this.forwardNoArrowParamsConversionAt(n, () => {
            let r = super.parseMaybeAssign(e, t);
            return (this.resetStartLocationFromNode(r, n), r);
           });
           s.extra?.parenthesized && r();
           let i = this.maybeUnwrapTypeCastExpression(s);
           return ('ArrowFunctionExpression' !== i.type && r(), (i.typeParameters = n), this.resetStartLocationFromNode(i, n), s);
          }, s),
          a = null;
         if (i.node && 'ArrowFunctionExpression' === this.maybeUnwrapTypeCastExpression(i.node).type) {
          if (!i.error && !i.aborted) return (i.node.async && this.raise(ve.UnexpectedTypeParameterBeforeAsyncArrowFunction, n), i.node);
          a = i.node;
         }
         if (r?.node) return ((this.state = r.failState), r.node);
         if (a) return ((this.state = i.failState), a);
         throw r?.thrown ? r.error : i.thrown ? i.error : this.raise(ve.UnexpectedTokenAfterTypeParameter, n);
        }
        return super.parseMaybeAssign(e, t);
       }
       parseArrow(e) {
        if (this.match(14)) {
         let t = this.tryParse(() => {
          let t = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = !0;
          let r = this.startNode();
          return (([r.typeAnnotation, e.predicate] = this.flowParseTypeAndPredicateInitialiser()), (this.state.noAnonFunctionType = t), this.canInsertSemicolon() && this.unexpected(), this.match(19) || this.unexpected(), r);
         });
         if (t.thrown) return null;
         (t.error && (this.state = t.failState), (e.returnType = t.node.typeAnnotation ? this.finishNode(t.node, 'TypeAnnotation') : null));
        }
        return super.parseArrow(e);
       }
       shouldParseArrow(e) {
        return this.match(14) || super.shouldParseArrow(e);
       }
       setArrowFunctionParameters(e, t) {
        this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(e.start)) ? (e.params = t) : super.setArrowFunctionParameters(e, t);
       }
       checkParams(e, t, r, s = !0) {
        if (!r || !this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(e.start))) {
         for (let t = 0; t < e.params.length; t++) this.isThisParam(e.params[t]) && t > 0 && this.raise(ve.ThisParamMustBeFirst, e.params[t]);
         super.checkParams(e, t, r, s);
        }
       }
       parseParenAndDistinguishExpression(e) {
        return super.parseParenAndDistinguishExpression(e && !this.state.noArrowAt.includes(this.sourceToOffsetPos(this.state.start)));
       }
       parseSubscripts(e, t, r) {
        if ('Identifier' === e.type && 'async' === e.name && this.state.noArrowAt.includes(t.index)) {
         this.next();
         let r = this.startNodeAt(t);
         ((r.callee = e), (r.arguments = super.parseCallExpressionArguments()), (e = this.finishNode(r, 'CallExpression')));
        } else if ('Identifier' === e.type && 'async' === e.name && this.match(47)) {
         let s = this.state.clone(),
          n = this.tryParse((e) => this.parseAsyncArrowWithTypeParameters(t) || e(), s);
         if (!n.error && !n.aborted) return n.node;
         let i = this.tryParse(() => super.parseSubscripts(e, t, r), s);
         if (i.node && !i.error) return i.node;
         if (n.node) return ((this.state = n.failState), n.node);
         if (i.node) return ((this.state = i.failState), i.node);
         throw n.error || i.error;
        }
        return super.parseSubscripts(e, t, r);
       }
       parseSubscript(e, t, r, s) {
        if (this.match(18) && this.isLookaheadToken_lt()) {
         if (((s.optionalChainMember = !0), r)) return ((s.stop = !0), e);
         this.next();
         let n = this.startNodeAt(t);
         return ((n.callee = e), (n.typeArguments = this.flowParseTypeParameterInstantiationInExpression()), this.expect(10), (n.arguments = this.parseCallExpressionArguments()), (n.optional = !0), this.finishCallExpression(n, !0));
        }
        if (!r && this.shouldParseTypes() && (this.match(47) || this.match(51))) {
         let r = this.startNodeAt(t);
         r.callee = e;
         let n = this.tryParse(() => ((r.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew()), this.expect(10), (r.arguments = super.parseCallExpressionArguments()), s.optionalChainMember && (r.optional = !1), this.finishCallExpression(r, s.optionalChainMember)));
         if (n.node) return (n.error && (this.state = n.failState), n.node);
        }
        return super.parseSubscript(e, t, r, s);
       }
       parseNewCallee(e) {
        super.parseNewCallee(e);
        let t = null;
        (this.shouldParseTypes() && this.match(47) && (t = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), (e.typeArguments = t));
       }
       parseAsyncArrowWithTypeParameters(e) {
        let t = this.startNodeAt(e);
        if ((this.parseFunctionParams(t, !1), this.parseArrow(t))) return super.parseArrowExpression(t, void 0, !0);
       }
       readToken_mult_modulo(e) {
        let t = this.input.charCodeAt(this.state.pos + 1);
        if (42 === e && 47 === t && this.state.hasFlowComment) return ((this.state.hasFlowComment = !1), (this.state.pos += 2), void this.nextToken());
        super.readToken_mult_modulo(e);
       }
       readToken_pipe_amp(e) {
        let t = this.input.charCodeAt(this.state.pos + 1);
        124 !== e || 125 !== t ? super.readToken_pipe_amp(e) : this.finishOp(9, 2);
       }
       parseTopLevel(e, t) {
        let r = super.parseTopLevel(e, t);
        return (this.state.hasFlowComment && this.raise(ve.UnterminatedFlowComment, this.state.curPosition()), r);
       }
       skipBlockComment() {
        if (!this.hasPlugin('flowComments') || !this.skipFlowComment()) return super.skipBlockComment(this.state.hasFlowComment ? '*-/' : '*/');
        {
         if (this.state.hasFlowComment) throw this.raise(ve.NestedFlowComment, this.state.startLoc);
         this.hasFlowCommentCompletion();
         let e = this.skipFlowComment();
         e && ((this.state.pos += e), (this.state.hasFlowComment = !0));
        }
       }
       skipFlowComment() {
        let { pos: e } = this.state,
         t = 2;
        for (; [32, 9].includes(this.input.charCodeAt(e + t)); ) t++;
        let r = this.input.charCodeAt(t + e),
         s = this.input.charCodeAt(t + e + 1);
        return 58 === r && 58 === s ? t + 2 : 'flow-include' === this.input.slice(t + e, t + e + 12) ? t + 12 : 58 === r && 58 !== s && t;
       }
       hasFlowCommentCompletion() {
        if (-1 === this.input.indexOf('*/', this.state.pos)) throw this.raise(C.UnterminatedComment, this.state.curPosition());
       }
       flowEnumErrorBooleanMemberNotInitialized(e, { enumName: t, memberName: r }) {
        this.raise(ve.EnumBooleanMemberNotInitialized, e, { memberName: r, enumName: t });
       }
       flowEnumErrorInvalidMemberInitializer(e, t) {
        return this.raise(t.explicitType ? ('symbol' === t.explicitType ? ve.EnumInvalidMemberInitializerSymbolType : ve.EnumInvalidMemberInitializerPrimaryType) : ve.EnumInvalidMemberInitializerUnknownType, e, t);
       }
       flowEnumErrorNumberMemberNotInitialized(e, t) {
        this.raise(ve.EnumNumberMemberNotInitialized, e, t);
       }
       flowEnumErrorStringMemberInconsistentlyInitialized(e, t) {
        this.raise(ve.EnumStringMemberInconsistentlyInitialized, e, t);
       }
       flowEnumMemberInit() {
        let e = this.state.startLoc,
         t = () => this.match(12) || this.match(8);
        switch (this.state.type) {
         case 135: {
          let r = this.parseNumericLiteral(this.state.value);
          return t() ? { type: 'number', loc: r.loc.start, value: r } : { type: 'invalid', loc: e };
         }
         case 134: {
          let r = this.parseStringLiteral(this.state.value);
          return t() ? { type: 'string', loc: r.loc.start, value: r } : { type: 'invalid', loc: e };
         }
         case 85:
         case 86: {
          let r = this.parseBooleanLiteral(this.match(85));
          return t() ? { type: 'boolean', loc: r.loc.start, value: r } : { type: 'invalid', loc: e };
         }
         default:
          return { type: 'invalid', loc: e };
        }
       }
       flowEnumMemberRaw() {
        let e = this.state.startLoc;
        return { id: this.parseIdentifier(!0), init: this.eat(29) ? this.flowEnumMemberInit() : { type: 'none', loc: e } };
       }
       flowEnumCheckExplicitTypeMismatch(e, t, r) {
        let { explicitType: s } = t;
        null !== s && s !== r && this.flowEnumErrorInvalidMemberInitializer(e, t);
       }
       flowEnumMembers({ enumName: e, explicitType: t }) {
        let r = new Set(),
         s = { booleanMembers: [], numberMembers: [], stringMembers: [], defaultedMembers: [] },
         n = !1;
        for (; !this.match(8); ) {
         if (this.eat(21)) {
          n = !0;
          break;
         }
         let i = this.startNode(),
          { id: a, init: o } = this.flowEnumMemberRaw(),
          u = a.name;
         if ('' === u) continue;
         (/^[a-z]/.test(u) && this.raise(ve.EnumInvalidMemberName, a, { memberName: u, suggestion: u[0].toUpperCase() + u.slice(1), enumName: e }), r.has(u) && this.raise(ve.EnumDuplicateMemberName, a, { memberName: u, enumName: e }), r.add(u));
         let l = { enumName: e, explicitType: t, memberName: u };
         switch (((i.id = a), o.type)) {
          case 'boolean':
           (this.flowEnumCheckExplicitTypeMismatch(o.loc, l, 'boolean'), (i.init = o.value), s.booleanMembers.push(this.finishNode(i, 'EnumBooleanMember')));
           break;
          case 'number':
           (this.flowEnumCheckExplicitTypeMismatch(o.loc, l, 'number'), (i.init = o.value), s.numberMembers.push(this.finishNode(i, 'EnumNumberMember')));
           break;
          case 'string':
           (this.flowEnumCheckExplicitTypeMismatch(o.loc, l, 'string'), (i.init = o.value), s.stringMembers.push(this.finishNode(i, 'EnumStringMember')));
           break;
          case 'invalid':
           throw this.flowEnumErrorInvalidMemberInitializer(o.loc, l);
          case 'none':
           switch (t) {
            case 'boolean':
             this.flowEnumErrorBooleanMemberNotInitialized(o.loc, l);
             break;
            case 'number':
             this.flowEnumErrorNumberMemberNotInitialized(o.loc, l);
             break;
            default:
             s.defaultedMembers.push(this.finishNode(i, 'EnumDefaultedMember'));
           }
         }
         this.match(8) || this.expect(12);
        }
        return { members: s, hasUnknownMembers: n };
       }
       flowEnumStringMembers(e, t, { enumName: r }) {
        if (0 === e.length) return t;
        if (0 === t.length) return e;
        if (t.length > e.length) {
         for (let t of e) this.flowEnumErrorStringMemberInconsistentlyInitialized(t, { enumName: r });
         return t;
        }
        for (let s of t) this.flowEnumErrorStringMemberInconsistentlyInitialized(s, { enumName: r });
        return e;
       }
       flowEnumParseExplicitType({ enumName: e }) {
        if (!this.eatContextual(102)) return null;
        if (!X(this.state.type)) throw this.raise(ve.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, { enumName: e });
        let { value: t } = this.state;
        return (this.next(), 'boolean' !== t && 'number' !== t && 'string' !== t && 'symbol' !== t && this.raise(ve.EnumInvalidExplicitType, this.state.startLoc, { enumName: e, invalidEnumType: t }), t);
       }
       flowEnumBody(e, t) {
        let r = t.name,
         s = t.loc.start,
         n = this.flowEnumParseExplicitType({ enumName: r });
        this.expect(5);
        let { members: i, hasUnknownMembers: a } = this.flowEnumMembers({ enumName: r, explicitType: n });
        switch (((e.hasUnknownMembers = a), n)) {
         case 'boolean':
          return ((e.explicitType = !0), (e.members = i.booleanMembers), this.expect(8), this.finishNode(e, 'EnumBooleanBody'));
         case 'number':
          return ((e.explicitType = !0), (e.members = i.numberMembers), this.expect(8), this.finishNode(e, 'EnumNumberBody'));
         case 'string':
          return ((e.explicitType = !0), (e.members = this.flowEnumStringMembers(i.stringMembers, i.defaultedMembers, { enumName: r })), this.expect(8), this.finishNode(e, 'EnumStringBody'));
         case 'symbol':
          return ((e.members = i.defaultedMembers), this.expect(8), this.finishNode(e, 'EnumSymbolBody'));
         default: {
          let t = () => ((e.members = []), this.expect(8), this.finishNode(e, 'EnumStringBody'));
          e.explicitType = !1;
          let n = i.booleanMembers.length,
           a = i.numberMembers.length,
           o = i.stringMembers.length,
           u = i.defaultedMembers.length;
          if (!(n || a || o || u)) return t();
          if (!n && !a) return ((e.members = this.flowEnumStringMembers(i.stringMembers, i.defaultedMembers, { enumName: r })), this.expect(8), this.finishNode(e, 'EnumStringBody'));
          if (!a && !o && n >= u) {
           for (let e of i.defaultedMembers) this.flowEnumErrorBooleanMemberNotInitialized(e.loc.start, { enumName: r, memberName: e.id.name });
           return ((e.members = i.booleanMembers), this.expect(8), this.finishNode(e, 'EnumBooleanBody'));
          }
          if (!n && !o && a >= u) {
           for (let e of i.defaultedMembers) this.flowEnumErrorNumberMemberNotInitialized(e.loc.start, { enumName: r, memberName: e.id.name });
           return ((e.members = i.numberMembers), this.expect(8), this.finishNode(e, 'EnumNumberBody'));
          }
          return (this.raise(ve.EnumInconsistentMemberValues, s, { enumName: r }), t());
         }
        }
       }
       flowParseEnumDeclaration(e) {
        let t = this.parseIdentifier();
        return ((e.id = t), (e.body = this.flowEnumBody(this.startNode(), t)), this.finishNode(e, 'EnumDeclaration'));
       }
       jsxParseOpeningElementAfterName(e) {
        return (this.shouldParseTypes() && (this.match(47) || this.match(51)) && (e.typeArguments = this.flowParseTypeParameterInstantiationInExpression()), super.jsxParseOpeningElementAfterName(e));
       }
       isLookaheadToken_lt() {
        let e = this.nextTokenStart();
        if (60 === this.input.charCodeAt(e)) {
         let t = this.input.charCodeAt(e + 1);
         return 60 !== t && 61 !== t;
        }
        return !1;
       }
       reScan_lt_gt() {
        let { type: e } = this.state;
        47 === e ? ((this.state.pos -= 1), this.readToken_lt()) : 48 === e && ((this.state.pos -= 1), this.readToken_gt());
       }
       reScan_lt() {
        let { type: e } = this.state;
        return 51 === e ? ((this.state.pos -= 2), this.finishOp(47, 1), 47) : e;
       }
       maybeUnwrapTypeCastExpression(e) {
        return 'TypeCastExpression' === e.type ? e.expression : e;
       }
      },
     typescript: (e) =>
      class extends e {
       getScopeHandler() {
        return qe;
       }
       tsIsIdentifier() {
        return X(this.state.type);
       }
       tsTokenCanFollowModifier() {
        return this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(139) || this.isLiteralPropertyName();
       }
       tsNextTokenOnSameLineAndCanFollowModifier() {
        return (this.next(), !this.hasPrecedingLineBreak() && this.tsTokenCanFollowModifier());
       }
       tsNextTokenCanFollowModifier() {
        return this.match(106) ? (this.next(), this.tsTokenCanFollowModifier()) : this.tsNextTokenOnSameLineAndCanFollowModifier();
       }
       tsParseModifier(e, t, r) {
        if (!X(this.state.type) && 58 !== this.state.type && 75 !== this.state.type) return;
        let s = this.state.value;
        if (e.includes(s)) {
         if ((r && this.match(106)) || (t && this.tsIsStartOfStaticBlocks())) return;
         if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) return s;
        }
       }
       tsParseModifiers({ allowedModifiers: e, disallowedModifiers: t, stopOnStartOfClassStaticBlock: r, errorTemplate: s = At.InvalidModifierOnTypeMember }, n) {
        let i = (e, t, r, s) => {
          t === r && n[s] && this.raise(At.InvalidModifiersOrder, e, { orderedModifiers: [r, s] });
         },
         a = (e, t, r, s) => {
          ((n[r] && t === s) || (n[s] && t === r)) && this.raise(At.IncompatibleModifiers, e, { modifiers: [r, s] });
         };
        for (;;) {
         let { startLoc: o } = this.state,
          u = this.tsParseModifier(e.concat(t ?? []), r, n.static);
         if (!u) break;
         (wt(u) ? (n.accessibility ? this.raise(At.DuplicateAccessibilityModifier, o, { modifier: u }) : (i(o, u, u, 'override'), i(o, u, u, 'static'), i(o, u, u, 'readonly'), (n.accessibility = u))) : St(u) ? (n[u] && this.raise(At.DuplicateModifier, o, { modifier: u }), (n[u] = !0), i(o, u, 'in', 'out')) : (Object.prototype.hasOwnProperty.call(n, u) ? this.raise(At.DuplicateModifier, o, { modifier: u }) : (i(o, u, 'static', 'readonly'), i(o, u, 'static', 'override'), i(o, u, 'override', 'readonly'), i(o, u, 'abstract', 'override'), a(o, u, 'declare', 'override'), a(o, u, 'static', 'abstract')), (n[u] = !0)), t?.includes(u) && this.raise(s, o, { modifier: u }));
        }
       }
       tsIsListTerminator(e) {
        switch (e) {
         case 'EnumMembers':
         case 'TypeMembers':
          return this.match(8);
         case 'HeritageClauseElement':
          return this.match(5);
         case 'TupleElementTypes':
          return this.match(3);
         case 'TypeParametersOrArguments':
          return this.match(48);
        }
       }
       tsParseList(e, t) {
        let r = [];
        for (; !this.tsIsListTerminator(e); ) r.push(t());
        return r;
       }
       tsParseDelimitedList(e, t, r) {
        return (function (e) {
         if (null == e) throw new Error(`Unexpected ${e} value.`);
         return e;
        })(this.tsParseDelimitedListWorker(e, t, !0, r));
       }
       tsParseDelimitedListWorker(e, t, r, s) {
        let n = [],
         i = -1;
        for (; !this.tsIsListTerminator(e); ) {
         i = -1;
         let s = t();
         if (null == s) return;
         if ((n.push(s), !this.eat(12))) {
          if (this.tsIsListTerminator(e)) break;
          return void (r && this.expect(12));
         }
         i = this.state.lastTokStartLoc.index;
        }
        return (s && (s.value = i), n);
       }
       tsParseBracketedList(e, t, r, s, n) {
        s || (r ? this.expect(0) : this.expect(47));
        let i = this.tsParseDelimitedList(e, t, n);
        return (r ? this.expect(3) : this.expect(48), i);
       }
       tsParseImportType() {
        let e = this.startNode();
        return (this.expect(83), this.expect(10), this.match(134) ? (e.argument = this.tsParseLiteralTypeNode()) : (this.raise(At.UnsupportedImportTypeArgument, this.state.startLoc), (e.argument = this.tsParseNonConditionalType())), this.eat(12) ? (e.options = this.tsParseImportTypeOptions()) : (e.options = null), this.expect(11), this.eat(16) && (e.qualifier = this.tsParseEntityName(3)), this.match(47) && (e.typeArguments = this.tsParseTypeArguments()), this.finishNode(e, 'TSImportType'));
       }
       tsParseImportTypeOptions() {
        let e = this.startNode();
        this.expect(5);
        let t = this.startNode();
        return (this.isContextual(76) ? ((t.method = !1), (t.key = this.parseIdentifier(!0)), (t.computed = !1), (t.shorthand = !1)) : this.unexpected(null, 76), this.expect(14), (t.value = this.tsParseImportTypeWithPropertyValue()), (e.properties = [this.finishObjectProperty(t)]), this.eat(12), this.expect(8), this.finishNode(e, 'ObjectExpression'));
       }
       tsParseImportTypeWithPropertyValue() {
        let e = this.startNode(),
         t = [];
        for (this.expect(5); !this.match(8); ) {
         let e = this.state.type;
         (X(e) || 134 === e ? t.push(super.parsePropertyDefinition(null)) : this.unexpected(), this.eat(12));
        }
        return ((e.properties = t), this.next(), this.finishNode(e, 'ObjectExpression'));
       }
       tsParseEntityName(e) {
        let t;
        if (1 & e && this.match(78))
         if (2 & e) t = this.parseIdentifier(!0);
         else {
          let e = this.startNode();
          (this.next(), (t = this.finishNode(e, 'ThisExpression')));
         }
        else t = this.parseIdentifier(!!(1 & e));
        for (; this.eat(16); ) {
         let r = this.startNodeAtNode(t);
         ((r.left = t), (r.right = this.parseIdentifier(!!(1 & e))), (t = this.finishNode(r, 'TSQualifiedName')));
        }
        return t;
       }
       tsParseTypeReference() {
        let e = this.startNode();
        return ((e.typeName = this.tsParseEntityName(1)), !this.hasPrecedingLineBreak() && this.match(47) && (e.typeArguments = this.tsParseTypeArguments()), this.finishNode(e, 'TSTypeReference'));
       }
       tsParseThisTypePredicate(e) {
        this.next();
        let t = this.startNodeAtNode(e);
        return ((t.parameterName = e), (t.typeAnnotation = this.tsParseTypeAnnotation(!1)), (t.asserts = !1), this.finishNode(t, 'TSTypePredicate'));
       }
       tsParseThisTypeNode() {
        let e = this.startNode();
        return (this.next(), this.finishNode(e, 'TSThisType'));
       }
       tsParseTypeQuery() {
        let e = this.startNode();
        return (this.expect(87), this.match(83) ? (e.exprName = this.tsParseImportType()) : (e.exprName = this.tsParseEntityName(1)), !this.hasPrecedingLineBreak() && this.match(47) && (e.typeArguments = this.tsParseTypeArguments()), this.finishNode(e, 'TSTypeQuery'));
       }
       tsParseInOutModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ['in', 'out'], disallowedModifiers: ['const', 'public', 'private', 'protected', 'readonly', 'declare', 'abstract', 'override'], errorTemplate: At.InvalidModifierOnTypeParameter });
       tsParseConstModifier = this.tsParseModifiers.bind(this, { allowedModifiers: ['const'], disallowedModifiers: ['in', 'out'], errorTemplate: At.InvalidModifierOnTypeParameterPositions });
       tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ['in', 'out', 'const'], disallowedModifiers: ['public', 'private', 'protected', 'readonly', 'declare', 'abstract', 'override'], errorTemplate: At.InvalidModifierOnTypeParameter });
       tsParseTypeParameter(e) {
        let t = this.startNode();
        return (e(t), (t.name = this.tsParseTypeParameterName()), (t.constraint = this.tsEatThenParseType(81)), (t.default = this.tsEatThenParseType(29)), this.finishNode(t, 'TSTypeParameter'));
       }
       tsTryParseTypeParameters(e) {
        if (this.match(47)) return this.tsParseTypeParameters(e);
       }
       tsParseTypeParameters(e) {
        let t = this.startNode();
        this.match(47) || this.match(143) ? this.next() : this.unexpected();
        let r = { value: -1 };
        return ((t.params = this.tsParseBracketedList('TypeParametersOrArguments', this.tsParseTypeParameter.bind(this, e), !1, !0, r)), 0 === t.params.length && this.raise(At.EmptyTypeParameters, t), -1 !== r.value && this.addExtra(t, 'trailingComma', r.value), this.finishNode(t, 'TSTypeParameterDeclaration'));
       }
       tsFillSignature(e, t) {
        let r = 19 === e,
         s = 'returnType';
        ((t.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier)), this.expect(10), (t.params = this.tsParseBindingListForSignature()), (r || this.match(e)) && (t[s] = this.tsParseTypeOrTypePredicateAnnotation(e)));
       }
       tsParseBindingListForSignature() {
        let e = super.parseBindingList(11, 41, 2);
        for (let t of e) {
         let { type: e } = t;
         ('AssignmentPattern' === e || 'TSParameterProperty' === e) && this.raise(At.UnsupportedSignatureParameterKind, t, { type: e });
        }
        return e;
       }
       tsParseTypeMemberSemicolon() {
        !this.eat(12) && !this.isLineTerminator() && this.expect(13);
       }
       tsParseSignatureMember(e, t) {
        return (this.tsFillSignature(14, t), this.tsParseTypeMemberSemicolon(), this.finishNode(t, e));
       }
       tsIsUnambiguouslyIndexSignature() {
        return (this.next(), !!X(this.state.type) && (this.next(), this.match(14)));
       }
       tsTryParseIndexSignature(e) {
        if (!this.match(0) || !this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))) return;
        this.expect(0);
        let t = this.parseIdentifier();
        ((t.typeAnnotation = this.tsParseTypeAnnotation()), this.resetEndLocation(t), this.expect(3), (e.parameters = [t]));
        let r = this.tsTryParseTypeAnnotation();
        return (r && (e.typeAnnotation = r), this.tsParseTypeMemberSemicolon(), this.finishNode(e, 'TSIndexSignature'));
       }
       tsParsePropertyOrMethodSignature(e, t) {
        if ((this.eat(17) && (e.optional = !0), this.match(10) || this.match(47))) {
         t && this.raise(At.ReadonlyForMethodSignature, e);
         let r = e;
         (r.kind && this.match(47) && this.raise(At.AccessorCannotHaveTypeParameters, this.state.curPosition()), this.tsFillSignature(14, r), this.tsParseTypeMemberSemicolon());
         let s = 'params',
          n = 'returnType';
         if ('get' === r.kind) r[s].length > 0 && (this.raise(C.BadGetterArity, this.state.curPosition()), this.isThisParam(r[s][0]) && this.raise(At.AccessorCannotDeclareThisParameter, this.state.curPosition()));
         else if ('set' === r.kind) {
          if (1 !== r[s].length) this.raise(C.BadSetterArity, this.state.curPosition());
          else {
           let e = r[s][0];
           (this.isThisParam(e) && this.raise(At.AccessorCannotDeclareThisParameter, this.state.curPosition()), 'Identifier' === e.type && e.optional && this.raise(At.SetAccessorCannotHaveOptionalParameter, this.state.curPosition()), 'RestElement' === e.type && this.raise(At.SetAccessorCannotHaveRestParameter, this.state.curPosition()));
          }
          r[n] && this.raise(At.SetAccessorCannotHaveReturnType, r[n]);
         } else r.kind = 'method';
         return this.finishNode(r, 'TSMethodSignature');
        }
        {
         let r = e;
         t && (r.readonly = !0);
         let s = this.tsTryParseTypeAnnotation();
         return (s && (r.typeAnnotation = s), this.tsParseTypeMemberSemicolon(), this.finishNode(r, 'TSPropertySignature'));
        }
       }
       tsParseTypeMember() {
        let e = this.startNode();
        if (this.match(10) || this.match(47)) return this.tsParseSignatureMember('TSCallSignatureDeclaration', e);
        if (this.match(77)) {
         let t = this.startNode();
         return (this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember('TSConstructSignatureDeclaration', e) : ((e.key = this.createIdentifier(t, 'new')), this.tsParsePropertyOrMethodSignature(e, !1)));
        }
        return (this.tsParseModifiers({ allowedModifiers: ['readonly'], disallowedModifiers: ['declare', 'abstract', 'private', 'protected', 'public', 'static', 'override'] }, e), this.tsTryParseIndexSignature(e) || (super.parsePropertyName(e), !e.computed && 'Identifier' === e.key.type && ('get' === e.key.name || 'set' === e.key.name) && this.tsTokenCanFollowModifier() && ((e.kind = e.key.name), super.parsePropertyName(e), !this.match(10) && !this.match(47) && this.unexpected(null, 10)), this.tsParsePropertyOrMethodSignature(e, !!e.readonly)));
       }
       tsParseTypeLiteral() {
        let e = this.startNode();
        return ((e.members = this.tsParseObjectTypeMembers()), this.finishNode(e, 'TSTypeLiteral'));
       }
       tsParseObjectTypeMembers() {
        this.expect(5);
        let e = this.tsParseList('TypeMembers', this.tsParseTypeMember.bind(this));
        return (this.expect(8), e);
       }
       tsIsStartOfMappedType() {
        return (this.next(), this.eat(53) ? this.isContextual(122) : (this.isContextual(122) && this.next(), !(!this.match(0) || (this.next(), !this.tsIsIdentifier())) && (this.next(), this.match(58))));
       }
       tsParseMappedType() {
        let e = this.startNode();
        return (this.expect(5), this.match(53) ? ((e.readonly = this.state.value), this.next(), this.expectContextual(122)) : this.eatContextual(122) && (e.readonly = !0), this.expect(0), (e.key = this.tsParseTypeParameterName()), (e.constraint = this.tsExpectThenParseType(58)), (e.nameType = this.eatContextual(93) ? this.tsParseType() : null), this.expect(3), this.match(53) ? ((e.optional = this.state.value), this.next(), this.expect(17)) : this.eat(17) && (e.optional = !0), (e.typeAnnotation = this.tsTryParseType()), this.semicolon(), this.expect(8), this.finishNode(e, 'TSMappedType'));
       }
       tsParseTupleType() {
        let e = this.startNode();
        e.elementTypes = this.tsParseBracketedList('TupleElementTypes', this.tsParseTupleElementType.bind(this), !0, !1);
        let t = !1;
        return (
         e.elementTypes.forEach((e) => {
          let { type: r } = e;
          (t && 'TSRestType' !== r && 'TSOptionalType' !== r && !('TSNamedTupleMember' === r && e.optional) && this.raise(At.OptionalTypeBeforeRequired, e), t || (t = ('TSNamedTupleMember' === r && e.optional) || 'TSOptionalType' === r));
         }),
         this.finishNode(e, 'TSTupleType')
        );
       }
       tsParseTupleElementType() {
        let e,
         t,
         r,
         s,
         n = this.state.startLoc,
         i = this.eat(21),
         { startLoc: a } = this.state,
         o = K(this.state.type) ? this.lookaheadCharCode() : null;
        if (58 === o) ((e = !0), (r = !1), (t = this.parseIdentifier(!0)), this.expect(14), (s = this.tsParseType()));
        else if (63 === o) {
         r = !0;
         let n = this.state.value,
          i = this.tsParseNonArrayType();
         58 === this.lookaheadCharCode() ? ((e = !0), (t = this.createIdentifier(this.startNodeAt(a), n)), this.expect(17), this.expect(14), (s = this.tsParseType())) : ((e = !1), (s = i), this.expect(17));
        } else ((s = this.tsParseType()), (r = this.eat(17)), (e = this.eat(14)));
        if (e) {
         let e;
         (t ? ((e = this.startNodeAt(a)), (e.optional = r), (e.label = t), (e.elementType = s), this.eat(17) && ((e.optional = !0), this.raise(At.TupleOptionalAfterType, this.state.lastTokStartLoc))) : ((e = this.startNodeAt(a)), (e.optional = r), this.raise(At.InvalidTupleMemberLabel, s), (e.label = s), (e.elementType = this.tsParseType())), (s = this.finishNode(e, 'TSNamedTupleMember')));
        } else if (r) {
         let e = this.startNodeAt(a);
         ((e.typeAnnotation = s), (s = this.finishNode(e, 'TSOptionalType')));
        }
        if (i) {
         let e = this.startNodeAt(n);
         ((e.typeAnnotation = s), (s = this.finishNode(e, 'TSRestType')));
        }
        return s;
       }
       tsParseParenthesizedType() {
        let e = this.startNode();
        return (this.expect(10), (e.typeAnnotation = this.tsParseType()), this.expect(11), this.finishNode(e, 'TSParenthesizedType'));
       }
       tsParseFunctionOrConstructorType(e, t) {
        let r = this.startNode();
        return ('TSConstructorType' === e && ((r.abstract = !!t), t && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, r)), this.finishNode(r, e));
       }
       tsParseLiteralTypeNode() {
        let e = this.startNode();
        switch (this.state.type) {
         case 135:
         case 136:
         case 134:
         case 85:
         case 86:
          e.literal = super.parseExprAtom();
          break;
         default:
          this.unexpected();
        }
        return this.finishNode(e, 'TSLiteralType');
       }
       tsParseTemplateLiteralType() {
        {
         let e = this.state.startLoc,
          t = this.parseTemplateElement(!1),
          r = [t];
         if (t.tail) {
          let t = this.startNodeAt(e),
           s = this.startNodeAt(e);
          return ((s.expressions = []), (s.quasis = r), (t.literal = this.finishNode(s, 'TemplateLiteral')), this.finishNode(t, 'TSLiteralType'));
         }
         {
          let s = [];
          for (; !t.tail; ) (s.push(this.tsParseType()), this.readTemplateContinuation(), r.push((t = this.parseTemplateElement(!1))));
          let n = this.startNodeAt(e);
          return ((n.types = s), (n.quasis = r), this.finishNode(n, 'TSTemplateLiteralType'));
         }
        }
       }
       parseTemplateSubstitution() {
        return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
       }
       tsParseThisTypeOrThisTypePredicate() {
        let e = this.tsParseThisTypeNode();
        return this.isContextual(116) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(e) : e;
       }
       tsParseNonArrayType() {
        switch (this.state.type) {
         case 134:
         case 135:
         case 136:
         case 85:
         case 86:
          return this.tsParseLiteralTypeNode();
         case 53:
          if ('-' === this.state.value) {
           let e = this.startNode(),
            t = this.lookahead();
           return (135 !== t.type && 136 !== t.type && this.unexpected(), (e.literal = this.parseMaybeUnary()), this.finishNode(e, 'TSLiteralType'));
          }
          break;
         case 78:
          return this.tsParseThisTypeOrThisTypePredicate();
         case 87:
          return this.tsParseTypeQuery();
         case 83:
          return this.tsParseImportType();
         case 5:
          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
         case 0:
          return this.tsParseTupleType();
         case 10:
          if (!(1024 & this.optionFlags)) {
           let e = this.state.startLoc;
           this.next();
           let t = this.tsParseType();
           return (this.expect(11), this.addExtra(t, 'parenthesized', !0), this.addExtra(t, 'parenStart', e.index), t);
          }
          return this.tsParseParenthesizedType();
         case 25:
         case 24:
          return this.tsParseTemplateLiteralType();
         default: {
          let { type: e } = this.state;
          if (X(e) || 88 === e || 84 === e) {
           let t =
            88 === e
             ? 'TSVoidKeyword'
             : 84 === e
               ? 'TSNullKeyword'
               : (function (e) {
                  switch (e) {
                   case 'any':
                    return 'TSAnyKeyword';
                   case 'boolean':
                    return 'TSBooleanKeyword';
                   case 'bigint':
                    return 'TSBigIntKeyword';
                   case 'never':
                    return 'TSNeverKeyword';
                   case 'number':
                    return 'TSNumberKeyword';
                   case 'object':
                    return 'TSObjectKeyword';
                   case 'string':
                    return 'TSStringKeyword';
                   case 'symbol':
                    return 'TSSymbolKeyword';
                   case 'undefined':
                    return 'TSUndefinedKeyword';
                   case 'unknown':
                    return 'TSUnknownKeyword';
                   default:
                    return;
                  }
                 })(this.state.value);
           if (void 0 !== t && 46 !== this.lookaheadCharCode()) {
            let e = this.startNode();
            return (this.next(), this.finishNode(e, t));
           }
           return this.tsParseTypeReference();
          }
         }
        }
        throw this.unexpected();
       }
       tsParseArrayTypeOrHigher() {
        let { startLoc: e } = this.state,
         t = this.tsParseNonArrayType();
        for (; !this.hasPrecedingLineBreak() && this.eat(0); )
         if (this.match(3)) {
          let r = this.startNodeAt(e);
          ((r.elementType = t), this.expect(3), (t = this.finishNode(r, 'TSArrayType')));
         } else {
          let r = this.startNodeAt(e);
          ((r.objectType = t), (r.indexType = this.tsParseType()), this.expect(3), (t = this.finishNode(r, 'TSIndexedAccessType')));
         }
        return t;
       }
       tsParseTypeOperator() {
        let e = this.startNode(),
         t = this.state.value;
        return (this.next(), (e.operator = t), (e.typeAnnotation = this.tsParseTypeOperatorOrHigher()), 'readonly' === t && this.tsCheckTypeAnnotationForReadOnly(e), this.finishNode(e, 'TSTypeOperator'));
       }
       tsCheckTypeAnnotationForReadOnly(e) {
        switch (e.typeAnnotation.type) {
         case 'TSTupleType':
         case 'TSArrayType':
          return;
         default:
          this.raise(At.UnexpectedReadonly, e);
        }
       }
       tsParseInferType() {
        let e = this.startNode();
        this.expectContextual(115);
        let t = this.startNode();
        return ((t.name = this.tsParseTypeParameterName()), (t.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType())), (e.typeParameter = this.finishNode(t, 'TSTypeParameter')), this.finishNode(e, 'TSInferType'));
       }
       tsParseConstraintForInferType() {
        if (this.eat(81)) {
         let e = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
         if (this.state.inDisallowConditionalTypesContext || !this.match(17)) return e;
        }
       }
       tsParseTypeOperatorOrHigher() {
        return (function (e) {
         return e >= 121 && e <= 123;
        })(this.state.type) && !this.state.containsEsc
         ? this.tsParseTypeOperator()
         : this.isContextual(115)
           ? this.tsParseInferType()
           : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
       }
       tsParseUnionOrIntersectionType(e, t, r) {
        let s = this.startNode(),
         n = this.eat(r),
         i = [];
        do {
         i.push(t());
        } while (this.eat(r));
        return 1 !== i.length || n ? ((s.types = i), this.finishNode(s, e)) : i[0];
       }
       tsParseIntersectionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType('TSIntersectionType', this.tsParseTypeOperatorOrHigher.bind(this), 45);
       }
       tsParseUnionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType('TSUnionType', this.tsParseIntersectionTypeOrHigher.bind(this), 43);
       }
       tsIsStartOfFunctionType() {
        return !!this.match(47) || (this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this)));
       }
       tsSkipParameterStart() {
        if (X(this.state.type) || this.match(78)) return (this.next(), !0);
        if (this.match(5)) {
         let { errors: e } = this.state,
          t = e.length;
         try {
          return (this.parseObjectLike(8, !0), e.length === t);
         } catch {
          return !1;
         }
        }
        if (this.match(0)) {
         this.next();
         let { errors: e } = this.state,
          t = e.length;
         try {
          return (super.parseBindingList(3, 93, 1), e.length === t);
         } catch {
          return !1;
         }
        }
        return !1;
       }
       tsIsUnambiguouslyStartOfFunctionType() {
        return (this.next(), !!(this.match(11) || this.match(21) || (this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(17) || this.match(29) || (this.match(11) && (this.next(), this.match(19)))))));
       }
       tsParseTypeOrTypePredicateAnnotation(e) {
        return this.tsInType(() => {
         let t = this.startNode();
         this.expect(e);
         let r = this.startNode(),
          s = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
         if (s && this.match(78)) {
          let e = this.tsParseThisTypeOrThisTypePredicate();
          return ('TSThisType' === e.type ? ((r.parameterName = e), (r.asserts = !0), (r.typeAnnotation = null), (e = this.finishNode(r, 'TSTypePredicate'))) : (this.resetStartLocationFromNode(e, r), (e.asserts = !0)), (t.typeAnnotation = e), this.finishNode(t, 'TSTypeAnnotation'));
         }
         let n = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
         if (!n) return s ? ((r.parameterName = this.parseIdentifier()), (r.asserts = s), (r.typeAnnotation = null), (t.typeAnnotation = this.finishNode(r, 'TSTypePredicate')), this.finishNode(t, 'TSTypeAnnotation')) : this.tsParseTypeAnnotation(!1, t);
         let i = this.tsParseTypeAnnotation(!1);
         return ((r.parameterName = n), (r.typeAnnotation = i), (r.asserts = s), (t.typeAnnotation = this.finishNode(r, 'TSTypePredicate')), this.finishNode(t, 'TSTypeAnnotation'));
        });
       }
       tsTryParseTypeOrTypePredicateAnnotation() {
        if (this.match(14)) return this.tsParseTypeOrTypePredicateAnnotation(14);
       }
       tsTryParseTypeAnnotation() {
        if (this.match(14)) return this.tsParseTypeAnnotation();
       }
       tsTryParseType() {
        return this.tsEatThenParseType(14);
       }
       tsParseTypePredicatePrefix() {
        let e = this.parseIdentifier();
        if (this.isContextual(116) && !this.hasPrecedingLineBreak()) return (this.next(), e);
       }
       tsParseTypePredicateAsserts() {
        if (109 !== this.state.type) return !1;
        let e = this.state.containsEsc;
        return (this.next(), !(!X(this.state.type) && !this.match(78)) && (e && this.raise(C.InvalidEscapedReservedWord, this.state.lastTokStartLoc, { reservedWord: 'asserts' }), !0));
       }
       tsParseTypeAnnotation(e = !0, t = this.startNode()) {
        return (
         this.tsInType(() => {
          (e && this.expect(14), (t.typeAnnotation = this.tsParseType()));
         }),
         this.finishNode(t, 'TSTypeAnnotation')
        );
       }
       tsParseType() {
        Ft(this.state.inType);
        let e = this.tsParseNonConditionalType();
        if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) return e;
        let t = this.startNodeAtNode(e);
        return ((t.checkType = e), (t.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType())), this.expect(17), (t.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType())), this.expect(14), (t.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType())), this.finishNode(t, 'TSConditionalType'));
       }
       isAbstractConstructorSignature() {
        return this.isContextual(124) && this.isLookaheadContextual('new');
       }
       tsParseNonConditionalType() {
        return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType('TSFunctionType') : this.match(77) ? this.tsParseFunctionOrConstructorType('TSConstructorType') : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType('TSConstructorType', !0) : this.tsParseUnionTypeOrHigher();
       }
       tsParseTypeAssertion() {
        this.getPluginOption('typescript', 'disallowAmbiguousJSXLike') && this.raise(At.ReservedTypeAssertion, this.state.startLoc);
        let e = this.startNode();
        return ((e.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType()))), this.expect(48), (e.expression = this.parseMaybeUnary()), this.finishNode(e, 'TSTypeAssertion'));
       }
       tsParseHeritageClause(e) {
        let t = this.state.startLoc,
         r = this.tsParseDelimitedList('HeritageClauseElement', () => {
          {
           let t = super.parseExprSubscripts();
           vt(t) || this.raise(At.InvalidHeritageClauseType, t.loc.start, { token: e });
           let r = 'extends' === e ? 'TSInterfaceHeritage' : 'TSClassImplements';
           if ('TSInstantiationExpression' === t.type) return ((t.type = r), t);
           let s = this.startNodeAtNode(t);
           return ((s.expression = t), (this.match(47) || this.match(51)) && (s.typeArguments = this.tsParseTypeArgumentsInExpression()), this.finishNode(s, r));
          }
         });
        return (r.length || this.raise(At.EmptyHeritageClauseType, t, { token: e }), r);
       }
       tsParseInterfaceDeclaration(e, t = {}) {
        if (this.hasFollowingLineBreak()) return null;
        (this.expectContextual(129), t.declare && (e.declare = !0), X(this.state.type) ? ((e.id = this.parseIdentifier()), this.checkIdentifier(e.id, 130)) : ((e.id = null), this.raise(At.MissingInterfaceName, this.state.startLoc)), (e.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers)), this.eat(81) && (e.extends = this.tsParseHeritageClause('extends')));
        let r = this.startNode();
        return ((r.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this))), (e.body = this.finishNode(r, 'TSInterfaceBody')), this.finishNode(e, 'TSInterfaceDeclaration'));
       }
       tsParseTypeAliasDeclaration(e) {
        return (
         (e.id = this.parseIdentifier()),
         this.checkIdentifier(e.id, 2),
         (e.typeAnnotation = this.tsInType(() => {
          if (((e.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers)), this.expect(29), this.isContextual(114) && 46 !== this.lookaheadCharCode())) {
           let e = this.startNode();
           return (this.next(), this.finishNode(e, 'TSIntrinsicKeyword'));
          }
          return this.tsParseType();
         })),
         this.semicolon(),
         this.finishNode(e, 'TSTypeAliasDeclaration')
        );
       }
       tsInTopLevelContext(e) {
        if (this.curContext() === v.brace) return e();
        {
         let t = this.state.context;
         this.state.context = [t[0]];
         try {
          return e();
         } finally {
          this.state.context = t;
         }
        }
       }
       tsInType(e) {
        let t = this.state.inType;
        this.state.inType = !0;
        try {
         return e();
        } finally {
         this.state.inType = t;
        }
       }
       tsInDisallowConditionalTypesContext(e) {
        let t = this.state.inDisallowConditionalTypesContext;
        this.state.inDisallowConditionalTypesContext = !0;
        try {
         return e();
        } finally {
         this.state.inDisallowConditionalTypesContext = t;
        }
       }
       tsInAllowConditionalTypesContext(e) {
        let t = this.state.inDisallowConditionalTypesContext;
        this.state.inDisallowConditionalTypesContext = !1;
        try {
         return e();
        } finally {
         this.state.inDisallowConditionalTypesContext = t;
        }
       }
       tsEatThenParseType(e) {
        if (this.match(e)) return this.tsNextThenParseType();
       }
       tsExpectThenParseType(e) {
        return this.tsInType(() => (this.expect(e), this.tsParseType()));
       }
       tsNextThenParseType() {
        return this.tsInType(() => (this.next(), this.tsParseType()));
       }
       tsParseEnumMember() {
        let e = this.startNode();
        return ((e.id = this.match(134) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(!0)), this.eat(29) && (e.initializer = super.parseMaybeAssignAllowIn()), this.finishNode(e, 'TSEnumMember'));
       }
       tsParseEnumDeclaration(e, t = {}) {
        return (t.const && (e.const = !0), t.declare && (e.declare = !0), this.expectContextual(126), (e.id = this.parseIdentifier()), this.checkIdentifier(e.id, e.const ? 8971 : 8459), (e.body = this.tsParseEnumBody()), this.finishNode(e, 'TSEnumDeclaration'));
       }
       tsParseEnumBody() {
        let e = this.startNode();
        return (this.expect(5), (e.members = this.tsParseDelimitedList('EnumMembers', this.tsParseEnumMember.bind(this))), this.expect(8), this.finishNode(e, 'TSEnumBody'));
       }
       tsParseModuleBlock() {
        let e = this.startNode();
        return (this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody((e.body = []), void 0, !0, 8), this.scope.exit(), this.finishNode(e, 'TSModuleBlock'));
       }
       tsParseModuleOrNamespaceDeclaration(e, t = !1) {
        return ((e.id = this.tsParseEntityName(1)), 'Identifier' === e.id.type && this.checkIdentifier(e.id, 1024), this.scope.enter(1024), this.prodParam.enter(0), (e.body = this.tsParseModuleBlock()), this.prodParam.exit(), this.scope.exit(), this.finishNode(e, 'TSModuleDeclaration'));
       }
       tsParseAmbientExternalModuleDeclaration(e) {
        return (this.isContextual(112) ? ((e.kind = 'global'), (e.id = this.parseIdentifier())) : this.match(134) ? ((e.kind = 'module'), (e.id = super.parseStringLiteral(this.state.value))) : this.unexpected(), this.match(5) ? (this.scope.enter(1024), this.prodParam.enter(0), (e.body = this.tsParseModuleBlock()), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(e, 'TSModuleDeclaration'));
       }
       tsParseImportEqualsDeclaration(e, t, r) {
        ((e.id = t || this.parseIdentifier()), this.checkIdentifier(e.id, 4096), this.expect(29));
        let s = this.tsParseModuleReference();
        return ('type' === e.importKind && 'TSExternalModuleReference' !== s.type && this.raise(At.ImportAliasHasImportType, s), (e.moduleReference = s), this.semicolon(), this.finishNode(e, 'TSImportEqualsDeclaration'));
       }
       tsIsExternalModuleReference() {
        return this.isContextual(119) && 40 === this.lookaheadCharCode();
       }
       tsParseModuleReference() {
        return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(0);
       }
       tsParseExternalModuleReference() {
        let e = this.startNode();
        return (this.expectContextual(119), this.expect(10), this.match(134) || this.unexpected(), (e.expression = super.parseExprAtom()), this.expect(11), (this.sawUnambiguousESM = !0), this.finishNode(e, 'TSExternalModuleReference'));
       }
       tsLookAhead(e) {
        let t = this.state.clone(),
         r = e();
        return ((this.state = t), r);
       }
       tsTryParseAndCatch(e) {
        let t = this.tryParse((t) => e() || t());
        if (!t.aborted && t.node) return (t.error && (this.state = t.failState), t.node);
       }
       tsTryParse(e) {
        let t = this.state.clone(),
         r = e();
        if (void 0 !== r && !1 !== r) return r;
        this.state = t;
       }
       tsTryParseDeclare(e) {
        if (this.isLineTerminator()) return;
        let t = this.state.type;
        return this.tsInAmbientContext(() => {
         switch (t) {
          case 68:
           return ((e.declare = !0), super.parseFunctionStatement(e, !1, !1));
          case 80:
           return ((e.declare = !0), this.parseClass(e, !0, !1));
          case 126:
           return this.tsParseEnumDeclaration(e, { declare: !0 });
          case 112:
           return this.tsParseAmbientExternalModuleDeclaration(e);
          case 100:
           if (this.state.containsEsc) return;
          case 75:
          case 74:
           return this.match(75) && this.isLookaheadContextual('enum') ? (this.expect(75), this.tsParseEnumDeclaration(e, { const: !0, declare: !0 })) : ((e.declare = !0), this.parseVarStatement(e, this.state.value, !0));
          case 107:
           if (this.isUsing()) return (this.raise(At.InvalidModifierOnUsingDeclaration, this.state.startLoc, 'declare'), (e.declare = !0), this.parseVarStatement(e, 'using', !0));
           break;
          case 96:
           if (this.isAwaitUsing()) return (this.raise(At.InvalidModifierOnAwaitUsingDeclaration, this.state.startLoc, 'declare'), (e.declare = !0), this.next(), this.parseVarStatement(e, 'await using', !0));
           break;
          case 129: {
           let t = this.tsParseInterfaceDeclaration(e, { declare: !0 });
           if (t) return t;
          }
          default:
           if (X(t)) return this.tsParseDeclaration(e, this.state.type, !0, null);
         }
        });
       }
       tsTryParseExportDeclaration() {
        return this.tsParseDeclaration(this.startNode(), this.state.type, !0, null);
       }
       tsParseDeclaration(e, t, r, s) {
        switch (t) {
         case 124:
          if (this.tsCheckLineTerminator(r) && (this.match(80) || X(this.state.type))) return this.tsParseAbstractDeclaration(e, s);
          break;
         case 127:
          if (this.tsCheckLineTerminator(r)) {
           if (this.match(134)) return this.tsParseAmbientExternalModuleDeclaration(e);
           if (X(this.state.type)) return ((e.kind = 'module'), this.tsParseModuleOrNamespaceDeclaration(e));
          }
          break;
         case 128:
          if (this.tsCheckLineTerminator(r) && X(this.state.type)) return ((e.kind = 'namespace'), this.tsParseModuleOrNamespaceDeclaration(e));
          break;
         case 130:
          if (this.tsCheckLineTerminator(r) && X(this.state.type)) return this.tsParseTypeAliasDeclaration(e);
        }
       }
       tsCheckLineTerminator(e) {
        return e ? !this.hasFollowingLineBreak() && (this.next(), !0) : !this.isLineTerminator();
       }
       tsTryParseGenericAsyncArrowFunction(e) {
        if (!this.match(47)) return;
        let t = this.state.maybeInArrowParameters;
        this.state.maybeInArrowParameters = !0;
        let r = this.tsTryParseAndCatch(() => {
         let t = this.startNodeAt(e);
         return ((t.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier)), super.parseFunctionParams(t), (t.returnType = this.tsTryParseTypeOrTypePredicateAnnotation()), this.expect(19), t);
        });
        return ((this.state.maybeInArrowParameters = t), r ? super.parseArrowExpression(r, null, !0) : void 0);
       }
       tsParseTypeArgumentsInExpression() {
        if (47 === this.reScan_lt()) return this.tsParseTypeArguments();
       }
       tsParseTypeArguments() {
        let e = this.startNode();
        return ((e.params = this.tsInType(() => this.tsInTopLevelContext(() => (this.expect(47), this.tsParseDelimitedList('TypeParametersOrArguments', this.tsParseType.bind(this)))))), 0 === e.params.length ? this.raise(At.EmptyTypeArguments, e) : !this.state.inType && this.curContext() === v.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(e, 'TSTypeParameterInstantiation'));
       }
       tsIsDeclarationStart() {
        return (function (e) {
         return e >= 124 && e <= 130;
        })(this.state.type);
       }
       isExportDefaultSpecifier() {
        return !this.tsIsDeclarationStart() && super.isExportDefaultSpecifier();
       }
       parseBindingElement(e, t) {
        let r = t.length ? t[0].loc.start : this.state.startLoc,
         s = {};
        this.tsParseModifiers({ allowedModifiers: ['public', 'private', 'protected', 'override', 'readonly'] }, s);
        let n = s.accessibility,
         i = s.override,
         a = s.readonly;
        !(4 & e) && (n || a || i) && this.raise(At.UnexpectedParameterModifier, r);
        let o = this.parseMaybeDefault();
        2 & e && this.parseFunctionParamType(o);
        let u = this.parseMaybeDefault(o.loc.start, o);
        if (n || a || i) {
         let e = this.startNodeAt(r);
         return (t.length && (e.decorators = t), n && (e.accessibility = n), a && (e.readonly = a), i && (e.override = i), 'Identifier' !== u.type && 'AssignmentPattern' !== u.type && this.raise(At.UnsupportedParameterPropertyKind, e), (e.parameter = u), this.finishNode(e, 'TSParameterProperty'));
        }
        return (t.length && (o.decorators = t), u);
       }
       isSimpleParameter(e) {
        return ('TSParameterProperty' === e.type && super.isSimpleParameter(e.parameter)) || super.isSimpleParameter(e);
       }
       tsDisallowOptionalPattern(e) {
        for (let t of e.params) 'Identifier' !== t.type && t.optional && !this.state.isAmbientContext && this.raise(At.PatternIsOptional, t);
       }
       setArrowFunctionParameters(e, t, r) {
        (super.setArrowFunctionParameters(e, t, r), this.tsDisallowOptionalPattern(e));
       }
       parseFunctionBodyAndFinish(e, t, r = !1) {
        this.match(14) && (e.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
        let s = 'FunctionDeclaration' === t ? 'TSDeclareFunction' : 'ClassMethod' === t || 'ClassPrivateMethod' === t ? 'TSDeclareMethod' : void 0;
        return s && !this.match(5) && this.isLineTerminator() ? this.finishNode(e, s) : 'TSDeclareFunction' === s && this.state.isAmbientContext && (this.raise(At.DeclareFunctionHasImplementation, e), e.declare) ? super.parseFunctionBodyAndFinish(e, s, r) : (this.tsDisallowOptionalPattern(e), super.parseFunctionBodyAndFinish(e, t, r));
       }
       registerFunctionStatementId(e) {
        !e.body && e.id ? this.checkIdentifier(e.id, 1024) : super.registerFunctionStatementId(e);
       }
       tsCheckForInvalidTypeCasts(e) {
        e.forEach((e) => {
         'TSTypeCastExpression' === e?.type && this.raise(At.UnexpectedTypeAnnotation, e.typeAnnotation);
        });
       }
       toReferencedList(e, t) {
        return (this.tsCheckForInvalidTypeCasts(e), e);
       }
       parseArrayLike(e, t, r) {
        let s = super.parseArrayLike(e, t, r);
        return ('ArrayExpression' === s.type && this.tsCheckForInvalidTypeCasts(s.elements), s);
       }
       parseSubscript(e, t, r, s) {
        if (!this.hasPrecedingLineBreak() && this.match(35)) {
         ((this.state.canStartJSXElement = !1), this.next());
         let r = this.startNodeAt(t);
         return ((r.expression = e), this.finishNode(r, 'TSNonNullExpression'));
        }
        let n = !1;
        if (this.match(18) && 60 === this.lookaheadCharCode()) {
         if (r) return ((s.stop = !0), e);
         ((s.optionalChainMember = n = !0), this.next());
        }
        if (this.match(47) || this.match(51)) {
         let i,
          a = this.tsTryParseAndCatch(() => {
           if (!r && this.atPossibleAsyncArrow(e)) {
            let e = this.tsTryParseGenericAsyncArrowFunction(t);
            if (e) return ((s.stop = !0), e);
           }
           let a = this.tsParseTypeArgumentsInExpression();
           if (!a) return;
           if (n && !this.match(10)) return void (i = this.state.curPosition());
           if (re(this.state.type)) {
            let r = super.parseTaggedTemplateExpression(e, t, s);
            return ((r.typeArguments = a), r);
           }
           if (!r && this.eat(10)) {
            let r = this.startNodeAt(t);
            return ((r.callee = e), (r.arguments = this.parseCallExpressionArguments()), this.tsCheckForInvalidTypeCasts(r.arguments), (r.typeArguments = a), s.optionalChainMember && (r.optional = n), this.finishCallExpression(r, s.optionalChainMember));
           }
           let o = this.state.type;
           if (48 === o || 52 === o || (10 !== o && Y(o) && !this.hasPrecedingLineBreak())) return;
           let u = this.startNodeAt(t);
           return ((u.expression = e), (u.typeArguments = a), this.finishNode(u, 'TSInstantiationExpression'));
          });
         if ((i && this.unexpected(i, 10), a)) return ('TSInstantiationExpression' === a.type && ((this.match(16) || (this.match(18) && 40 !== this.lookaheadCharCode())) && this.raise(At.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc), !this.match(16) && !this.match(18) && (a.expression = super.stopParseSubscript(e, s))), a);
        }
        return super.parseSubscript(e, t, r, s);
       }
       parseNewCallee(e) {
        super.parseNewCallee(e);
        let { callee: t } = e;
        'TSInstantiationExpression' === t.type && !t.extra?.parenthesized && ((e.typeArguments = t.typeArguments), (e.callee = t.expression));
       }
       parseExprOp(e, t, r) {
        let s;
        if (te(58) > r && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (s = this.isContextual(120)))) {
         let n = this.startNodeAt(t);
         return ((n.expression = e), (n.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (s && this.raise(C.UnexpectedKeyword, this.state.startLoc, { keyword: 'const' }), this.tsParseTypeReference()) : this.tsParseType()))), this.finishNode(n, s ? 'TSSatisfiesExpression' : 'TSAsExpression'), this.reScan_lt_gt(), this.parseExprOp(n, t, r));
        }
        return super.parseExprOp(e, t, r);
       }
       checkReservedWord(e, t, r, s) {
        this.state.isAmbientContext || super.checkReservedWord(e, t, r, s);
       }
       checkImportReflection(e) {
        (super.checkImportReflection(e), e.module && 'value' !== e.importKind && this.raise(At.ImportReflectionHasImportType, e.specifiers[0].loc.start));
       }
       checkDuplicateExports() {}
       isPotentialImportPhase(e) {
        if (super.isPotentialImportPhase(e)) return !0;
        if (this.isContextual(130)) {
         let t = this.lookaheadCharCode();
         return e ? 123 === t || 42 === t : 61 !== t;
        }
        return !e && this.isContextual(87);
       }
       applyImportPhase(e, t, r, s) {
        (super.applyImportPhase(e, t, r, s), t ? (e.exportKind = 'type' === r ? 'type' : 'value') : (e.importKind = 'type' === r || 'typeof' === r ? r : 'value'));
       }
       parseImport(e) {
        if (this.match(134)) return ((e.importKind = 'value'), super.parseImport(e));
        let t;
        if (X(this.state.type) && 61 === this.lookaheadCharCode()) return ((e.importKind = 'value'), this.tsParseImportEqualsDeclaration(e));
        if (this.isContextual(130)) {
         let r = this.parseMaybeImportPhase(e, !1);
         if (61 === this.lookaheadCharCode()) return this.tsParseImportEqualsDeclaration(e, r);
         t = super.parseImportSpecifiersAndAfter(e, r);
        } else t = super.parseImport(e);
        return ('type' === t.importKind && t.specifiers.length > 1 && 'ImportDefaultSpecifier' === t.specifiers[0].type && this.raise(At.TypeImportCannotSpecifyDefaultAndNamed, t), t);
       }
       parseExport(e, t) {
        if (this.match(83)) {
         let t = this.startNode();
         this.next();
         let r = null;
         this.isContextual(130) && this.isPotentialImportPhase(!1) ? (r = this.parseMaybeImportPhase(t, !1)) : (t.importKind = 'value');
         let s = this.tsParseImportEqualsDeclaration(t, r, !0);
         return ((e.attributes = []), (e.declaration = s), (e.exportKind = 'value'), (e.source = null), (e.specifiers = []), this.finishNode(e, 'ExportNamedDeclaration'));
        }
        if (this.eat(29)) {
         let t = e;
         return ((t.expression = super.parseExpression()), this.semicolon(), (this.sawUnambiguousESM = !0), this.finishNode(t, 'TSExportAssignment'));
        }
        if (this.eatContextual(93)) {
         let t = e;
         return (this.expectContextual(128), (t.id = this.parseIdentifier()), this.semicolon(), this.finishNode(t, 'TSNamespaceExportDeclaration'));
        }
        return super.parseExport(e, t);
       }
       isAbstractClass() {
        return this.isContextual(124) && this.isLookaheadContextual('class');
       }
       parseExportDefaultExpression() {
        if (this.isAbstractClass()) {
         let e = this.startNode();
         return (this.next(), (e.abstract = !0), this.parseClass(e, !0, !0));
        }
        if (this.match(129)) {
         let e = this.tsParseInterfaceDeclaration(this.startNode());
         if (e) return e;
        }
        return super.parseExportDefaultExpression();
       }
       parseVarStatement(e, t, r = !1) {
        let { isAmbientContext: s } = this.state,
         n = super.parseVarStatement(e, t, r || s);
        if (!s) return n;
        if (!e.declare && ('using' === t || 'await using' === t)) return (this.raiseOverwrite(At.UsingDeclarationInAmbientContext, e, t), n);
        for (let { id: i, init: a } of n.declarations) a && ('var' === t || 'let' === t || i.typeAnnotation ? this.raise(At.InitializerNotAllowedInAmbientContext, a) : kt(a, this.hasPlugin('estree')) || this.raise(At.ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference, a));
        return n;
       }
       parseStatementContent(e, t) {
        if (!this.state.containsEsc)
         switch (this.state.type) {
          case 75:
           if (this.isLookaheadContextual('enum')) {
            let e = this.startNode();
            return (this.expect(75), this.tsParseEnumDeclaration(e, { const: !0 }));
           }
           break;
          case 124:
          case 125:
           if (this.nextTokenIsIdentifierAndNotTSRelationalOperatorOnSameLine()) {
            let e = this.state.type,
             r = this.startNode();
            this.next();
            let s = 125 === e ? this.tsTryParseDeclare(r) : this.tsParseAbstractDeclaration(r, t);
            return s ? (125 === e && (s.declare = !0), s) : ((r.expression = this.createIdentifier(this.startNodeAt(r.loc.start), 125 === e ? 'declare' : 'abstract')), this.semicolon(!1), this.finishNode(r, 'ExpressionStatement'));
           }
           break;
          case 126:
           return this.tsParseEnumDeclaration(this.startNode());
          case 112:
           if (123 === this.lookaheadCharCode()) {
            let e = this.startNode();
            return this.tsParseAmbientExternalModuleDeclaration(e);
           }
           break;
          case 129: {
           let e = this.tsParseInterfaceDeclaration(this.startNode());
           if (e) return e;
           break;
          }
          case 127:
           if (this.nextTokenIsIdentifierOrStringLiteralOnSameLine()) {
            let e = this.startNode();
            return (this.next(), this.tsParseDeclaration(e, 127, !1, t));
           }
           break;
          case 128:
           if (this.nextTokenIsIdentifierOnSameLine()) {
            let e = this.startNode();
            return (this.next(), this.tsParseDeclaration(e, 128, !1, t));
           }
           break;
          case 130:
           if (this.nextTokenIsIdentifierOnSameLine()) {
            let e = this.startNode();
            return (this.next(), this.tsParseTypeAliasDeclaration(e));
           }
         }
        return super.parseStatementContent(e, t);
       }
       parseAccessModifier() {
        return this.tsParseModifier(['public', 'protected', 'private']);
       }
       tsHasSomeModifiers(e, t) {
        return t.some((t) => (wt(t) ? e.accessibility === t : !!e[t]));
       }
       tsIsStartOfStaticBlocks() {
        return this.isContextual(106) && 123 === this.lookaheadCharCode();
       }
       parseClassMember(e, t, r) {
        let s = ['declare', 'private', 'public', 'protected', 'override', 'abstract', 'readonly', 'static'];
        this.tsParseModifiers({ allowedModifiers: s, disallowedModifiers: ['in', 'out'], stopOnStartOfClassStaticBlock: !0, errorTemplate: At.InvalidModifierOnTypeParameterPositions }, t);
        let n = () => {
         this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(t, s) && this.raise(At.StaticBlockCannotHaveModifier, this.state.curPosition()), super.parseClassStaticBlock(e, t)) : this.parseClassMemberWithIsStatic(e, t, r, !!t.static);
        };
        t.declare ? this.tsInAmbientContext(n) : n();
       }
       parseClassMemberWithIsStatic(e, t, r, s) {
        let n = this.tsTryParseIndexSignature(t);
        if (n) return (e.body.push(n), t.abstract && this.raise(At.IndexSignatureHasAbstract, t), t.accessibility && this.raise(At.IndexSignatureHasAccessibility, t, { modifier: t.accessibility }), t.declare && this.raise(At.IndexSignatureHasDeclare, t), void (t.override && this.raise(At.IndexSignatureHasOverride, t)));
        (!this.state.inAbstractClass && t.abstract && this.raise(At.NonAbstractClassHasAbstractMethod, t), t.override && (r.hadSuperClass || this.raise(At.OverrideNotInSubClass, t)), super.parseClassMemberWithIsStatic(e, t, r, s));
       }
       parsePostMemberNameModifiers(e) {
        (this.eat(17) && (e.optional = !0), e.readonly && this.match(10) && this.raise(At.ClassMethodHasReadonly, e), e.declare && this.match(10) && this.raise(At.ClassMethodHasDeclare, e));
       }
       shouldParseExportDeclaration() {
        return !!this.tsIsDeclarationStart() || super.shouldParseExportDeclaration();
       }
       parseConditional(e, t, r) {
        if (!this.match(17)) return e;
        if (this.state.maybeInArrowParameters) {
         let t = this.lookaheadCharCode();
         if (44 === t || 61 === t || 58 === t || 41 === t) return (this.setOptionalParametersError(r), e);
        }
        return super.parseConditional(e, t, r);
       }
       parseParenItem(e, t) {
        let r = super.parseParenItem(e, t);
        if ((this.eat(17) && ((r.optional = !0), this.resetEndLocation(e)), this.match(14))) {
         let r = this.startNodeAt(t);
         return ((r.expression = e), (r.typeAnnotation = this.tsParseTypeAnnotation()), this.finishNode(r, 'TSTypeCastExpression'));
        }
        return e;
       }
       parseExportDeclaration(e) {
        if (!this.state.isAmbientContext && this.isContextual(125)) return this.tsInAmbientContext(() => this.parseExportDeclaration(e));
        let t = this.state.startLoc,
         r = this.eatContextual(125);
        if (r && (this.isContextual(125) || !this.shouldParseExportDeclaration())) throw this.raise(At.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
        let s = (X(this.state.type) && this.tsTryParseExportDeclaration()) || super.parseExportDeclaration(e);
        return s ? (('TSInterfaceDeclaration' === s.type || 'TSTypeAliasDeclaration' === s.type || r) && (e.exportKind = 'type'), r && 'TSImportEqualsDeclaration' !== s.type && (this.resetStartLocation(s, t), (s.declare = !0)), s) : null;
       }
       parseClassId(e, t, r, s) {
        if ((!t || r) && this.isContextual(113)) return;
        super.parseClassId(e, t, r, e.declare ? 1024 : 8331);
        let n = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
        n && (e.typeParameters = n);
       }
       parseClassPropertyAnnotation(e) {
        e.optional || (this.eat(35) ? (e.definite = !0) : this.eat(17) && (e.optional = !0));
        let t = this.tsTryParseTypeAnnotation();
        t && (e.typeAnnotation = t);
       }
       parseClassProperty(e) {
        if ((this.parseClassPropertyAnnotation(e), this.state.isAmbientContext && !(e.readonly && !e.typeAnnotation) && this.match(29) && this.raise(At.DeclareClassFieldHasInitializer, this.state.startLoc), e.abstract && this.match(29))) {
         let { key: t } = e;
         this.raise(At.AbstractPropertyHasInitializer, this.state.startLoc, { propertyName: 'Identifier' !== t.type || e.computed ? `[${this.input.slice(this.offsetToSourcePos(t.start), this.offsetToSourcePos(t.end))}]` : t.name });
        }
        return super.parseClassProperty(e);
       }
       parseClassPrivateProperty(e) {
        return (e.abstract && this.raise(At.PrivateElementHasAbstract, e), e.accessibility && this.raise(At.PrivateElementHasAccessibility, e, { modifier: e.accessibility }), this.parseClassPropertyAnnotation(e), super.parseClassPrivateProperty(e));
       }
       parseClassAccessorProperty(e) {
        return (this.parseClassPropertyAnnotation(e), e.optional && this.raise(At.AccessorCannotBeOptional, e), super.parseClassAccessorProperty(e));
       }
       pushClassMethod(e, t, r, s, n, i) {
        let a = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        a && n && this.raise(At.ConstructorHasTypeParameters, a);
        let { declare: o = !1, kind: u } = t;
        (o && ('get' === u || 'set' === u) && this.raise(At.DeclareAccessor, t, { kind: u }), a && (t.typeParameters = a), super.pushClassMethod(e, t, r, s, n, i));
       }
       pushClassPrivateMethod(e, t, r, s) {
        let n = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        (n && (t.typeParameters = n), super.pushClassPrivateMethod(e, t, r, s));
       }
       declareClassPrivateMethodInScope(e, t) {
        'TSDeclareMethod' !== e.type && (('MethodDefinition' === e.type && null == e.value.body) || super.declareClassPrivateMethodInScope(e, t));
       }
       parseClassSuper(e) {
        (super.parseClassSuper(e), e.superClass && (this.match(47) || this.match(51)) && (e.superTypeArguments = this.tsParseTypeArgumentsInExpression()), this.eatContextual(113) && (e.implements = this.tsParseHeritageClause('implements')));
       }
       parseObjPropValue(e, t, r, s, n, i, a) {
        let o = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        return (o && (e.typeParameters = o), super.parseObjPropValue(e, t, r, s, n, i, a));
       }
       parseFunctionParams(e, t) {
        let r = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        (r && (e.typeParameters = r), super.parseFunctionParams(e, t));
       }
       parseVarId(e, t) {
        (super.parseVarId(e, t), 'Identifier' === e.id.type && !this.hasPrecedingLineBreak() && this.eat(35) && (e.definite = !0));
        let r = this.tsTryParseTypeAnnotation();
        r && ((e.id.typeAnnotation = r), this.resetEndLocation(e.id));
       }
       parseAsyncArrowFromCallExpression(e, t) {
        return (this.match(14) && (e.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(e, t));
       }
       parseMaybeAssign(e, t) {
        let r, s, n;
        if (this.hasPlugin('jsx') && (this.match(143) || this.match(47))) {
         if (((r = this.state.clone()), (s = this.tryParse(() => super.parseMaybeAssign(e, t), r)), !s.error)) return s.node;
         let { context: n } = this.state,
          i = n[n.length - 1];
         (i === v.j_oTag || i === v.j_expr) && n.pop();
        }
        if (!s?.error && !this.match(47)) return super.parseMaybeAssign(e, t);
        (!r || r === this.state) && (r = this.state.clone());
        let i,
         a = this.tryParse((r) => {
          i = this.tsParseTypeParameters(this.tsParseConstModifier);
          let s = super.parseMaybeAssign(e, t);
          if ((('ArrowFunctionExpression' !== s.type || s.extra?.parenthesized) && r(), 0 !== i?.params.length && this.resetStartLocationFromNode(s, i), (s.typeParameters = i), this.hasPlugin('jsx') && 1 === s.typeParameters.params.length && !s.typeParameters.extra?.trailingComma)) {
           let e = s.typeParameters.params[0];
           e.constraint || this.raise(At.SingleTypeParameterWithoutTrailingComma, p(e.loc.end, 1), { typeParameterName: e.name.name });
          }
          return s;
         }, r);
        if (!a.error && !a.aborted) return (i && this.reportReservedArrowTypeParam(i), a.node);
        if (!s && (Ft(!this.hasPlugin('jsx')), (n = this.tryParse(() => super.parseMaybeAssign(e, t), r)), !n.error)) return n.node;
        if (s?.node) return ((this.state = s.failState), s.node);
        if (a.node) return ((this.state = a.failState), i && this.reportReservedArrowTypeParam(i), a.node);
        if (n?.node) return ((this.state = n.failState), n.node);
        throw s?.error || a.error || n?.error;
       }
       reportReservedArrowTypeParam(e) {
        1 === e.params.length && !e.params[0].constraint && !e.extra?.trailingComma && this.getPluginOption('typescript', 'disallowAmbiguousJSXLike') && this.raise(At.ReservedArrowTypeParam, e);
       }
       parseMaybeUnary(e, t) {
        return !this.hasPlugin('jsx') && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(e, t);
       }
       parseArrow(e) {
        if (this.match(14)) {
         let t = this.tryParse((e) => {
          let t = this.tsParseTypeOrTypePredicateAnnotation(14);
          return ((this.canInsertSemicolon() || !this.match(19)) && e(), t);
         });
         if (t.aborted) return;
         t.thrown || (t.error && (this.state = t.failState), (e.returnType = t.node));
        }
        return super.parseArrow(e);
       }
       parseFunctionParamType(e) {
        this.eat(17) && (e.optional = !0);
        let t = this.tsTryParseTypeAnnotation();
        return (t && (e.typeAnnotation = t), this.resetEndLocation(e), e);
       }
       isAssignable(e, t) {
        switch (e.type) {
         case 'TSTypeCastExpression':
          return this.isAssignable(e.expression, t);
         case 'TSParameterProperty':
          return !0;
         default:
          return super.isAssignable(e, t);
        }
       }
       toAssignable(e, t = !1) {
        switch (e.type) {
         case 'ParenthesizedExpression':
          this.toAssignableParenthesizedExpression(e, t);
          break;
         case 'TSAsExpression':
         case 'TSSatisfiesExpression':
         case 'TSNonNullExpression':
         case 'TSTypeAssertion':
          (t ? this.expressionScope.recordArrowParameterBindingError(At.UnexpectedTypeCastInParameter, e) : this.raise(At.UnexpectedTypeCastInParameter, e), this.toAssignable(e.expression, t));
          break;
         case 'AssignmentExpression':
          !t && 'TSTypeCastExpression' === e.left.type && (e.left = this.typeCastToParameter(e.left));
         default:
          super.toAssignable(e, t);
        }
       }
       toAssignableParenthesizedExpression(e, t) {
        switch (e.expression.type) {
         case 'TSAsExpression':
         case 'TSSatisfiesExpression':
         case 'TSNonNullExpression':
         case 'TSTypeAssertion':
         case 'ParenthesizedExpression':
          this.toAssignable(e.expression, t);
          break;
         default:
          super.toAssignable(e, t);
        }
       }
       checkToRestConversion(e, t) {
        switch (e.type) {
         case 'TSAsExpression':
         case 'TSSatisfiesExpression':
         case 'TSTypeAssertion':
         case 'TSNonNullExpression':
          this.checkToRestConversion(e.expression, !1);
          break;
         default:
          super.checkToRestConversion(e, t);
        }
       }
       isValidLVal(e, t, r, s) {
        switch (e) {
         case 'TSTypeCastExpression':
          return !0;
         case 'TSParameterProperty':
          return 'parameter';
         case 'TSNonNullExpression':
          return 'expression';
         case 'TSAsExpression':
         case 'TSSatisfiesExpression':
         case 'TSTypeAssertion':
          return (64 !== s || !r) && ['expression', !0];
         default:
          return super.isValidLVal(e, t, r, s);
        }
       }
       parseBindingAtom() {
        return 78 === this.state.type ? this.parseIdentifier(!0) : super.parseBindingAtom();
       }
       parseMaybeDecoratorArguments(e, t) {
        if (this.match(47) || this.match(51)) {
         let r = this.tsParseTypeArgumentsInExpression();
         if (this.match(10)) {
          let s = super.parseMaybeDecoratorArguments(e, t);
          return ((s.typeArguments = r), s);
         }
         this.unexpected(null, 10);
        }
        return super.parseMaybeDecoratorArguments(e, t);
       }
       checkCommaAfterRest(e) {
        return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === e ? (this.next(), !1) : super.checkCommaAfterRest(e);
       }
       isClassMethod() {
        return this.match(47) || super.isClassMethod();
       }
       isClassProperty() {
        return this.match(35) || this.match(14) || super.isClassProperty();
       }
       parseMaybeDefault(e, t) {
        let r = super.parseMaybeDefault(e, t);
        return ('AssignmentPattern' === r.type && r.typeAnnotation && r.right.start < r.typeAnnotation.start && this.raise(At.TypeAnnotationAfterAssign, r.typeAnnotation), r);
       }
       getTokenFromCode(e) {
        if (this.state.inType) {
         if (62 === e) return void this.finishOp(48, 1);
         if (60 === e) return void this.finishOp(47, 1);
        }
        super.getTokenFromCode(e);
       }
       reScan_lt_gt() {
        let { type: e } = this.state;
        47 === e ? ((this.state.pos -= 1), this.readToken_lt()) : 48 === e && ((this.state.pos -= 1), this.readToken_gt());
       }
       reScan_lt() {
        let { type: e } = this.state;
        return 51 === e ? ((this.state.pos -= 2), this.finishOp(47, 1), 47) : e;
       }
       toAssignableListItem(e, t, r) {
        let s = e[t];
        ('TSTypeCastExpression' === s.type && (e[t] = this.typeCastToParameter(s)), super.toAssignableListItem(e, t, r));
       }
       typeCastToParameter(e) {
        return ((e.expression.typeAnnotation = e.typeAnnotation), this.resetEndLocation(e.expression, e.typeAnnotation.loc.end), e.expression);
       }
       shouldParseArrow(e) {
        return this.match(14) ? e.every((e) => this.isAssignable(e, !0)) : super.shouldParseArrow(e);
       }
       shouldParseAsyncArrow() {
        return this.match(14) || super.shouldParseAsyncArrow();
       }
       canHaveLeadingDecorator() {
        return super.canHaveLeadingDecorator() || this.isAbstractClass();
       }
       jsxParseOpeningElementAfterName(e) {
        if (this.match(47) || this.match(51)) {
         let t = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
         t && (e.typeArguments = t);
        }
        return super.jsxParseOpeningElementAfterName(e);
       }
       getGetterSetterExpectedParamCount(e) {
        let t = super.getGetterSetterExpectedParamCount(e),
         r = this.getObjectOrClassMethodParams(e)[0];
        return r && this.isThisParam(r) ? t + 1 : t;
       }
       parseCatchClauseParam() {
        let e = super.parseCatchClauseParam(),
         t = this.tsTryParseTypeAnnotation();
        return (t && ((e.typeAnnotation = t), this.resetEndLocation(e)), e);
       }
       tsInAmbientContext(e) {
        let { isAmbientContext: t, strict: r } = this.state;
        ((this.state.isAmbientContext = !0), (this.state.strict = !1));
        try {
         return e();
        } finally {
         ((this.state.isAmbientContext = t), (this.state.strict = r));
        }
       }
       parseClass(e, t, r) {
        let s = this.state.inAbstractClass;
        this.state.inAbstractClass = !!e.abstract;
        try {
         return super.parseClass(e, t, r);
        } finally {
         this.state.inAbstractClass = s;
        }
       }
       tsParseAbstractDeclaration(e, t) {
        if (this.match(80)) return ((e.abstract = !0), this.maybeTakeDecorators(t, this.parseClass(e, !0, !1)));
        if (this.isContextual(129)) return this.hasFollowingLineBreak() ? null : ((e.abstract = !0), this.raise(At.NonClassMethodPropertyHasAbstractModifier, e), this.tsParseInterfaceDeclaration(e));
        throw this.unexpected(null, 80);
       }
       parseMethod(e, t, r, s, n, i, a) {
        let o = super.parseMethod(e, t, r, s, n, i, a);
        if ((o.abstract || 'TSAbstractMethodDefinition' === o.type) && (this.hasPlugin('estree') ? o.value : o).body) {
         let { key: e } = o;
         this.raise(At.AbstractMethodHasImplementation, o, { methodName: 'Identifier' !== e.type || o.computed ? `[${this.input.slice(this.offsetToSourcePos(e.start), this.offsetToSourcePos(e.end))}]` : e.name });
        }
        return o;
       }
       tsParseTypeParameterName() {
        return this.parseIdentifier();
       }
       shouldParseAsAmbientContext() {
        return !!this.getPluginOption('typescript', 'dts');
       }
       parse() {
        return (this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.parse());
       }
       getExpression() {
        return (this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.getExpression());
       }
       parseExportSpecifier(e, t, r, s) {
        return !t && s ? (this.parseTypeOnlyImportExportSpecifier(e, !1, r), this.finishNode(e, 'ExportSpecifier')) : ((e.exportKind = 'value'), super.parseExportSpecifier(e, t, r, s));
       }
       parseImportSpecifier(e, t, r, s, n) {
        return !t && s ? (this.parseTypeOnlyImportExportSpecifier(e, !0, r), this.finishNode(e, 'ImportSpecifier')) : ((e.importKind = 'value'), super.parseImportSpecifier(e, t, r, s, r ? 4098 : 4096));
       }
       parseTypeOnlyImportExportSpecifier(e, t, r) {
        let s,
         n = t ? 'imported' : 'local',
         i = t ? 'local' : 'exported',
         a = e[n],
         o = !1,
         u = !0,
         l = a.loc.start;
        if (this.isContextual(93)) {
         let e = this.parseIdentifier();
         if (this.isContextual(93)) {
          let r = this.parseIdentifier();
          K(this.state.type) ? ((o = !0), (a = e), (s = t ? this.parseIdentifier() : this.parseModuleExportName()), (u = !1)) : ((s = r), (u = !1));
         } else K(this.state.type) ? ((u = !1), (s = t ? this.parseIdentifier() : this.parseModuleExportName())) : ((o = !0), (a = e));
        } else K(this.state.type) && ((o = !0), t ? ((a = this.parseIdentifier(!0)), this.isContextual(93) || this.checkReservedWord(a.name, a.loc.start, !0, !0)) : (a = this.parseModuleExportName()));
        (o && r && this.raise(t ? At.TypeModifierIsUsedInTypeImports : At.TypeModifierIsUsedInTypeExports, l), (e[n] = a), (e[i] = s), (e[t ? 'importKind' : 'exportKind'] = o ? 'type' : 'value'), u && this.eatContextual(93) && (e[i] = t ? this.parseIdentifier() : this.parseModuleExportName()), e[i] || (e[i] = this.cloneIdentifier(e[n])), t && this.checkIdentifier(e[i], o ? 4098 : 4096));
       }
       fillOptionalPropertiesForTSESLint(e) {
        switch (e.type) {
         case 'ExpressionStatement':
          return void (e.directive ?? (e.directive = void 0));
         case 'RestElement':
          e.value = void 0;
         case 'Identifier':
         case 'ArrayPattern':
         case 'AssignmentPattern':
         case 'ObjectPattern':
          return (e.decorators ?? (e.decorators = []), e.optional ?? (e.optional = !1), void (e.typeAnnotation ?? (e.typeAnnotation = void 0)));
         case 'TSParameterProperty':
          return (e.accessibility ?? (e.accessibility = void 0), e.decorators ?? (e.decorators = []), e.override ?? (e.override = !1), e.readonly ?? (e.readonly = !1), void (e.static ?? (e.static = !1)));
         case 'TSEmptyBodyFunctionExpression':
          e.body = null;
         case 'TSDeclareFunction':
         case 'FunctionDeclaration':
         case 'FunctionExpression':
         case 'ClassMethod':
         case 'ClassPrivateMethod':
          return (e.declare ?? (e.declare = !1), e.returnType ?? (e.returnType = void 0), void (e.typeParameters ?? (e.typeParameters = void 0)));
         case 'Property':
          return void (e.optional ?? (e.optional = !1));
         case 'TSMethodSignature':
         case 'TSPropertySignature':
          e.optional ?? (e.optional = !1);
         case 'TSIndexSignature':
          return (e.accessibility ?? (e.accessibility = void 0), e.readonly ?? (e.readonly = !1), void (e.static ?? (e.static = !1)));
         case 'TSAbstractPropertyDefinition':
         case 'PropertyDefinition':
         case 'TSAbstractAccessorProperty':
         case 'AccessorProperty':
          (e.declare ?? (e.declare = !1), e.definite ?? (e.definite = !1), e.readonly ?? (e.readonly = !1), e.typeAnnotation ?? (e.typeAnnotation = void 0));
         case 'TSAbstractMethodDefinition':
         case 'MethodDefinition':
          return (e.accessibility ?? (e.accessibility = void 0), e.decorators ?? (e.decorators = []), e.override ?? (e.override = !1), void (e.optional ?? (e.optional = !1)));
         case 'ClassExpression':
          e.id ?? (e.id = null);
         case 'ClassDeclaration':
          return (e.abstract ?? (e.abstract = !1), e.declare ?? (e.declare = !1), e.decorators ?? (e.decorators = []), e.implements ?? (e.implements = []), e.superTypeArguments ?? (e.superTypeArguments = void 0), void (e.typeParameters ?? (e.typeParameters = void 0)));
         case 'TSTypeAliasDeclaration':
         case 'VariableDeclaration':
          return void (e.declare ?? (e.declare = !1));
         case 'VariableDeclarator':
          return void (e.definite ?? (e.definite = !1));
         case 'TSEnumDeclaration':
          return (e.const ?? (e.const = !1), void (e.declare ?? (e.declare = !1)));
         case 'TSEnumMember':
          return void (e.computed ?? (e.computed = !1));
         case 'TSImportType':
          return (e.qualifier ?? (e.qualifier = null), e.options ?? (e.options = null), void (e.typeArguments ?? (e.typeArguments = null)));
         case 'TSInterfaceDeclaration':
          return (e.declare ?? (e.declare = !1), void (e.extends ?? (e.extends = [])));
         case 'TSMappedType':
          return (e.optional ?? (e.optional = !1), void (e.readonly ?? (e.readonly = void 0)));
         case 'TSModuleDeclaration':
          return (e.declare ?? (e.declare = !1), void (e.global ?? (e.global = 'global' === e.kind)));
         case 'TSTypeParameter':
          return (e.const ?? (e.const = !1), e.in ?? (e.in = !1), void (e.out ?? (e.out = !1)));
        }
       }
       chStartsBindingIdentifierAndNotRelationalOperator(e, t) {
        if (ce(e)) {
         if (((Ct.lastIndex = t), Ct.test(this.input))) {
          let e = this.codePointAtPos(Ct.lastIndex);
          if (!he(e) && 92 !== e) return !1;
         }
         return !0;
        }
        return 92 === e;
       }
       nextTokenIsIdentifierAndNotTSRelationalOperatorOnSameLine() {
        let e = this.nextTokenInLineStart(),
         t = this.codePointAtPos(e);
        return this.chStartsBindingIdentifierAndNotRelationalOperator(t, e);
       }
       nextTokenIsIdentifierOrStringLiteralOnSameLine() {
        let e = this.nextTokenInLineStart(),
         t = this.codePointAtPos(e);
        return this.chStartsBindingIdentifier(t, e) || 34 === t || 39 === t;
       }
      },
     v8intrinsic: (e) =>
      class extends e {
       parseV8Intrinsic() {
        if (this.match(54)) {
         let e = this.state.startLoc,
          t = this.startNode();
         if ((this.next(), X(this.state.type))) {
          let e = this.parseIdentifierName(),
           r = this.createIdentifier(t, e);
          if ((this.castNodeTo(r, 'V8IntrinsicIdentifier'), this.match(10))) return r;
         }
         this.unexpected(e);
        }
       }
       parseExprAtom(e) {
        return this.parseV8Intrinsic() || super.parseExprAtom(e);
       }
      },
     placeholders: (e) =>
      class extends e {
       parsePlaceholder(e) {
        if (this.match(133)) {
         let t = this.startNode();
         return (this.next(), this.assertNoSpace(), (t.name = super.parseIdentifier(!0)), this.assertNoSpace(), this.expect(133), this.finishPlaceholder(t, e));
        }
       }
       finishPlaceholder(e, t) {
        let r = e;
        return ((!r.expectedNode || !r.type) && (r = this.finishNode(r, 'Placeholder')), (r.expectedNode = t), r);
       }
       getTokenFromCode(e) {
        37 === e && 37 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(133, 2) : super.getTokenFromCode(e);
       }
       parseExprAtom(e) {
        return this.parsePlaceholder('Expression') || super.parseExprAtom(e);
       }
       parseIdentifier(e) {
        return this.parsePlaceholder('Identifier') || super.parseIdentifier(e);
       }
       checkReservedWord(e, t, r, s) {
        void 0 !== e && super.checkReservedWord(e, t, r, s);
       }
       cloneIdentifier(e) {
        let t = super.cloneIdentifier(e);
        return ('Placeholder' === t.type && (t.expectedNode = e.expectedNode), t);
       }
       cloneStringLiteral(e) {
        return 'Placeholder' === e.type ? this.cloneIdentifier(e) : super.cloneStringLiteral(e);
       }
       parseBindingAtom() {
        return this.parsePlaceholder('Pattern') || super.parseBindingAtom();
       }
       isValidLVal(e, t, r, s) {
        return 'Placeholder' === e || super.isValidLVal(e, t, r, s);
       }
       toAssignable(e, t) {
        e && 'Placeholder' === e.type && 'Expression' === e.expectedNode ? (e.expectedNode = 'Pattern') : super.toAssignable(e, t);
       }
       chStartsBindingIdentifier(e, t) {
        if (super.chStartsBindingIdentifier(e, t)) return !0;
        let r = this.nextTokenStart();
        return 37 === this.input.charCodeAt(r) && 37 === this.input.charCodeAt(r + 1);
       }
       verifyBreakContinue(e, t) {
        (e.label && 'Placeholder' === e.label.type) || super.verifyBreakContinue(e, t);
       }
       parseExpressionStatement(e, t) {
        if ('Placeholder' !== t.type || t.extra?.parenthesized) return super.parseExpressionStatement(e, t);
        if (this.match(14)) {
         let r = e;
         return ((r.label = this.finishPlaceholder(t, 'Identifier')), this.next(), (r.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration()), this.finishNode(r, 'LabeledStatement'));
        }
        this.semicolon();
        let r = e;
        return ((r.name = t.name), this.finishPlaceholder(r, 'Statement'));
       }
       parseBlock(e, t, r) {
        return this.parsePlaceholder('BlockStatement') || super.parseBlock(e, t, r);
       }
       parseFunctionId(e) {
        return this.parsePlaceholder('Identifier') || super.parseFunctionId(e);
       }
       parseClass(e, t, r) {
        let s = t ? 'ClassDeclaration' : 'ClassExpression';
        this.next();
        let n = this.state.strict,
         i = this.parsePlaceholder('Identifier');
        if (i) {
         if (!(this.match(81) || this.match(133) || this.match(5))) {
          if (r || !t) return ((e.id = null), (e.body = this.finishPlaceholder(i, 'ClassBody')), this.finishNode(e, s));
          throw this.raise(Bt.ClassNameIsRequired, this.state.startLoc);
         }
         e.id = i;
        } else this.parseClassId(e, t, r);
        return (super.parseClassSuper(e), (e.body = this.parsePlaceholder('ClassBody') || super.parseClassBody(!!e.superClass, n)), this.finishNode(e, s));
       }
       parseExport(e, t) {
        let r = this.parsePlaceholder('Identifier');
        if (!r) return super.parseExport(e, t);
        let s = e;
        if (!this.isContextual(98) && !this.match(12)) return ((s.specifiers = []), (s.source = null), (s.declaration = this.finishPlaceholder(r, 'Declaration')), this.finishNode(s, 'ExportNamedDeclaration'));
        this.expectPlugin('exportDefaultFrom');
        let n = this.startNode();
        return ((n.exported = r), (s.specifiers = [this.finishNode(n, 'ExportDefaultSpecifier')]), super.parseExport(s, t));
       }
       isExportDefaultSpecifier() {
        if (this.match(65)) {
         let e = this.nextTokenStart();
         if (this.isUnparsedContextual(e, 'from') && this.input.startsWith(ee(133), this.nextTokenStartSince(e + 4))) return !0;
        }
        return super.isExportDefaultSpecifier();
       }
       maybeParseExportDefaultSpecifier(e, t) {
        return !!e.specifiers?.length || super.maybeParseExportDefaultSpecifier(e, t);
       }
       checkExport(e) {
        let { specifiers: t } = e;
        (t?.length && (e.specifiers = t.filter((e) => 'Placeholder' === e.exported.type)), super.checkExport(e), (e.specifiers = t));
       }
       parseImport(e) {
        let t = this.parsePlaceholder('Identifier');
        if (!t) return super.parseImport(e);
        if (((e.specifiers = []), !this.isContextual(98) && !this.match(12))) return ((e.source = this.finishPlaceholder(t, 'StringLiteral')), this.semicolon(), this.finishNode(e, 'ImportDeclaration'));
        let r = this.startNodeAtNode(t);
        return ((r.local = t), e.specifiers.push(this.finishNode(r, 'ImportDefaultSpecifier')), this.eat(12) && (this.maybeParseStarImportSpecifier(e) || this.parseNamedImportSpecifiers(e)), this.expectContextual(98), (e.source = this.parseImportSource()), this.semicolon(), this.finishNode(e, 'ImportDeclaration'));
       }
       parseImportSource() {
        return this.parsePlaceholder('StringLiteral') || super.parseImportSource();
       }
       assertNoSpace() {
        this.state.start > this.offsetToSourcePos(this.state.lastTokEndLoc.index) && this.raise(Bt.UnexpectedSpace, this.state.lastTokEndLoc);
       }
      },
    },
    jt = Object.keys(Mt),
    _t = class extends Tt {
     checkProto(e, t, r, s) {
      if ('SpreadElement' === e.type || this.isObjectMethod(e) || e.computed || e.shorthand) return r;
      let n = e.key;
      return '__proto__' === ('Identifier' === n.type ? n.name : n.value) ? (t ? (this.raise(C.RecordNoProto, n), !0) : (r && (s ? null === s.doubleProtoLoc && (s.doubleProtoLoc = n.loc.start) : this.raise(C.DuplicateProto, n)), !0)) : r;
     }
     shouldExitDescending(e, t) {
      return 'ArrowFunctionExpression' === e.type && this.offsetToSourcePos(e.start) === t;
     }
     getExpression() {
      if ((this.enterInitialScopes(), this.nextToken(), this.match(140))) throw this.raise(C.ParseExpressionEmptyInput, this.state.startLoc);
      let e = this.parseExpression();
      if (!this.match(140)) throw this.raise(C.ParseExpressionExpectsEOF, this.state.startLoc, { unexpected: this.input.codePointAt(this.state.start) });
      return (this.finalizeRemainingComments(), (e.comments = this.comments), (e.errors = this.state.errors), 256 & this.optionFlags && (e.tokens = this.tokens), e);
     }
     parseExpression(e, t) {
      return e ? this.disallowInAnd(() => this.parseExpressionBase(t)) : this.allowInAnd(() => this.parseExpressionBase(t));
     }
     parseExpressionBase(e) {
      let t = this.state.startLoc,
       r = this.parseMaybeAssign(e);
      if (this.match(12)) {
       let s = this.startNodeAt(t);
       for (s.expressions = [r]; this.eat(12); ) s.expressions.push(this.parseMaybeAssign(e));
       return (this.toReferencedList(s.expressions), this.finishNode(s, 'SequenceExpression'));
      }
      return r;
     }
     parseMaybeAssignDisallowIn(e, t) {
      return this.disallowInAnd(() => this.parseMaybeAssign(e, t));
     }
     parseMaybeAssignAllowIn(e, t) {
      return this.allowInAnd(() => this.parseMaybeAssign(e, t));
     }
     setOptionalParametersError(e) {
      e.optionalParametersLoc = this.state.startLoc;
     }
     parseMaybeAssign(e, t) {
      let r,
       s = this.state.startLoc,
       n = this.isContextual(108);
      if (n && this.prodParam.hasYield) {
       this.next();
       let e = this.parseYield(s);
       return (t && (e = t.call(this, e, s)), e);
      }
      e ? (r = !1) : ((e = new Dt()), (r = !0));
      let { type: i } = this.state;
      (10 === i || X(i)) && (this.state.potentialArrowAt = this.state.start);
      let a = this.parseMaybeConditional(e);
      if ((t && (a = t.call(this, a, s)), (o = this.state.type) >= 29 && o <= 33)) {
       let t = this.startNodeAt(s),
        r = this.state.value;
       if (((t.operator = r), this.match(29))) {
        (this.toAssignable(a, !0), (t.left = a));
        let r = s.index;
        (null != e.doubleProtoLoc && e.doubleProtoLoc.index >= r && (e.doubleProtoLoc = null), null != e.shorthandAssignLoc && e.shorthandAssignLoc.index >= r && (e.shorthandAssignLoc = null), null != e.privateKeyLoc && e.privateKeyLoc.index >= r && (this.checkDestructuringPrivate(e), (e.privateKeyLoc = null)), null != e.voidPatternLoc && e.voidPatternLoc.index >= r && (e.voidPatternLoc = null));
       } else t.left = a;
       return (this.next(), (t.right = this.parseMaybeAssign()), this.checkLVal(a, this.finishNode(t, 'AssignmentExpression'), void 0, void 0, void 0, void 0, '||=' === r || '&&=' === r || '??=' === r), t);
      }
      var o;
      if ((r && this.checkExpressionErrors(e, !0), n)) {
       let { type: e } = this.state;
       if ((this.hasPlugin('v8intrinsic') ? Y(e) : Y(e) && !this.match(54)) && !this.isAmbiguousPrefixOrIdentifier()) return (this.raiseOverwrite(C.YieldNotInGeneratorFunction, s), this.parseYield(s));
      }
      return a;
     }
     parseMaybeConditional(e) {
      let t = this.state.startLoc,
       r = this.state.potentialArrowAt,
       s = this.parseExprOps(e);
      return this.shouldExitDescending(s, r) ? s : this.parseConditional(s, t, e);
     }
     parseConditional(e, t, r) {
      if (this.eat(17)) {
       let r = this.startNodeAt(t);
       return ((r.test = e), (r.consequent = this.parseMaybeAssignAllowIn()), this.expect(14), (r.alternate = this.parseMaybeAssign()), this.finishNode(r, 'ConditionalExpression'));
      }
      return e;
     }
     parseMaybeUnaryOrPrivate(e) {
      return this.match(139) ? this.parsePrivateName() : this.parseMaybeUnary(e);
     }
     parseExprOps(e) {
      let t = this.state.startLoc,
       r = this.state.potentialArrowAt,
       s = this.parseMaybeUnaryOrPrivate(e);
      return this.shouldExitDescending(s, r) ? s : this.parseExprOp(s, t, -1);
     }
     parseExprOp(e, t, r) {
      if (this.isPrivateName(e)) {
       let t = this.getPrivateNameSV(e);
       ((r >= te(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(C.PrivateInExpectedIn, e, { identifierName: t }), this.classScope.usePrivateName(t, e.loc.start));
      }
      let s = this.state.type;
      if ((n = s) >= 39 && n <= 59 && (this.prodParam.hasIn || !this.match(58))) {
       let n = te(s);
       if (n > r) {
        if (39 === s) {
         if ((this.expectPlugin('pipelineOperator'), this.state.inFSharpPipelineDirectBody)) return e;
         this.checkPipelineAtInfixOperator(e, t);
        }
        let i = this.startNodeAt(t);
        ((i.left = e), (i.operator = this.state.value));
        let a = 41 === s || 42 === s,
         o = 40 === s;
        (o && (n = te(42)), this.next(), (i.right = this.parseExprOpRightExpr(s, n)));
        let u = this.finishNode(i, a || o ? 'LogicalExpression' : 'BinaryExpression'),
         l = this.state.type;
        if ((o && (41 === l || 42 === l)) || (a && 40 === l)) throw this.raise(C.MixingCoalesceWithLogical, this.state.startLoc);
        return this.parseExprOp(u, t, r);
       }
      }
      var n;
      return e;
     }
     parseExprOpRightExpr(e, t) {
      if (39 === (this.state.startLoc, e))
       switch (this.getPluginOption('pipelineOperator', 'proposal')) {
        case 'hack':
         return this.withTopicBindingContext(() => this.parseHackPipeBody());
        case 'fsharp':
         return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(t));
       }
      return this.parseExprOpBaseRightExpr(e, t);
     }
     parseExprOpBaseRightExpr(e, t) {
      let r = this.state.startLoc;
      return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), r, 57 === e ? t - 1 : t);
     }
     parseHackPipeBody() {
      let { startLoc: e } = this.state,
       t = this.parseMaybeAssign();
      return (D.has(t.type) && !t.extra?.parenthesized && this.raise(C.PipeUnparenthesizedBody, e, { type: t.type }), this.topicReferenceWasUsedInCurrentContext() || this.raise(C.PipeTopicUnused, e), t);
     }
     checkExponentialAfterUnary(e) {
      this.match(57) && this.raise(C.UnexpectedTokenUnaryExponentiation, e.argument);
     }
     parseMaybeUnary(e, t) {
      let r = this.state.startLoc,
       s = this.isContextual(96);
      if (s && this.recordAwaitIfAllowed()) {
       this.next();
       let e = this.parseAwait(r);
       return (t || this.checkExponentialAfterUnary(e), e);
      }
      let n = this.match(34),
       i = this.startNode();
      if (((a = this.state.type), W[a])) {
       ((i.operator = this.state.value), (i.prefix = !0), this.match(72) && this.expectPlugin('throwExpressions'));
       let r = this.match(89);
       if ((this.next(), (i.argument = this.parseMaybeUnary(null, !0)), this.checkExpressionErrors(e, !0), this.state.strict && r)) {
        let e = i.argument;
        'Identifier' === e.type ? this.raise(C.StrictDelete, i) : this.hasPropertyAsPrivateName(e) && this.raise(C.DeletePrivateField, i);
       }
       if (!n) return (t || this.checkExponentialAfterUnary(i), this.finishNode(i, 'UnaryExpression'));
      }
      var a;
      let o = this.parseUpdate(i, n, e);
      if (s) {
       let { type: e } = this.state;
       if ((this.hasPlugin('v8intrinsic') ? Y(e) : Y(e) && !this.match(54)) && !this.isAmbiguousPrefixOrIdentifier()) return (this.raiseOverwrite(C.AwaitNotInAsyncContext, r), this.parseAwait(r));
      }
      return o;
     }
     parseUpdate(e, t, r) {
      if (t) {
       let t = e;
       return (this.checkLVal(t.argument, this.finishNode(t, 'UpdateExpression')), e);
      }
      let s = this.state.startLoc,
       n = this.parseExprSubscripts(r);
      if (this.checkExpressionErrors(r, !1)) return n;
      for (; 34 === this.state.type && !this.canInsertSemicolon(); ) {
       let e = this.startNodeAt(s);
       ((e.operator = this.state.value), (e.prefix = !1), (e.argument = n), this.next(), this.checkLVal(n, (n = this.finishNode(e, 'UpdateExpression'))));
      }
      return n;
     }
     parseExprSubscripts(e) {
      let t = this.state.startLoc,
       r = this.state.potentialArrowAt,
       s = this.parseExprAtom(e);
      return this.shouldExitDescending(s, r) ? s : this.parseSubscripts(s, t);
     }
     parseSubscripts(e, t, r) {
      let s = { optionalChainMember: !1, maybeAsyncArrow: this.atPossibleAsyncArrow(e), stop: !1 };
      do {
       ((e = this.parseSubscript(e, t, r, s)), (s.maybeAsyncArrow = !1));
      } while (!s.stop);
      return e;
     }
     parseSubscript(e, t, r, s) {
      let { type: n } = this.state;
      if (!r && 15 === n) return this.parseBind(e, t, r, s);
      if (re(n)) return this.parseTaggedTemplateExpression(e, t, s);
      let i = !1;
      if (18 === n) {
       if (r && (this.raise(C.OptionalChainingNoNew, this.state.startLoc), 40 === this.lookaheadCharCode())) return this.stopParseSubscript(e, s);
       ((s.optionalChainMember = i = !0), this.next());
      }
      if (!r && this.match(10)) return this.parseCoverCallAndAsyncArrowHead(e, t, s, i);
      {
       let r = this.eat(0);
       return r || i || this.eat(16) ? this.parseMember(e, t, s, r, i) : this.stopParseSubscript(e, s);
      }
     }
     stopParseSubscript(e, t) {
      return ((t.stop = !0), e);
     }
     parseMember(e, t, r, s, n) {
      let i = this.startNodeAt(t);
      return ((i.object = e), (i.computed = s), s ? ((i.property = this.parseExpression()), this.expect(3)) : this.match(139) ? ('Super' === e.type && this.raise(C.SuperPrivateField, t), this.classScope.usePrivateName(this.state.value, this.state.startLoc), (i.property = this.parsePrivateName())) : (i.property = this.parseIdentifier(!0)), r.optionalChainMember ? ((i.optional = n), this.finishNode(i, 'OptionalMemberExpression')) : this.finishNode(i, 'MemberExpression'));
     }
     parseBind(e, t, r, s) {
      let n = this.startNodeAt(t);
      return ((n.object = e), this.next(), (n.callee = this.parseNoCallExpr()), (s.stop = !0), this.parseSubscripts(this.finishNode(n, 'BindExpression'), t, r));
     }
     parseCoverCallAndAsyncArrowHead(e, t, r, s) {
      let n = this.state.maybeInArrowParameters,
       i = null;
      ((this.state.maybeInArrowParameters = !0), this.next());
      let a = this.startNodeAt(t);
      a.callee = e;
      let { maybeAsyncArrow: o, optionalChainMember: u } = r;
      (o && (this.expressionScope.enter(new dt(2)), (i = new Dt())), u && (a.optional = s), (a.arguments = s ? this.parseCallExpressionArguments() : this.parseCallExpressionArguments('Super' !== e.type, a, i)));
      let l = this.finishCallExpression(a, u);
      return (o && this.shouldParseAsyncArrow() && !s ? ((r.stop = !0), this.checkDestructuringPrivate(i), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), (l = this.parseAsyncArrowFromCallExpression(this.startNodeAt(t), l))) : (o && (this.checkExpressionErrors(i, !0), this.expressionScope.exit()), this.toReferencedArguments(l)), (this.state.maybeInArrowParameters = n), l);
     }
     toReferencedArguments(e, t) {
      this.toReferencedListDeep(e.arguments, t);
     }
     parseTaggedTemplateExpression(e, t, r) {
      let s = this.startNodeAt(t);
      return ((s.tag = e), (s.quasi = this.parseTemplate(!0)), r.optionalChainMember && this.raise(C.OptionalChainingNoTemplate, t), this.finishNode(s, 'TaggedTemplateExpression'));
     }
     atPossibleAsyncArrow(e) {
      return 'Identifier' === e.type && 'async' === e.name && this.state.lastTokEndLoc.index === e.end && !this.canInsertSemicolon() && e.end - e.start == 5 && this.offsetToSourcePos(e.start) === this.state.potentialArrowAt;
     }
     finishCallExpression(e, t) {
      if ('Import' === e.callee.type)
       if (0 === e.arguments.length || e.arguments.length > 2) this.raise(C.ImportCallArity, e);
       else for (let r of e.arguments) 'SpreadElement' === r.type && this.raise(C.ImportCallSpreadArgument, r);
      return this.finishNode(e, t ? 'OptionalCallExpression' : 'CallExpression');
     }
     parseCallExpressionArguments(e, t, r) {
      let s = [],
       n = !0,
       i = this.state.inFSharpPipelineDirectBody;
      for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(11); ) {
       if (n) n = !1;
       else if ((this.expect(12), this.match(11))) {
        (t && this.addTrailingCommaExtraToNode(t), this.next());
        break;
       }
       s.push(this.parseExprListItem(11, !1, r, e));
      }
      return ((this.state.inFSharpPipelineDirectBody = i), s);
     }
     shouldParseAsyncArrow() {
      return this.match(19) && !this.canInsertSemicolon();
     }
     parseAsyncArrowFromCallExpression(e, t) {
      return (this.resetPreviousNodeTrailingComments(t), this.expect(19), this.parseArrowExpression(e, t.arguments, !0, t.extra?.trailingCommaLoc), t.innerComments && He(e, t.innerComments), t.callee.trailingComments && He(e, t.callee.trailingComments), e);
     }
     parseNoCallExpr() {
      let e = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), e, !0);
     }
     parseExprAtom(e) {
      let t,
       r = null,
       { type: s } = this.state;
      switch (s) {
       case 79:
        return this.parseSuper();
       case 83:
        return ((t = this.startNode()), this.next(), this.match(16) ? this.parseImportMetaPropertyOrPhaseCall(t) : this.match(10) ? (512 & this.optionFlags ? this.parseImportCall(t) : this.finishNode(t, 'Import')) : (this.raise(C.UnsupportedImport, this.state.lastTokStartLoc), this.finishNode(t, 'Import')));
       case 78:
        return ((t = this.startNode()), this.next(), this.finishNode(t, 'ThisExpression'));
       case 90:
        return this.parseDo(this.startNode(), !1);
       case 56:
       case 31:
        return (this.readRegexp(), this.parseRegExpLiteral(this.state.value));
       case 135:
        return this.parseNumericLiteral(this.state.value);
       case 136:
        return this.parseBigIntLiteral(this.state.value);
       case 134:
        return this.parseStringLiteral(this.state.value);
       case 84:
        return this.parseNullLiteral();
       case 85:
        return this.parseBooleanLiteral(!0);
       case 86:
        return this.parseBooleanLiteral(!1);
       case 10: {
        let e = this.state.potentialArrowAt === this.state.start;
        return this.parseParenAndDistinguishExpression(e);
       }
       case 0:
        return this.parseArrayLike(3, !1, e);
       case 5:
        return this.parseObjectLike(8, !1, !1, e);
       case 68:
        return this.parseFunctionOrFunctionSent();
       case 26:
        r = this.parseDecorators();
       case 80:
        return this.parseClass(this.maybeTakeDecorators(r, this.startNode()), !1);
       case 77:
        return this.parseNewOrNewTarget();
       case 25:
       case 24:
        return this.parseTemplate(!1);
       case 15: {
        ((t = this.startNode()), this.next(), (t.object = null));
        let e = (t.callee = this.parseNoCallExpr());
        if ('MemberExpression' === e.type) return this.finishNode(t, 'BindExpression');
        throw this.raise(C.UnsupportedBind, e);
       }
       case 139:
        return (this.raise(C.PrivateInExpectedIn, this.state.startLoc, { identifierName: this.state.value }), this.parsePrivateName());
       case 33:
        return this.parseTopicReferenceThenEqualsSign(54, '%');
       case 32:
        return this.parseTopicReferenceThenEqualsSign(44, '^');
       case 37:
       case 38:
        return this.parseTopicReference('hack');
       case 44:
       case 54:
       case 27: {
        let e = this.getPluginOption('pipelineOperator', 'proposal');
        if (e) return this.parseTopicReference(e);
        throw this.unexpected();
       }
       case 47: {
        let e = this.input.codePointAt(this.nextTokenStart());
        throw ce(e) || 62 === e ? this.expectOnePlugin(['jsx', 'flow', 'typescript']) : this.unexpected();
       }
       default:
        if (X(s)) {
         if (this.isContextual(127) && 123 === this.lookaheadInLineCharCode()) return this.parseModuleExpression();
         let e = this.state.potentialArrowAt === this.state.start,
          t = this.state.containsEsc,
          r = this.parseIdentifier();
         if (!t && 'async' === r.name && !this.canInsertSemicolon()) {
          let { type: e } = this.state;
          if (68 === e) return (this.resetPreviousNodeTrailingComments(r), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(r)));
          if (X(e)) return 61 === this.lookaheadCharCode() ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(r)) : r;
          if (90 === e) return (this.resetPreviousNodeTrailingComments(r), this.parseDo(this.startNodeAtNode(r), !0));
         }
         return e && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(r), [r], !1)) : r;
        }
        throw this.unexpected();
      }
     }
     parseTopicReferenceThenEqualsSign(e, t) {
      let r = this.getPluginOption('pipelineOperator', 'proposal');
      if (r) return ((this.state.type = e), (this.state.value = t), this.state.pos--, this.state.end--, (this.state.endLoc = p(this.state.endLoc, -1)), this.parseTopicReference(r));
      throw this.unexpected();
     }
     parseTopicReference(e) {
      let t = this.startNode(),
       r = this.state.startLoc,
       s = this.state.type;
      return (this.next(), this.finishTopicReference(t, r, e, s));
     }
     finishTopicReference(e, t, r, s) {
      if (this.testTopicReferenceConfiguration(r, t, s)) return (this.topicReferenceIsAllowedInCurrentContext() || this.raise(C.PipeTopicUnbound, t), this.registerTopicReference(), this.finishNode(e, 'TopicReference'));
      throw this.raise(C.PipeTopicUnconfiguredToken, t, { token: ee(s) });
     }
     testTopicReferenceConfiguration(e, t, r) {
      switch (e) {
       case 'hack':
        return this.hasPlugin(['pipelineOperator', { topicToken: ee(r) }]);
       case 'smart':
        return 27 === r;
       default:
        throw this.raise(C.PipeTopicRequiresHackPipes, t);
      }
     }
     parseAsyncArrowUnaryFunction(e) {
      this.prodParam.enter(We(!0, this.prodParam.hasYield));
      let t = [this.parseIdentifier()];
      return (this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(C.LineTerminatorBeforeArrow, this.state.curPosition()), this.expect(19), this.parseArrowExpression(e, t, !0));
     }
     parseDo(e, t) {
      (this.expectPlugin('doExpressions'), t && this.expectPlugin('asyncDoExpressions'), (e.async = t), this.next());
      let r = this.state.labels;
      return ((this.state.labels = []), t ? (this.prodParam.enter(2), (e.body = this.parseBlock()), this.prodParam.exit()) : (e.body = this.parseBlock()), (this.state.labels = r), this.finishNode(e, 'DoExpression'));
     }
     parseSuper() {
      let e = this.startNode();
      return (this.next(), this.match(10) && !this.scope.allowDirectSuper ? this.raise(C.SuperNotAllowed, e) : this.scope.allowSuper || this.raise(C.UnexpectedSuper, e), !this.match(10) && !this.match(0) && !this.match(16) && this.raise(C.UnsupportedSuper, e), this.finishNode(e, 'Super'));
     }
     parsePrivateName() {
      let e = this.startNode(),
       t = this.startNodeAt(p(this.state.startLoc, 1)),
       r = this.state.value;
      return (this.next(), (e.id = this.createIdentifier(t, r)), this.finishNode(e, 'PrivateName'));
     }
     parseFunctionOrFunctionSent() {
      let e = this.startNode();
      if ((this.next(), this.prodParam.hasYield && this.match(16))) {
       let t = this.createIdentifier(this.startNodeAtNode(e), 'function');
       return (this.next(), this.match(103) ? this.expectPlugin('functionSent') : this.hasPlugin('functionSent') || this.unexpected(), this.parseMetaProperty(e, t, 'sent'));
      }
      return this.parseFunction(e);
     }
     parseMetaProperty(e, t, r) {
      e.meta = t;
      let s = this.state.containsEsc;
      return ((e.property = this.parseIdentifier(!0)), (e.property.name !== r || s) && this.raise(C.UnsupportedMetaProperty, e.property, { target: t.name, onlyValidPropertyName: r }), this.finishNode(e, 'MetaProperty'));
     }
     parseImportMetaPropertyOrPhaseCall(e) {
      if ((this.next(), this.isContextual(105) || this.isContextual(97))) {
       let t = this.isContextual(105);
       return (this.expectPlugin(t ? 'sourcePhaseImports' : 'deferredImportEvaluation'), this.next(), (e.phase = t ? 'source' : 'defer'), this.parseImportCall(e));
      }
      {
       let t = this.createIdentifierAt(this.startNodeAtNode(e), 'import', this.state.lastTokStartLoc);
       return (this.isContextual(101) && (this.inModule || this.raise(C.ImportMetaOutsideModule, t), (this.sawUnambiguousESM = !0)), this.parseMetaProperty(e, t, 'meta'));
      }
     }
     parseLiteralAtNode(e, t, r) {
      return (this.addExtra(r, 'rawValue', e), this.addExtra(r, 'raw', this.input.slice(this.offsetToSourcePos(r.start), this.state.end)), (r.value = e), this.next(), this.finishNode(r, t));
     }
     parseLiteral(e, t) {
      let r = this.startNode();
      return this.parseLiteralAtNode(e, t, r);
     }
     parseStringLiteral(e) {
      return this.parseLiteral(e, 'StringLiteral');
     }
     parseNumericLiteral(e) {
      return this.parseLiteral(e, 'NumericLiteral');
     }
     parseBigIntLiteral(e) {
      {
       let t;
       try {
        t = BigInt(e);
       } catch {
        t = null;
       }
       return this.parseLiteral(t, 'BigIntLiteral');
      }
     }
     parseDecimalLiteral(e) {
      return this.parseLiteral(e, 'DecimalLiteral');
     }
     parseRegExpLiteral(e) {
      let t = this.startNode();
      return (this.addExtra(t, 'raw', this.input.slice(this.offsetToSourcePos(t.start), this.state.end)), (t.pattern = e.pattern), (t.flags = e.flags), this.next(), this.finishNode(t, 'RegExpLiteral'));
     }
     parseBooleanLiteral(e) {
      let t = this.startNode();
      return ((t.value = e), this.next(), this.finishNode(t, 'BooleanLiteral'));
     }
     parseNullLiteral() {
      let e = this.startNode();
      return (this.next(), this.finishNode(e, 'NullLiteral'));
     }
     parseParenAndDistinguishExpression(e) {
      let t,
       r = this.state.startLoc;
      (this.next(), this.expressionScope.enter(new dt(1)));
      let s = this.state.maybeInArrowParameters,
       n = this.state.inFSharpPipelineDirectBody;
      ((this.state.maybeInArrowParameters = !0), (this.state.inFSharpPipelineDirectBody = !1));
      let i,
       a,
       o = this.state.startLoc,
       u = [],
       l = new Dt(),
       p = !0;
      for (; !this.match(11); ) {
       if (p) p = !1;
       else if ((this.expect(12, null === l.optionalParametersLoc ? null : l.optionalParametersLoc), this.match(11))) {
        a = this.state.startLoc;
        break;
       }
       if (this.match(21)) {
        let e = this.state.startLoc;
        if (((i = this.state.startLoc), u.push(this.parseParenItem(this.parseRestBinding(), e)), !this.checkCommaAfterRest(41))) break;
       } else u.push(this.parseMaybeAssignAllowInOrVoidPattern(11, l, this.parseParenItem));
      }
      let c = this.state.lastTokEndLoc;
      (this.expect(11), (this.state.maybeInArrowParameters = s), (this.state.inFSharpPipelineDirectBody = n));
      let h = this.startNodeAt(r);
      return e && this.shouldParseArrow(u) && (h = this.parseArrow(h)) ? (this.checkDestructuringPrivate(l), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(h, u, !1), h) : (this.expressionScope.exit(), u.length || this.unexpected(this.state.lastTokStartLoc), a && this.unexpected(a), i && this.unexpected(i), this.checkExpressionErrors(l, !0), this.toReferencedListDeep(u, !0), u.length > 1 ? ((t = this.startNodeAt(o)), (t.expressions = u), this.finishNode(t, 'SequenceExpression'), this.resetEndLocation(t, c)) : (t = u[0]), this.wrapParenthesis(r, t));
     }
     wrapParenthesis(e, t) {
      if (!(1024 & this.optionFlags)) return (this.addExtra(t, 'parenthesized', !0), this.addExtra(t, 'parenStart', e.index), this.takeSurroundingComments(t, e.index, this.state.lastTokEndLoc.index), t);
      let r = this.startNodeAt(e);
      return ((r.expression = t), this.finishNode(r, 'ParenthesizedExpression'));
     }
     shouldParseArrow(e) {
      return !this.canInsertSemicolon();
     }
     parseArrow(e) {
      if (this.eat(19)) return e;
     }
     parseParenItem(e, t) {
      return e;
     }
     parseNewOrNewTarget() {
      let e = this.startNode();
      if ((this.next(), this.match(16))) {
       let t = this.createIdentifier(this.startNodeAtNode(e), 'new');
       this.next();
       let r = this.parseMetaProperty(e, t, 'target');
       return (this.scope.allowNewTarget || this.raise(C.UnexpectedNewTarget, r), r);
      }
      return this.parseNew(e);
     }
     parseNew(e) {
      if ((this.parseNewCallee(e), this.eat(10))) {
       let t = this.parseExprList(11);
       (this.toReferencedList(t), (e.arguments = t));
      } else e.arguments = [];
      return this.finishNode(e, 'NewExpression');
     }
     parseNewCallee(e) {
      let t = this.match(83),
       r = this.parseNoCallExpr();
      ((e.callee = r), t && ('Import' === r.type || 'ImportExpression' === r.type) && this.raise(C.ImportCallNotNewExpression, r));
     }
     parseTemplateElement(e) {
      let { start: t, startLoc: r, end: s, value: n } = this.state,
       i = t + 1,
       a = this.startNodeAt(p(r, 1));
      null === n && (e || this.raise(C.InvalidEscapeSequenceTemplate, p(this.state.firstInvalidTemplateEscapePos, 1)));
      let o = this.match(24),
       u = o ? -1 : -2,
       l = s + u;
      ((a.value = { raw: this.input.slice(i, l).replace(/\r\n?/g, '\n'), cooked: null === n ? null : n.slice(1, u) }), (a.tail = o), this.next());
      let c = this.finishNode(a, 'TemplateElement');
      return (this.resetEndLocation(c, p(this.state.lastTokEndLoc, u)), c);
     }
     parseTemplate(e) {
      let t = this.startNode(),
       r = this.parseTemplateElement(e),
       s = [r],
       n = [];
      for (; !r.tail; ) (n.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), s.push((r = this.parseTemplateElement(e))));
      return ((t.expressions = n), (t.quasis = s), this.finishNode(t, 'TemplateLiteral'));
     }
     parseTemplateSubstitution() {
      return this.parseExpression();
     }
     parseObjectLike(e, t, r, s) {
      r && this.expectPlugin('recordAndTuple');
      let n = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      let i = !1,
       a = !0,
       o = this.startNode();
      for (o.properties = [], this.next(); !this.match(e); ) {
       if (a) a = !1;
       else if ((this.expect(12), this.match(e))) {
        this.addTrailingCommaExtraToNode(o);
        break;
       }
       let n;
       (t ? (n = this.parseBindingProperty()) : ((n = this.parsePropertyDefinition(s)), (i = this.checkProto(n, r, i, s))), r && !this.isObjectProperty(n) && 'SpreadElement' !== n.type && this.raise(C.InvalidRecordProperty, n), o.properties.push(n));
      }
      (this.next(), (this.state.inFSharpPipelineDirectBody = n));
      let u = 'ObjectExpression';
      return (t ? (u = 'ObjectPattern') : r && (u = 'RecordExpression'), this.finishNode(o, u));
     }
     addTrailingCommaExtraToNode(e) {
      (this.addExtra(e, 'trailingComma', this.state.lastTokStartLoc.index), this.addExtra(e, 'trailingCommaLoc', this.state.lastTokStartLoc, !1));
     }
     maybeAsyncOrAccessorProp(e) {
      return !e.computed && 'Identifier' === e.key.type && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
     }
     parsePropertyDefinition(e) {
      let t = [];
      if (this.match(26)) for (this.hasPlugin('decorators') && this.raise(C.UnsupportedPropertyDecorator, this.state.startLoc); this.match(26); ) t.push(this.parseDecorator());
      let r,
       s = this.startNode(),
       n = !1,
       i = !1;
      if (this.match(21)) return (t.length && this.unexpected(), this.parseSpread());
      (t.length && ((s.decorators = t), (t = [])), (s.method = !1), e && (r = this.state.startLoc));
      let a = this.eat(55);
      this.parsePropertyNamePrefixOperator(s);
      let o = this.state.containsEsc;
      if ((this.parsePropertyName(s, e), !a && !o && this.maybeAsyncOrAccessorProp(s))) {
       let { key: e } = s,
        t = e.name;
       ('async' === t && !this.hasPrecedingLineBreak() && ((n = !0), this.resetPreviousNodeTrailingComments(e), (a = this.eat(55)), this.parsePropertyName(s)), ('get' === t || 'set' === t) && ((i = !0), this.resetPreviousNodeTrailingComments(e), (s.kind = t), this.match(55) && ((a = !0), this.raise(C.AccessorIsGenerator, this.state.curPosition(), { kind: t }), this.next()), this.parsePropertyName(s)));
      }
      return this.parseObjPropValue(s, r, a, n, !1, i, e);
     }
     getGetterSetterExpectedParamCount(e) {
      return 'get' === e.kind ? 0 : 1;
     }
     getObjectOrClassMethodParams(e) {
      return e.params;
     }
     checkGetterSetterParams(e) {
      let t = this.getGetterSetterExpectedParamCount(e),
       r = this.getObjectOrClassMethodParams(e);
      (r.length !== t && this.raise('get' === e.kind ? C.BadGetterArity : C.BadSetterArity, e), 'set' === e.kind && 'RestElement' === r[r.length - 1]?.type && this.raise(C.BadSetterRestParameter, e));
     }
     parseObjectMethod(e, t, r, s, n) {
      if (n) {
       let r = this.parseMethod(e, t, !1, !1, !1, 'ObjectMethod');
       return (this.checkGetterSetterParams(r), r);
      }
      if (r || t || this.match(10)) return (s && this.unexpected(), (e.kind = 'method'), (e.method = !0), this.parseMethod(e, t, r, !1, !1, 'ObjectMethod'));
     }
     parseObjectProperty(e, t, r, s) {
      if (((e.shorthand = !1), this.eat(14))) return ((e.value = r ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowInOrVoidPattern(8, s)), this.finishObjectProperty(e));
      if (!e.computed && 'Identifier' === e.key.type) {
       if ((this.checkReservedWord(e.key.name, e.key.loc.start, !0, !1), r)) e.value = this.parseMaybeDefault(t, this.cloneIdentifier(e.key));
       else if (this.match(29)) {
        let r = this.state.startLoc;
        (null != s ? null === s.shorthandAssignLoc && (s.shorthandAssignLoc = r) : this.raise(C.InvalidCoverInitializedName, r), (e.value = this.parseMaybeDefault(t, this.cloneIdentifier(e.key))));
       } else e.value = this.cloneIdentifier(e.key);
       return ((e.shorthand = !0), this.finishObjectProperty(e));
      }
     }
     finishObjectProperty(e) {
      return this.finishNode(e, 'ObjectProperty');
     }
     parseObjPropValue(e, t, r, s, n, i, a) {
      let o = this.parseObjectMethod(e, r, s, n, i) || this.parseObjectProperty(e, t, n, a);
      return (o || this.unexpected(), o);
     }
     parsePropertyName(e, t) {
      if (this.eat(0)) ((e.computed = !0), (e.key = this.parseMaybeAssignAllowIn()), this.expect(3));
      else {
       let r,
        { type: s, value: n } = this.state;
       if (K(s)) r = this.parseIdentifier(!0);
       else
        switch (s) {
         case 135:
          r = this.parseNumericLiteral(n);
          break;
         case 134:
          r = this.parseStringLiteral(n);
          break;
         case 136:
          r = this.parseBigIntLiteral(n);
          break;
         case 139: {
          let e = this.state.startLoc;
          (null != t ? null === t.privateKeyLoc && (t.privateKeyLoc = e) : this.raise(C.UnexpectedPrivateField, e), (r = this.parsePrivateName()));
          break;
         }
         default:
          this.unexpected();
        }
       ((e.key = r), 139 !== s && (e.computed = !1));
      }
     }
     initFunction(e, t) {
      ((e.id = null), (e.generator = !1), (e.async = t));
     }
     parseMethod(e, t, r, s, n, i, a = !1) {
      (this.initFunction(e, r), (e.generator = t), this.scope.enter(530 | (a ? 576 : 0) | (n ? 32 : 0)), this.prodParam.enter(We(r, e.generator)), this.parseFunctionParams(e, s));
      let o = this.parseFunctionBodyAndFinish(e, i, !0);
      return (this.prodParam.exit(), this.scope.exit(), o);
     }
     parseArrayLike(e, t, r) {
      t && this.expectPlugin('recordAndTuple');
      let s = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      let n = this.startNode();
      return (this.next(), (n.elements = this.parseExprList(e, !t, r, n)), (this.state.inFSharpPipelineDirectBody = s), this.finishNode(n, t ? 'TupleExpression' : 'ArrayExpression'));
     }
     parseArrowExpression(e, t, r, s) {
      this.scope.enter(518);
      let n = We(r, !1);
      (!this.match(5) && this.prodParam.hasIn && (n |= 8), this.prodParam.enter(n), this.initFunction(e, r));
      let i = this.state.maybeInArrowParameters;
      return (t && ((this.state.maybeInArrowParameters = !0), this.setArrowFunctionParameters(e, t, s)), (this.state.maybeInArrowParameters = !1), this.parseFunctionBody(e, !0), this.prodParam.exit(), this.scope.exit(), (this.state.maybeInArrowParameters = i), this.finishNode(e, 'ArrowFunctionExpression'));
     }
     setArrowFunctionParameters(e, t, r) {
      (this.toAssignableList(t, r, !1), (e.params = t));
     }
     parseFunctionBodyAndFinish(e, t, r = !1) {
      return (this.parseFunctionBody(e, !1, r), this.finishNode(e, t));
     }
     parseFunctionBody(e, t, r = !1) {
      let s = t && !this.match(5);
      if ((this.expressionScope.enter(mt()), s)) ((e.body = this.parseMaybeAssign()), this.checkParams(e, !1, t, !1));
      else {
       let s = this.state.strict,
        n = this.state.labels;
       ((this.state.labels = []),
        this.prodParam.enter(4 | this.prodParam.currentFlags()),
        (e.body = this.parseBlock(!0, !1, (n) => {
         let i = !this.isSimpleParamList(e.params);
         n && i && this.raise(C.IllegalLanguageModeDirective, ('method' !== e.kind && 'constructor' !== e.kind) || !e.key ? e : e.key.loc.end);
         let a = !s && this.state.strict;
         (this.checkParams(e, !(this.state.strict || t || r || i), t, a), this.state.strict && e.id && this.checkIdentifier(e.id, 65, a));
        })),
        this.prodParam.exit(),
        (this.state.labels = n));
      }
      this.expressionScope.exit();
     }
     isSimpleParameter(e) {
      return 'Identifier' === e.type;
     }
     isSimpleParamList(e) {
      for (let t = 0, r = e.length; t < r; t++) if (!this.isSimpleParameter(e[t])) return !1;
      return !0;
     }
     checkParams(e, t, r, s = !0) {
      let n = !t && new Set(),
       i = { type: 'FormalParameters' };
      for (let a of e.params) this.checkLVal(a, i, 5, n, s);
     }
     parseExprList(e, t, r, s) {
      let n = [],
       i = !0;
      for (; !this.eat(e); ) {
       if (i) i = !1;
       else if ((this.expect(12), this.match(e))) {
        (s && this.addTrailingCommaExtraToNode(s), this.next());
        break;
       }
       n.push(this.parseExprListItem(e, t, r));
      }
      return n;
     }
     parseExprListItem(e, t, r, s) {
      let n;
      if (this.match(12)) (t || this.raise(C.UnexpectedToken, this.state.curPosition(), { unexpected: ',' }), (n = null));
      else if (this.match(21)) {
       let e = this.state.startLoc;
       n = this.parseParenItem(this.parseSpread(r), e);
      } else if (this.match(17)) {
       (this.expectPlugin('partialApplication'), s || this.raise(C.UnexpectedArgumentPlaceholder, this.state.startLoc));
       let e = this.startNode();
       (this.next(), (n = this.finishNode(e, 'ArgumentPlaceholder')));
      } else n = this.parseMaybeAssignAllowInOrVoidPattern(e, r, this.parseParenItem);
      return n;
     }
     parseIdentifier(e) {
      let t = this.startNode(),
       r = this.parseIdentifierName(e);
      return this.createIdentifier(t, r);
     }
     createIdentifier(e, t) {
      return ((e.name = t), (e.loc.identifierName = t), this.finishNode(e, 'Identifier'));
     }
     createIdentifierAt(e, t, r) {
      return ((e.name = t), (e.loc.identifierName = t), this.finishNodeAt(e, 'Identifier', r));
     }
     parseIdentifierName(e) {
      let t,
       { startLoc: r, type: s } = this.state;
      K(s) ? (t = this.state.value) : this.unexpected();
      let n = s <= 92;
      return (e ? n && this.replaceToken(132) : this.checkReservedWord(t, r, n, !1), this.next(), t);
     }
     checkReservedWord(e, t, r, s) {
      var n;
      if (!(e.length > 10) && ((n = e), Te.has(n)))
       if (
        r &&
        (function (e) {
         return me.has(e);
        })(e)
       )
        this.raise(C.UnexpectedKeyword, t, { keyword: e });
       else if ((this.state.strict ? (s ? be : xe) : ge)(e, this.inModule)) this.raise(C.UnexpectedReservedWord, t, { reservedWord: e });
       else if ('yield' === e) {
        if (this.prodParam.hasYield) return void this.raise(C.YieldBindingIdentifier, t);
       } else if ('await' === e) {
        if (this.prodParam.hasAwait) return void this.raise(C.AwaitBindingIdentifier, t);
        if (this.scope.inStaticBlock) return void this.raise(C.AwaitBindingIdentifierInStaticBlock, t);
        this.expressionScope.recordAsyncArrowParametersError(t);
       } else if ('arguments' === e && this.scope.inClassAndNotInNonArrowFunction) return void this.raise(C.ArgumentsInClass, t);
     }
     recordAwaitIfAllowed() {
      let e = this.prodParam.hasAwait;
      return (e && !this.scope.inFunction && (this.state.hasTopLevelAwait = !0), e);
     }
     parseAwait(e) {
      let t = this.startNodeAt(e);
      return (this.expressionScope.recordParameterInitializerError(C.AwaitExpressionFormalParameter, t), this.eat(55) && this.raise(C.ObsoleteAwaitStar, t), !this.scope.inFunction && !(1 & this.optionFlags) && (this.isAmbiguousPrefixOrIdentifier() ? (this.ambiguousScriptDifferentAst = !0) : (this.sawUnambiguousESM = !0)), this.state.soloAwait || (t.argument = this.parseMaybeUnary(null, !0)), this.finishNode(t, 'AwaitExpression'));
     }
     isAmbiguousPrefixOrIdentifier() {
      if (this.hasPrecedingLineBreak()) return !0;
      let { type: e } = this.state;
      return 53 === e || 10 === e || 0 === e || re(e) || (102 === e && !this.state.containsEsc) || 138 === e || 56 === e || (this.hasPlugin('v8intrinsic') && 54 === e);
     }
     parseYield(e) {
      let t = this.startNodeAt(e);
      this.expressionScope.recordParameterInitializerError(C.YieldInParameter, t);
      let r = !1,
       s = null;
      if (!this.hasPrecedingLineBreak())
       switch (((r = this.eat(55)), this.state.type)) {
        case 13:
        case 140:
        case 8:
        case 11:
        case 3:
        case 9:
        case 14:
        case 12:
         if (!r) break;
        default:
         s = this.parseMaybeAssign();
       }
      return ((t.delegate = r), (t.argument = s), this.finishNode(t, 'YieldExpression'));
     }
     parseImportCall(e) {
      if ((this.next(), (e.source = this.parseMaybeAssignAllowIn()), (e.options = null), this.eat(12)))
       if (this.match(11)) this.addTrailingCommaExtraToNode(e.source);
       else if (((e.options = this.parseMaybeAssignAllowIn()), this.eat(12) && (this.addTrailingCommaExtraToNode(e.options), !this.match(11)))) {
        do {
         this.parseMaybeAssignAllowIn();
        } while (this.eat(12) && !this.match(11));
        this.raise(C.ImportCallArity, e);
       }
      return (this.expect(11), this.finishNode(e, 'ImportExpression'));
     }
     checkPipelineAtInfixOperator(e, t) {
      this.hasPlugin(['pipelineOperator', { proposal: 'smart' }]) && 'SequenceExpression' === e.type && this.raise(C.PipelineHeadSequenceExpression, t);
     }
     parseSmartPipelineBodyInStyle(e, t) {
      if (this.isSimpleReference(e)) {
       let r = this.startNodeAt(t);
       return ((r.callee = e), this.finishNode(r, 'PipelineBareFunction'));
      }
      {
       let r = this.startNodeAt(t);
       return (this.checkSmartPipeTopicBodyEarlyErrors(t), (r.expression = e), this.finishNode(r, 'PipelineTopicExpression'));
      }
     }
     isSimpleReference(e) {
      switch (e.type) {
       case 'MemberExpression':
        return !e.computed && this.isSimpleReference(e.object);
       case 'Identifier':
        return !0;
       default:
        return !1;
      }
     }
     checkSmartPipeTopicBodyEarlyErrors(e) {
      if (this.match(19)) throw this.raise(C.PipelineBodyNoArrow, this.state.startLoc);
      this.topicReferenceWasUsedInCurrentContext() || this.raise(C.PipelineTopicUnused, e);
     }
     withTopicBindingContext(e) {
      let t = this.state.topicContext;
      this.state.topicContext = { maxNumOfResolvableTopics: 1, maxTopicIndex: null };
      try {
       return e();
      } finally {
       this.state.topicContext = t;
      }
     }
     withSmartMixTopicForbiddingContext(e) {
      return e();
     }
     withSoloAwaitPermittingContext(e) {
      let t = this.state.soloAwait;
      this.state.soloAwait = !0;
      try {
       return e();
      } finally {
       this.state.soloAwait = t;
      }
     }
     allowInAnd(e) {
      let t = this.prodParam.currentFlags();
      if (8 & ~t) {
       this.prodParam.enter(8 | t);
       try {
        return e();
       } finally {
        this.prodParam.exit();
       }
      }
      return e();
     }
     disallowInAnd(e) {
      let t = this.prodParam.currentFlags();
      if (8 & t) {
       this.prodParam.enter(-9 & t);
       try {
        return e();
       } finally {
        this.prodParam.exit();
       }
      }
      return e();
     }
     registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
     }
     topicReferenceIsAllowedInCurrentContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
     }
     topicReferenceWasUsedInCurrentContext() {
      return null != this.state.topicContext.maxTopicIndex && this.state.topicContext.maxTopicIndex >= 0;
     }
     parseFSharpPipelineBody(e) {
      let t = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      let r = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !0;
      let s = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), t, e);
      return ((this.state.inFSharpPipelineDirectBody = r), s);
     }
     parseModuleExpression() {
      this.expectPlugin('moduleBlocks');
      let e = this.startNode();
      (this.next(), this.match(5) || this.unexpected(null, 5));
      let t = this.startNodeAt(this.state.endLoc);
      this.next();
      let r = this.initializeScopes(!0);
      this.enterInitialScopes();
      try {
       e.body = this.parseProgram(t, 8, 'module');
      } finally {
       r();
      }
      return this.finishNode(e, 'ModuleExpression');
     }
     parseVoidPattern(e) {
      this.expectPlugin('discardBinding');
      let t = this.startNode();
      return (null != e && (e.voidPatternLoc = this.state.startLoc), this.next(), this.finishNode(t, 'VoidPattern'));
     }
     parseMaybeAssignAllowInOrVoidPattern(e, t, r) {
      if (null != t && this.match(88)) {
       let r = this.lookaheadCharCode();
       if (44 === r || r === (3 === e ? 93 : 8 === e ? 125 : 41) || 61 === r) return this.parseMaybeDefault(this.state.startLoc, this.parseVoidPattern(t));
      }
      return this.parseMaybeAssignAllowIn(t, r);
     }
     parsePropertyNamePrefixOperator(e) {}
    },
    Rt = { kind: 1 },
    Ut = { kind: 2 },
    $t = /[\uD800-\uDFFF]/u,
    qt = /in(?:stanceof)?/y;
   var Jt = class extends _t {
     parseTopLevel(e, t) {
      return (
       (e.program = this.parseProgram(t, 140, 'module' === this.options.sourceType ? 'module' : 'script')),
       (e.comments = this.comments),
       256 & this.optionFlags &&
        (e.tokens = (function (e, t, r) {
         for (let s = 0; s < e.length; s++) {
          let t = e[s],
           { type: r } = t;
          'number' == typeof r && (t.type = se(r));
         }
         return e;
        })(this.tokens, this.input, this.startIndex)),
       this.finishNode(e, 'File')
      );
     }
     parseProgram(e, t, r) {
      if (((e.sourceType = r), (e.interpreter = this.parseInterpreterDirective()), this.parseBlockBody(e, !0, !0, t), this.inModule)) {
       if (!(64 & this.optionFlags) && this.scope.undefinedExports.size > 0) for (let [e, t] of Array.from(this.scope.undefinedExports)) this.raise(C.ModuleExportUndefined, t, { localName: e });
       this.addExtra(e, 'topLevelAwait', this.state.hasTopLevelAwait);
      }
      let s;
      return ((s = 140 === t ? this.finishNode(e, 'Program') : this.finishNodeAt(e, 'Program', p(this.state.startLoc, -1))), s);
     }
     stmtToDirective(e) {
      let t = this.castNodeTo(e, 'Directive'),
       r = this.castNodeTo(e.expression, 'DirectiveLiteral'),
       s = r.value,
       n = this.input.slice(this.offsetToSourcePos(r.start), this.offsetToSourcePos(r.end)),
       i = (r.value = n.slice(1, -1));
      return (this.addExtra(r, 'raw', n), this.addExtra(r, 'rawValue', i), this.addExtra(r, 'expressionValue', s), (t.value = r), delete e.expression, t);
     }
     parseInterpreterDirective() {
      if (!this.match(28)) return null;
      let e = this.startNode();
      return ((e.value = this.state.value), this.next(), this.finishNode(e, 'InterpreterDirective'));
     }
     isLet() {
      return !!this.isContextual(100) && this.hasFollowingBindingAtom();
     }
     isUsing() {
      return !!this.isContextual(107) && this.nextTokenIsIdentifierOnSameLine();
     }
     isForUsing() {
      if (!this.isContextual(107)) return !1;
      let e = this.nextTokenInLineStart(),
       t = this.codePointAtPos(e);
      if (this.isUnparsedContextual(e, 'of')) {
       let t = this.lookaheadCharCodeSince(e + 2);
       if (61 !== t && 58 !== t && 59 !== t) return !1;
      }
      return !(!this.chStartsBindingIdentifier(t, e) && !this.isUnparsedContextual(e, 'void'));
     }
     nextTokenIsIdentifierOnSameLine() {
      let e = this.nextTokenInLineStart(),
       t = this.codePointAtPos(e);
      return this.chStartsBindingIdentifier(t, e);
     }
     isAwaitUsing() {
      if (!this.isContextual(96)) return !1;
      let e = this.nextTokenInLineStart();
      if (this.isUnparsedContextual(e, 'using')) {
       e = this.nextTokenInLineStartSince(e + 5);
       let t = this.codePointAtPos(e);
       if (this.chStartsBindingIdentifier(t, e)) return !0;
      }
      return !1;
     }
     chStartsBindingIdentifier(e, t) {
      if (ce(e)) {
       if (((qt.lastIndex = t), qt.test(this.input))) {
        let e = this.codePointAtPos(qt.lastIndex);
        if (!he(e) && 92 !== e) return !1;
       }
       return !0;
      }
      return 92 === e;
     }
     chStartsBindingPattern(e) {
      return 91 === e || 123 === e;
     }
     hasFollowingBindingAtom() {
      let e = this.nextTokenStart(),
       t = this.codePointAtPos(e);
      return this.chStartsBindingPattern(t) || this.chStartsBindingIdentifier(t, e);
     }
     hasInLineFollowingBindingIdentifierOrBrace() {
      let e = this.nextTokenInLineStart(),
       t = this.codePointAtPos(e);
      return 123 === t || this.chStartsBindingIdentifier(t, e);
     }
     allowsUsing() {
      return (this.scope.inModule || !this.scope.inTopLevel) && !this.scope.inBareCaseStatement;
     }
     parseModuleItem() {
      return this.parseStatementLike(15);
     }
     parseStatementListItem() {
      return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
     }
     parseStatementOrSloppyAnnexBFunctionDeclaration(e = !1) {
      let t = 0;
      return (this.options.annexB && !this.state.strict && ((t |= 4), e && (t |= 8)), this.parseStatementLike(t));
     }
     parseStatement() {
      return this.parseStatementLike(0);
     }
     parseStatementLike(e) {
      let t = null;
      return (this.match(26) && (t = this.parseDecorators(!0)), this.parseStatementContent(e, t));
     }
     parseStatementContent(e, t) {
      let r = this.state.type,
       s = this.startNode(),
       n = !!(2 & e),
       i = !!(4 & e),
       a = 1 & e;
      switch (r) {
       case 60:
        return this.parseBreakContinueStatement(s, !0);
       case 63:
        return this.parseBreakContinueStatement(s, !1);
       case 64:
        return this.parseDebuggerStatement(s);
       case 90:
        return this.parseDoWhileStatement(s);
       case 91:
        return this.parseForStatement(s);
       case 68:
        if (46 === this.lookaheadCharCode()) break;
        return (i || this.raise(this.state.strict ? C.StrictFunction : this.options.annexB ? C.SloppyFunctionAnnexB : C.SloppyFunction, this.state.startLoc), this.parseFunctionStatement(s, !1, !n && i));
       case 80:
        return (n || this.unexpected(), this.parseClass(this.maybeTakeDecorators(t, s), !0));
       case 69:
        return this.parseIfStatement(s);
       case 70:
        return this.parseReturnStatement(s);
       case 71:
        return this.parseSwitchStatement(s);
       case 72:
        return this.parseThrowStatement(s);
       case 73:
        return this.parseTryStatement(s);
       case 96:
        if (this.isAwaitUsing()) return (this.allowsUsing() ? (n ? this.recordAwaitIfAllowed() || this.raise(C.AwaitUsingNotInAsyncContext, s) : this.raise(C.UnexpectedLexicalDeclaration, s)) : this.raise(C.UnexpectedUsingDeclaration, s), this.next(), this.parseVarStatement(s, 'await using'));
        break;
       case 107:
        if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifierOrBrace()) break;
        return (this.allowsUsing() ? n || this.raise(C.UnexpectedLexicalDeclaration, this.state.startLoc) : this.raise(C.UnexpectedUsingDeclaration, this.state.startLoc), this.parseVarStatement(s, 'using'));
       case 100: {
        if (this.state.containsEsc) break;
        let e = this.nextTokenStart(),
         t = this.codePointAtPos(e);
        if (91 !== t && ((!n && this.hasFollowingLineBreak()) || (!this.chStartsBindingIdentifier(t, e) && 123 !== t))) break;
       }
       case 75:
        n || this.raise(C.UnexpectedLexicalDeclaration, this.state.startLoc);
       case 74: {
        let e = this.state.value;
        return this.parseVarStatement(s, e);
       }
       case 92:
        return this.parseWhileStatement(s);
       case 76:
        return this.parseWithStatement(s);
       case 5:
        return this.parseBlock();
       case 13:
        return this.parseEmptyStatement(s);
       case 83: {
        let e = this.lookaheadCharCode();
        if (40 === e || 46 === e) break;
       }
       case 82: {
        let e;
        return (!(8 & this.optionFlags) && !a && this.raise(C.UnexpectedImportExport, this.state.startLoc), this.next(), (e = 83 === r ? this.parseImport(s) : this.parseExport(s, t)), this.assertModuleNodeAllowed(e), e);
       }
       default:
        if (this.isAsyncFunction()) return (n || this.raise(C.AsyncFunctionInSingleStatementContext, this.state.startLoc), this.next(), this.parseFunctionStatement(s, !0, !n && i));
      }
      let o = this.state.value,
       u = this.parseExpression();
      return X(r) && 'Identifier' === u.type && this.eat(14) ? this.parseLabeledStatement(s, o, u, e) : this.parseExpressionStatement(s, u, t);
     }
     assertModuleNodeAllowed(e) {
      !(8 & this.optionFlags) && !this.inModule && this.raise(C.ImportOutsideModule, e);
     }
     decoratorsEnabledBeforeExport() {
      return !!this.hasPlugin('decorators-legacy') || (this.hasPlugin('decorators') && !1 !== this.getPluginOption('decorators', 'decoratorsBeforeExport'));
     }
     maybeTakeDecorators(e, t, r) {
      return (e && (t.decorators?.length ? ('boolean' != typeof this.getPluginOption('decorators', 'decoratorsBeforeExport') && this.raise(C.DecoratorsBeforeAfterExport, t.decorators[0]), t.decorators.unshift(...e)) : (t.decorators = e), this.resetStartLocationFromNode(t, e[0]), r && this.resetStartLocationFromNode(r, t)), t);
     }
     canHaveLeadingDecorator() {
      return this.match(80);
     }
     parseDecorators(e) {
      let t = [];
      do {
       t.push(this.parseDecorator());
      } while (this.match(26));
      if (this.match(82)) (e || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(C.DecoratorExportClass, this.state.startLoc));
      else if (!this.canHaveLeadingDecorator()) throw this.raise(C.UnexpectedLeadingDecorator, this.state.startLoc);
      return t;
     }
     parseDecorator() {
      this.expectOnePlugin(['decorators', 'decorators-legacy']);
      let e = this.startNode();
      if ((this.next(), this.hasPlugin('decorators'))) {
       let t,
        r = this.state.startLoc;
       if (this.match(10)) {
        let r = this.state.startLoc;
        (this.next(), (t = this.parseExpression()), this.expect(11), (t = this.wrapParenthesis(r, t)));
        let s = this.state.startLoc;
        ((e.expression = this.parseMaybeDecoratorArguments(t, r)), !1 === this.getPluginOption('decorators', 'allowCallParenthesized') && e.expression !== t && this.raise(C.DecoratorArgumentsOutsideParentheses, s));
       } else {
        for (t = this.parseIdentifier(!1); this.eat(16); ) {
         let e = this.startNodeAt(r);
         ((e.object = t), this.match(139) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), (e.property = this.parsePrivateName())) : (e.property = this.parseIdentifier(!0)), (e.computed = !1), (t = this.finishNode(e, 'MemberExpression')));
        }
        e.expression = this.parseMaybeDecoratorArguments(t, r);
       }
      } else e.expression = this.parseExprSubscripts();
      return this.finishNode(e, 'Decorator');
     }
     parseMaybeDecoratorArguments(e, t) {
      if (this.eat(10)) {
       let r = this.startNodeAt(t);
       return ((r.callee = e), (r.arguments = this.parseCallExpressionArguments()), this.toReferencedList(r.arguments), this.finishNode(r, 'CallExpression'));
      }
      return e;
     }
     parseBreakContinueStatement(e, t) {
      return (this.next(), this.isLineTerminator() ? (e.label = null) : ((e.label = this.parseIdentifier()), this.semicolon()), this.verifyBreakContinue(e, t), this.finishNode(e, t ? 'BreakStatement' : 'ContinueStatement'));
     }
     verifyBreakContinue(e, t) {
      let r;
      for (r = 0; r < this.state.labels.length; ++r) {
       let s = this.state.labels[r];
       if ((null == e.label || s.name === e.label.name) && ((null != s.kind && (t || 1 === s.kind)) || (e.label && t))) break;
      }
      if (r === this.state.labels.length) {
       let r = t ? 'BreakStatement' : 'ContinueStatement';
       this.raise(C.IllegalBreakContinue, e, { type: r });
      }
     }
     parseDebuggerStatement(e) {
      return (this.next(), this.semicolon(), this.finishNode(e, 'DebuggerStatement'));
     }
     parseHeaderExpression() {
      this.expect(10);
      let e = this.parseExpression();
      return (this.expect(11), e);
     }
     parseDoWhileStatement(e) {
      return (this.next(), this.state.labels.push(Rt), (e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement())), this.state.labels.pop(), this.expect(92), (e.test = this.parseHeaderExpression()), this.eat(13), this.finishNode(e, 'DoWhileStatement'));
     }
     parseForStatement(e) {
      (this.next(), this.state.labels.push(Rt));
      let t = null;
      if ((this.isContextual(96) && this.recordAwaitIfAllowed() && ((t = this.state.startLoc), this.next()), this.scope.enter(0), this.expect(10), this.match(13))) return (null !== t && this.unexpected(t), this.parseFor(e, null));
      let r = this.isContextual(100);
      {
       let s = this.isAwaitUsing(),
        n = s || this.isForUsing(),
        i = (r && this.hasFollowingBindingAtom()) || n;
       if (this.match(74) || this.match(75) || i) {
        let r,
         i = this.startNode();
        (s ? ((r = 'await using'), this.recordAwaitIfAllowed() || this.raise(C.AwaitUsingNotInAsyncContext, this.state.startLoc), this.next()) : (r = this.state.value), this.next(), this.parseVar(i, !0, r));
        let a = this.finishNode(i, 'VariableDeclaration'),
         o = this.match(58);
        return (o && n && this.raise(C.ForInUsing, a), (o || this.isContextual(102)) && 1 === a.declarations.length ? this.parseForIn(e, a, t) : (null !== t && this.unexpected(t), this.parseFor(e, a)));
       }
      }
      let s = this.isContextual(95),
       n = new Dt(),
       i = this.parseExpression(!0, n),
       a = this.isContextual(102);
      if ((a && (r && this.raise(C.ForOfLet, i), null === t && s && 'Identifier' === i.type && this.raise(C.ForOfAsync, i)), a || this.match(58))) {
       (this.checkDestructuringPrivate(n), this.toAssignable(i, !0));
       let r = a ? 'ForOfStatement' : 'ForInStatement';
       return (this.checkLVal(i, { type: r }), this.parseForIn(e, i, t));
      }
      return (this.checkExpressionErrors(n, !0), null !== t && this.unexpected(t), this.parseFor(e, i));
     }
     parseFunctionStatement(e, t, r) {
      return (this.next(), this.parseFunction(e, 1 | (r ? 2 : 0) | (t ? 8 : 0)));
     }
     parseIfStatement(e) {
      return (this.next(), (e.test = this.parseHeaderExpression()), (e.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration()), (e.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null), this.finishNode(e, 'IfStatement'));
     }
     parseReturnStatement(e) {
      return (this.prodParam.hasReturn || this.raise(C.IllegalReturn, this.state.startLoc), this.next(), this.isLineTerminator() ? (e.argument = null) : ((e.argument = this.parseExpression()), this.semicolon()), this.finishNode(e, 'ReturnStatement'));
     }
     parseSwitchStatement(e) {
      (this.next(), (e.discriminant = this.parseHeaderExpression()));
      let t,
       r = (e.cases = []);
      (this.expect(5), this.state.labels.push(Ut), this.scope.enter(256));
      for (let s; !this.match(8); )
       if (this.match(61) || this.match(65)) {
        let e = this.match(61);
        (t && this.finishNode(t, 'SwitchCase'), r.push((t = this.startNode())), (t.consequent = []), this.next(), e ? (t.test = this.parseExpression()) : (s && this.raise(C.MultipleDefaultsInSwitch, this.state.lastTokStartLoc), (s = !0), (t.test = null)), this.expect(14));
       } else t ? t.consequent.push(this.parseStatementListItem()) : this.unexpected();
      return (this.scope.exit(), t && this.finishNode(t, 'SwitchCase'), this.next(), this.state.labels.pop(), this.finishNode(e, 'SwitchStatement'));
     }
     parseThrowStatement(e) {
      return (this.next(), this.hasPrecedingLineBreak() && this.raise(C.NewlineAfterThrow, this.state.lastTokEndLoc), (e.argument = this.parseExpression()), this.semicolon(), this.finishNode(e, 'ThrowStatement'));
     }
     parseCatchClauseParam() {
      let e = this.parseBindingAtom();
      return (this.scope.enter(this.options.annexB && 'Identifier' === e.type ? 8 : 0), this.checkLVal(e, { type: 'CatchClause' }, 9), e);
     }
     parseTryStatement(e) {
      if ((this.next(), (e.block = this.parseBlock()), (e.handler = null), this.match(62))) {
       let t = this.startNode();
       (this.next(), this.match(10) ? (this.expect(10), (t.param = this.parseCatchClauseParam()), this.expect(11)) : ((t.param = null), this.scope.enter(0)), (t.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(!1, !1))), this.scope.exit(), (e.handler = this.finishNode(t, 'CatchClause')));
      }
      return ((e.finalizer = this.eat(67) ? this.parseBlock() : null), !e.handler && !e.finalizer && this.raise(C.NoCatchOrFinally, e), this.finishNode(e, 'TryStatement'));
     }
     parseVarStatement(e, t, r = !1) {
      return (this.next(), this.parseVar(e, !1, t, r), this.semicolon(), this.finishNode(e, 'VariableDeclaration'));
     }
     parseWhileStatement(e) {
      return (this.next(), (e.test = this.parseHeaderExpression()), this.state.labels.push(Rt), (e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement())), this.state.labels.pop(), this.finishNode(e, 'WhileStatement'));
     }
     parseWithStatement(e) {
      return (this.state.strict && this.raise(C.StrictWith, this.state.startLoc), this.next(), (e.object = this.parseHeaderExpression()), (e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement())), this.finishNode(e, 'WithStatement'));
     }
     parseEmptyStatement(e) {
      return (this.next(), this.finishNode(e, 'EmptyStatement'));
     }
     parseLabeledStatement(e, t, r, s) {
      for (let a of this.state.labels) a.name === t && this.raise(C.LabelRedeclaration, r, { labelName: t });
      let n = (i = this.state.type) >= 90 && i <= 92 ? 1 : this.match(71) ? 2 : null;
      var i;
      for (let a = this.state.labels.length - 1; a >= 0; a--) {
       let t = this.state.labels[a];
       if (t.statementStart !== e.start) break;
       ((t.statementStart = this.sourceToOffsetPos(this.state.start)), (t.kind = n));
      }
      return (this.state.labels.push({ name: t, kind: n, statementStart: this.sourceToOffsetPos(this.state.start) }), (e.body = 8 & s ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(!0) : this.parseStatement()), this.state.labels.pop(), (e.label = r), this.finishNode(e, 'LabeledStatement'));
     }
     parseExpressionStatement(e, t, r) {
      return ((e.expression = t), this.semicolon(), this.finishNode(e, 'ExpressionStatement'));
     }
     parseBlock(e = !1, t = !0, r) {
      let s = this.startNode();
      return (e && this.state.strictErrors.clear(), this.expect(5), t && this.scope.enter(0), this.parseBlockBody(s, e, !1, 8, r), t && this.scope.exit(), this.finishNode(s, 'BlockStatement'));
     }
     isValidDirective(e) {
      return 'ExpressionStatement' === e.type && 'StringLiteral' === e.expression.type && !e.expression.extra.parenthesized;
     }
     parseBlockBody(e, t, r, s, n) {
      let i = (e.body = []),
       a = (e.directives = []);
      this.parseBlockOrModuleBlockBody(i, t ? a : void 0, r, s, n);
     }
     parseBlockOrModuleBlockBody(e, t, r, s, n) {
      let i = this.state.strict,
       a = !1,
       o = !1;
      for (; !this.match(s); ) {
       let s = r ? this.parseModuleItem() : this.parseStatementListItem();
       if (t && !o) {
        if (this.isValidDirective(s)) {
         let e = this.stmtToDirective(s);
         (t.push(e), !a && 'use strict' === e.value.value && ((a = !0), this.setStrict(!0)));
         continue;
        }
        ((o = !0), this.state.strictErrors.clear());
       }
       e.push(s);
      }
      (n?.call(this, a), i || this.setStrict(!1), this.next());
     }
     parseFor(e, t) {
      return ((e.init = t), this.semicolon(!1), (e.test = this.match(13) ? null : this.parseExpression()), this.semicolon(!1), (e.update = this.match(11) ? null : this.parseExpression()), this.expect(11), (e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement())), this.scope.exit(), this.state.labels.pop(), this.finishNode(e, 'ForStatement'));
     }
     parseForIn(e, t, r) {
      let s = this.match(58);
      return (this.next(), s ? null !== r && this.unexpected(r) : (e.await = null !== r), 'VariableDeclaration' === t.type && null != t.declarations[0].init && (!s || !this.options.annexB || this.state.strict || 'var' !== t.kind || 'Identifier' !== t.declarations[0].id.type) && this.raise(C.ForInOfLoopInitializer, t, { type: s ? 'ForInStatement' : 'ForOfStatement' }), 'AssignmentPattern' === t.type && this.raise(C.InvalidLhs, t, { ancestor: { type: 'ForStatement' } }), (e.left = t), (e.right = s ? this.parseExpression() : this.parseMaybeAssignAllowIn()), this.expect(11), (e.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement())), this.scope.exit(), this.state.labels.pop(), this.finishNode(e, s ? 'ForInStatement' : 'ForOfStatement'));
     }
     parseVar(e, t, r, s = !1) {
      let n = (e.declarations = []);
      for (e.kind = r; ; ) {
       let e = this.startNode();
       if ((this.parseVarId(e, r), (e.init = this.eat(29) ? (t ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn()) : null), null === e.init && !s && ('Identifier' === e.id.type || (t && (this.match(58) || this.isContextual(102))) ? ('const' === r || 'using' === r || 'await using' === r) && !(this.match(58) || this.isContextual(102)) && this.raise(C.DeclarationMissingInitializer, this.state.lastTokEndLoc, { kind: r }) : this.raise(C.DeclarationMissingInitializer, this.state.lastTokEndLoc, { kind: 'destructuring' })), n.push(this.finishNode(e, 'VariableDeclarator')), !this.eat(12))) break;
      }
      return e;
     }
     parseVarId(e, t) {
      let r = this.parseBindingAtom();
      ('using' === t || 'await using' === t ? ('ArrayPattern' === r.type || 'ObjectPattern' === r.type) && this.raise(C.UsingDeclarationHasBindingPattern, r.loc.start) : 'VoidPattern' === r.type && this.raise(C.UnexpectedVoidPattern, r.loc.start), this.checkLVal(r, { type: 'VariableDeclarator' }, 'var' === t ? 5 : 8201), (e.id = r));
     }
     parseAsyncFunctionExpression(e) {
      return this.parseFunction(e, 8);
     }
     parseFunction(e, t = 0) {
      let r = 2 & t,
       s = !!(1 & t),
       n = s && !(4 & t),
       i = !!(8 & t);
      (this.initFunction(e, i), this.match(55) && (r && this.raise(C.GeneratorInSingleStatementContext, this.state.startLoc), this.next(), (e.generator = !0)), s && (e.id = this.parseFunctionId(n)));
      let a = this.state.maybeInArrowParameters;
      return (
       (this.state.maybeInArrowParameters = !1),
       this.scope.enter(514),
       this.prodParam.enter(We(i, e.generator)),
       s || (e.id = this.parseFunctionId()),
       this.parseFunctionParams(e, !1),
       this.withSmartMixTopicForbiddingContext(() => {
        this.parseFunctionBodyAndFinish(e, s ? 'FunctionDeclaration' : 'FunctionExpression');
       }),
       this.prodParam.exit(),
       this.scope.exit(),
       s && !r && this.registerFunctionStatementId(e),
       (this.state.maybeInArrowParameters = a),
       e
      );
     }
     parseFunctionId(e) {
      return e || X(this.state.type) ? this.parseIdentifier() : null;
     }
     parseFunctionParams(e, t) {
      (this.expect(10), this.expressionScope.enter(new ht(3)), (e.params = this.parseBindingList(11, 41, 2 | (t ? 4 : 0))), this.expressionScope.exit());
     }
     registerFunctionStatementId(e) {
      e.id && this.scope.declareName(e.id.name, !this.options.annexB || this.state.strict || e.generator || e.async ? (this.scope.treatFunctionsAsVar ? 5 : 8201) : 17, e.id.loc.start);
     }
     parseClass(e, t, r) {
      this.next();
      let s = this.state.strict;
      return ((this.state.strict = !0), this.parseClassId(e, t, r), this.parseClassSuper(e), (e.body = this.parseClassBody(!!e.superClass, s)), this.finishNode(e, t ? 'ClassDeclaration' : 'ClassExpression'));
     }
     isClassProperty() {
      return this.match(29) || this.match(13) || this.match(8);
     }
     isClassMethod() {
      return this.match(10);
     }
     nameIsConstructor(e) {
      return ('Identifier' === e.type && 'constructor' === e.name) || ('StringLiteral' === e.type && 'constructor' === e.value);
     }
     isNonstaticConstructor(e) {
      return !e.computed && !e.static && this.nameIsConstructor(e.key);
     }
     parseClassBody(e, t) {
      this.classScope.enter();
      let r = { hadConstructor: !1, hadSuperClass: e },
       s = [],
       n = this.startNode();
      if (
       ((n.body = []),
       this.expect(5),
       this.withSmartMixTopicForbiddingContext(() => {
        for (; !this.match(8); ) {
         if (this.eat(13)) {
          if (s.length > 0) throw this.raise(C.DecoratorSemicolon, this.state.lastTokEndLoc);
          continue;
         }
         if (this.match(26)) {
          s.push(this.parseDecorator());
          continue;
         }
         let e = this.startNode();
         (s.length && ((e.decorators = s), this.resetStartLocationFromNode(e, s[0]), (s = [])), this.parseClassMember(n, e, r), 'constructor' === e.kind && e.decorators && e.decorators.length > 0 && this.raise(C.DecoratorConstructor, e));
        }
       }),
       (this.state.strict = t),
       this.next(),
       s.length)
      )
       throw this.raise(C.TrailingDecorator, this.state.startLoc);
      return (this.classScope.exit(), this.finishNode(n, 'ClassBody'));
     }
     parseClassMemberFromModifier(e, t) {
      let r = this.parseIdentifier(!0);
      if (this.isClassMethod()) {
       let s = t;
       return ((s.kind = 'method'), (s.computed = !1), (s.key = r), (s.static = !1), this.pushClassMethod(e, s, !1, !1, !1, !1), !0);
      }
      if (this.isClassProperty()) {
       let s = t;
       return ((s.computed = !1), (s.key = r), (s.static = !1), e.body.push(this.parseClassProperty(s)), !0);
      }
      return (this.resetPreviousNodeTrailingComments(r), !1);
     }
     parseClassMember(e, t, r) {
      let s = this.isContextual(106);
      if (s) {
       if (this.parseClassMemberFromModifier(e, t)) return;
       if (this.eat(5)) return void this.parseClassStaticBlock(e, t);
      }
      this.parseClassMemberWithIsStatic(e, t, r, s);
     }
     parseClassMemberWithIsStatic(e, t, r, s) {
      let n = t,
       i = t,
       a = t,
       o = t,
       u = t,
       l = n,
       p = n;
      if (((t.static = s), this.parsePropertyNamePrefixOperator(t), this.eat(55))) {
       l.kind = 'method';
       let t = this.match(139);
       return (this.parseClassElementName(l), this.parsePostMemberNameModifiers(l), t ? void this.pushClassPrivateMethod(e, i, !0, !1) : (this.isNonstaticConstructor(n) && this.raise(C.ConstructorIsGenerator, n.key), void this.pushClassMethod(e, n, !0, !1, !1, !1)));
      }
      let c = !this.state.containsEsc && X(this.state.type),
       h = this.parseClassElementName(t),
       d = c ? h.name : null,
       f = this.isPrivateName(h),
       m = this.state.startLoc;
      if ((this.parsePostMemberNameModifiers(p), this.isClassMethod())) {
       if (((l.kind = 'method'), f)) return void this.pushClassPrivateMethod(e, i, !1, !1);
       let s = this.isNonstaticConstructor(n),
        a = !1;
       (s && ((n.kind = 'constructor'), r.hadConstructor && !this.hasPlugin('typescript') && this.raise(C.DuplicateConstructor, h), s && this.hasPlugin('typescript') && t.override && this.raise(C.OverrideOnConstructor, h), (r.hadConstructor = !0), (a = r.hadSuperClass)), this.pushClassMethod(e, n, !1, !1, s, a));
      } else if (this.isClassProperty()) f ? this.pushClassPrivateProperty(e, o) : this.pushClassProperty(e, a);
      else if ('async' !== d || this.isLineTerminator())
       if (('get' !== d && 'set' !== d) || (this.match(55) && this.isLineTerminator()))
        if ('accessor' !== d || this.isLineTerminator()) this.isLineTerminator() ? (f ? this.pushClassPrivateProperty(e, o) : this.pushClassProperty(e, a)) : this.unexpected();
        else {
         (this.expectPlugin('decoratorAutoAccessors'), this.resetPreviousNodeTrailingComments(h));
         let t = this.match(139);
         (this.parseClassElementName(a), this.pushClassAccessorProperty(e, u, t));
        }
       else {
        (this.resetPreviousNodeTrailingComments(h), (l.kind = d));
        let t = this.match(139);
        (this.parseClassElementName(n), t ? this.pushClassPrivateMethod(e, i, !1, !1) : (this.isNonstaticConstructor(n) && this.raise(C.ConstructorIsAccessor, n.key), this.pushClassMethod(e, n, !1, !1, !1, !1)), this.checkGetterSetterParams(n));
       }
      else {
       this.resetPreviousNodeTrailingComments(h);
       let t = this.eat(55);
       (p.optional && this.unexpected(m), (l.kind = 'method'));
       let r = this.match(139);
       (this.parseClassElementName(l), this.parsePostMemberNameModifiers(p), r ? this.pushClassPrivateMethod(e, i, t, !0) : (this.isNonstaticConstructor(n) && this.raise(C.ConstructorIsAsync, n.key), this.pushClassMethod(e, n, t, !0, !1, !1)));
      }
     }
     parseClassElementName(e) {
      let { type: t, value: r } = this.state;
      if (((132 === t || 134 === t) && e.static && 'prototype' === r && this.raise(C.StaticPrototype, this.state.startLoc), 139 === t)) {
       'constructor' === r && this.raise(C.ConstructorClassPrivateField, this.state.startLoc);
       let t = this.parsePrivateName();
       return ((e.key = t), t);
      }
      return (this.parsePropertyName(e), e.key);
     }
     parseClassStaticBlock(e, t) {
      this.scope.enter(720);
      let r = this.state.labels;
      ((this.state.labels = []), this.prodParam.enter(0));
      let s = (t.body = []);
      (this.parseBlockOrModuleBlockBody(s, void 0, !1, 8), this.prodParam.exit(), this.scope.exit(), (this.state.labels = r), e.body.push(this.finishNode(t, 'StaticBlock')), t.decorators?.length && this.raise(C.DecoratorStaticBlock, t));
     }
     pushClassProperty(e, t) {
      (!t.computed && this.nameIsConstructor(t.key) && this.raise(C.ConstructorClassField, t.key), e.body.push(this.parseClassProperty(t)));
     }
     pushClassPrivateProperty(e, t) {
      let r = this.parseClassPrivateProperty(t);
      (e.body.push(r), this.classScope.declarePrivateName(this.getPrivateNameSV(r.key), 0, r.key.loc.start));
     }
     pushClassAccessorProperty(e, t, r) {
      !r && !t.computed && this.nameIsConstructor(t.key) && this.raise(C.ConstructorClassField, t.key);
      let s = this.parseClassAccessorProperty(t);
      (e.body.push(s), r && this.classScope.declarePrivateName(this.getPrivateNameSV(s.key), 0, s.key.loc.start));
     }
     pushClassMethod(e, t, r, s, n, i) {
      e.body.push(this.parseMethod(t, r, s, n, i, 'ClassMethod', !0));
     }
     pushClassPrivateMethod(e, t, r, s) {
      let n = this.parseMethod(t, r, s, !1, !1, 'ClassPrivateMethod', !0);
      e.body.push(n);
      let i = 'get' === n.kind ? (n.static ? 6 : 2) : 'set' === n.kind ? (n.static ? 5 : 1) : 0;
      this.declareClassPrivateMethodInScope(n, i);
     }
     declareClassPrivateMethodInScope(e, t) {
      this.classScope.declarePrivateName(this.getPrivateNameSV(e.key), t, e.key.loc.start);
     }
     parsePostMemberNameModifiers(e) {}
     parseClassPrivateProperty(e) {
      return (this.parseInitializer(e), this.semicolon(), this.finishNode(e, 'ClassPrivateProperty'));
     }
     parseClassProperty(e) {
      return (this.parseInitializer(e), this.semicolon(), this.finishNode(e, 'ClassProperty'));
     }
     parseClassAccessorProperty(e) {
      return (this.parseInitializer(e), this.semicolon(), this.finishNode(e, 'ClassAccessorProperty'));
     }
     parseInitializer(e) {
      (this.scope.enter(592), this.expressionScope.enter(mt()), this.prodParam.enter(0), (e.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null), this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit());
     }
     parseClassId(e, t, r, s = 8331) {
      if (X(this.state.type)) ((e.id = this.parseIdentifier()), t && this.declareNameFromIdentifier(e.id, s));
      else {
       if (!r && t) throw this.raise(C.MissingClassName, this.state.startLoc);
       e.id = null;
      }
     }
     parseClassSuper(e) {
      e.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
     }
     parseExport(e, t) {
      let r = this.parseMaybeImportPhase(e, !0),
       s = this.maybeParseExportDefaultSpecifier(e, r),
       n = !s || this.eat(12),
       i = n && this.eatExportStar(e),
       a = i && this.maybeParseExportNamespaceSpecifier(e),
       o = n && (!a || this.eat(12)),
       u = s || i;
      if (i && !a) {
       if ((s && this.unexpected(), t)) throw this.raise(C.UnsupportedDecoratorExport, e);
       return (this.parseExportFrom(e, !0), (this.sawUnambiguousESM = !0), this.finishNode(e, 'ExportAllDeclaration'));
      }
      let l,
       p = this.maybeParseExportNamedSpecifiers(e);
      if ((s && n && !i && !p && this.unexpected(null, 5), a && o && this.unexpected(null, 98), u || p)) {
       if (((l = !1), t)) throw this.raise(C.UnsupportedDecoratorExport, e);
       this.parseExportFrom(e, u);
      } else l = this.maybeParseExportDeclaration(e);
      if (u || p || l) {
       let r = e;
       if ((this.checkExport(r, !0, !1, !!r.source), 'ClassDeclaration' === r.declaration?.type)) this.maybeTakeDecorators(t, r.declaration, r);
       else if (t) throw this.raise(C.UnsupportedDecoratorExport, e);
       return ((this.sawUnambiguousESM = !0), this.finishNode(r, 'ExportNamedDeclaration'));
      }
      if (this.eat(65)) {
       let r = e,
        s = this.parseExportDefaultExpression();
       if (((r.declaration = s), 'ClassDeclaration' === s.type)) this.maybeTakeDecorators(t, s, r);
       else if (t) throw this.raise(C.UnsupportedDecoratorExport, e);
       return (this.checkExport(r, !0, !0), (this.sawUnambiguousESM = !0), this.finishNode(r, 'ExportDefaultDeclaration'));
      }
      throw this.unexpected(null, 5);
     }
     eatExportStar(e) {
      return this.eat(55);
     }
     maybeParseExportDefaultSpecifier(e, t) {
      if (t || this.isExportDefaultSpecifier()) {
       this.expectPlugin('exportDefaultFrom', t?.loc.start);
       let r = t || this.parseIdentifier(!0),
        s = this.startNodeAtNode(r);
       return ((s.exported = r), (e.specifiers = [this.finishNode(s, 'ExportDefaultSpecifier')]), !0);
      }
      return !1;
     }
     maybeParseExportNamespaceSpecifier(e) {
      if (this.isContextual(93)) {
       e.specifiers ?? (e.specifiers = []);
       let t = this.startNodeAt(this.state.lastTokStartLoc);
       return (this.next(), (t.exported = this.parseModuleExportName()), e.specifiers.push(this.finishNode(t, 'ExportNamespaceSpecifier')), !0);
      }
      return !1;
     }
     maybeParseExportNamedSpecifiers(e) {
      if (this.match(5)) {
       let t = e;
       t.specifiers || (t.specifiers = []);
       let r = 'type' === t.exportKind;
       return (t.specifiers.push(...this.parseExportSpecifiers(r)), (t.source = null), (t.attributes = []), (t.declaration = null), !0);
      }
      return !1;
     }
     maybeParseExportDeclaration(e) {
      return !!this.shouldParseExportDeclaration() && ((e.specifiers = []), (e.source = null), (e.attributes = []), (e.declaration = this.parseExportDeclaration(e)), !0);
     }
     isAsyncFunction() {
      if (!this.isContextual(95)) return !1;
      let e = this.nextTokenInLineStart();
      return this.isUnparsedContextual(e, 'function');
     }
     parseExportDefaultExpression() {
      let e = this.startNode();
      if (this.match(68)) return (this.next(), this.parseFunction(e, 5));
      if (this.isAsyncFunction()) return (this.next(), this.next(), this.parseFunction(e, 13));
      if (this.match(80)) return this.parseClass(e, !0, !0);
      if (this.match(26)) return (this.hasPlugin('decorators') && !0 === this.getPluginOption('decorators', 'decoratorsBeforeExport') && this.raise(C.DecoratorBeforeExport, this.state.startLoc), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(!1), this.startNode()), !0, !0));
      if (this.match(75) || this.match(74) || this.isLet() || this.isUsing() || this.isAwaitUsing()) throw this.raise(C.UnsupportedDefaultExport, this.state.startLoc);
      let t = this.parseMaybeAssignAllowIn();
      return (this.semicolon(), t);
     }
     parseExportDeclaration(e) {
      return this.match(80) ? this.parseClass(this.startNode(), !0, !1) : this.parseStatementListItem();
     }
     isExportDefaultSpecifier() {
      let { type: e } = this.state;
      if (X(e)) {
       if ((95 === e && !this.state.containsEsc) || 100 === e) return !1;
       if ((130 === e || 129 === e) && !this.state.containsEsc) {
        let e = this.nextTokenStart(),
         t = this.input.charCodeAt(e);
        if (123 === t || (this.chStartsBindingIdentifier(t, e) && !this.input.startsWith('from', e))) return (this.expectOnePlugin(['flow', 'typescript']), !1);
       }
      } else if (!this.match(65)) return !1;
      let t = this.nextTokenStart(),
       r = this.isUnparsedContextual(t, 'from');
      if (44 === this.input.charCodeAt(t) || (X(this.state.type) && r)) return !0;
      if (this.match(65) && r) {
       let e = this.input.charCodeAt(this.nextTokenStartSince(t + 4));
       return 34 === e || 39 === e;
      }
      return !1;
     }
     parseExportFrom(e, t) {
      (this.eatContextual(98) ? ((e.source = this.parseImportSource()), this.checkExport(e), this.maybeParseImportAttributes(e), this.checkJSONModuleImport(e)) : t && this.unexpected(), this.semicolon());
     }
     shouldParseExportDeclaration() {
      let { type: e } = this.state;
      return 26 === e && (this.expectOnePlugin(['decorators', 'decorators-legacy']), this.hasPlugin('decorators')) ? (!0 === this.getPluginOption('decorators', 'decoratorsBeforeExport') && this.raise(C.DecoratorBeforeExport, this.state.startLoc), !0) : this.isUsing() || this.isAwaitUsing() ? (this.raise(C.UsingDeclarationExport, this.state.startLoc), !0) : 74 === e || 75 === e || 68 === e || 80 === e || this.isLet() || this.isAsyncFunction();
     }
     checkExport(e, t, r, s) {
      if (t)
       if (r) {
        if ((this.checkDuplicateExports(e, 'default'), this.hasPlugin('exportDefaultFrom'))) {
         let t = e.declaration;
         'Identifier' === t.type && 'from' === t.name && t.end - t.start == 4 && !t.extra?.parenthesized && this.raise(C.ExportDefaultFromAsIdentifier, t);
        }
       } else if (e.specifiers?.length)
        for (let n of e.specifiers) {
         let { exported: e } = n,
          t = 'Identifier' === e.type ? e.name : e.value;
         if ((this.checkDuplicateExports(n, t), !s && n.local)) {
          let { local: e } = n;
          'Identifier' !== e.type ? this.raise(C.ExportBindingIsString, n, { localName: e.value, exportName: t }) : (this.checkReservedWord(e.name, e.loc.start, !0, !1), this.scope.checkLocalExport(e));
         }
        }
       else if (e.declaration) {
        let t = e.declaration;
        if ('FunctionDeclaration' === t.type || 'ClassDeclaration' === t.type) {
         let { id: r } = t;
         if (!r) throw new Error('Assertion failure');
         this.checkDuplicateExports(e, r.name);
        } else if ('VariableDeclaration' === t.type) for (let e of t.declarations) this.checkDeclaration(e.id);
       }
     }
     checkDeclaration(e) {
      if ('Identifier' === e.type) this.checkDuplicateExports(e, e.name);
      else if ('ObjectPattern' === e.type) for (let t of e.properties) this.checkDeclaration(t);
      else if ('ArrayPattern' === e.type) for (let t of e.elements) t && this.checkDeclaration(t);
      else 'ObjectProperty' === e.type ? this.checkDeclaration(e.value) : 'RestElement' === e.type ? this.checkDeclaration(e.argument) : 'AssignmentPattern' === e.type && this.checkDeclaration(e.left);
     }
     checkDuplicateExports(e, t) {
      (this.exportedIdentifiers.has(t) && ('default' === t ? this.raise(C.DuplicateDefaultExport, e) : this.raise(C.DuplicateExport, e, { exportName: t })), this.exportedIdentifiers.add(t));
     }
     parseExportSpecifiers(e) {
      let t = [],
       r = !0;
      for (this.expect(5); !this.eat(8); ) {
       if (r) r = !1;
       else if ((this.expect(12), this.eat(8))) break;
       let s = this.isContextual(130),
        n = this.match(134),
        i = this.startNode();
       ((i.local = this.parseModuleExportName()), t.push(this.parseExportSpecifier(i, n, e, s)));
      }
      return t;
     }
     parseExportSpecifier(e, t, r, s) {
      return (this.eatContextual(93) ? (e.exported = this.parseModuleExportName()) : t ? (e.exported = this.cloneStringLiteral(e.local)) : e.exported || (e.exported = this.cloneIdentifier(e.local)), this.finishNode(e, 'ExportSpecifier'));
     }
     parseModuleExportName() {
      if (this.match(134)) {
       let e = this.parseStringLiteral(this.state.value),
        t = $t.exec(e.value);
       return (t && this.raise(C.ModuleExportNameHasLoneSurrogate, e, { surrogateCharCode: t[0].charCodeAt(0) }), e);
      }
      return this.parseIdentifier(!0);
     }
     isJSONModuleImport(e) {
      return null != e.assertions && e.assertions.some(({ key: e, value: t }) => 'json' === t.value && ('Identifier' === e.type ? 'type' === e.name : 'type' === e.value));
     }
     checkImportReflection(e) {
      let { specifiers: t } = e,
       r = 1 === t.length ? t[0].type : null;
      'source' === e.phase ? 'ImportDefaultSpecifier' !== r && this.raise(C.SourcePhaseImportRequiresDefault, t[0].loc.start) : 'defer' === e.phase ? 'ImportNamespaceSpecifier' !== r && this.raise(C.DeferImportRequiresNamespace, t[0].loc.start) : e.module && ('ImportDefaultSpecifier' !== r && this.raise(C.ImportReflectionNotBinding, t[0].loc.start), e.assertions?.length > 0 && this.raise(C.ImportReflectionHasAssertion, t[0].loc.start));
     }
     checkJSONModuleImport(e) {
      if (this.isJSONModuleImport(e) && 'ExportAllDeclaration' !== e.type) {
       let { specifiers: t } = e;
       if (null != t) {
        let e = t.find((e) => {
         let t;
         if (('ExportSpecifier' === e.type ? (t = e.local) : 'ImportSpecifier' === e.type && (t = e.imported), void 0 !== t)) return 'Identifier' === t.type ? 'default' !== t.name : 'default' !== t.value;
        });
        void 0 !== e && this.raise(C.ImportJSONBindingNotDefault, e.loc.start);
       }
      }
     }
     isPotentialImportPhase(e) {
      return !e && (this.isContextual(105) || this.isContextual(97));
     }
     applyImportPhase(e, t, r, s) {
      t || (this.hasPlugin('importReflection') && (e.module = !1), 'source' === r ? (this.expectPlugin('sourcePhaseImports', s), (e.phase = 'source')) : 'defer' === r ? (this.expectPlugin('deferredImportEvaluation', s), (e.phase = 'defer')) : this.hasPlugin('sourcePhaseImports') && (e.phase = null));
     }
     parseMaybeImportPhase(e, t) {
      if (!this.isPotentialImportPhase(t)) return (this.applyImportPhase(e, t, null), null);
      let r = this.startNode(),
       s = this.parseIdentifierName(!0),
       { type: n } = this.state;
      return (K(n) ? 98 !== n || 102 === this.lookaheadCharCode() : 12 !== n) ? (this.applyImportPhase(e, t, s, r.loc.start), null) : (this.applyImportPhase(e, t, null), this.createIdentifier(r, s));
     }
     isPrecedingIdImportPhase(e) {
      let { type: t } = this.state;
      return X(t) ? 98 !== t || 102 === this.lookaheadCharCode() : 12 !== t;
     }
     parseImport(e) {
      return this.match(134) ? this.parseImportSourceAndAttributes(e) : this.parseImportSpecifiersAndAfter(e, this.parseMaybeImportPhase(e, !1));
     }
     parseImportSpecifiersAndAfter(e, t) {
      e.specifiers = [];
      let r = !this.maybeParseDefaultImportSpecifier(e, t) || this.eat(12),
       s = r && this.maybeParseStarImportSpecifier(e);
      return (r && !s && this.parseNamedImportSpecifiers(e), this.expectContextual(98), this.parseImportSourceAndAttributes(e));
     }
     parseImportSourceAndAttributes(e) {
      return (e.specifiers ?? (e.specifiers = []), (e.source = this.parseImportSource()), this.maybeParseImportAttributes(e), this.checkImportReflection(e), this.checkJSONModuleImport(e), this.semicolon(), (this.sawUnambiguousESM = !0), this.finishNode(e, 'ImportDeclaration'));
     }
     parseImportSource() {
      return (this.match(134) || this.unexpected(), this.parseExprAtom());
     }
     parseImportSpecifierLocal(e, t, r) {
      ((t.local = this.parseIdentifier()), e.specifiers.push(this.finishImportSpecifier(t, r)));
     }
     finishImportSpecifier(e, t, r = 8201) {
      return (this.checkLVal(e.local, { type: t }, r), this.finishNode(e, t));
     }
     parseImportAttributes() {
      this.expect(5);
      let e = [],
       t = new Set();
      do {
       if (this.match(8)) break;
       let r = this.startNode(),
        s = this.state.value;
       if ((t.has(s) && this.raise(C.ModuleAttributesWithDuplicateKeys, this.state.startLoc, { key: s }), t.add(s), this.match(134) ? (r.key = this.parseStringLiteral(s)) : (r.key = this.parseIdentifier(!0)), this.expect(14), !this.match(134))) throw this.raise(C.ModuleAttributeInvalidValue, this.state.startLoc);
       ((r.value = this.parseStringLiteral(this.state.value)), e.push(this.finishNode(r, 'ImportAttribute')));
      } while (this.eat(12));
      return (this.expect(8), e);
     }
     parseModuleAttributes() {
      let e = [],
       t = new Set();
      do {
       let r = this.startNode();
       if (((r.key = this.parseIdentifier(!0)), 'type' !== r.key.name && this.raise(C.ModuleAttributeDifferentFromType, r.key), t.has(r.key.name) && this.raise(C.ModuleAttributesWithDuplicateKeys, r.key, { key: r.key.name }), t.add(r.key.name), this.expect(14), !this.match(134))) throw this.raise(C.ModuleAttributeInvalidValue, this.state.startLoc);
       ((r.value = this.parseStringLiteral(this.state.value)), e.push(this.finishNode(r, 'ImportAttribute')));
      } while (this.eat(12));
      return e;
     }
     maybeParseImportAttributes(e) {
      let t;
      if (this.match(76)) {
       if (this.hasPrecedingLineBreak() && 40 === this.lookaheadCharCode()) return;
       (this.next(), (t = this.parseImportAttributes()));
      } else this.isContextual(94) && !this.hasPrecedingLineBreak() ? (this.hasPlugin('deprecatedImportAssert') || this.raise(C.ImportAttributesUseAssert, this.state.startLoc), this.addExtra(e, 'deprecatedAssertSyntax', !0), this.next(), (t = this.parseImportAttributes())) : (t = []);
      e.attributes = t;
     }
     maybeParseDefaultImportSpecifier(e, t) {
      if (t) {
       let r = this.startNodeAtNode(t);
       return ((r.local = t), e.specifiers.push(this.finishImportSpecifier(r, 'ImportDefaultSpecifier')), !0);
      }
      return !!K(this.state.type) && (this.parseImportSpecifierLocal(e, this.startNode(), 'ImportDefaultSpecifier'), !0);
     }
     maybeParseStarImportSpecifier(e) {
      if (this.match(55)) {
       let t = this.startNode();
       return (this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(e, t, 'ImportNamespaceSpecifier'), !0);
      }
      return !1;
     }
     parseNamedImportSpecifiers(e) {
      let t = !0;
      for (this.expect(5); !this.eat(8); ) {
       if (t) t = !1;
       else {
        if (this.eat(14)) throw this.raise(C.DestructureNamedImport, this.state.startLoc);
        if ((this.expect(12), this.eat(8))) break;
       }
       let r = this.startNode(),
        s = this.match(134),
        n = this.isContextual(130);
       r.imported = this.parseModuleExportName();
       let i = this.parseImportSpecifier(r, s, 'type' === e.importKind || 'typeof' === e.importKind, n, void 0);
       e.specifiers.push(i);
      }
     }
     parseImportSpecifier(e, t, r, s, n) {
      if (this.eatContextual(93)) e.local = this.parseIdentifier();
      else {
       let { imported: r } = e;
       if (t) throw this.raise(C.ImportBindingIsString, e, { importName: r.value });
       (this.checkReservedWord(r.name, e.loc.start, !0, !0), e.local || (e.local = this.cloneIdentifier(r)));
      }
      return this.finishImportSpecifier(e, 'ImportSpecifier', n);
     }
     isThisParam(e) {
      return 'Identifier' === e.type && 'this' === e.name;
     }
    },
    Wt = class extends Jt {
     constructor(e, t, r) {
      let s = (function (e) {
       let t = { sourceType: 'script', sourceFilename: void 0, startIndex: 0, startColumn: 0, startLine: 1, allowAwaitOutsideFunction: !1, allowReturnOutsideFunction: !1, allowNewTargetOutsideFunction: !1, allowImportExportEverywhere: !1, allowSuperOutsideMethod: !1, allowUndeclaredExports: !1, allowYieldOutsideFunction: !1, plugins: [], strictMode: void 0, ranges: !1, tokens: !1, createImportExpressions: !0, createParenthesizedExpressions: !1, errorRecovery: !1, attachComment: !0, annexB: !0 };
       if (null == e) return t;
       if (null != e.annexB && !1 !== e.annexB) throw new Error('The `annexB` option can only be set to `false`.');
       for (let r of Object.keys(t)) null != e[r] && (t[r] = e[r]);
       if (1 === t.startLine) null == e.startIndex && t.startColumn > 0 ? (t.startIndex = t.startColumn) : null == e.startColumn && t.startIndex > 0 && (t.startColumn = t.startIndex);
       else if (null == e.startColumn || null == e.startIndex) throw new Error('With a `startLine > 1` you must also specify `startIndex` and `startColumn`.');
       if ('commonjs' === t.sourceType) {
        if (null != e.allowAwaitOutsideFunction) throw new Error("The `allowAwaitOutsideFunction` option cannot be used with `sourceType: 'commonjs'`.");
        if (null != e.allowReturnOutsideFunction) throw new Error("`sourceType: 'commonjs'` implies `allowReturnOutsideFunction: true`, please remove the `allowReturnOutsideFunction` option or use `sourceType: 'script'`.");
        if (null != e.allowNewTargetOutsideFunction) throw new Error("`sourceType: 'commonjs'` implies `allowNewTargetOutsideFunction: true`, please remove the `allowNewTargetOutsideFunction` option or use `sourceType: 'script'`.");
       }
       return t;
      })(e);
      (super(s, t), (this.options = s), this.initializeScopes(), (this.plugins = r), (this.filename = s.sourceFilename), (this.startIndex = s.startIndex));
      let n = 0;
      (s.allowAwaitOutsideFunction && (n |= 1), s.allowReturnOutsideFunction && (n |= 2), s.allowImportExportEverywhere && (n |= 8), s.allowSuperOutsideMethod && (n |= 16), s.allowUndeclaredExports && (n |= 64), s.allowNewTargetOutsideFunction && (n |= 4), s.allowYieldOutsideFunction && (n |= 32), s.ranges && (n |= 128), s.tokens && (n |= 256), s.createImportExpressions && (n |= 512), s.createParenthesizedExpressions && (n |= 1024), s.errorRecovery && (n |= 2048), s.attachComment && (n |= 4096), s.annexB && (n |= 8192), (this.optionFlags = n));
     }
     getScopeHandler() {
      return Fe;
     }
     parse() {
      this.enterInitialScopes();
      let e = this.startNode(),
       t = this.startNode();
      (this.nextToken(), (e.errors = null));
      let r = this.parseTopLevel(e, t);
      return ((r.errors = this.state.errors), (r.comments.length = this.state.commentsLen), r);
     }
    };
   function Vt(e, t) {
    if ('unambiguous' !== t?.sourceType) return Ht(t, e).parse();
    t = Object.assign({}, t);
    try {
     t.sourceType = 'module';
     let r = Ht(t, e),
      s = r.parse();
     if (r.sawUnambiguousESM) return s;
     if (r.ambiguousScriptDifferentAst)
      try {
       return ((t.sourceType = 'script'), Ht(t, e).parse());
      } catch {}
     else s.program.sourceType = 'script';
     return s;
    } catch (r) {
     try {
      return ((t.sourceType = 'script'), Ht(t, e).parse());
     } catch {}
     throw r;
    }
   }
   function zt(e, t) {
    let r = Ht(t, e);
    return (r.options.strictMode && (r.state.strict = !0), r.getExpression());
   }
   !(function (e) {
    let t = {};
    for (let r of Object.keys(e)) t[r] = se(e[r]);
   })(H);
   function Ht(e, t) {
    let r = Wt,
     s = new Map();
    if (e?.plugins) {
     for (let t of e.plugins) {
      let e, r;
      ('string' == typeof t ? (e = t) : ([e, r] = t), s.has(e) || s.set(e, r || {}));
     }
     ((function (e) {
      if (e.has('decorators')) {
       if (e.has('decorators-legacy')) throw new Error('Cannot use the decorators and decorators-legacy plugin together');
       let t = e.get('decorators').decoratorsBeforeExport;
       if (null != t && 'boolean' != typeof t) throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
       let r = e.get('decorators').allowCallParenthesized;
       if (null != r && 'boolean' != typeof r) throw new Error("'allowCallParenthesized' must be a boolean.");
      }
      if (e.has('flow') && e.has('typescript')) throw new Error('Cannot combine flow and typescript plugins.');
      if (e.has('placeholders') && e.has('v8intrinsic')) throw new Error('Cannot combine placeholders and v8intrinsic plugins.');
      if (e.has('pipelineOperator')) {
       let t = e.get('pipelineOperator').proposal;
       if (!Ot.includes(t)) {
        let e = Ot.map((e) => `"${e}"`).join(', ');
        throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${e}.`);
       }
       if ('hack' === t) {
        if (e.has('placeholders')) throw new Error('Cannot combine placeholders plugin and Hack-style pipes.');
        if (e.has('v8intrinsic')) throw new Error('Cannot combine v8intrinsic plugin and Hack-style pipes.');
        let t = e.get('pipelineOperator').topicToken;
        if (!Lt.includes(t)) {
         let e = Lt.map((e) => `"${e}"`).join(', ');
         throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${e}.`);
        }
       }
      }
      if (e.has('moduleAttributes')) throw new Error('`moduleAttributes` has been removed in Babel 8, please migrate to import attributes instead.');
      if (e.has('importAssertions')) throw new Error('`importAssertions` has been removed in Babel 8, please use import attributes instead. To use the non-standard `assert` syntax you can enable the `deprecatedImportAssert` parser plugin.');
      if (!e.has('deprecatedImportAssert') && e.has('importAttributes') && e.get('importAttributes').deprecatedAssertSyntax) throw new Error("The 'importAttributes' plugin has been removed in Babel 8. If you need to enable support for the deprecated `assert` syntax, you can enable the `deprecatedImportAssert` parser plugin.");
      if (e.has('recordAndTuple')) throw new Error("The 'recordAndTuple' plugin has been removed in Babel 8. Please remove it from your configuration.");
      if (e.has('asyncDoExpressions') && !e.has('doExpressions')) {
       let e = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
       throw ((e.missingPlugins = 'doExpressions'), e);
      }
      if (e.has('optionalChainingAssign') && '2023-07' !== e.get('optionalChainingAssign').version) throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'.");
      if (e.has('discardBinding') && 'void' !== e.get('discardBinding').syntaxType) throw new Error("The 'discardBinding' plugin requires a 'syntaxType' option. Currently the only supported value is 'void'.");
      if (e.has('decimal')) throw new Error("The 'decimal' plugin has been removed in Babel 8. Please remove it from your configuration.");
      if (e.has('importReflection')) throw new Error("The 'importReflection' plugin has been removed in Babel 8. Use 'sourcePhaseImports' instead, and replace 'import module' with 'import source' in your code.");
     })(s),
      (r = (function (e) {
       let t = [];
       for (let n of jt) e.has(n) && t.push(n);
       let r = t.join('|'),
        s = Xt.get(r);
       if (!s) {
        s = Wt;
        for (let e of t) s = Mt[e](s);
        Xt.set(r, s);
       }
       return s;
      })(s)));
    }
    return new r(e, t, s);
   }
   var Xt = new Map();
   function Kt(e) {
    return (t, r, s) => {
     let n = !!s?.backwards;
     if (!1 === r) return !1;
     let { length: i } = t,
      a = r;
     for (; a >= 0 && a < i; ) {
      let r = t.charAt(a);
      if (e instanceof RegExp) {
       if (!e.test(r)) return a;
      } else if (!e.includes(r)) return a;
      n ? a-- : a++;
     }
     return (-1 === a || a === i) && a;
    };
   }
   Kt(/\s/u);
   var Gt = Kt(' \t'),
    Yt = (Kt(',; \t'), Kt(/[^\n\r]/u));
   var Qt = function (e, t) {
     if (!1 === t) return !1;
     if ('/' === e.charAt(t) && '*' === e.charAt(t + 1)) for (let r = t + 2; r < e.length; ++r) if ('*' === e.charAt(r) && '/' === e.charAt(r + 1)) return r + 2;
     return t;
    },
    Zt = (e) => '\n' === e || '\r' === e || '\u2028' === e || '\u2029' === e;
   var er = function (e, t, r) {
    let s = !!r?.backwards;
    if (!1 === t) return !1;
    let n = e.charAt(t);
    if (s) {
     if ('\r' === e.charAt(t - 1) && '\n' === n) return t - 2;
     if (Zt(n)) return t - 1;
    } else {
     if ('\r' === n && '\n' === e.charAt(t + 1)) return t + 2;
     if (Zt(n)) return t + 1;
    }
    return t;
   };
   var tr = function (e, t) {
    return !1 !== t && ('/' === e.charAt(t) && '/' === e.charAt(t + 1) ? Yt(e, t) : t);
   };
   var rr = function (e, t) {
    let r = null,
     s = t;
    for (; s !== r; ) ((r = s), (s = Gt(e, s)), (s = Qt(e, s)), (s = tr(e, s)), (s = er(e, s)));
    return s;
   };
   var sr = function (e) {
     if (!e.startsWith('#!')) return '';
     let t = e.indexOf('\n');
     return -1 === t ? e : e.slice(0, t);
    },
    nr =
     (e, t) =>
     (r, s, ...n) =>
      1 | r && null == s ? void 0 : (t.call(s) ?? s[e]).apply(s, n),
    ir =
     Array.prototype.findLast ??
     function (e) {
      for (let t = this.length - 1; t >= 0; t--) {
       let r = this[t];
       if (e(r, t, this)) return r;
      }
     },
    ar = nr('findLast', function () {
     if (Array.isArray(this)) return ir;
    });
   function or(e) {
    return this[e < 0 ? this.length + e : e];
   }
   var ur = nr('at', function () {
    if (Array.isArray(this) || 'string' == typeof this) return or;
   });
   function lr(e) {
    let t = e.range?.[0] ?? e.start,
     r = (e.declaration?.decorators ?? e.decorators)?.[0];
    return r ? Math.min(lr(r), t) : t;
   }
   function pr(e) {
    return e.range?.[1] ?? e.end;
   }
   var cr = function (e) {
     let t = new Set(e);
     return (e) => t.has(e?.type);
    },
    hr = cr(['Block', 'CommentBlock', 'MultiLine']),
    dr = cr(['Line', 'CommentLine', 'SingleLine', 'HashbangComment', 'HTMLOpen', 'HTMLClose', 'Hashbang', 'InterpreterDirective']),
    fr = new WeakMap();
   var mr = function (e) {
    return (fr.has(e) || fr.set(e, hr(e) && '*' === e.value[0] && /@(?:type|satisfies)\b/u.test(e.value)), fr.get(e));
   };
   var yr = new WeakMap();
   var Dr = function (e) {
    return (
     yr.has(e) ||
      yr.set(
       e,
       (function (e) {
        if (!hr(e)) return !1;
        let t = `*${e.value}*`.split('\n');
        return t.length > 1 && t.every((e) => '*' === e.trimStart()[0]);
       })(e),
      ),
     yr.get(e)
    );
   };
   var gr = function (e) {
    if (e.length < 2) return;
    let t;
    for (let r = e.length - 1; r >= 0; r--) {
     let s = e[r];
     if ((t && pr(s) === lr(t) && Dr(s) && Dr(t) && (e.splice(r + 1, 1), (s.value += '*//*' + t.value), (s.range = [lr(s), pr(t)])), !dr(s) && !hr(s))) throw new TypeError(`Unknown comment type: "${s.type}".`);
     t = s;
    }
   };
   var xr = function (e) {
     return null !== e && 'object' == typeof e;
    },
    Er = null;
   function br(e) {
    if (null !== Er && (Er.property, 1)) {
     let e = Er;
     return ((Er = br.prototype = null), e);
    }
    return ((Er = br.prototype = e ?? Object.create(null)), new br());
   }
   for (let Ts = 0; Ts <= 10; Ts++) br();
   var Tr = [['decorators', 'key', 'typeAnnotation', 'value'], [], ['elementType'], ['expression'], ['expression', 'typeAnnotation'], ['left', 'right'], ['argument'], ['directives', 'body'], ['label'], ['callee', 'typeArguments', 'arguments'], ['body'], ['decorators', 'id', 'typeParameters', 'superClass', 'superTypeArguments', 'mixins', 'implements', 'body', 'superTypeParameters'], ['id', 'typeParameters'], ['decorators', 'key', 'typeParameters', 'params', 'returnType', 'body'], ['decorators', 'variance', 'key', 'typeAnnotation', 'value'], ['name', 'typeAnnotation'], ['test', 'consequent', 'alternate'], ['checkType', 'extendsType', 'trueType', 'falseType'], ['value'], ['id', 'body'], ['declaration', 'specifiers', 'source', 'attributes'], ['id'], ['id', 'typeParameters', 'extends', 'body'], ['typeAnnotation'], ['id', 'typeParameters', 'right'], ['body', 'test'], ['members'], ['id', 'init'], ['exported'], ['left', 'right', 'body'], ['id', 'typeParameters', 'params', 'predicate', 'returnType', 'body'], ['id', 'params', 'body', 'typeParameters', 'returnType'], ['key', 'value'], ['local'], ['objectType', 'indexType'], ['typeParameter'], ['types'], ['node'], ['object', 'property'], ['argument', 'cases'], ['pattern', 'body', 'guard'], ['literal'], ['decorators', 'key', 'value'], ['expressions'], ['qualification', 'id'], ['decorators', 'key', 'typeAnnotation'], ['typeParameters', 'params', 'returnType'], ['expression', 'typeArguments'], ['params'], ['parameterName', 'typeAnnotation']],
    Cr = (function (e, t = 'type') {
     return (
      (function (e) {
       br(e);
      })(e),
      function (r) {
       let s = r[t],
        n = e[s];
       if (!Array.isArray(n)) throw Object.assign(new Error(`Missing visitor keys for '${s}'.`), { node: r });
       return n;
      }
     );
    })({ AccessorProperty: Tr[0], AnyTypeAnnotation: Tr[1], ArgumentPlaceholder: Tr[1], ArrayExpression: ['elements'], ArrayPattern: ['elements', 'typeAnnotation', 'decorators'], ArrayTypeAnnotation: Tr[2], ArrowFunctionExpression: ['typeParameters', 'params', 'predicate', 'returnType', 'body'], AsConstExpression: Tr[3], AsExpression: Tr[4], AssignmentExpression: Tr[5], AssignmentPattern: ['left', 'right', 'decorators', 'typeAnnotation'], AwaitExpression: Tr[6], BigIntLiteral: Tr[1], BigIntLiteralTypeAnnotation: Tr[1], BigIntTypeAnnotation: Tr[1], BinaryExpression: Tr[5], BindExpression: ['object', 'callee'], BlockStatement: Tr[7], BooleanLiteral: Tr[1], BooleanLiteralTypeAnnotation: Tr[1], BooleanTypeAnnotation: Tr[1], BreakStatement: Tr[8], CallExpression: Tr[9], CatchClause: ['param', 'body'], ChainExpression: Tr[3], ClassAccessorProperty: Tr[0], ClassBody: Tr[10], ClassDeclaration: Tr[11], ClassExpression: Tr[11], ClassImplements: Tr[12], ClassMethod: Tr[13], ClassPrivateMethod: Tr[13], ClassPrivateProperty: Tr[14], ClassProperty: Tr[14], ComponentDeclaration: ['id', 'params', 'body', 'typeParameters', 'rendersType'], ComponentParameter: ['name', 'local'], ComponentTypeAnnotation: ['params', 'rest', 'typeParameters', 'rendersType'], ComponentTypeParameter: Tr[15], ConditionalExpression: Tr[16], ConditionalTypeAnnotation: Tr[17], ContinueStatement: Tr[8], DebuggerStatement: Tr[1], DeclareClass: ['id', 'typeParameters', 'extends', 'mixins', 'implements', 'body'], DeclareComponent: ['id', 'params', 'rest', 'typeParameters', 'rendersType'], DeclaredPredicate: Tr[18], DeclareEnum: Tr[19], DeclareExportAllDeclaration: ['source', 'attributes'], DeclareExportDeclaration: Tr[20], DeclareFunction: ['id', 'predicate'], DeclareHook: Tr[21], DeclareInterface: Tr[22], DeclareModule: Tr[19], DeclareModuleExports: Tr[23], DeclareNamespace: Tr[19], DeclareOpaqueType: ['id', 'typeParameters', 'supertype', 'lowerBound', 'upperBound'], DeclareTypeAlias: Tr[24], DeclareVariable: Tr[21], Decorator: Tr[3], Directive: Tr[18], DirectiveLiteral: Tr[1], DoExpression: Tr[10], DoWhileStatement: Tr[25], EmptyStatement: Tr[1], EmptyTypeAnnotation: Tr[1], EnumBigIntBody: Tr[26], EnumBigIntMember: Tr[27], EnumBooleanBody: Tr[26], EnumBooleanMember: Tr[27], EnumDeclaration: Tr[19], EnumDefaultedMember: Tr[21], EnumNumberBody: Tr[26], EnumNumberMember: Tr[27], EnumStringBody: Tr[26], EnumStringMember: Tr[27], EnumSymbolBody: Tr[26], ExistsTypeAnnotation: Tr[1], ExperimentalRestProperty: Tr[6], ExperimentalSpreadProperty: Tr[6], ExportAllDeclaration: ['source', 'attributes', 'exported'], ExportDefaultDeclaration: ['declaration'], ExportDefaultSpecifier: Tr[28], ExportNamedDeclaration: Tr[20], ExportNamespaceSpecifier: Tr[28], ExportSpecifier: ['local', 'exported'], ExpressionStatement: Tr[3], File: ['program'], ForInStatement: Tr[29], ForOfStatement: Tr[29], ForStatement: ['init', 'test', 'update', 'body'], FunctionDeclaration: Tr[30], FunctionExpression: Tr[30], FunctionTypeAnnotation: ['typeParameters', 'this', 'params', 'rest', 'returnType'], FunctionTypeParam: Tr[15], GenericTypeAnnotation: Tr[12], HookDeclaration: Tr[31], HookTypeAnnotation: ['params', 'returnType', 'rest', 'typeParameters'], Identifier: ['typeAnnotation', 'decorators'], IfStatement: Tr[16], ImportAttribute: Tr[32], ImportDeclaration: ['specifiers', 'source', 'attributes'], ImportDefaultSpecifier: Tr[33], ImportExpression: ['source', 'options'], ImportNamespaceSpecifier: Tr[33], ImportSpecifier: ['imported', 'local'], IndexedAccessType: Tr[34], InferredPredicate: Tr[1], InferTypeAnnotation: Tr[35], InterfaceDeclaration: Tr[22], InterfaceExtends: Tr[12], InterfaceTypeAnnotation: ['extends', 'body'], InterpreterDirective: Tr[1], IntersectionTypeAnnotation: Tr[36], JsExpressionRoot: Tr[37], JsonRoot: Tr[37], JSXAttribute: ['name', 'value'], JSXClosingElement: ['name'], JSXClosingFragment: Tr[1], JSXElement: ['openingElement', 'children', 'closingElement'], JSXEmptyExpression: Tr[1], JSXExpressionContainer: Tr[3], JSXFragment: ['openingFragment', 'children', 'closingFragment'], JSXIdentifier: Tr[1], JSXMemberExpression: Tr[38], JSXNamespacedName: ['namespace', 'name'], JSXOpeningElement: ['name', 'typeArguments', 'attributes'], JSXOpeningFragment: Tr[1], JSXSpreadAttribute: Tr[6], JSXSpreadChild: Tr[3], JSXText: Tr[1], KeyofTypeAnnotation: Tr[6], LabeledStatement: ['label', 'body'], Literal: Tr[1], LogicalExpression: Tr[5], MatchArrayPattern: ['elements', 'rest'], MatchAsPattern: ['pattern', 'target'], MatchBindingPattern: Tr[21], MatchExpression: Tr[39], MatchExpressionCase: Tr[40], MatchIdentifierPattern: Tr[21], MatchLiteralPattern: Tr[41], MatchMemberPattern: ['base', 'property'], MatchObjectPattern: ['properties', 'rest'], MatchObjectPatternProperty: ['key', 'pattern'], MatchOrPattern: ['patterns'], MatchRestPattern: Tr[6], MatchStatement: Tr[39], MatchStatementCase: Tr[40], MatchUnaryPattern: Tr[6], MatchWildcardPattern: Tr[1], MemberExpression: Tr[38], MetaProperty: ['meta', 'property'], MethodDefinition: Tr[42], MixedTypeAnnotation: Tr[1], ModuleExpression: Tr[10], NeverTypeAnnotation: Tr[1], NewExpression: Tr[9], NGChainedExpression: Tr[43], NGEmptyExpression: Tr[1], NGMicrosyntax: Tr[10], NGMicrosyntaxAs: ['key', 'alias'], NGMicrosyntaxExpression: ['expression', 'alias'], NGMicrosyntaxKey: Tr[1], NGMicrosyntaxKeyedExpression: ['key', 'expression'], NGMicrosyntaxLet: Tr[32], NGPipeExpression: ['left', 'right', 'arguments'], NGRoot: Tr[37], NullableTypeAnnotation: Tr[23], NullLiteral: Tr[1], NullLiteralTypeAnnotation: Tr[1], NumberLiteralTypeAnnotation: Tr[1], NumberTypeAnnotation: Tr[1], NumericLiteral: Tr[1], ObjectExpression: ['properties'], ObjectMethod: Tr[13], ObjectPattern: ['decorators', 'properties', 'typeAnnotation'], ObjectProperty: Tr[42], ObjectTypeAnnotation: ['properties', 'indexers', 'callProperties', 'internalSlots'], ObjectTypeCallProperty: Tr[18], ObjectTypeIndexer: ['variance', 'id', 'key', 'value'], ObjectTypeInternalSlot: ['id', 'value'], ObjectTypeMappedTypeProperty: ['keyTparam', 'propType', 'sourceType', 'variance'], ObjectTypeProperty: ['key', 'value', 'variance'], ObjectTypeSpreadProperty: Tr[6], OpaqueType: ['id', 'typeParameters', 'supertype', 'impltype', 'lowerBound', 'upperBound'], OptionalCallExpression: Tr[9], OptionalIndexedAccessType: Tr[34], OptionalMemberExpression: Tr[38], ParenthesizedExpression: Tr[3], PipelineBareFunction: ['callee'], PipelinePrimaryTopicReference: Tr[1], PipelineTopicExpression: Tr[3], Placeholder: Tr[1], PrivateIdentifier: Tr[1], PrivateName: Tr[21], Program: Tr[7], Property: Tr[32], PropertyDefinition: Tr[14], QualifiedTypeIdentifier: Tr[44], QualifiedTypeofIdentifier: Tr[44], RegExpLiteral: Tr[1], RestElement: ['argument', 'typeAnnotation', 'decorators'], ReturnStatement: Tr[6], SatisfiesExpression: Tr[4], SequenceExpression: Tr[43], SpreadElement: Tr[6], StaticBlock: Tr[10], StringLiteral: Tr[1], StringLiteralTypeAnnotation: Tr[1], StringTypeAnnotation: Tr[1], Super: Tr[1], SwitchCase: ['test', 'consequent'], SwitchStatement: ['discriminant', 'cases'], SymbolTypeAnnotation: Tr[1], TaggedTemplateExpression: ['tag', 'typeArguments', 'quasi'], TemplateElement: Tr[1], TemplateLiteral: ['quasis', 'expressions'], ThisExpression: Tr[1], ThisTypeAnnotation: Tr[1], ThrowStatement: Tr[6], TopicReference: Tr[1], TryStatement: ['block', 'handler', 'finalizer'], TSAbstractAccessorProperty: Tr[45], TSAbstractKeyword: Tr[1], TSAbstractMethodDefinition: Tr[32], TSAbstractPropertyDefinition: Tr[45], TSAnyKeyword: Tr[1], TSArrayType: Tr[2], TSAsExpression: Tr[4], TSAsyncKeyword: Tr[1], TSBigIntKeyword: Tr[1], TSBooleanKeyword: Tr[1], TSCallSignatureDeclaration: Tr[46], TSClassImplements: Tr[47], TSConditionalType: Tr[17], TSConstructorType: Tr[46], TSConstructSignatureDeclaration: Tr[46], TSDeclareFunction: Tr[31], TSDeclareKeyword: Tr[1], TSDeclareMethod: ['decorators', 'key', 'typeParameters', 'params', 'returnType'], TSEmptyBodyFunctionExpression: ['id', 'typeParameters', 'params', 'returnType'], TSEnumBody: Tr[26], TSEnumDeclaration: Tr[19], TSEnumMember: ['id', 'initializer'], TSExportAssignment: Tr[3], TSExportKeyword: Tr[1], TSExternalModuleReference: Tr[3], TSFunctionType: Tr[46], TSImportEqualsDeclaration: ['id', 'moduleReference'], TSImportType: ['options', 'qualifier', 'typeArguments', 'source'], TSIndexedAccessType: Tr[34], TSIndexSignature: ['parameters', 'typeAnnotation'], TSInferType: Tr[35], TSInstantiationExpression: Tr[47], TSInterfaceBody: Tr[10], TSInterfaceDeclaration: Tr[22], TSInterfaceHeritage: Tr[47], TSIntersectionType: Tr[36], TSIntrinsicKeyword: Tr[1], TSJSDocAllType: Tr[1], TSJSDocNonNullableType: Tr[23], TSJSDocNullableType: Tr[23], TSJSDocUnknownType: Tr[1], TSLiteralType: Tr[41], TSMappedType: ['key', 'constraint', 'nameType', 'typeAnnotation'], TSMethodSignature: ['key', 'typeParameters', 'params', 'returnType'], TSModuleBlock: Tr[10], TSModuleDeclaration: Tr[19], TSNamedTupleMember: ['label', 'elementType'], TSNamespaceExportDeclaration: Tr[21], TSNeverKeyword: Tr[1], TSNonNullExpression: Tr[3], TSNullKeyword: Tr[1], TSNumberKeyword: Tr[1], TSObjectKeyword: Tr[1], TSOptionalType: Tr[23], TSParameterProperty: ['parameter', 'decorators'], TSParenthesizedType: Tr[23], TSPrivateKeyword: Tr[1], TSPropertySignature: ['key', 'typeAnnotation'], TSProtectedKeyword: Tr[1], TSPublicKeyword: Tr[1], TSQualifiedName: Tr[5], TSReadonlyKeyword: Tr[1], TSRestType: Tr[23], TSSatisfiesExpression: Tr[4], TSStaticKeyword: Tr[1], TSStringKeyword: Tr[1], TSSymbolKeyword: Tr[1], TSTemplateLiteralType: ['quasis', 'types'], TSThisType: Tr[1], TSTupleType: ['elementTypes'], TSTypeAliasDeclaration: ['id', 'typeParameters', 'typeAnnotation'], TSTypeAnnotation: Tr[23], TSTypeAssertion: Tr[4], TSTypeLiteral: Tr[26], TSTypeOperator: Tr[23], TSTypeParameter: ['name', 'constraint', 'default'], TSTypeParameterDeclaration: Tr[48], TSTypeParameterInstantiation: Tr[48], TSTypePredicate: Tr[49], TSTypeQuery: ['exprName', 'typeArguments'], TSTypeReference: ['typeName', 'typeArguments'], TSUndefinedKeyword: Tr[1], TSUnionType: Tr[36], TSUnknownKeyword: Tr[1], TSVoidKeyword: Tr[1], TupleTypeAnnotation: ['types', 'elementTypes'], TupleTypeLabeledElement: ['label', 'elementType', 'variance'], TupleTypeSpreadElement: ['label', 'typeAnnotation'], TypeAlias: Tr[24], TypeAnnotation: Tr[23], TypeCastExpression: Tr[4], TypeofTypeAnnotation: ['argument', 'typeArguments'], TypeOperator: Tr[23], TypeParameter: ['bound', 'default', 'variance'], TypeParameterDeclaration: Tr[48], TypeParameterInstantiation: Tr[48], TypePredicate: Tr[49], UnaryExpression: Tr[6], UndefinedTypeAnnotation: Tr[1], UnionTypeAnnotation: Tr[36], UnknownTypeAnnotation: Tr[1], UpdateExpression: Tr[6], V8IntrinsicIdentifier: Tr[1], VariableDeclaration: ['declarations'], VariableDeclarator: Tr[27], Variance: Tr[1], VoidPattern: Tr[1], VoidTypeAnnotation: Tr[1], WhileStatement: Tr[25], WithStatement: ['object', 'body'], YieldExpression: Tr[6] });
   var Fr = function e(t, r) {
    if (!xr(t)) return t;
    if (Array.isArray(t)) {
     for (let s = 0; s < t.length; s++) t[s] = e(t[s], r);
     return t;
    }
    if (r.onEnter) {
     let s = r.onEnter(t) ?? t;
     if (s !== t) return e(s, r);
     t = s;
    }
    let s = Cr(t);
    for (let n = 0; n < s.length; n++) t[s[n]] = e(t[s[n]], r);
    return (r.onLeave && (t = r.onLeave(t) || t), t);
   };
   cr(['RegExpLiteral', 'BigIntLiteral', 'NumericLiteral', 'StringLiteral', 'DirectiveLiteral', 'Literal', 'JSXText', 'TemplateElement', 'StringLiteralTypeAnnotation', 'NumberLiteralTypeAnnotation', 'BigIntLiteralTypeAnnotation']);
   function Ar(e) {
    return 'LogicalExpression' === e.type && 'LogicalExpression' === e.right.type && e.operator === e.right.operator;
   }
   function wr(e) {
    return Ar(e) ? wr({ type: 'LogicalExpression', operator: e.operator, left: wr({ type: 'LogicalExpression', operator: e.operator, left: e.left, right: e.right.left, range: [lr(e.left), pr(e.right.left)] }), right: e.right.right, range: [lr(e), pr(e)] }) : e;
   }
   var Sr = function (e, t) {
    let { parser: r, text: s } = t,
     { comments: n } = e,
     i = 'oxc' === r && 'ts' === t.oxcAstType;
    gr(n);
    let a,
     o = 'File' === e.type ? e.program : e;
    return (
     o.interpreter && (n.unshift(o.interpreter), delete o.interpreter),
     i && e.hashbang && (n.unshift(e.hashbang), delete e.hashbang),
     'Program' === e.type && (e.range = [0, s.length]),
     (e = Fr(e, {
      onEnter(t) {
       switch (t.type) {
        case 'ParenthesizedExpression': {
         let { expression: e } = t,
          r = lr(t);
         if ('TypeCastExpression' === e.type) return ((e.range = [r, pr(t)]), e);
         let o = !1;
         if (!i) {
          if (!a) {
           a = [];
           for (let e of n) mr(e) && a.push(pr(e));
          }
          let e = ar(0, a, (e) => e <= r);
          o = e && 0 === s.slice(e, r).trim().length;
         }
         return o ? void 0 : ((e.extra = { ...e.extra, parenthesized: !0 }), e);
        }
        case 'TemplateLiteral':
         if (t.expressions.length !== t.quasis.length - 1) throw new Error('Malformed template literal.');
         break;
        case 'TemplateElement':
         if ('flow' === r || 'hermes' === r || 'espree' === r || 'typescript' === r || i) {
          let e = lr(t) + 1,
           r = pr(t) - (t.tail ? 1 : 2);
          t.range = [e, r];
         }
         break;
        case 'VariableDeclaration': {
         let e = ur(0, t.declarations, -1);
         e?.init && ';' !== s[pr(e)] && (t.range = [lr(t), pr(e)]);
         break;
        }
        case 'TSParenthesizedType':
         return t.typeAnnotation;
        case 'TopicReference':
         e.extra = { ...e.extra, __isUsingHackPipeline: !0 };
         break;
        case 'TSUnionType':
        case 'TSIntersectionType':
         if (1 === t.types.length) return t.types[0];
         break;
        case 'ImportExpression':
         'hermes' === r && t.attributes && !t.options && (t.options = t.attributes);
       }
      },
      onLeave(e) {
       switch (e.type) {
        case 'LogicalExpression':
         if (Ar(e)) return wr(e);
         break;
        case 'TSImportType':
         !e.source && 'TSLiteralType' === e.argument.type && ((e.source = e.argument.literal), delete e.argument);
       }
      },
     }))
    );
   };
   var vr = function (e, t) {
     let r = new SyntaxError(e + ' (' + t.loc.start.line + ':' + t.loc.start.column + ')');
     return Object.assign(r, t);
    },
    Pr = 'Unexpected parseExpression() input: ';
   var kr = function (e) {
     let { message: t, loc: r, reasonCode: s } = e;
     if (!r) return e;
     let { line: n, column: i } = r,
      a = e;
     ('MissingPlugin' === s || 'MissingOneOfPlugins' === s) && ((t = 'Unexpected token.'), (a = void 0));
     let o = ` (${n}:${i})`;
     return (t.endsWith(o) && (t = t.slice(0, -o.length)), t.startsWith(Pr) && (t = t.slice(36)), vr(t, { loc: { start: { line: n, column: i + 1 } }, cause: a }));
    },
    Ir =
     String.prototype.replaceAll ??
     function (e, t) {
      return e.global ? this.replace(e, t) : this.split(e).join(t);
     },
    Nr = nr('replaceAll', function () {
     if ('string' == typeof this) return Ir;
    }),
    Br = /\*\/$/,
    Or = /^\/\*\*?/,
    Lr = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/,
    Mr = /(^|\s+)\/\/([^\n\r]*)/g,
    jr = /^(\r?\n)+/,
    _r = /(?:^|\r?\n) *(@[^\n\r]*?) *\r?\n *(?![^\n\r@]*\/\/[^]*)([^\s@][^\n\r@]+?) *\r?\n/g,
    Rr = /(?:^|\r?\n) *@(\S+) *([^\n\r]*)/g,
    Ur = /(\r?\n|^) *\* ?/g,
    $r = [];
   var qr = ['noformat', 'noprettier'],
    Jr = ['format', 'prettier'];
   function Wr(e) {
    let t = sr(e);
    t && (e = e.slice(t.length + 1));
    let r = (function (e) {
      let t = e.match(Lr);
      return t ? t[0].trimStart() : '';
     })(e),
     { pragmas: s, comments: n } = (function (e) {
      e = Nr(0, e.replace(Or, '').replace(Br, ''), Ur, '$1');
      let t = '';
      for (; t !== e; ) ((t = e), (e = Nr(0, e, _r, '\n$1 $2\n')));
      e = e.replace(jr, '').trimEnd();
      let r,
       s = Object.create(null),
       n = Nr(0, e, Rr, '').replace(jr, '').trimEnd();
      for (; (r = Rr.exec(e)); ) {
       let e = Nr(0, r[2], Mr, '');
       if ('string' == typeof s[r[1]] || Array.isArray(s[r[1]])) {
        let t = s[r[1]];
        s[r[1]] = [...$r, ...(Array.isArray(t) ? t : [t]), e];
       } else s[r[1]] = e;
      }
      return { comments: n, pragmas: s };
     })(r);
    return { shebang: t, text: e, pragmas: s, comments: n };
   }
   function Vr(e) {
    let { pragmas: t } = Wr(e);
    return Jr.some((e) => Object.prototype.hasOwnProperty.call(t, e));
   }
   function zr(e) {
    let { pragmas: t } = Wr(e);
    return qr.some((e) => Object.prototype.hasOwnProperty.call(t, e));
   }
   var Hr = function (e) {
     return ((e = 'function' == typeof e ? { parse: e } : e), { astFormat: 'estree', hasPragma: Vr, hasIgnorePragma: zr, locStart: lr, locEnd: pr, ...e });
    },
    Xr = 'module',
    Kr = 'commonjs';
   var Gr = function (e, t) {
     let { type: r = 'JsExpressionRoot', rootMarker: s, text: n } = t,
      { tokens: i, comments: a } = e;
     return (delete e.tokens, delete e.comments, { tokens: i, comments: a, type: r, node: e, range: [0, n.length], rootMarker: s });
    },
    Yr = (e) =>
     Hr(
      (function ({ isExpression: e = !1, optionsCombinations: t }) {
       return (r, s = {}) => {
        let { filepath: n } = s;
        if (
         ('string' != typeof n && (n = void 0),
         ('babel' === s.parser || '__babel_estree' === s.parser) &&
          (function (e, t) {
           if (t?.endsWith('.js.flow')) return !0;
           let r = sr(e);
           r && (e = e.slice(r.length));
           let s = rr(e, 0);
           return (!1 !== s && (e = e.slice(0, s)), rs.test(e));
          })(r, n))
        )
         return ((s.parser = 'babel-flow'), ls.parse(r, s));
        let i = t,
         a =
          s.__babelSourceType ??
          (function (e) {
           if ('string' == typeof e) {
            if (((e = e.toLowerCase()), /\.(?:mjs|mts)$/iu.test(e))) return Xr;
            if (/\.(?:cjs|cts)$/iu.test(e)) return Kr;
           }
          })(n);
        a && a !== Xr && (i = i.map((e) => ({ ...e, sourceType: a, ...(a === Kr ? { allowReturnOutsideFunction: void 0, allowNewTargetOutsideFunction: void 0 } : void 0) })));
        let o = /%[A-Z]/u.test(r);
        r.includes('|>') ? (i = (o ? [...es, Zr] : es).flatMap((e) => i.map((t) => ts([e], t)))) : o && (i = i.map((e) => ts([Zr], e)));
        let u,
         l = e ? zt : Vt;
        try {
         u = (function (e) {
          let t = [];
          for (let r of e)
           try {
            return r();
           } catch (s) {
            t.push(s);
           }
          throw Object.assign(new Error('All combinations failed'), { errors: t });
         })(
          i.map(
           (e) => () =>
            (function (e, t, r) {
             let s = e(t, r),
              n = s.errors.find((e) => !ss.has(e.reasonCode));
             if (n) throw n;
             return s;
            })(l, r, e),
          ),
         );
        } catch ({ errors: [p] }) {
         throw kr(p);
        }
        return (e && (u = Gr(u, { text: r, rootMarker: s.rootMarker })), Sr(u, { text: r }));
       };
      })(e),
     ),
    Qr = { sourceType: Xr, allowImportExportEverywhere: !0, allowReturnOutsideFunction: !0, allowNewTargetOutsideFunction: !0, allowSuperOutsideMethod: !0, allowUndeclaredExports: !0, errorRecovery: !0, createParenthesizedExpressions: !0, attachComment: !1, plugins: ['doExpressions', 'exportDefaultFrom', 'functionBind', 'functionSent', 'throwExpressions', 'partialApplication', 'decorators', 'moduleBlocks', 'asyncDoExpressions', 'destructuringPrivate', 'decoratorAutoAccessors', 'sourcePhaseImports', 'deferredImportEvaluation', ['optionalChainingAssign', { version: '2023-07' }], ['discardBinding', { syntaxType: 'void' }]], tokens: !1, ranges: !1 },
    Zr = 'v8intrinsic',
    es = [
     ['pipelineOperator', { proposal: 'hack', topicToken: '%' }],
     ['pipelineOperator', { proposal: 'fsharp' }],
    ],
    ts = (e, t = Qr) => ({ ...t, plugins: [...t.plugins, ...e] }),
    rs = /@(?:no)?flow\b/u;
   var ss = new Set(['StrictNumericEscape', 'StrictWith', 'StrictOctalLiteral', 'StrictDelete', 'StrictEvalArguments', 'StrictEvalArgumentsBinding', 'StrictFunction', 'ForInOfLoopInitializer', 'ConstructorHasTypeParameters', 'UnsupportedParameterPropertyKind', 'DecoratorExportClass', 'ParamDupe', 'InvalidDecimal', 'RestTrailingComma', 'UnsupportedParameterDecorator', 'UnterminatedJsxContent', 'UnexpectedReservedWord', 'ModuleAttributesWithDuplicateKeys', 'InvalidEscapeSequenceTemplate', 'NonAbstractClassHasAbstractMethod', 'OptionalTypeBeforeRequired', 'PatternIsOptional', 'DeclareClassFieldHasInitializer', 'TypeImportCannotSpecifyDefaultAndNamed', 'VarRedeclaration', 'InvalidPrivateFieldResolution', 'DuplicateExport', 'ImportAttributesUseAssert', 'DeclarationMissingInitializer']),
    ns = [ts(['jsx'])],
    is = Yr({ optionsCombinations: ns }),
    as = Yr({ optionsCombinations: [ts(['jsx', 'typescript']), ts(['typescript'])] }),
    os = Yr({ isExpression: !0, optionsCombinations: [ts(['jsx'])] }),
    us = Yr({ isExpression: !0, optionsCombinations: [ts(['typescript'])] }),
    ls = Yr({ optionsCombinations: [ts(['jsx', ['flow', { all: !0 }], 'flowComments'])] }),
    ps = Yr({ optionsCombinations: ns.map((e) => ts(['estree'], e)) }),
    cs = {};
   n(cs, { json: () => Ds, 'json-stringify': () => Es, json5: () => gs, jsonc: () => xs });
   var hs = function (e) {
     return Array.isArray(e) && e.length > 0;
    },
    ds = { tokens: !1, ranges: !1, attachComment: !1, createParenthesizedExpressions: !0 };
   function fs(e, t = {}) {
    let r,
     { allowComments: s = !0, allowEmpty: n = !1 } = t;
    try {
     r = zt(e, ds);
    } catch (i) {
     if (n && 'BABEL_PARSER_SYNTAX_ERROR' === i.code && 'ParseExpressionEmptyInput' === i.reasonCode)
      try {
       r = (function (e) {
        let t = Vt(e, ds),
         { program: r } = t;
        if (0 === r.body.length && 0 === r.directives.length && !r.interpreter) return t;
       })(e);
      } catch {}
     if (!r) throw kr(i);
    }
    if (!s && hs(r.comments)) throw ms(r.comments[0], 'Comment');
    return ((r = Gr(r, { type: 'JsonRoot', text: e })), 'File' === r.node.type ? delete r.node : ys(r.node), r);
   }
   function ms(e, t) {
    let [r, s] = [e.loc.start, e.loc.end].map(({ line: e, column: t }) => ({ line: e, column: t + 1 }));
    return vr(`${t} is not allowed in JSON.`, { loc: { start: r, end: s } });
   }
   function ys(e) {
    switch (e.type) {
     case 'ArrayExpression':
      for (let t of e.elements) null !== t && ys(t);
      return;
     case 'ObjectExpression':
      for (let t of e.properties) ys(t);
      return;
     case 'ObjectProperty':
      if (e.computed) throw ms(e.key, 'Computed key');
      if (e.shorthand) throw ms(e.key, 'Shorthand property');
      return ('Identifier' !== e.key.type && ys(e.key), void ys(e.value));
     case 'UnaryExpression': {
      let { operator: t, argument: r } = e;
      if ('+' !== t && '-' !== t) throw ms(e, `Operator '${e.operator}'`);
      if ('NumericLiteral' === r.type || ('Identifier' === r.type && ('Infinity' === r.name || 'NaN' === r.name))) return;
      throw ms(r, `Operator '${t}' before '${r.type}'`);
     }
     case 'Identifier':
      if ('Infinity' !== e.name && 'NaN' !== e.name && 'undefined' !== e.name) throw ms(e, `Identifier '${e.name}'`);
      return;
     case 'TemplateLiteral':
      if (hs(e.expressions)) throw ms(e.expressions[0], "'TemplateLiteral' with expression");
      for (let t of e.quasis) ys(t);
      return;
     case 'NullLiteral':
     case 'BooleanLiteral':
     case 'NumericLiteral':
     case 'StringLiteral':
     case 'TemplateElement':
      return;
     default:
      throw ms(e, `'${e.type}'`);
    }
   }
   var Ds = Hr({ parse: (e) => fs(e), hasPragma: () => !0, hasIgnorePragma: () => !1 }),
    gs = Hr((e) => fs(e)),
    xs = Hr((e) => fs(e, { allowEmpty: !0 })),
    Es = Hr({ parse: (e) => fs(e, { allowComments: !1 }), astFormat: 'estree-json' }),
    bs = { ...a, ...cs };
  },
  91635(e, t, r) {
   r.d(t, { Ay: () => He });
   var s = Object.create,
    n = Object.defineProperty,
    i = Object.getOwnPropertyDescriptor,
    a = Object.getOwnPropertyNames,
    o = Object.getPrototypeOf,
    u = Object.prototype.hasOwnProperty,
    l = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports),
    p = (e, t) => {
     for (var r in t) n(e, r, { get: t[r], enumerable: !0 });
    },
    c = (e, t, r) => (
     (r = null != e ? s(o(e)) : {}),
     ((e, t, r, s) => {
      if ((t && 'object' == typeof t) || 'function' == typeof t) for (let o of a(t)) !u.call(e, o) && o !== r && n(e, o, { get: () => t[o], enumerable: !(s = i(t, o)) || s.enumerable });
      return e;
     })(!t && e && e.__esModule ? r : n(r, 'default', { value: e, enumerable: !0 }), e)
    ),
    h = l((e, t) => {
     var r = String,
      s = function () {
       return { isColorSupported: !1, reset: r, bold: r, dim: r, italic: r, underline: r, inverse: r, hidden: r, strikethrough: r, black: r, red: r, green: r, yellow: r, blue: r, magenta: r, cyan: r, white: r, gray: r, bgBlack: r, bgRed: r, bgGreen: r, bgYellow: r, bgBlue: r, bgMagenta: r, bgCyan: r, bgWhite: r, blackBright: r, redBright: r, greenBright: r, yellowBright: r, blueBright: r, magentaBright: r, cyanBright: r, whiteBright: r, bgBlackBright: r, bgRedBright: r, bgGreenBright: r, bgYellowBright: r, bgBlueBright: r, bgMagentaBright: r, bgCyanBright: r, bgWhiteBright: r };
      };
     ((t.exports = s()), (t.exports.createColors = s));
    }),
    d = l(() => {}),
    f = l((e, t) => {
     var r = h(),
      s = d(),
      n = class e extends Error {
       constructor(t, r, s, n, i, a) {
        (super(t), (this.name = 'CssSyntaxError'), (this.reason = t), i && (this.file = i), n && (this.source = n), a && (this.plugin = a), typeof r < 'u' && typeof s < 'u' && ('number' == typeof r ? ((this.line = r), (this.column = s)) : ((this.line = r.line), (this.column = r.column), (this.endLine = s.line), (this.endColumn = s.column))), this.setMessage(), Error.captureStackTrace && Error.captureStackTrace(this, e));
       }
       setMessage() {
        ((this.message = this.plugin ? this.plugin + ': ' : ''), (this.message += this.file ? this.file : '<css input>'), typeof this.line < 'u' && (this.message += ':' + this.line + ':' + this.column), (this.message += ': ' + this.reason));
       }
       showSourceCode(e) {
        if (!this.source) return '';
        let t = this.source;
        null == e && (e = r.isColorSupported);
        let n = (e) => e,
         i = (e) => e,
         a = (e) => e;
        if (e) {
         let { bold: e, gray: t, red: o } = r.createColors(!0);
         ((i = (t) => e(o(t))), (n = (e) => t(e)), s && (a = (e) => s(e)));
        }
        let o = t.split(/\r?\n/),
         u = Math.max(this.line - 3, 0),
         l = Math.min(this.line + 2, o.length),
         p = String(l).length;
        return o
         .slice(u, l)
         .map((e, t) => {
          let r = u + 1 + t,
           s = ' ' + (' ' + r).slice(-p) + ' | ';
          if (r === this.line) {
           if (e.length > 160) {
            let t = 20,
             r = Math.max(0, this.column - t),
             o = Math.max(this.column + t, this.endColumn + t),
             u = e.slice(r, o),
             l = n(s.replace(/\d/g, ' ')) + e.slice(0, Math.min(this.column - 1, t - 1)).replace(/[^\t]/g, ' ');
            return i('>') + n(s) + a(u) + '\n ' + l + i('^');
           }
           let t = n(s.replace(/\d/g, ' ')) + e.slice(0, this.column - 1).replace(/[^\t]/g, ' ');
           return i('>') + n(s) + a(e) + '\n ' + t + i('^');
          }
          return ' ' + n(s) + a(e);
         })
         .join('\n');
       }
       toString() {
        let e = this.showSourceCode();
        return (e && (e = '\n\n' + e + '\n'), this.name + ': ' + this.message + e);
       }
      };
     ((t.exports = n), (n.default = n));
    }),
    m = l((e, t) => {
     var r = { after: '\n', beforeClose: '\n', beforeComment: '\n', beforeDecl: '\n', beforeOpen: ' ', beforeRule: '\n', colon: ': ', commentLeft: ' ', commentRight: ' ', emptyBody: '', indent: '    ', semicolon: !1 };
     var s = class {
      constructor(e) {
       this.builder = e;
      }
      atrule(e, t) {
       let r = '@' + e.name,
        s = e.params ? this.rawValue(e, 'params') : '';
       if ((typeof e.raws.afterName < 'u' ? (r += e.raws.afterName) : s && (r += ' '), e.nodes)) this.block(e, r + s);
       else {
        let n = (e.raws.between || '') + (t ? ';' : '');
        this.builder(r + s + n, e);
       }
      }
      beforeAfter(e, t) {
       let r;
       r = 'decl' === e.type ? this.raw(e, null, 'beforeDecl') : 'comment' === e.type ? this.raw(e, null, 'beforeComment') : 'before' === t ? this.raw(e, null, 'beforeRule') : this.raw(e, null, 'beforeClose');
       let s = e.parent,
        n = 0;
       for (; s && 'root' !== s.type; ) ((n += 1), (s = s.parent));
       if (r.includes('\n')) {
        let t = this.raw(e, null, 'indent');
        if (t.length) for (let e = 0; e < n; e++) r += t;
       }
       return r;
      }
      block(e, t) {
       let r,
        s = this.raw(e, 'between', 'beforeOpen');
       (this.builder(t + s + '{', e, 'start'), e.nodes && e.nodes.length ? (this.body(e), (r = this.raw(e, 'after'))) : (r = this.raw(e, 'after', 'emptyBody')), r && this.builder(r), this.builder('}', e, 'end'));
      }
      body(e) {
       let t = e.nodes.length - 1;
       for (; t > 0 && 'comment' === e.nodes[t].type; ) t -= 1;
       let r = this.raw(e, 'semicolon');
       for (let s = 0; s < e.nodes.length; s++) {
        let n = e.nodes[s],
         i = this.raw(n, 'before');
        (i && this.builder(i), this.stringify(n, t !== s || r));
       }
      }
      comment(e) {
       let t = this.raw(e, 'left', 'commentLeft'),
        r = this.raw(e, 'right', 'commentRight');
       this.builder('/*' + t + e.text + r + '*/', e);
      }
      decl(e, t) {
       let r = this.raw(e, 'between', 'colon'),
        s = e.prop + r + this.rawValue(e, 'value');
       (e.important && (s += e.raws.important || ' !important'), t && (s += ';'), this.builder(s, e));
      }
      document(e) {
       this.body(e);
      }
      raw(e, t, s) {
       let n;
       if ((s || (s = t), t && ((n = e.raws[t]), typeof n < 'u'))) return n;
       let i = e.parent;
       if ('before' === s && (!i || ('root' === i.type && i.first === e) || (i && 'document' === i.type))) return '';
       if (!i) return r[s];
       let a = e.root();
       if ((a.rawCache || (a.rawCache = {}), typeof a.rawCache[s] < 'u')) return a.rawCache[s];
       if ('before' === s || 'after' === s) return this.beforeAfter(e, s);
       {
        let r = 'raw' + ((o = s)[0].toUpperCase() + o.slice(1));
        this[r]
         ? (n = this[r](a, e))
         : a.walk((e) => {
            if (((n = e.raws[t]), typeof n < 'u')) return !1;
           });
       }
       var o;
       return (typeof n > 'u' && (n = r[s]), (a.rawCache[s] = n), n);
      }
      rawBeforeClose(e) {
       let t;
       return (
        e.walk((e) => {
         if (e.nodes && e.nodes.length > 0 && typeof e.raws.after < 'u') return ((t = e.raws.after), t.includes('\n') && (t = t.replace(/[^\n]+$/, '')), !1);
        }),
        t && (t = t.replace(/\S/g, '')),
        t
       );
      }
      rawBeforeComment(e, t) {
       let r;
       return (
        e.walkComments((e) => {
         if (typeof e.raws.before < 'u') return ((r = e.raws.before), r.includes('\n') && (r = r.replace(/[^\n]+$/, '')), !1);
        }),
        typeof r > 'u' ? (r = this.raw(t, null, 'beforeDecl')) : r && (r = r.replace(/\S/g, '')),
        r
       );
      }
      rawBeforeDecl(e, t) {
       let r;
       return (
        e.walkDecls((e) => {
         if (typeof e.raws.before < 'u') return ((r = e.raws.before), r.includes('\n') && (r = r.replace(/[^\n]+$/, '')), !1);
        }),
        typeof r > 'u' ? (r = this.raw(t, null, 'beforeRule')) : r && (r = r.replace(/\S/g, '')),
        r
       );
      }
      rawBeforeOpen(e) {
       let t;
       return (
        e.walk((e) => {
         if ('decl' !== e.type && ((t = e.raws.between), typeof t < 'u')) return !1;
        }),
        t
       );
      }
      rawBeforeRule(e) {
       let t;
       return (
        e.walk((r) => {
         if (r.nodes && (r.parent !== e || e.first !== r) && typeof r.raws.before < 'u') return ((t = r.raws.before), t.includes('\n') && (t = t.replace(/[^\n]+$/, '')), !1);
        }),
        t && (t = t.replace(/\S/g, '')),
        t
       );
      }
      rawColon(e) {
       let t;
       return (
        e.walkDecls((e) => {
         if (typeof e.raws.between < 'u') return ((t = e.raws.between.replace(/[^\s:]/g, '')), !1);
        }),
        t
       );
      }
      rawEmptyBody(e) {
       let t;
       return (
        e.walk((e) => {
         if (e.nodes && 0 === e.nodes.length && ((t = e.raws.after), typeof t < 'u')) return !1;
        }),
        t
       );
      }
      rawIndent(e) {
       if (e.raws.indent) return e.raws.indent;
       let t;
       return (
        e.walk((r) => {
         let s = r.parent;
         if (s && s !== e && s.parent && s.parent === e && typeof r.raws.before < 'u') {
          let e = r.raws.before.split('\n');
          return ((t = e[e.length - 1]), (t = t.replace(/\S/g, '')), !1);
         }
        }),
        t
       );
      }
      rawSemicolon(e) {
       let t;
       return (
        e.walk((e) => {
         if (e.nodes && e.nodes.length && 'decl' === e.last.type && ((t = e.raws.semicolon), typeof t < 'u')) return !1;
        }),
        t
       );
      }
      rawValue(e, t) {
       let r = e[t],
        s = e.raws[t];
       return s && s.value === r ? s.raw : r;
      }
      root(e) {
       (this.body(e), e.raws.after && this.builder(e.raws.after));
      }
      rule(e) {
       (this.block(e, this.rawValue(e, 'selector')), e.raws.ownSemicolon && this.builder(e.raws.ownSemicolon, e, 'end'));
      }
      stringify(e, t) {
       if (!this[e.type]) throw new Error('Unknown AST node type ' + e.type + '. Maybe you need to change PostCSS stringifier.');
       this[e.type](e, t);
      }
     };
     ((t.exports = s), (s.default = s));
    }),
    y = l((e, t) => {
     var r = m();
     function s(e, t) {
      new r(t).stringify(e);
     }
     ((t.exports = s), (s.default = s));
    }),
    D = l((e, t) => {
     ((t.exports.isClean = Symbol('isClean')), (t.exports.my = Symbol('my')));
    }),
    g = l((e, t) => {
     var r = f(),
      s = m(),
      n = y(),
      { isClean: i, my: a } = D();
     function o(e, t) {
      let r = new e.constructor();
      for (let s in e) {
       if (!Object.prototype.hasOwnProperty.call(e, s) || 'proxyCache' === s) continue;
       let n = e[s],
        i = typeof n;
       'parent' === s && 'object' === i ? t && (r[s] = t) : 'source' === s ? (r[s] = n) : Array.isArray(n) ? (r[s] = n.map((e) => o(e, r))) : ('object' === i && null !== n && (n = o(n)), (r[s] = n));
      }
      return r;
     }
     function u(e, t) {
      if (t && typeof t.offset < 'u') return t.offset;
      let r = 1,
       s = 1,
       n = 0;
      for (let i = 0; i < e.length; i++) {
       if (s === t.line && r === t.column) {
        n = i;
        break;
       }
       '\n' === e[i] ? ((r = 1), (s += 1)) : (r += 1);
      }
      return n;
     }
     var l = class {
      get proxyOf() {
       return this;
      }
      constructor(e = {}) {
       ((this.raws = {}), (this[i] = !1), (this[a] = !0));
       for (let t in e)
        if ('nodes' === t) {
         this.nodes = [];
         for (let r of e[t]) 'function' == typeof r.clone ? this.append(r.clone()) : this.append(r);
        } else this[t] = e[t];
      }
      addToError(e) {
       if (((e.postcssNode = this), e.stack && this.source && /\n\s{4}at /.test(e.stack))) {
        let t = this.source;
        e.stack = e.stack.replace(/\n\s{4}at /, `$&${t.input.from}:${t.start.line}:${t.start.column}$&`);
       }
       return e;
      }
      after(e) {
       return (this.parent.insertAfter(this, e), this);
      }
      assign(e = {}) {
       for (let t in e) this[t] = e[t];
       return this;
      }
      before(e) {
       return (this.parent.insertBefore(this, e), this);
      }
      cleanRaws(e) {
       (delete this.raws.before, delete this.raws.after, e || delete this.raws.between);
      }
      clone(e = {}) {
       let t = o(this);
       for (let r in e) t[r] = e[r];
       return t;
      }
      cloneAfter(e = {}) {
       let t = this.clone(e);
       return (this.parent.insertAfter(this, t), t);
      }
      cloneBefore(e = {}) {
       let t = this.clone(e);
       return (this.parent.insertBefore(this, t), t);
      }
      error(e, t = {}) {
       if (this.source) {
        let { end: r, start: s } = this.rangeBy(t);
        return this.source.input.error(e, { column: s.column, line: s.line }, { column: r.column, line: r.line }, t);
       }
       return new r(e);
      }
      getProxyProcessor() {
       return { get: (e, t) => ('proxyOf' === t ? e : 'root' === t ? () => e.root().toProxy() : e[t]), set: (e, t, r) => (e[t] === r || ((e[t] = r), ('prop' === t || 'value' === t || 'name' === t || 'params' === t || 'important' === t || 'text' === t) && e.markDirty()), !0) };
      }
      markClean() {
       this[i] = !0;
      }
      markDirty() {
       if (this[i]) {
        this[i] = !1;
        let e = this;
        for (; (e = e.parent); ) e[i] = !1;
       }
      }
      next() {
       if (!this.parent) return;
       let e = this.parent.index(this);
       return this.parent.nodes[e + 1];
      }
      positionBy(e = {}) {
       let t = this.source.start;
       if (e.index) t = this.positionInside(e.index);
       else if (e.word) {
        let r = 'document' in this.source.input ? this.source.input.document : this.source.input.css,
         s = r.slice(u(r, this.source.start), u(r, this.source.end)).indexOf(e.word);
        -1 !== s && (t = this.positionInside(s));
       }
       return t;
      }
      positionInside(e) {
       let t = this.source.start.column,
        r = this.source.start.line,
        s = 'document' in this.source.input ? this.source.input.document : this.source.input.css,
        n = u(s, this.source.start),
        i = n + e;
       for (let a = n; a < i; a++) '\n' === s[a] ? ((t = 1), (r += 1)) : (t += 1);
       return { column: t, line: r, offset: i };
      }
      prev() {
       if (!this.parent) return;
       let e = this.parent.index(this);
       return this.parent.nodes[e - 1];
      }
      rangeBy(e = {}) {
       let t = 'document' in this.source.input ? this.source.input.document : this.source.input.css,
        r = { column: this.source.start.column, line: this.source.start.line, offset: u(t, this.source.start) },
        s = this.source.end ? { column: this.source.end.column + 1, line: this.source.end.line, offset: 'number' == typeof this.source.end.offset ? this.source.end.offset : u(t, this.source.end) + 1 } : { column: r.column + 1, line: r.line, offset: r.offset + 1 };
       if (e.word) {
        let n = t.slice(u(t, this.source.start), u(t, this.source.end)).indexOf(e.word);
        -1 !== n && ((r = this.positionInside(n)), (s = this.positionInside(n + e.word.length)));
       } else (e.start ? (r = { column: e.start.column, line: e.start.line, offset: u(t, e.start) }) : e.index && (r = this.positionInside(e.index)), e.end ? (s = { column: e.end.column, line: e.end.line, offset: u(t, e.end) }) : 'number' == typeof e.endIndex ? (s = this.positionInside(e.endIndex)) : e.index && (s = this.positionInside(e.index + 1)));
       return ((s.line < r.line || (s.line === r.line && s.column <= r.column)) && (s = { column: r.column + 1, line: r.line, offset: r.offset + 1 }), { end: s, start: r });
      }
      raw(e, t) {
       return new s().raw(this, e, t);
      }
      remove() {
       return (this.parent && this.parent.removeChild(this), (this.parent = void 0), this);
      }
      replaceWith(...e) {
       if (this.parent) {
        let t = this,
         r = !1;
        for (let s of e) s === this ? (r = !0) : r ? (this.parent.insertAfter(t, s), (t = s)) : this.parent.insertBefore(t, s);
        r || this.remove();
       }
       return this;
      }
      root() {
       let e = this;
       for (; e.parent && 'document' !== e.parent.type; ) e = e.parent;
       return e;
      }
      toJSON(e, t) {
       let r = {},
        s = null == t;
       t = t || new Map();
       let n = 0;
       for (let i in this) {
        if (!Object.prototype.hasOwnProperty.call(this, i) || 'parent' === i || 'proxyCache' === i) continue;
        let e = this[i];
        if (Array.isArray(e)) r[i] = e.map((e) => ('object' == typeof e && e.toJSON ? e.toJSON(null, t) : e));
        else if ('object' == typeof e && e.toJSON) r[i] = e.toJSON(null, t);
        else if ('source' === i) {
         if (null == e) continue;
         let s = t.get(e.input);
         (null == s && ((s = n), t.set(e.input, n), n++), (r[i] = { end: e.end, inputId: s, start: e.start }));
        } else r[i] = e;
       }
       return (s && (r.inputs = [...t.keys()].map((e) => e.toJSON())), r);
      }
      toProxy() {
       return (this.proxyCache || (this.proxyCache = new Proxy(this, this.getProxyProcessor())), this.proxyCache);
      }
      toString(e = n) {
       e.stringify && (e = e.stringify);
       let t = '';
       return (
        e(this, (e) => {
         t += e;
        }),
        t
       );
      }
      warn(e, t, r = {}) {
       let s = { node: this };
       for (let n in r) s[n] = r[n];
       return e.warn(t, s);
      }
     };
     ((t.exports = l), (l.default = l));
    }),
    x = l((e, t) => {
     var r = g(),
      s = class extends r {
       constructor(e) {
        (super(e), (this.type = 'comment'));
       }
      };
     ((t.exports = s), (s.default = s));
    }),
    E = l((e, t) => {
     var r = g(),
      s = class extends r {
       get variable() {
        return this.prop.startsWith('--') || '$' === this.prop[0];
       }
       constructor(e) {
        (e && typeof e.value < 'u' && 'string' != typeof e.value && (e = { ...e, value: String(e.value) }), super(e), (this.type = 'decl'));
       }
      };
     ((t.exports = s), (s.default = s));
    }),
    b = l((e, t) => {
     var r,
      s,
      n,
      i,
      a = x(),
      o = E(),
      u = g(),
      { isClean: l, my: p } = D();
     function c(e) {
      return e.map((e) => (e.nodes && (e.nodes = c(e.nodes)), delete e.source, e));
     }
     function h(e) {
      if (((e[l] = !1), e.proxyOf.nodes)) for (let t of e.proxyOf.nodes) h(t);
     }
     var d = class e extends u {
      get first() {
       if (this.proxyOf.nodes) return this.proxyOf.nodes[0];
      }
      get last() {
       if (this.proxyOf.nodes) return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
      }
      append(...e) {
       for (let t of e) {
        let e = this.normalize(t, this.last);
        for (let t of e) this.proxyOf.nodes.push(t);
       }
       return (this.markDirty(), this);
      }
      cleanRaws(e) {
       if ((super.cleanRaws(e), this.nodes)) for (let t of this.nodes) t.cleanRaws(e);
      }
      each(e) {
       if (!this.proxyOf.nodes) return;
       let t,
        r,
        s = this.getIterator();
       for (; this.indexes[s] < this.proxyOf.nodes.length && ((t = this.indexes[s]), (r = e(this.proxyOf.nodes[t], t)), !1 !== r); ) this.indexes[s] += 1;
       return (delete this.indexes[s], r);
      }
      every(e) {
       return this.nodes.every(e);
      }
      getIterator() {
       (this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), (this.lastEach += 1));
       let e = this.lastEach;
       return ((this.indexes[e] = 0), e);
      }
      getProxyProcessor() {
       return { get: (e, t) => ('proxyOf' === t ? e : e[t] ? ('each' === t || ('string' == typeof t && t.startsWith('walk')) ? (...r) => e[t](...r.map((e) => ('function' == typeof e ? (t, r) => e(t.toProxy(), r) : e))) : 'every' === t || 'some' === t ? (r) => e[t]((e, ...t) => r(e.toProxy(), ...t)) : 'root' === t ? () => e.root().toProxy() : 'nodes' === t ? e.nodes.map((e) => e.toProxy()) : 'first' === t || 'last' === t ? e[t].toProxy() : e[t]) : e[t]), set: (e, t, r) => (e[t] === r || ((e[t] = r), ('name' === t || 'params' === t || 'selector' === t) && e.markDirty()), !0) };
      }
      index(e) {
       return 'number' == typeof e ? e : (e.proxyOf && (e = e.proxyOf), this.proxyOf.nodes.indexOf(e));
      }
      insertAfter(e, t) {
       let r,
        s = this.index(e),
        n = this.normalize(t, this.proxyOf.nodes[s]).reverse();
       s = this.index(e);
       for (let i of n) this.proxyOf.nodes.splice(s + 1, 0, i);
       for (let i in this.indexes) ((r = this.indexes[i]), s < r && (this.indexes[i] = r + n.length));
       return (this.markDirty(), this);
      }
      insertBefore(e, t) {
       let r,
        s = this.index(e),
        n = 0 === s && 'prepend',
        i = this.normalize(t, this.proxyOf.nodes[s], n).reverse();
       s = this.index(e);
       for (let a of i) this.proxyOf.nodes.splice(s, 0, a);
       for (let a in this.indexes) ((r = this.indexes[a]), s <= r && (this.indexes[a] = r + i.length));
       return (this.markDirty(), this);
      }
      normalize(t, n) {
       if ('string' == typeof t) t = c(s(t).nodes);
       else if (typeof t > 'u') t = [];
       else if (Array.isArray(t)) {
        t = t.slice(0);
        for (let e of t) e.parent && e.parent.removeChild(e, 'ignore');
       } else if ('root' === t.type && 'document' !== this.type) {
        t = t.nodes.slice(0);
        for (let e of t) e.parent && e.parent.removeChild(e, 'ignore');
       } else if (t.type) t = [t];
       else if (t.prop) {
        if (typeof t.value > 'u') throw new Error('Value field is missed in node creation');
        ('string' != typeof t.value && (t.value = String(t.value)), (t = [new o(t)]));
       } else if (t.selector || t.selectors) t = [new i(t)];
       else if (t.name) t = [new r(t)];
       else {
        if (!t.text) throw new Error('Unknown node type in node creation');
        t = [new a(t)];
       }
       return t.map((t) => (t[p] || e.rebuild(t), (t = t.proxyOf).parent && t.parent.removeChild(t), t[l] && h(t), t.raws || (t.raws = {}), typeof t.raws.before > 'u' && n && typeof n.raws.before < 'u' && (t.raws.before = n.raws.before.replace(/\S/g, '')), (t.parent = this.proxyOf), t));
      }
      prepend(...e) {
       e = e.reverse();
       for (let t of e) {
        let e = this.normalize(t, this.first, 'prepend').reverse();
        for (let t of e) this.proxyOf.nodes.unshift(t);
        for (let t in this.indexes) this.indexes[t] = this.indexes[t] + e.length;
       }
       return (this.markDirty(), this);
      }
      push(e) {
       return ((e.parent = this), this.proxyOf.nodes.push(e), this);
      }
      removeAll() {
       for (let e of this.proxyOf.nodes) e.parent = void 0;
       return ((this.proxyOf.nodes = []), this.markDirty(), this);
      }
      removeChild(e) {
       let t;
       ((e = this.index(e)), (this.proxyOf.nodes[e].parent = void 0), this.proxyOf.nodes.splice(e, 1));
       for (let r in this.indexes) ((t = this.indexes[r]), t >= e && (this.indexes[r] = t - 1));
       return (this.markDirty(), this);
      }
      replaceValues(e, t, r) {
       return (
        r || ((r = t), (t = {})),
        this.walkDecls((s) => {
         (t.props && !t.props.includes(s.prop)) || (t.fast && !s.value.includes(t.fast)) || (s.value = s.value.replace(e, r));
        }),
        this.markDirty(),
        this
       );
      }
      some(e) {
       return this.nodes.some(e);
      }
      walk(e) {
       return this.each((t, r) => {
        let s;
        try {
         s = e(t, r);
        } catch (n) {
         throw t.addToError(n);
        }
        return (!1 !== s && t.walk && (s = t.walk(e)), s);
       });
      }
      walkAtRules(e, t) {
       return t
        ? e instanceof RegExp
          ? this.walk((r, s) => {
             if ('atrule' === r.type && e.test(r.name)) return t(r, s);
            })
          : this.walk((r, s) => {
             if ('atrule' === r.type && r.name === e) return t(r, s);
            })
        : ((t = e),
          this.walk((e, r) => {
           if ('atrule' === e.type) return t(e, r);
          }));
      }
      walkComments(e) {
       return this.walk((t, r) => {
        if ('comment' === t.type) return e(t, r);
       });
      }
      walkDecls(e, t) {
       return t
        ? e instanceof RegExp
          ? this.walk((r, s) => {
             if ('decl' === r.type && e.test(r.prop)) return t(r, s);
            })
          : this.walk((r, s) => {
             if ('decl' === r.type && r.prop === e) return t(r, s);
            })
        : ((t = e),
          this.walk((e, r) => {
           if ('decl' === e.type) return t(e, r);
          }));
      }
      walkRules(e, t) {
       return t
        ? e instanceof RegExp
          ? this.walk((r, s) => {
             if ('rule' === r.type && e.test(r.selector)) return t(r, s);
            })
          : this.walk((r, s) => {
             if ('rule' === r.type && r.selector === e) return t(r, s);
            })
        : ((t = e),
          this.walk((e, r) => {
           if ('rule' === e.type) return t(e, r);
          }));
      }
     };
     ((d.registerParse = (e) => {
      s = e;
     }),
      (d.registerRule = (e) => {
       i = e;
      }),
      (d.registerAtRule = (e) => {
       r = e;
      }),
      (d.registerRoot = (e) => {
       n = e;
      }),
      (t.exports = d),
      (d.default = d),
      (d.rebuild = (e) => {
       ('atrule' === e.type ? Object.setPrototypeOf(e, r.prototype) : 'rule' === e.type ? Object.setPrototypeOf(e, i.prototype) : 'decl' === e.type ? Object.setPrototypeOf(e, o.prototype) : 'comment' === e.type ? Object.setPrototypeOf(e, a.prototype) : 'root' === e.type && Object.setPrototypeOf(e, n.prototype),
        (e[p] = !0),
        e.nodes &&
         e.nodes.forEach((e) => {
          d.rebuild(e);
         }));
      }));
    }),
    T = l((e, t) => {
     t.exports = {
      nanoid: (e = 21) => {
       let t = '',
        r = 0 | e;
       for (; r--; ) t += 'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'[(64 * Math.random()) | 0];
       return t;
      },
      customAlphabet:
       (e, t = 21) =>
       (r = t) => {
        let s = '',
         n = 0 | r;
        for (; n--; ) s += e[(Math.random() * e.length) | 0];
        return s;
       },
     };
    }),
    C = l(() => {}),
    F = l((e, t) => {
     t.exports = class {};
    }),
    A = l((e, t) => {
     var { nanoid: r } = T(),
      { isAbsolute: s, resolve: n } = {},
      { SourceMapConsumer: i, SourceMapGenerator: a } = C(),
      { fileURLToPath: o, pathToFileURL: u } = {},
      l = f(),
      p = F(),
      c = d(),
      h = Symbol('lineToIndexCache'),
      m = !(!i || !a),
      y = !(!n || !s);
     function D(e) {
      if (e[h]) return e[h];
      let t = e.css.split('\n'),
       r = new Array(t.length),
       s = 0;
      for (let n = 0, i = t.length; n < i; n++) ((r[n] = s), (s += t[n].length + 1));
      return ((e[h] = r), r);
     }
     var g = class {
      get from() {
       return this.file || this.id;
      }
      constructor(e, t = {}) {
       if (null === e || typeof e > 'u' || ('object' == typeof e && !e.toString)) throw new Error(`PostCSS received ${e} instead of CSS string`);
       if (((this.css = e.toString()), '\ufeff' === this.css[0] || '\ufffe' === this.css[0] ? ((this.hasBOM = !0), (this.css = this.css.slice(1))) : (this.hasBOM = !1), (this.document = this.css), t.document && (this.document = t.document.toString()), t.from && (!y || /^\w+:\/\//.test(t.from) || s(t.from) ? (this.file = t.from) : (this.file = n(t.from))), y && m)) {
        let e = new p(this.css, t);
        if (e.text) {
         this.map = e;
         let t = e.consumer().file;
         !this.file && t && (this.file = this.mapResolve(t));
        }
       }
       (this.file || (this.id = '<input css ' + r(6) + '>'), this.map && (this.map.file = this.from));
      }
      error(e, t, r, s = {}) {
       let n, i, a, o, p;
       if (t && 'object' == typeof t) {
        let e = t,
         s = r;
        if ('number' == typeof e.offset) {
         o = e.offset;
         let s = this.fromOffset(o);
         ((t = s.line), (r = s.col));
        } else ((t = e.line), (r = e.column), (o = this.fromLineAndColumn(t, r)));
        if ('number' == typeof s.offset) {
         a = s.offset;
         let e = this.fromOffset(a);
         ((i = e.line), (n = e.col));
        } else ((i = s.line), (n = s.column), (a = this.fromLineAndColumn(s.line, s.column)));
       } else if (r) o = this.fromLineAndColumn(t, r);
       else {
        o = t;
        let e = this.fromOffset(o);
        ((t = e.line), (r = e.col));
       }
       let c = this.origin(t, r, i, n);
       return ((p = c ? new l(e, void 0 === c.endLine ? c.line : { column: c.column, line: c.line }, void 0 === c.endLine ? c.column : { column: c.endColumn, line: c.endLine }, c.source, c.file, s.plugin) : new l(e, void 0 === i ? t : { column: r, line: t }, void 0 === i ? r : { column: n, line: i }, this.css, this.file, s.plugin)), (p.input = { column: r, endColumn: n, endLine: i, endOffset: a, line: t, offset: o, source: this.css }), this.file && (u && (p.input.url = u(this.file).toString()), (p.input.file = this.file)), p);
      }
      fromLineAndColumn(e, t) {
       return D(this)[e - 1] + t - 1;
      }
      fromOffset(e) {
       let t = D(this),
        r = 0;
       if (e >= t[t.length - 1]) r = t.length - 1;
       else {
        let s,
         n = t.length - 2;
        for (; r < n; )
         if (((s = r + ((n - r) >> 1)), e < t[s])) n = s - 1;
         else {
          if (!(e >= t[s + 1])) {
           r = s;
           break;
          }
          r = s + 1;
         }
       }
       return { col: e - t[r] + 1, line: r + 1 };
      }
      mapResolve(e) {
       return /^\w+:\/\//.test(e) ? e : n(this.map.consumer().sourceRoot || this.map.root || '.', e);
      }
      origin(e, t, r, n) {
       if (!this.map) return !1;
       let i,
        a,
        l = this.map.consumer(),
        p = l.originalPositionFor({ column: t, line: e });
       if (!p.source) return !1;
       ('number' == typeof r && (i = l.originalPositionFor({ column: n, line: r })), (a = s(p.source) ? u(p.source) : new URL(p.source, this.map.consumer().sourceRoot || u(this.map.mapFile))));
       let c = { column: p.column, endColumn: i && i.column, endLine: i && i.line, line: p.line, url: a.toString() };
       if ('file:' === a.protocol) {
        if (!o) throw new Error('file: protocol is not available in this PostCSS build');
        c.file = o(a);
       }
       let h = l.sourceContentFor(p.source);
       return (h && (c.source = h), c);
      }
      toJSON() {
       let e = {};
       for (let t of ['hasBOM', 'css', 'file', 'id']) null != this[t] && (e[t] = this[t]);
       return (this.map && ((e.map = { ...this.map }), e.map.consumerCache && (e.map.consumerCache = void 0)), e);
      }
     };
     ((t.exports = g), (g.default = g), c && c.registerInput && c.registerInput(g));
    }),
    w = l((e, t) => {
     var r = b(),
      s = class extends r {
       constructor(e) {
        (super(e), (this.type = 'atrule'));
       }
       append(...e) {
        return (this.proxyOf.nodes || (this.nodes = []), super.append(...e));
       }
       prepend(...e) {
        return (this.proxyOf.nodes || (this.nodes = []), super.prepend(...e));
       }
      };
     ((t.exports = s), (s.default = s), r.registerAtRule(s));
    }),
    S = l((e, t) => {
     var r,
      s,
      n = b(),
      i = class extends n {
       constructor(e) {
        (super(e), (this.type = 'root'), this.nodes || (this.nodes = []));
       }
       normalize(e, t, r) {
        let s = super.normalize(e);
        if (t)
         if ('prepend' === r) this.nodes.length > 1 ? (t.raws.before = this.nodes[1].raws.before) : delete t.raws.before;
         else if (this.first !== t) for (let n of s) n.raws.before = t.raws.before;
        return s;
       }
       removeChild(e, t) {
        let r = this.index(e);
        return (!t && 0 === r && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[r].raws.before), super.removeChild(e));
       }
       toResult(e = {}) {
        return new r(new s(), this, e).stringify();
       }
      };
     ((i.registerLazyResult = (e) => {
      r = e;
     }),
      (i.registerProcessor = (e) => {
       s = e;
      }),
      (t.exports = i),
      (i.default = i),
      n.registerRoot(i));
    }),
    v = l((e, t) => {
     var r = {
      comma: (e) => r.split(e, [','], !0),
      space(e) {
       let t = [' ', '\n', '\t'];
       return r.split(e, t);
      },
      split(e, t, r) {
       let s = [],
        n = '',
        i = !1,
        a = 0,
        o = !1,
        u = '',
        l = !1;
       for (let p of e) (l ? (l = !1) : '\\' === p ? (l = !0) : o ? p === u && (o = !1) : '"' === p || "'" === p ? ((o = !0), (u = p)) : '(' === p ? (a += 1) : ')' === p ? a > 0 && (a -= 1) : 0 === a && t.includes(p) && (i = !0), i ? ('' !== n && s.push(n.trim()), (n = ''), (i = !1)) : (n += p));
       return ((r || '' !== n) && s.push(n.trim()), s);
      },
     };
     ((t.exports = r), (r.default = r));
    }),
    P = l((e, t) => {
     var r = b(),
      s = v(),
      n = class extends r {
       get selectors() {
        return s.comma(this.selector);
       }
       set selectors(e) {
        let t = this.selector ? this.selector.match(/,\s*/) : null,
         r = t ? t[0] : ',' + this.raw('between', 'beforeOpen');
        this.selector = e.join(r);
       }
       constructor(e) {
        (super(e), (this.type = 'rule'), this.nodes || (this.nodes = []));
       }
      };
     ((t.exports = n), (n.default = n), r.registerRule(n));
    }),
    k = l((e, t) => {
     var r = /[\t\n\f\r "#'()/;[\\\]{}]/g,
      s = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g,
      n = /.[\r\n"'(/\\]/,
      i = /[\da-f]/i;
     t.exports = function (e, t = {}) {
      let a,
       o,
       u,
       l,
       p,
       c,
       h,
       d,
       f,
       m,
       y = e.css.valueOf(),
       D = t.ignoreErrors,
       g = y.length,
       x = 0,
       E = [],
       b = [];
      function T(t) {
       throw e.error('Unclosed ' + t, x);
      }
      return {
       back: function (e) {
        b.push(e);
       },
       endOfFile: function () {
        return 0 === b.length && x >= g;
       },
       nextToken: function (e) {
        if (b.length) return b.pop();
        if (x >= g) return;
        let t = !!e && e.ignoreUnclosed;
        switch (((a = y.charCodeAt(x)), a)) {
         case 10:
         case 32:
         case 9:
         case 13:
         case 12:
          l = x;
          do {
           ((l += 1), (a = y.charCodeAt(l)));
          } while (32 === a || 10 === a || 9 === a || 13 === a || 12 === a);
          ((c = ['space', y.slice(x, l)]), (x = l - 1));
          break;
         case 91:
         case 93:
         case 123:
         case 125:
         case 58:
         case 59:
         case 41: {
          let e = String.fromCharCode(a);
          c = [e, e, x];
          break;
         }
         case 40:
          if (((m = E.length ? E.pop()[1] : ''), (f = y.charCodeAt(x + 1)), 'url' === m && 39 !== f && 34 !== f && 32 !== f && 10 !== f && 9 !== f && 12 !== f && 13 !== f)) {
           l = x;
           do {
            if (((h = !1), (l = y.indexOf(')', l + 1)), -1 === l)) {
             if (D || t) {
              l = x;
              break;
             }
             T('bracket');
            }
            for (d = l; 92 === y.charCodeAt(d - 1); ) ((d -= 1), (h = !h));
           } while (h);
           ((c = ['brackets', y.slice(x, l + 1), x, l]), (x = l));
          } else ((l = y.indexOf(')', x + 1)), (o = y.slice(x, l + 1)), -1 === l || n.test(o) ? (c = ['(', '(', x]) : ((c = ['brackets', o, x, l]), (x = l)));
          break;
         case 39:
         case 34:
          ((p = 39 === a ? "'" : '"'), (l = x));
          do {
           if (((h = !1), (l = y.indexOf(p, l + 1)), -1 === l)) {
            if (D || t) {
             l = x + 1;
             break;
            }
            T('string');
           }
           for (d = l; 92 === y.charCodeAt(d - 1); ) ((d -= 1), (h = !h));
          } while (h);
          ((c = ['string', y.slice(x, l + 1), x, l]), (x = l));
          break;
         case 64:
          ((r.lastIndex = x + 1), r.test(y), (l = 0 === r.lastIndex ? y.length - 1 : r.lastIndex - 2), (c = ['at-word', y.slice(x, l + 1), x, l]), (x = l));
          break;
         case 92:
          for (l = x, u = !0; 92 === y.charCodeAt(l + 1); ) ((l += 1), (u = !u));
          if (((a = y.charCodeAt(l + 1)), u && 47 !== a && 32 !== a && 10 !== a && 9 !== a && 13 !== a && 12 !== a && ((l += 1), i.test(y.charAt(l))))) {
           for (; i.test(y.charAt(l + 1)); ) l += 1;
           32 === y.charCodeAt(l + 1) && (l += 1);
          }
          ((c = ['word', y.slice(x, l + 1), x, l]), (x = l));
          break;
         default:
          47 === a && 42 === y.charCodeAt(x + 1) ? ((l = y.indexOf('*/', x + 2) + 1), 0 === l && (D || t ? (l = y.length) : T('comment')), (c = ['comment', y.slice(x, l + 1), x, l]), (x = l)) : ((s.lastIndex = x + 1), s.test(y), (l = 0 === s.lastIndex ? y.length - 1 : s.lastIndex - 2), (c = ['word', y.slice(x, l + 1), x, l]), E.push(c), (x = l));
        }
        return (x++, c);
       },
       position: function () {
        return x;
       },
      };
     };
    }),
    I = l((e, t) => {
     var r = w(),
      s = x(),
      n = E(),
      i = S(),
      a = P(),
      o = k(),
      u = { empty: !0, space: !0 };
     t.exports = class {
      constructor(e) {
       ((this.input = e), (this.root = new i()), (this.current = this.root), (this.spaces = ''), (this.semicolon = !1), this.createTokenizer(), (this.root.source = { input: e, start: { column: 1, line: 1, offset: 0 } }));
      }
      atrule(e) {
       let t = new r();
       ((t.name = e[1].slice(1)), '' === t.name && this.unnamedAtrule(t, e), this.init(t, e[2]));
       let s,
        n,
        i,
        a = !1,
        o = !1,
        u = [],
        l = [];
       for (; !this.tokenizer.endOfFile(); ) {
        if (((s = (e = this.tokenizer.nextToken())[0]), '(' === s || '[' === s ? l.push('(' === s ? ')' : ']') : '{' === s && l.length > 0 ? l.push('}') : s === l[l.length - 1] && l.pop(), 0 === l.length)) {
         if (';' === s) {
          ((t.source.end = this.getPosition(e[2])), t.source.end.offset++, (this.semicolon = !0));
          break;
         }
         if ('{' === s) {
          o = !0;
          break;
         }
         if ('}' === s) {
          if (u.length > 0) {
           for (i = u.length - 1, n = u[i]; n && 'space' === n[0]; ) n = u[--i];
           n && ((t.source.end = this.getPosition(n[3] || n[2])), t.source.end.offset++);
          }
          this.end(e);
          break;
         }
         u.push(e);
        } else u.push(e);
        if (this.tokenizer.endOfFile()) {
         a = !0;
         break;
        }
       }
       ((t.raws.between = this.spacesAndCommentsFromEnd(u)), u.length ? ((t.raws.afterName = this.spacesAndCommentsFromStart(u)), this.raw(t, 'params', u), a && ((e = u[u.length - 1]), (t.source.end = this.getPosition(e[3] || e[2])), t.source.end.offset++, (this.spaces = t.raws.between), (t.raws.between = ''))) : ((t.raws.afterName = ''), (t.params = '')), o && ((t.nodes = []), (this.current = t)));
      }
      checkMissedSemicolon(e) {
       let t = this.colon(e);
       if (!1 === t) return;
       let r,
        s = 0;
       for (let n = t - 1; n >= 0 && ((r = e[n]), 'space' === r[0] || ((s += 1), 2 !== s)); n--);
       throw this.input.error('Missed semicolon', 'word' === r[0] ? r[3] + 1 : r[2]);
      }
      colon(e) {
       let t,
        r,
        s,
        n = 0;
       for (let [i, a] of e.entries()) {
        if (((r = a), (s = r[0]), '(' === s && (n += 1), ')' === s && (n -= 1), 0 === n && ':' === s)) {
         if (t) {
          if ('word' === t[0] && 'progid' === t[1]) continue;
          return i;
         }
         this.doubleColon(r);
        }
        t = r;
       }
       return !1;
      }
      comment(e) {
       let t = new s();
       (this.init(t, e[2]), (t.source.end = this.getPosition(e[3] || e[2])), t.source.end.offset++);
       let r = e[1].slice(2, -2);
       if (/^\s*$/.test(r)) ((t.text = ''), (t.raws.left = r), (t.raws.right = ''));
       else {
        let e = r.match(/^(\s*)([^]*\S)(\s*)$/);
        ((t.text = e[2]), (t.raws.left = e[1]), (t.raws.right = e[3]));
       }
      }
      createTokenizer() {
       this.tokenizer = o(this.input);
      }
      decl(e, t) {
       let r = new n();
       this.init(r, e[0][2]);
       let s,
        i = e[e.length - 1];
       for (
        ';' === i[0] && ((this.semicolon = !0), e.pop()),
         r.source.end = this.getPosition(
          i[3] ||
           i[2] ||
           (function (e) {
            for (let t = e.length - 1; t >= 0; t--) {
             let r = e[t],
              s = r[3] || r[2];
             if (s) return s;
            }
           })(e),
         ),
         r.source.end.offset++;
        'word' !== e[0][0];
       )
        (1 === e.length && this.unknownWord(e), (r.raws.before += e.shift()[1]));
       for (r.source.start = this.getPosition(e[0][2]), r.prop = ''; e.length; ) {
        let t = e[0][0];
        if (':' === t || 'space' === t || 'comment' === t) break;
        r.prop += e.shift()[1];
       }
       for (r.raws.between = ''; e.length; ) {
        if (((s = e.shift()), ':' === s[0])) {
         r.raws.between += s[1];
         break;
        }
        ('word' === s[0] && /\w/.test(s[1]) && this.unknownWord([s]), (r.raws.between += s[1]));
       }
       ('_' === r.prop[0] || '*' === r.prop[0]) && ((r.raws.before += r.prop[0]), (r.prop = r.prop.slice(1)));
       let a,
        o = [];
       for (; e.length && ((a = e[0][0]), 'space' === a || 'comment' === a); ) o.push(e.shift());
       this.precheckMissedSemicolon(e);
       for (let n = e.length - 1; n >= 0; n--) {
        if (((s = e[n]), '!important' === s[1].toLowerCase())) {
         r.important = !0;
         let t = this.stringFrom(e, n);
         ((t = this.spacesFromEnd(e) + t), ' !important' !== t && (r.raws.important = t));
         break;
        }
        if ('important' === s[1].toLowerCase()) {
         let t = e.slice(0),
          s = '';
         for (let e = n; e > 0; e--) {
          let r = t[e][0];
          if (s.trim().startsWith('!') && 'space' !== r) break;
          s = t.pop()[1] + s;
         }
         s.trim().startsWith('!') && ((r.important = !0), (r.raws.important = s), (e = t));
        }
        if ('space' !== s[0] && 'comment' !== s[0]) break;
       }
       (e.some((e) => 'space' !== e[0] && 'comment' !== e[0]) && ((r.raws.between += o.map((e) => e[1]).join('')), (o = [])), this.raw(r, 'value', o.concat(e), t), r.value.includes(':') && !t && this.checkMissedSemicolon(e));
      }
      doubleColon(e) {
       throw this.input.error('Double colon', { offset: e[2] }, { offset: e[2] + e[1].length });
      }
      emptyRule(e) {
       let t = new a();
       (this.init(t, e[2]), (t.selector = ''), (t.raws.between = ''), (this.current = t));
      }
      end(e) {
       (this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), (this.semicolon = !1), (this.current.raws.after = (this.current.raws.after || '') + this.spaces), (this.spaces = ''), this.current.parent ? ((this.current.source.end = this.getPosition(e[2])), this.current.source.end.offset++, (this.current = this.current.parent)) : this.unexpectedClose(e));
      }
      endFile() {
       (this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), (this.current.raws.after = (this.current.raws.after || '') + this.spaces), (this.root.source.end = this.getPosition(this.tokenizer.position())));
      }
      freeSemicolon(e) {
       if (((this.spaces += e[1]), this.current.nodes)) {
        let t = this.current.nodes[this.current.nodes.length - 1];
        t && 'rule' === t.type && !t.raws.ownSemicolon && ((t.raws.ownSemicolon = this.spaces), (this.spaces = ''), (t.source.end = this.getPosition(e[2])), (t.source.end.offset += t.raws.ownSemicolon.length));
       }
      }
      getPosition(e) {
       let t = this.input.fromOffset(e);
       return { column: t.col, line: t.line, offset: e };
      }
      init(e, t) {
       (this.current.push(e), (e.source = { input: this.input, start: this.getPosition(t) }), (e.raws.before = this.spaces), (this.spaces = ''), 'comment' !== e.type && (this.semicolon = !1));
      }
      other(e) {
       let t = !1,
        r = null,
        s = !1,
        n = null,
        i = [],
        a = e[1].startsWith('--'),
        o = [],
        u = e;
       for (; u; ) {
        if (((r = u[0]), o.push(u), '(' === r || '[' === r)) (n || (n = u), i.push('(' === r ? ')' : ']'));
        else if (a && s && '{' === r) (n || (n = u), i.push('}'));
        else if (0 === i.length) {
         if (';' === r) {
          if (s) return void this.decl(o, a);
          break;
         }
         if ('{' === r) return void this.rule(o);
         if ('}' === r) {
          (this.tokenizer.back(o.pop()), (t = !0));
          break;
         }
         ':' === r && (s = !0);
        } else r === i[i.length - 1] && (i.pop(), 0 === i.length && (n = null));
        u = this.tokenizer.nextToken();
       }
       if ((this.tokenizer.endOfFile() && (t = !0), i.length > 0 && this.unclosedBracket(n), t && s)) {
        if (!a) for (; o.length && ((u = o[o.length - 1][0]), 'space' === u || 'comment' === u); ) this.tokenizer.back(o.pop());
        this.decl(o, a);
       } else this.unknownWord(o);
      }
      parse() {
       let e;
       for (; !this.tokenizer.endOfFile(); )
        switch (((e = this.tokenizer.nextToken()), e[0])) {
         case 'space':
          this.spaces += e[1];
          break;
         case ';':
          this.freeSemicolon(e);
          break;
         case '}':
          this.end(e);
          break;
         case 'comment':
          this.comment(e);
          break;
         case 'at-word':
          this.atrule(e);
          break;
         case '{':
          this.emptyRule(e);
          break;
         default:
          this.other(e);
        }
       this.endFile();
      }
      precheckMissedSemicolon() {}
      raw(e, t, r, s) {
       let n,
        i,
        a,
        o,
        l = r.length,
        p = '',
        c = !0;
       for (let h = 0; h < l; h += 1) ((n = r[h]), (i = n[0]), 'space' !== i || h !== l - 1 || s ? ('comment' === i ? ((o = r[h - 1] ? r[h - 1][0] : 'empty'), (a = r[h + 1] ? r[h + 1][0] : 'empty'), u[o] || u[a] || ',' === p.slice(-1) ? (c = !1) : (p += n[1])) : (p += n[1])) : (c = !1));
       if (!c) {
        let s = r.reduce((e, t) => e + t[1], '');
        e.raws[t] = { raw: s, value: p };
       }
       e[t] = p;
      }
      rule(e) {
       e.pop();
       let t = new a();
       (this.init(t, e[0][2]), (t.raws.between = this.spacesAndCommentsFromEnd(e)), this.raw(t, 'selector', e), (this.current = t));
      }
      spacesAndCommentsFromEnd(e) {
       let t,
        r = '';
       for (; e.length && ((t = e[e.length - 1][0]), 'space' === t || 'comment' === t); ) r = e.pop()[1] + r;
       return r;
      }
      spacesAndCommentsFromStart(e) {
       let t,
        r = '';
       for (; e.length && ((t = e[0][0]), 'space' === t || 'comment' === t); ) r += e.shift()[1];
       return r;
      }
      spacesFromEnd(e) {
       let t,
        r = '';
       for (; e.length && ((t = e[e.length - 1][0]), 'space' === t); ) r = e.pop()[1] + r;
       return r;
      }
      stringFrom(e, t) {
       let r = '';
       for (let s = t; s < e.length; s++) r += e[s][1];
       return (e.splice(t, e.length - t), r);
      }
      unclosedBlock() {
       let e = this.current.source.start;
       throw this.input.error('Unclosed block', e.line, e.column);
      }
      unclosedBracket(e) {
       throw this.input.error('Unclosed bracket', { offset: e[2] }, { offset: e[2] + 1 });
      }
      unexpectedClose(e) {
       throw this.input.error('Unexpected }', { offset: e[2] }, { offset: e[2] + 1 });
      }
      unknownWord(e) {
       throw this.input.error('Unknown word ' + e[0][1], { offset: e[0][2] }, { offset: e[0][2] + e[0][1].length });
      }
      unnamedAtrule(e, t) {
       throw this.input.error('At-rule without name', { offset: t[2] }, { offset: t[2] + t[1].length });
      }
     };
    }),
    N = l((e, t) => {
     var r = b(),
      s = A(),
      n = I();
     function i(e, t) {
      let r = new s(e, t),
       i = new n(r);
      try {
       i.parse();
      } catch (a) {
       throw a;
      }
      return i.root;
     }
     ((t.exports = i), (i.default = i), r.registerParse(i));
    }),
    B = l((e, t) => {
     var r = k(),
      s = A();
     t.exports = {
      isInlineComment(e) {
       if ('word' === e[0] && '//' === e[1].slice(0, 2)) {
        let t,
         n,
         i = e,
         a = [];
        for (; e; ) {
         if (/\r?\n/.test(e[1])) {
          if (/['"].*\r?\n/.test(e[1])) {
           (a.push(e[1].substring(0, e[1].indexOf('\n'))), (n = e[1].substring(e[1].indexOf('\n'))));
           let r = this.input.css.valueOf().substring(this.tokenizer.position());
           ((n += r), (t = e[3] + r.length - n.length));
          } else this.tokenizer.back(e);
          break;
         }
         (a.push(e[1]), (t = e[2]), (e = this.tokenizer.nextToken({ ignoreUnclosed: !0 })));
        }
        let o = ['comment', a.join(''), i[2], t];
        return (this.inlineComment(o), n && ((this.input = new s(n)), (this.tokenizer = r(this.input))), !0);
       }
       if ('/' === e[1]) {
        let r = this.tokenizer.nextToken({ ignoreUnclosed: !0 });
        if ('comment' === r[0] && /^\/\*/.test(r[1])) return ((r[0] = 'word'), (r[1] = r[1].slice(1)), (e[1] = '//'), this.tokenizer.back(r), t.exports.isInlineComment.bind(this)(e));
       }
       return !1;
      },
     };
    }),
    O = l((e, t) => {
     t.exports = {
      interpolation(e) {
       let t = [e, this.tokenizer.nextToken()],
        r = ['word', '}'];
       if (t[0][1].length > 1 || '{' !== t[1][0]) return (this.tokenizer.back(t[1]), !1);
       for (e = this.tokenizer.nextToken(); e && r.includes(e[0]); ) (t.push(e), (e = this.tokenizer.nextToken()));
       let s = t.map((e) => e[1]),
        [n] = t,
        i = t.pop(),
        a = ['word', s.join(''), n[2], i[2]];
       return (this.tokenizer.back(e), this.tokenizer.back(a), !0);
      },
     };
    }),
    L = l((e, t) => {
     var r = /^#[0-9a-fA-F]{6}$|^#[0-9a-fA-F]{3}$/,
      s = /\.[0-9]/;
     t.exports = {
      isMixinToken: (e) => {
       let [, t] = e,
        [n] = t;
       return ('.' === n || '#' === n) && !1 === r.test(t) && !1 === s.test(t);
      },
     };
    }),
    M = l((e, t) => {
     var r = k(),
      s = /^url\((.+)\)/;
     t.exports = (e) => {
      let { name: t, params: n = '' } = e;
      if ('import' === t && n.length) {
       e.import = !0;
       let t = r({ css: n });
       for (e.filename = n.replace(s, '$1'); !t.endOfFile(); ) {
        let [r, s] = t.nextToken();
        if ('word' === r && 'url' === s) return;
        if ('brackets' === r) {
         ((e.options = s), (e.filename = n.replace(s, '').trim()));
         break;
        }
       }
      }
     };
    }),
    j = l((e, t) => {
     var r = /:$/,
      s = /^:(\s+)?/;
     t.exports = (e) => {
      let { name: t, params: n = '' } = e;
      if (':' === e.name.slice(-1)) {
       if (r.test(t)) {
        let [s] = t.match(r);
        ((e.name = t.replace(s, '')), (e.raws.afterName = s + (e.raws.afterName || '')), (e.variable = !0), (e.value = e.params));
       }
       if (s.test(n)) {
        let [t] = n.match(s);
        ((e.value = n.replace(t, '')), (e.raws.afterName = (e.raws.afterName || '') + t), (e.variable = !0));
       }
      }
     };
    }),
    _ = l((e, t) => {
     var r = x(),
      s = I(),
      { isInlineComment: n } = B(),
      { interpolation: i } = O(),
      { isMixinToken: a } = L(),
      o = M(),
      u = j(),
      l = /(!\s*important)$/i;
     t.exports = class extends s {
      constructor(...e) {
       (super(...e), (this.lastNode = null));
      }
      atrule(e) {
       i.bind(this)(e) || (super.atrule(e), o(this.lastNode), u(this.lastNode));
      }
      decl(...e) {
       (super.decl(...e), /extend\(.+\)/i.test(this.lastNode.value) && (this.lastNode.extend = !0));
      }
      each(e) {
       e[0][1] = ` ${e[0][1]}`;
       let t = e.findIndex((e) => '(' === e[0]),
        r = e.reverse().find((e) => ')' === e[0]),
        s = e.reverse().indexOf(r),
        n = e
         .splice(t, s)
         .map((e) => e[1])
         .join('');
       for (let i of e.reverse()) this.tokenizer.back(i);
       (this.atrule(this.tokenizer.nextToken()), (this.lastNode.function = !0), (this.lastNode.params = n));
      }
      init(e, t, r) {
       (super.init(e, t, r), (this.lastNode = e));
      }
      inlineComment(e) {
       let t = new r(),
        s = e[1].slice(2);
       if ((this.init(t, e[2]), (t.source.end = this.getPosition(e[3] || e[2])), (t.inline = !0), (t.raws.begin = '//'), /^\s*$/.test(s))) ((t.text = ''), (t.raws.left = s), (t.raws.right = ''));
       else {
        let e = s.match(/^(\s*)([^]*[^\s])(\s*)$/);
        [, t.raws.left, t.text, t.raws.right] = e;
       }
      }
      mixin(e) {
       let [t] = e,
        r = t[1].slice(0, 1),
        s = e.findIndex((e) => 'brackets' === e[0]),
        n = e.findIndex((e) => '(' === e[0]),
        i = '';
       if ((s < 0 || s > 3) && n > 0) {
        let t = e.reduce((e, t, r) => (')' === t[0] ? r : e)),
         r = e
          .slice(n, t + n)
          .map((e) => e[1])
          .join(''),
         [s] = e.slice(n),
         i = [s[2], s[3]],
         [a] = e.slice(t, t + 1),
         o = [a[2], a[3]],
         u = ['brackets', r].concat(i, o),
         l = e.slice(0, n),
         p = e.slice(t + 1);
        ((e = l).push(u), (e = e.concat(p)));
       }
       let a = [];
       for (let u of e) if ((('!' === u[1] || a.length) && a.push(u), 'important' === u[1])) break;
       if (a.length) {
        let [t] = a,
         r = e.indexOf(t),
         s = a[a.length - 1],
         n = [t[2], t[3]],
         i = [s[4], s[5]],
         o = ['word', a.map((e) => e[1]).join('')].concat(n, i);
        e.splice(r, a.length, o);
       }
       let o = e.findIndex((e) => l.test(e[1]));
       o > 0 && (([, i] = e[o]), e.splice(o, 1));
       for (let u of e.reverse()) this.tokenizer.back(u);
       (this.atrule(this.tokenizer.nextToken()), (this.lastNode.mixin = !0), (this.lastNode.raws.identifier = r), i && ((this.lastNode.important = !0), (this.lastNode.raws.important = i)));
      }
      other(e) {
       n.bind(this)(e) || super.other(e);
      }
      rule(e) {
       let t = e[e.length - 1],
        r = e[e.length - 2];
       if ('at-word' === r[0] && '{' === t[0] && (this.tokenizer.back(t), i.bind(this)(r))) {
        let t = this.tokenizer.nextToken();
        e = e.slice(0, e.length - 2).concat([t]);
        for (let r of e.reverse()) this.tokenizer.back(r);
       } else (super.rule(e), /:extend\(.+\)/i.test(this.lastNode.selector) && (this.lastNode.extend = !0));
      }
      unknownWord(e) {
       let [t] = e;
       'each' !== e[0][1] || '(' !== e[1][0] ? (a(t) ? this.mixin(e) : super.unknownWord(e)) : this.each(e);
      }
     };
    }),
    R = l((e, t) => {
     var r = m();
     t.exports = class extends r {
      atrule(e, t) {
       if (!e.mixin && !e.variable && !e.function) return void super.atrule(e, t);
       let r = `${e.function ? '' : e.raws.identifier || '@'}${e.name}`,
        s = e.params ? this.rawValue(e, 'params') : '',
        n = e.raws.important || '';
       if ((e.variable && (s = e.value), typeof e.raws.afterName < 'u' ? (r += e.raws.afterName) : s && (r += ' '), e.nodes)) this.block(e, r + s + n);
       else {
        let i = (e.raws.between || '') + n + (t ? ';' : '');
        this.builder(r + s + i, e);
       }
      }
      comment(e) {
       if (e.inline) {
        let t = this.raw(e, 'left', 'commentLeft'),
         r = this.raw(e, 'right', 'commentRight');
        this.builder(`//${t}${e.text}${r}`, e);
       } else super.comment(e);
      }
     };
    }),
    U = l((e, t) => {
     var r = A(),
      s = _(),
      n = R();
     t.exports = {
      parse(e, t) {
       let n = new r(e, t),
        i = new s(n);
       return (
        i.parse(),
        i.root.walk((e) => {
         let t = n.css.lastIndexOf(e.source.input.css);
         if (0 === t) return;
         if (t + e.source.input.css.length !== n.css.length) throw new Error('Invalid state detected in postcss-less');
         let r = t + e.source.start.offset,
          s = n.fromOffset(t + e.source.start.offset);
         if (((e.source.start = { offset: r, line: s.line, column: s.col }), e.source.end)) {
          let r = t + e.source.end.offset,
           s = n.fromOffset(t + e.source.end.offset);
          e.source.end = { offset: r, line: s.line, column: s.col };
         }
        }),
        i.root
       );
      },
      stringify(e, t) {
       new n(t).stringify(e);
      },
      nodeToString(e) {
       let r = '';
       return (
        t.exports.stringify(e, (e) => {
         r += e;
        }),
        r
       );
      },
     };
    }),
    $ = l((e, t) => {
     var r,
      s,
      n = b(),
      i = class extends n {
       constructor(e) {
        (super({ type: 'document', ...e }), this.nodes || (this.nodes = []));
       }
       toResult(e = {}) {
        return new r(new s(), this, e).stringify();
       }
      };
     ((i.registerLazyResult = (e) => {
      r = e;
     }),
      (i.registerProcessor = (e) => {
       s = e;
      }),
      (t.exports = i),
      (i.default = i));
    }),
    q = l((e, t) => {
     var r = w(),
      s = x(),
      n = E(),
      i = A(),
      a = F(),
      o = S(),
      u = P();
     function l(e, t) {
      if (Array.isArray(e)) return e.map((e) => l(e));
      let { inputs: p, ...c } = e;
      if (p) {
       t = [];
       for (let e of p) {
        let r = { ...e, __proto__: i.prototype };
        (r.map && (r.map = { ...r.map, __proto__: a.prototype }), t.push(r));
       }
      }
      if ((c.nodes && (c.nodes = e.nodes.map((e) => l(e, t))), c.source)) {
       let { inputId: e, ...r } = c.source;
       ((c.source = r), null != e && (c.source.input = t[e]));
      }
      if ('root' === c.type) return new o(c);
      if ('decl' === c.type) return new n(c);
      if ('rule' === c.type) return new u(c);
      if ('comment' === c.type) return new s(c);
      if ('atrule' === c.type) return new r(c);
      throw new Error('Unknown node type: ' + e.type);
     }
     ((t.exports = l), (l.default = l));
    }),
    J = l((e, t) => {
     t.exports = class {
      generate() {}
     };
    }),
    W = l((e, t) => {
     var r = class {
      constructor(e, t = {}) {
       if (((this.type = 'warning'), (this.text = e), t.node && t.node.source)) {
        let e = t.node.rangeBy(t);
        ((this.line = e.start.line), (this.column = e.start.column), (this.endLine = e.end.line), (this.endColumn = e.end.column));
       }
       for (let r in t) this[r] = t[r];
      }
      toString() {
       return this.node ? this.node.error(this.text, { index: this.index, plugin: this.plugin, word: this.word }).message : this.plugin ? this.plugin + ': ' + this.text : this.text;
      }
     };
     ((t.exports = r), (r.default = r));
    }),
    V = l((e, t) => {
     var r = W(),
      s = class {
       get content() {
        return this.css;
       }
       constructor(e, t, r) {
        ((this.processor = e), (this.messages = []), (this.root = t), (this.opts = r), (this.css = ''), (this.map = void 0));
       }
       toString() {
        return this.css;
       }
       warn(e, t = {}) {
        t.plugin || (this.lastPlugin && this.lastPlugin.postcssPlugin && (t.plugin = this.lastPlugin.postcssPlugin));
        let s = new r(e, t);
        return (this.messages.push(s), s);
       }
       warnings() {
        return this.messages.filter((e) => 'warning' === e.type);
       }
      };
     ((t.exports = s), (s.default = s));
    }),
    z = l((e, t) => {
     var r = {};
     t.exports = function (e) {
      r[e] || ((r[e] = !0), typeof console < 'u' && console.warn && console.warn(e));
     };
    }),
    H = l((e, t) => {
     var r = b(),
      s = $(),
      n = J(),
      i = N(),
      a = V(),
      o = S(),
      u = y(),
      { isClean: l, my: p } = D(),
      c = (z(), { atrule: 'AtRule', comment: 'Comment', decl: 'Declaration', document: 'Document', root: 'Root', rule: 'Rule' }),
      h = { AtRule: !0, AtRuleExit: !0, Comment: !0, CommentExit: !0, Declaration: !0, DeclarationExit: !0, Document: !0, DocumentExit: !0, Once: !0, OnceExit: !0, postcssPlugin: !0, prepare: !0, Root: !0, RootExit: !0, Rule: !0, RuleExit: !0 },
      d = { Once: !0, postcssPlugin: !0, prepare: !0 },
      f = 0;
     function m(e) {
      return 'object' == typeof e && 'function' == typeof e.then;
     }
     function g(e) {
      let t = !1,
       r = c[e.type];
      return ('decl' === e.type ? (t = e.prop.toLowerCase()) : 'atrule' === e.type && (t = e.name.toLowerCase()), t && e.append ? [r, r + '-' + t, f, r + 'Exit', r + 'Exit-' + t] : t ? [r, r + '-' + t, r + 'Exit', r + 'Exit-' + t] : e.append ? [r, f, r + 'Exit'] : [r, r + 'Exit']);
     }
     function x(e) {
      let t;
      return ((t = 'document' === e.type ? ['Document', f, 'DocumentExit'] : 'root' === e.type ? ['Root', f, 'RootExit'] : g(e)), { eventIndex: 0, events: t, iterator: 0, node: e, visitorIndex: 0, visitors: [] });
     }
     function E(e) {
      return ((e[l] = !1), e.nodes && e.nodes.forEach((e) => E(e)), e);
     }
     var T = {},
      C = class e {
       get content() {
        return this.stringify().content;
       }
       get css() {
        return this.stringify().css;
       }
       get map() {
        return this.stringify().map;
       }
       get messages() {
        return this.sync().messages;
       }
       get opts() {
        return this.result.opts;
       }
       get processor() {
        return this.result.processor;
       }
       get root() {
        return this.sync().root;
       }
       get [Symbol.toStringTag]() {
        return 'LazyResult';
       }
       constructor(t, s, n) {
        let o;
        if (((this.stringified = !1), (this.processed = !1), 'object' != typeof s || null === s || ('root' !== s.type && 'document' !== s.type)))
         if (s instanceof e || s instanceof a) ((o = E(s.root)), s.map && (typeof n.map > 'u' && (n.map = {}), n.map.inline || (n.map.inline = !1), (n.map.prev = s.map)));
         else {
          let e = i;
          (n.syntax && (e = n.syntax.parse), n.parser && (e = n.parser), e.parse && (e = e.parse));
          try {
           o = e(s, n);
          } catch (u) {
           ((this.processed = !0), (this.error = u));
          }
          o && !o[p] && r.rebuild(o);
         }
        else o = E(s);
        ((this.result = new a(t, o, n)), (this.helpers = { ...T, postcss: T, result: this.result }), (this.plugins = this.processor.plugins.map((e) => ('object' == typeof e && e.prepare ? { ...e, ...e.prepare(this.result) } : e))));
       }
       async() {
        return this.error ? Promise.reject(this.error) : this.processed ? Promise.resolve(this.result) : (this.processing || (this.processing = this.runAsync()), this.processing);
       }
       catch(e) {
        return this.async().catch(e);
       }
       finally(e) {
        return this.async().then(e, e);
       }
       getAsyncError() {
        throw new Error('Use process(css).then(cb) to work with async plugins');
       }
       handleError(e, t) {
        let r = this.result.lastPlugin;
        try {
         (t && t.addToError(e), (this.error = e), 'CssSyntaxError' !== e.name || e.plugin ? r.postcssVersion : ((e.plugin = r.postcssPlugin), e.setMessage()));
        } catch (s) {
         console && console.error && console.error(s);
        }
        return e;
       }
       prepareVisitors() {
        this.listeners = {};
        let e = (e, t, r) => {
         (this.listeners[t] || (this.listeners[t] = []), this.listeners[t].push([e, r]));
        };
        for (let t of this.plugins)
         if ('object' == typeof t)
          for (let r in t) {
           if (!h[r] && /^[A-Z]/.test(r)) throw new Error(`Unknown event ${r} in ${t.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`);
           if (!d[r])
            if ('object' == typeof t[r]) for (let s in t[r]) e(t, '*' === s ? r : r + '-' + s.toLowerCase(), t[r][s]);
            else 'function' == typeof t[r] && e(t, r, t[r]);
          }
        this.hasListener = Object.keys(this.listeners).length > 0;
       }
       async runAsync() {
        this.plugin = 0;
        for (let t = 0; t < this.plugins.length; t++) {
         let r = this.plugins[t],
          s = this.runOnRoot(r);
         if (m(s))
          try {
           await s;
          } catch (e) {
           throw this.handleError(e);
          }
        }
        if ((this.prepareVisitors(), this.hasListener)) {
         let t = this.result.root;
         for (; !t[l]; ) {
          t[l] = !0;
          let r = [x(t)];
          for (; r.length > 0; ) {
           let t = this.visitTick(r);
           if (m(t))
            try {
             await t;
            } catch (e) {
             let t = r[r.length - 1].node;
             throw this.handleError(e, t);
            }
          }
         }
         if (this.listeners.OnceExit)
          for (let [r, s] of this.listeners.OnceExit) {
           this.result.lastPlugin = r;
           try {
            if ('document' === t.type) {
             let e = t.nodes.map((e) => s(e, this.helpers));
             await Promise.all(e);
            } else await s(t, this.helpers);
           } catch (e) {
            throw this.handleError(e);
           }
          }
        }
        return ((this.processed = !0), this.stringify());
       }
       runOnRoot(e) {
        this.result.lastPlugin = e;
        try {
         if ('object' == typeof e && e.Once) {
          if ('document' === this.result.root.type) {
           let t = this.result.root.nodes.map((t) => e.Once(t, this.helpers));
           return m(t[0]) ? Promise.all(t) : t;
          }
          return e.Once(this.result.root, this.helpers);
         }
         if ('function' == typeof e) return e(this.result.root, this.result);
        } catch (t) {
         throw this.handleError(t);
        }
       }
       stringify() {
        if (this.error) throw this.error;
        if (this.stringified) return this.result;
        ((this.stringified = !0), this.sync());
        let e = this.result.opts,
         t = u;
        (e.syntax && (t = e.syntax.stringify), e.stringifier && (t = e.stringifier), t.stringify && (t = t.stringify));
        let r = new n(t, this.result.root, this.result.opts).generate();
        return ((this.result.css = r[0]), (this.result.map = r[1]), this.result);
       }
       sync() {
        if (this.error) throw this.error;
        if (this.processed) return this.result;
        if (((this.processed = !0), this.processing)) throw this.getAsyncError();
        for (let e of this.plugins) {
         if (m(this.runOnRoot(e))) throw this.getAsyncError();
        }
        if ((this.prepareVisitors(), this.hasListener)) {
         let e = this.result.root;
         for (; !e[l]; ) ((e[l] = !0), this.walkSync(e));
         if (this.listeners.OnceExit)
          if ('document' === e.type) for (let t of e.nodes) this.visitSync(this.listeners.OnceExit, t);
          else this.visitSync(this.listeners.OnceExit, e);
        }
        return this.result;
       }
       then(e, t) {
        return this.async().then(e, t);
       }
       toString() {
        return this.css;
       }
       visitSync(e, t) {
        for (let [s, n] of e) {
         let e;
         this.result.lastPlugin = s;
         try {
          e = n(t, this.helpers);
         } catch (r) {
          throw this.handleError(r, t.proxyOf);
         }
         if ('root' !== t.type && 'document' !== t.type && !t.parent) return !0;
         if (m(e)) throw this.getAsyncError();
        }
       }
       visitTick(e) {
        let t = e[e.length - 1],
         { node: r, visitors: s } = t;
        if ('root' !== r.type && 'document' !== r.type && !r.parent) return void e.pop();
        if (s.length > 0 && t.visitorIndex < s.length) {
         let [e, n] = s[t.visitorIndex];
         ((t.visitorIndex += 1), t.visitorIndex === s.length && ((t.visitors = []), (t.visitorIndex = 0)), (this.result.lastPlugin = e));
         try {
          return n(r.toProxy(), this.helpers);
         } catch (i) {
          throw this.handleError(i, r);
         }
        }
        if (0 !== t.iterator) {
         let s,
          n = t.iterator;
         for (; (s = r.nodes[r.indexes[n]]); ) if (((r.indexes[n] += 1), !s[l])) return ((s[l] = !0), void e.push(x(s)));
         ((t.iterator = 0), delete r.indexes[n]);
        }
        let n = t.events;
        for (; t.eventIndex < n.length; ) {
         let e = n[t.eventIndex];
         if (((t.eventIndex += 1), e === f)) return void (r.nodes && r.nodes.length && ((r[l] = !0), (t.iterator = r.getIterator())));
         if (this.listeners[e]) return void (t.visitors = this.listeners[e]);
        }
        e.pop();
       }
       walkSync(e) {
        e[l] = !0;
        let t = g(e);
        for (let r of t)
         if (r === f)
          e.nodes &&
           e.each((e) => {
            e[l] || this.walkSync(e);
           });
         else {
          let t = this.listeners[r];
          if (t && this.visitSync(t, e.toProxy())) return;
         }
       }
       warnings() {
        return this.sync().warnings();
       }
      };
     ((C.registerPostcss = (e) => {
      T = e;
     }),
      (t.exports = C),
      (C.default = C),
      o.registerLazyResult(C),
      s.registerLazyResult(C));
    }),
    X = l((e, t) => {
     var r = J(),
      s = N(),
      n = V(),
      i = y(),
      a =
       (z(),
       class {
        get content() {
         return this.result.css;
        }
        get css() {
         return this.result.css;
        }
        get map() {
         return this.result.map;
        }
        get messages() {
         return [];
        }
        get opts() {
         return this.result.opts;
        }
        get processor() {
         return this.result.processor;
        }
        get root() {
         if (this._root) return this._root;
         let e,
          t = s;
         try {
          e = t(this._css, this._opts);
         } catch (r) {
          this.error = r;
         }
         if (this.error) throw this.error;
         return ((this._root = e), e);
        }
        get [Symbol.toStringTag]() {
         return 'NoWorkResult';
        }
        constructor(e, t, s) {
         ((t = t.toString()), (this.stringified = !1), (this._processor = e), (this._css = t), (this._opts = s), (this._map = void 0));
         let a,
          o = i;
         ((this.result = new n(this._processor, a, this._opts)), (this.result.css = t));
         let u = this;
         Object.defineProperty(this.result, 'root', { get: () => u.root });
         let l = new r(o, a, this._opts, t);
         if (l.isMap()) {
          let [e, t] = l.generate();
          (e && (this.result.css = e), t && (this.result.map = t));
         } else (l.clearAnnotation(), (this.result.css = l.css));
        }
        async() {
         return this.error ? Promise.reject(this.error) : Promise.resolve(this.result);
        }
        catch(e) {
         return this.async().catch(e);
        }
        finally(e) {
         return this.async().then(e, e);
        }
        sync() {
         if (this.error) throw this.error;
         return this.result;
        }
        then(e, t) {
         return this.async().then(e, t);
        }
        toString() {
         return this._css;
        }
        warnings() {
         return [];
        }
       });
     ((t.exports = a), (a.default = a));
    }),
    K = l((e, t) => {
     var r = $(),
      s = H(),
      n = X(),
      i = S(),
      a = class {
       constructor(e = []) {
        ((this.version = '8.5.6'), (this.plugins = this.normalize(e)));
       }
       normalize(e) {
        let t = [];
        for (let r of e)
         if ((!0 === r.postcss ? (r = r()) : r.postcss && (r = r.postcss), 'object' == typeof r && Array.isArray(r.plugins))) t = t.concat(r.plugins);
         else if ('object' == typeof r && r.postcssPlugin) t.push(r);
         else if ('function' == typeof r) t.push(r);
         else if ('object' != typeof r || (!r.parse && !r.stringify)) throw new Error(r + ' is not a PostCSS plugin');
        return t;
       }
       process(e, t = {}) {
        return this.plugins.length || t.parser || t.stringifier || t.syntax ? new s(this, e, t) : new n(this, e, t);
       }
       use(e) {
        return ((this.plugins = this.plugins.concat(this.normalize([e]))), this);
       }
      };
     ((t.exports = a), (a.default = a), i.registerProcessor(a), r.registerProcessor(a));
    }),
    G = l((e, t) => {
     var r = w(),
      s = x(),
      n = b(),
      i = f(),
      a = E(),
      o = $(),
      u = q(),
      l = A(),
      p = H(),
      c = v(),
      h = g(),
      d = N(),
      m = K(),
      D = V(),
      T = S(),
      C = P(),
      F = y(),
      k = W();
     function I(...e) {
      return (1 === e.length && Array.isArray(e[0]) && (e = e[0]), new m(e));
     }
     ((I.plugin = function (e, t) {
      let r,
       s = !1;
      function n(...r) {
       console && console.warn && !s && ((s = !0), console.warn(e + ': postcss.plugin was deprecated. Migration guide:\nhttps://evilmartians.com/chronicles/postcss-8-plugin-migration'));
       let n = t(...r);
       return ((n.postcssPlugin = e), (n.postcssVersion = new m().version), n);
      }
      return (
       Object.defineProperty(n, 'postcss', { get: () => (r || (r = n()), r) }),
       (n.process = function (e, t, r) {
        return I([n(r)]).process(e, t);
       }),
       n
      );
     }),
      (I.stringify = F),
      (I.parse = d),
      (I.fromJSON = u),
      (I.list = c),
      (I.comment = (e) => new s(e)),
      (I.atRule = (e) => new r(e)),
      (I.decl = (e) => new a(e)),
      (I.rule = (e) => new C(e)),
      (I.root = (e) => new T(e)),
      (I.document = (e) => new o(e)),
      (I.CssSyntaxError = i),
      (I.Declaration = a),
      (I.Container = n),
      (I.Processor = m),
      (I.Document = o),
      (I.Comment = s),
      (I.Warning = k),
      (I.AtRule = r),
      (I.Result = D),
      (I.Input = l),
      (I.Rule = C),
      (I.Root = T),
      (I.Node = h),
      p.registerPostcss(I),
      (t.exports = I),
      (I.default = I));
    }),
    Y = l((e, t) => {
     var { Container: r } = G();
     t.exports = class extends r {
      constructor(e) {
       (super(e), (this.type = 'decl'), (this.isNested = !0), this.nodes || (this.nodes = []));
      }
     };
    }),
    Q = l((e, t) => {
     var r = /[\t\n\f\r "#'()/;[\\\]{}]/g,
      s = /[,\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g,
      n = /.[\r\n"'(/\\]/,
      i = /[\da-f]/i,
      a = /[\n\f\r]/g;
     t.exports = function (e, t = {}) {
      let o,
       u,
       l,
       p,
       c,
       h,
       d,
       f,
       m,
       y,
       D = e.css.valueOf(),
       g = t.ignoreErrors,
       x = D.length,
       E = 0,
       b = [],
       T = [];
      function C(t) {
       throw e.error('Unclosed ' + t, E);
      }
      function F() {
       let e = 1,
        t = !1,
        r = !1;
       for (; e > 0; ) ((u += 1), D.length <= u && C('interpolation'), (o = D.charCodeAt(u)), (f = D.charCodeAt(u + 1)), t ? (r || o !== t ? (92 === o ? (r = !r) : r && (r = !1)) : ((t = !1), (r = !1))) : 39 === o || 34 === o ? (t = o) : 125 === o ? (e -= 1) : 35 === o && 123 === f && (e += 1));
      }
      return {
       back: function (e) {
        T.push(e);
       },
       endOfFile: function () {
        return 0 === T.length && E >= x;
       },
       nextToken: function (e) {
        if (T.length) return T.pop();
        if (E >= x) return;
        let t = !!e && e.ignoreUnclosed;
        switch (((o = D.charCodeAt(E)), o)) {
         case 10:
         case 32:
         case 9:
         case 13:
         case 12:
          u = E;
          do {
           ((u += 1), (o = D.charCodeAt(u)));
          } while (32 === o || 10 === o || 9 === o || 13 === o || 12 === o);
          ((m = ['space', D.slice(E, u)]), (E = u - 1));
          break;
         case 91:
         case 93:
         case 123:
         case 125:
         case 58:
         case 59:
         case 41: {
          let e = String.fromCharCode(o);
          m = [e, e, E];
          break;
         }
         case 44:
          m = ['word', ',', E, E + 1];
          break;
         case 40:
          if (((d = b.length ? b.pop()[1] : ''), (f = D.charCodeAt(E + 1)), 'url' === d && 39 !== f && 34 !== f)) {
           for (y = 1, h = !1, u = E + 1; u <= D.length - 1; ) {
            if (((f = D.charCodeAt(u)), 92 === f)) h = !h;
            else if (40 === f) y += 1;
            else if (41 === f && ((y -= 1), 0 === y)) break;
            u += 1;
           }
           ((p = D.slice(E, u + 1)), (m = ['brackets', p, E, u]), (E = u));
          } else ((u = D.indexOf(')', E + 1)), (p = D.slice(E, u + 1)), -1 === u || n.test(p) ? (m = ['(', '(', E]) : ((m = ['brackets', p, E, u]), (E = u)));
          break;
         case 39:
         case 34:
          for (l = o, u = E, h = !1; u < x && (u++, u === x && C('string'), (o = D.charCodeAt(u)), (f = D.charCodeAt(u + 1)), h || o !== l); ) 92 === o ? (h = !h) : h ? (h = !1) : 35 === o && 123 === f && F();
          ((m = ['string', D.slice(E, u + 1), E, u]), (E = u));
          break;
         case 64:
          ((r.lastIndex = E + 1), r.test(D), (u = 0 === r.lastIndex ? D.length - 1 : r.lastIndex - 2), (m = ['at-word', D.slice(E, u + 1), E, u]), (E = u));
          break;
         case 92:
          for (u = E, c = !0; 92 === D.charCodeAt(u + 1); ) ((u += 1), (c = !c));
          if (((o = D.charCodeAt(u + 1)), c && 47 !== o && 32 !== o && 10 !== o && 9 !== o && 13 !== o && 12 !== o && ((u += 1), i.test(D.charAt(u))))) {
           for (; i.test(D.charAt(u + 1)); ) u += 1;
           32 === D.charCodeAt(u + 1) && (u += 1);
          }
          ((m = ['word', D.slice(E, u + 1), E, u]), (E = u));
          break;
         default:
          ((f = D.charCodeAt(E + 1)), 35 === o && 123 === f ? ((u = E), F(), (p = D.slice(E, u + 1)), (m = ['word', p, E, u]), (E = u)) : 47 === o && 42 === f ? ((u = D.indexOf('*/', E + 2) + 1), 0 === u && (g || t ? (u = D.length) : C('comment')), (m = ['comment', D.slice(E, u + 1), E, u]), (E = u)) : 47 === o && 47 === f ? ((a.lastIndex = E + 1), a.test(D), (u = 0 === a.lastIndex ? D.length - 1 : a.lastIndex - 2), (p = D.slice(E, u + 1)), (m = ['comment', p, E, u, 'inline']), (E = u)) : ((s.lastIndex = E + 1), s.test(D), (u = 0 === s.lastIndex ? D.length - 1 : s.lastIndex - 2), (m = ['word', D.slice(E, u + 1), E, u]), b.push(m), (E = u)));
        }
        return (E++, m);
       },
       position: function () {
        return E;
       },
      };
     };
    }),
    Z = l((e, t) => {
     var { Comment: r } = G(),
      s = I(),
      n = Y(),
      i = Q();
     t.exports = class extends s {
      atrule(e) {
       let t = e[1],
        r = e;
       for (; !this.tokenizer.endOfFile(); ) {
        let e = this.tokenizer.nextToken();
        if ('word' !== e[0] || e[2] !== r[3] + 1) {
         this.tokenizer.back(e);
         break;
        }
        ((t += e[1]), (r = e));
       }
       super.atrule(['at-word', t, e[2], r[3]]);
      }
      comment(e) {
       if ('inline' === e[4]) {
        let t = new r();
        (this.init(t, e[2]), (t.raws.inline = !0));
        let s = this.input.fromOffset(e[3]);
        t.source.end = { column: s.col, line: s.line, offset: e[3] + 1 };
        let n = e[1].slice(2);
        if (/^\s*$/.test(n)) ((t.text = ''), (t.raws.left = n), (t.raws.right = ''));
        else {
         let e = n.match(/^(\s*)([^]*\S)(\s*)$/),
          r = e[2].replace(/(\*\/|\/\*)/g, '*//*');
         ((t.text = r), (t.raws.left = e[1]), (t.raws.right = e[3]), (t.raws.text = e[2]));
        }
       } else super.comment(e);
      }
      createTokenizer() {
       this.tokenizer = i(this.input);
      }
      raw(e, t, r, s) {
       if ((super.raw(e, t, r, s), e.raws[t])) {
        let s = e.raws[t].raw;
        ((e.raws[t].raw = r.reduce((e, t) => {
         if ('comment' === t[0] && 'inline' === t[4]) {
          return e + '/*' + t[1].slice(2).replace(/(\*\/|\/\*)/g, '*//*') + '*/';
         }
         return e + t[1];
        }, '')),
         s !== e.raws[t].raw && (e.raws[t].scss = s));
       }
      }
      rule(e) {
       let t = !1,
        r = 0,
        s = '';
       for (let n of e)
        if (t) 'comment' !== n[0] && '{' !== n[0] && (s += n[1]);
        else {
         if ('space' === n[0] && n[1].includes('\n')) break;
         '(' === n[0] ? (r += 1) : ')' === n[0] ? (r -= 1) : 0 === r && ':' === n[0] && (t = !0);
        }
       if (!t || '' === s.trim() || /^[#:A-Za-z-]/.test(s)) super.rule(e);
       else {
        e.pop();
        let t,
         r,
         s = new n();
        this.init(s, e[0][2]);
        for (let n = e.length - 1; n >= 0; n--)
         if ('space' !== e[n][0]) {
          t = e[n];
          break;
         }
        if (t[3]) {
         let e = this.input.fromOffset(t[3]);
         s.source.end = { column: e.col, line: e.line, offset: t[3] + 1 };
        } else {
         let e = this.input.fromOffset(t[2]);
         s.source.end = { column: e.col, line: e.line, offset: t[2] + 1 };
        }
        for (; 'word' !== e[0][0]; ) s.raws.before += e.shift()[1];
        if (e[0][2]) {
         let t = this.input.fromOffset(e[0][2]);
         s.source.start = { column: t.col, line: t.line, offset: e[0][2] };
        }
        for (s.prop = ''; e.length; ) {
         let t = e[0][0];
         if (':' === t || 'space' === t || 'comment' === t) break;
         s.prop += e.shift()[1];
        }
        for (s.raws.between = ''; e.length; ) {
         if (((r = e.shift()), ':' === r[0])) {
          s.raws.between += r[1];
          break;
         }
         s.raws.between += r[1];
        }
        (('_' === s.prop[0] || '*' === s.prop[0]) && ((s.raws.before += s.prop[0]), (s.prop = s.prop.slice(1))), (s.raws.between += this.spacesAndCommentsFromStart(e)), this.precheckMissedSemicolon(e));
        for (let n = e.length - 1; n > 0; n--) {
         if (((r = e[n]), '!important' === r[1])) {
          s.important = !0;
          let t = this.stringFrom(e, n);
          ((t = this.spacesFromEnd(e) + t), ' !important' !== t && (s.raws.important = t));
          break;
         }
         if ('important' === r[1]) {
          let t = e.slice(0),
           r = '';
          for (let e = n; e > 0; e--) {
           let s = t[e][0];
           if (0 === r.trim().indexOf('!') && 'space' !== s) break;
           r = t.pop()[1] + r;
          }
          0 === r.trim().indexOf('!') && ((s.important = !0), (s.raws.important = r), (e = t));
         }
         if ('space' !== r[0] && 'comment' !== r[0]) break;
        }
        (this.raw(s, 'value', e), s.value.includes(':') && this.checkMissedSemicolon(e), (this.current = s));
       }
      }
     };
    }),
    ee = l((e, t) => {
     var { Input: r } = G(),
      s = Z();
     t.exports = function (e, t) {
      let n = new r(e, t),
       i = new s(n);
      return (i.parse(), i.root);
     };
    }),
    te = l((e) => {
     (Object.defineProperty(e, '__esModule', { value: !0 }),
      (e.default = function (e) {
       ((this.after = e.after), (this.before = e.before), (this.type = e.type), (this.value = e.value), (this.sourceIndex = e.sourceIndex));
      }));
    }),
    re = l((e) => {
     Object.defineProperty(e, '__esModule', { value: !0 });
     var t,
      r = te(),
      s = (t = r) && t.__esModule ? t : { default: t };
     function n(e) {
      var t = this;
      (this.constructor(e),
       (this.nodes = e.nodes),
       void 0 === this.after && (this.after = this.nodes.length > 0 ? this.nodes[this.nodes.length - 1].after : ''),
       void 0 === this.before && (this.before = this.nodes.length > 0 ? this.nodes[0].before : ''),
       void 0 === this.sourceIndex && (this.sourceIndex = this.before.length),
       this.nodes.forEach(function (e) {
        e.parent = t;
       }));
     }
     ((n.prototype = Object.create(s.default.prototype)),
      (n.constructor = s.default),
      (n.prototype.walk = function (e, t) {
       for (var r = 'string' == typeof e || e instanceof RegExp, s = r ? t : e, n = 'string' == typeof e ? new RegExp(e) : e, i = 0; i < this.nodes.length; i++) {
        var a = this.nodes[i];
        if (((!r || n.test(a.type)) && s && !1 === s(a, i, this.nodes)) || (a.nodes && !1 === a.walk(e, t))) return !1;
       }
       return !0;
      }),
      (n.prototype.each = function () {
       for (var e = arguments.length <= 0 || void 0 === arguments[0] ? function () {} : arguments[0], t = 0; t < this.nodes.length; t++) {
        if (!1 === e(this.nodes[t], t, this.nodes)) return !1;
       }
       return !0;
      }),
      (e.default = n));
    }),
    se = l((e) => {
     (Object.defineProperty(e, '__esModule', { value: !0 }),
      (e.parseMediaFeature = n),
      (e.parseMediaQuery = i),
      (e.parseMediaList = function (e) {
       var s = [],
        n = 0,
        a = 0,
        o = /^(\s*)url\s*\(/.exec(e);
       if (null !== o) {
        for (var u = o[0].length, l = 1; l > 0; ) {
         var p = e[u];
         ('(' === p && l++, ')' === p && l--, u++);
        }
        (s.unshift(new t.default({ type: 'url', value: e.substring(0, u).trim(), sourceIndex: o[1].length, before: o[1], after: /^(\s*)/.exec(e.substring(u))[1] })), (n = u));
       }
       for (var c = n; c < e.length; c++) {
        var h = e[c];
        if (('(' === h && a++, ')' === h && a--, 0 === a && ',' === h)) {
         var d = e.substring(n, c),
          f = /^(\s*)/.exec(d)[1];
         (s.push(new r.default({ type: 'media-query', value: d.trim(), sourceIndex: n + f.length, nodes: i(d, n), before: f, after: /(\s*)$/.exec(d)[1] })), (n = c + 1));
        }
       }
       var m = e.substring(n),
        y = /^(\s*)/.exec(m)[1];
       return (s.push(new r.default({ type: 'media-query', value: m.trim(), sourceIndex: n + y.length, nodes: i(m, n), before: y, after: /(\s*)$/.exec(m)[1] })), s);
      }));
     var t = s(te()),
      r = s(re());
     function s(e) {
      return e && e.__esModule ? e : { default: e };
     }
     function n(e) {
      var t = [{ mode: 'normal', character: null }],
       r = [],
       s = 0,
       n = '',
       i = null,
       a = null,
       o = arguments.length <= 1 || void 0 === arguments[1] ? 0 : arguments[1],
       u = e;
      '(' === e[0] && ')' === e[e.length - 1] && ((u = e.substring(1, e.length - 1)), o++);
      for (var l = 0; l < u.length; l++) {
       var p = u[l];
       if ((("'" === p || '"' === p) && (!0 === t[s].isCalculationEnabled ? (t.push({ mode: 'string', isCalculationEnabled: !1, character: p }), s++) : 'string' === t[s].mode && t[s].character === p && '\\' !== u[l - 1] && (t.pop(), s--)), '{' === p ? (t.push({ mode: 'interpolation', isCalculationEnabled: !0 }), s++) : '}' === p && (t.pop(), s--), 'normal' === t[s].mode && ':' === p)) {
        var c = u.substring(l + 1);
        (((a = { type: 'value', before: /^(\s*)/.exec(c)[1], after: /(\s*)$/.exec(c)[1], value: c.trim() }).sourceIndex = a.before.length + l + 1 + o), (i = { type: 'colon', sourceIndex: l + o, after: a.before, value: ':' }));
        break;
       }
       n += p;
      }
      return (((n = { type: 'media-feature', before: /^(\s*)/.exec(n)[1], after: /(\s*)$/.exec(n)[1], value: n.trim() }).sourceIndex = n.before.length + o), r.push(n), null !== i && ((i.before = n.after), r.push(i)), null !== a && r.push(a), r);
     }
     function i(e) {
      var s = arguments.length <= 1 || void 0 === arguments[1] ? 0 : arguments[1],
       i = [],
       a = 0,
       o = !1,
       u = void 0;
      u = { before: '', after: '', value: '' };
      for (var l = 0; l < e.length; l++) {
       var p = e[l];
       (o ? ((u.value += p), ('{' === p || '(' === p) && a++, (')' === p || '}' === p) && a--) : -1 !== p.search(/\s/) ? (u.before += p) : ('(' === p && ((u.type = 'media-feature-expression'), a++), (u.value = p), (u.sourceIndex = s + l), (o = !0)), o && 0 === a && (')' === p || l === e.length - 1 || -1 !== e[l + 1].search(/\s/)) && (-1 !== ['not', 'only', 'and'].indexOf(u.value) && (u.type = 'keyword'), 'media-feature-expression' === u.type && (u.nodes = n(u.value, u.sourceIndex)), i.push(Array.isArray(u.nodes) ? new r.default(u) : new t.default(u)), (u = { before: '', after: '', value: '' }), (o = !1)));
      }
      for (var c = 0; c < i.length; c++)
       if (((u = i[c]), c > 0 && (i[c - 1].after = u.before), void 0 === u.type)) {
        if (c > 0) {
         if ('media-feature-expression' === i[c - 1].type) {
          u.type = 'keyword';
          continue;
         }
         if ('not' === i[c - 1].value || 'only' === i[c - 1].value) {
          u.type = 'media-type';
          continue;
         }
         if ('and' === i[c - 1].value) {
          u.type = 'media-feature-expression';
          continue;
         }
         'media-type' === i[c - 1].type && (i[c + 1] ? (u.type = 'media-feature-expression' === i[c + 1].type ? 'keyword' : 'media-feature-expression') : (u.type = 'media-feature-expression'));
        }
        if (0 === c) {
         if (!i[c + 1]) {
          u.type = 'media-type';
          continue;
         }
         if (i[c + 1] && ('media-feature-expression' === i[c + 1].type || 'keyword' === i[c + 1].type)) {
          u.type = 'media-type';
          continue;
         }
         if (i[c + 2]) {
          if ('media-feature-expression' === i[c + 2].type) {
           ((u.type = 'media-type'), (i[c + 1].type = 'keyword'));
           continue;
          }
          if ('keyword' === i[c + 2].type) {
           ((u.type = 'keyword'), (i[c + 1].type = 'media-type'));
           continue;
          }
         }
         if (i[c + 3] && 'media-feature-expression' === i[c + 3].type) {
          ((u.type = 'keyword'), (i[c + 1].type = 'media-type'), (i[c + 2].type = 'keyword'));
          continue;
         }
        }
       }
      return i;
     }
    }),
    ne = l((e) => {
     (Object.defineProperty(e, '__esModule', { value: !0 }),
      (e.default = function (e) {
       return new s.default({ nodes: (0, n.parseMediaList)(e), type: 'media-query-list', value: e.trim() });
      }));
     var t,
      r = re(),
      s = (t = r) && t.__esModule ? t : { default: t },
      n = se();
    }),
    ie = l((e, t) => {
     t.exports = function (e, t) {
      return (t = 'number' == typeof t ? t : 1 / 0)
       ? (function e(r, s) {
          return r.reduce(function (r, n) {
           return Array.isArray(n) && s < t ? r.concat(e(n, s + 1)) : r.concat(n);
          }, []);
         })(e, 1)
       : Array.isArray(e)
         ? e.map(function (e) {
            return e;
           })
         : e;
     };
    }),
    ae = l((e, t) => {
     t.exports = function (e, t) {
      for (var r = -1, s = []; -1 !== (r = e.indexOf(t, r + 1)); ) s.push(r);
      return s;
     };
    }),
    oe = l((e, t) => {
     t.exports = function (e, t, r) {
      return 0 === e.length
       ? e
       : t
         ? (r || e.sort(t),
           (function (e, t) {
            for (var r = 1, s = e.length, n = e[0], i = e[0], a = 1; a < s; ++a)
             if (((i = n), t((n = e[a]), i))) {
              if (a === r) {
               r++;
               continue;
              }
              e[r++] = n;
             }
            return ((e.length = r), e);
           })(e, t))
         : (r || e.sort(),
           (function (e) {
            for (var t = 1, r = e.length, s = e[0], n = e[0], i = 1; i < r; ++i, n = s)
             if (((n = s), (s = e[i]) !== n)) {
              if (i === t) {
               t++;
               continue;
              }
              e[t++] = s;
             }
            return ((e.length = t), e);
           })(e));
     };
    }),
    ue = l((e, t) => {
     e.__esModule = !0;
     var r =
      'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
       ? function (e) {
          return typeof e;
         }
       : function (e) {
          return e && 'function' == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e;
         };
     var s = function e(t, s) {
       if ('object' !== (typeof t > 'u' ? 'undefined' : r(t))) return t;
       var n = new t.constructor();
       for (var i in t)
        if (t.hasOwnProperty(i)) {
         var a = t[i],
          o = typeof a > 'u' ? 'undefined' : r(a);
         'parent' === i && 'object' === o
          ? s && (n[i] = s)
          : (n[i] =
             a instanceof Array
              ? a.map(function (t) {
                 return e(t, n);
                })
              : e(a, n));
        }
       return n;
      },
      n = (function () {
       function e() {
        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        for (var r in ((function (e, t) {
         if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
        })(this, e),
        t))
         this[r] = t[r];
        var s = t.spaces,
         n = (s = void 0 === s ? {} : s).before,
         i = void 0 === n ? '' : n,
         a = s.after,
         o = void 0 === a ? '' : a;
        this.spaces = { before: i, after: o };
       }
       return (
        (e.prototype.remove = function () {
         return (this.parent && this.parent.removeChild(this), (this.parent = void 0), this);
        }),
        (e.prototype.replaceWith = function () {
         if (this.parent) {
          for (var e in arguments) this.parent.insertBefore(this, arguments[e]);
          this.remove();
         }
         return this;
        }),
        (e.prototype.next = function () {
         return this.parent.at(this.parent.index(this) + 1);
        }),
        (e.prototype.prev = function () {
         return this.parent.at(this.parent.index(this) - 1);
        }),
        (e.prototype.clone = function () {
         var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
          t = s(this);
         for (var r in e) t[r] = e[r];
         return t;
        }),
        (e.prototype.toString = function () {
         return [this.spaces.before, String(this.value), this.spaces.after].join('');
        }),
        e
       );
      })();
     ((e.default = n), (t.exports = e.default));
    }),
    le = l((e) => {
     e.__esModule = !0;
     ((e.TAG = 'tag'), (e.STRING = 'string'), (e.SELECTOR = 'selector'), (e.ROOT = 'root'), (e.PSEUDO = 'pseudo'), (e.NESTING = 'nesting'), (e.ID = 'id'), (e.COMMENT = 'comment'), (e.COMBINATOR = 'combinator'), (e.CLASS = 'class'), (e.ATTRIBUTE = 'attribute'), (e.UNIVERSAL = 'universal'));
    }),
    pe = l((e, t) => {
     e.__esModule = !0;
     var r,
      s = (function () {
       function e(e, t) {
        for (var r = 0; r < t.length; r++) {
         var s = t[r];
         ((s.enumerable = s.enumerable || !1), (s.configurable = !0), 'value' in s && (s.writable = !0), Object.defineProperty(e, s.key, s));
        }
       }
       return function (t, r, s) {
        return (r && e(t.prototype, r), s && e(t, s), t);
       };
      })(),
      n = ue(),
      i = (r = n) && r.__esModule ? r : { default: r },
      a = (function (e) {
       if (e && e.__esModule) return e;
       var t = {};
       if (null != e) for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
       return ((t.default = e), t);
      })(le());
     var o = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, t);
       var s = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
       })(this, e.call(this, r));
       return (s.nodes || (s.nodes = []), s);
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        ((e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t)));
       })(t, e),
       (t.prototype.append = function (e) {
        return ((e.parent = this), this.nodes.push(e), this);
       }),
       (t.prototype.prepend = function (e) {
        return ((e.parent = this), this.nodes.unshift(e), this);
       }),
       (t.prototype.at = function (e) {
        return this.nodes[e];
       }),
       (t.prototype.index = function (e) {
        return 'number' == typeof e ? e : this.nodes.indexOf(e);
       }),
       (t.prototype.removeChild = function (e) {
        ((e = this.index(e)), (this.at(e).parent = void 0), this.nodes.splice(e, 1));
        var t = void 0;
        for (var r in this.indexes) (t = this.indexes[r]) >= e && (this.indexes[r] = t - 1);
        return this;
       }),
       (t.prototype.removeAll = function () {
        var e = this.nodes,
         t = Array.isArray(e),
         r = 0;
        for (e = t ? e : e[Symbol.iterator](); ; ) {
         var s;
         if (t) {
          if (r >= e.length) break;
          s = e[r++];
         } else {
          if ((r = e.next()).done) break;
          s = r.value;
         }
         s.parent = void 0;
        }
        return ((this.nodes = []), this);
       }),
       (t.prototype.empty = function () {
        return this.removeAll();
       }),
       (t.prototype.insertAfter = function (e, t) {
        var r = this.index(e);
        this.nodes.splice(r + 1, 0, t);
        var s = void 0;
        for (var n in this.indexes) r <= (s = this.indexes[n]) && (this.indexes[n] = s + this.nodes.length);
        return this;
       }),
       (t.prototype.insertBefore = function (e, t) {
        var r = this.index(e);
        this.nodes.splice(r, 0, t);
        var s = void 0;
        for (var n in this.indexes) r <= (s = this.indexes[n]) && (this.indexes[n] = s + this.nodes.length);
        return this;
       }),
       (t.prototype.each = function (e) {
        (this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach++);
        var t = this.lastEach;
        if (((this.indexes[t] = 0), this.length)) {
         for (var r = void 0, s = void 0; this.indexes[t] < this.length && ((r = this.indexes[t]), !1 !== (s = e(this.at(r), r))); ) this.indexes[t] += 1;
         if ((delete this.indexes[t], !1 === s)) return !1;
        }
       }),
       (t.prototype.walk = function (e) {
        return this.each(function (t, r) {
         var s = e(t, r);
         if ((!1 !== s && t.length && (s = t.walk(e)), !1 === s)) return !1;
        });
       }),
       (t.prototype.walkAttributes = function (e) {
        var t = this;
        return this.walk(function (r) {
         if (r.type === a.ATTRIBUTE) return e.call(t, r);
        });
       }),
       (t.prototype.walkClasses = function (e) {
        var t = this;
        return this.walk(function (r) {
         if (r.type === a.CLASS) return e.call(t, r);
        });
       }),
       (t.prototype.walkCombinators = function (e) {
        var t = this;
        return this.walk(function (r) {
         if (r.type === a.COMBINATOR) return e.call(t, r);
        });
       }),
       (t.prototype.walkComments = function (e) {
        var t = this;
        return this.walk(function (r) {
         if (r.type === a.COMMENT) return e.call(t, r);
        });
       }),
       (t.prototype.walkIds = function (e) {
        var t = this;
        return this.walk(function (r) {
         if (r.type === a.ID) return e.call(t, r);
        });
       }),
       (t.prototype.walkNesting = function (e) {
        var t = this;
        return this.walk(function (r) {
         if (r.type === a.NESTING) return e.call(t, r);
        });
       }),
       (t.prototype.walkPseudos = function (e) {
        var t = this;
        return this.walk(function (r) {
         if (r.type === a.PSEUDO) return e.call(t, r);
        });
       }),
       (t.prototype.walkTags = function (e) {
        var t = this;
        return this.walk(function (r) {
         if (r.type === a.TAG) return e.call(t, r);
        });
       }),
       (t.prototype.walkUniversals = function (e) {
        var t = this;
        return this.walk(function (r) {
         if (r.type === a.UNIVERSAL) return e.call(t, r);
        });
       }),
       (t.prototype.split = function (e) {
        var t = this,
         r = [];
        return this.reduce(function (s, n, i) {
         var a = e.call(t, n);
         return (r.push(n), a ? (s.push(r), (r = [])) : i === t.length - 1 && s.push(r), s);
        }, []);
       }),
       (t.prototype.map = function (e) {
        return this.nodes.map(e);
       }),
       (t.prototype.reduce = function (e, t) {
        return this.nodes.reduce(e, t);
       }),
       (t.prototype.every = function (e) {
        return this.nodes.every(e);
       }),
       (t.prototype.some = function (e) {
        return this.nodes.some(e);
       }),
       (t.prototype.filter = function (e) {
        return this.nodes.filter(e);
       }),
       (t.prototype.sort = function (e) {
        return this.nodes.sort(e);
       }),
       (t.prototype.toString = function () {
        return this.map(String).join('');
       }),
       s(t, [
        {
         key: 'first',
         get: function () {
          return this.at(0);
         },
        },
        {
         key: 'last',
         get: function () {
          return this.at(this.length - 1);
         },
        },
        {
         key: 'length',
         get: function () {
          return this.nodes.length;
         },
        },
       ]),
       t
      );
     })(i.default);
     ((e.default = o), (t.exports = e.default));
    }),
    ce = l((e, t) => {
     e.__esModule = !0;
     var r,
      s = pe(),
      n = (r = s) && r.__esModule ? r : { default: r },
      i = le();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, t);
       var s = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
       })(this, e.call(this, r));
       return ((s.type = i.ROOT), s);
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        ((e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t)));
       })(t, e),
       (t.prototype.toString = function () {
        var e = this.reduce(function (e, t) {
         var r = String(t);
         return r ? e + r + ',' : '';
        }, '').slice(0, -1);
        return this.trailingComma ? e + ',' : e;
       }),
       t
      );
     })(n.default);
     ((e.default = a), (t.exports = e.default));
    }),
    he = l((e, t) => {
     e.__esModule = !0;
     var r,
      s = pe(),
      n = (r = s) && r.__esModule ? r : { default: r },
      i = le();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, t);
       var s = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
       })(this, e.call(this, r));
       return ((s.type = i.SELECTOR), s);
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        ((e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t)));
       })(t, e),
       t
      );
     })(n.default);
     ((e.default = a), (t.exports = e.default));
    }),
    de = l((e, t) => {
     e.__esModule = !0;
     var r,
      s = (function () {
       function e(e, t) {
        for (var r = 0; r < t.length; r++) {
         var s = t[r];
         ((s.enumerable = s.enumerable || !1), (s.configurable = !0), 'value' in s && (s.writable = !0), Object.defineProperty(e, s.key, s));
        }
       }
       return function (t, r, s) {
        return (r && e(t.prototype, r), s && e(t, s), t);
       };
      })(),
      n = ue();
     var i = (function (e) {
      function t() {
       return (
        (function (e, t) {
         if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
        })(this, t),
        (function (e, t) {
         if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
         return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
        })(this, e.apply(this, arguments))
       );
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        ((e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t)));
       })(t, e),
       (t.prototype.toString = function () {
        return [this.spaces.before, this.ns, String(this.value), this.spaces.after].join('');
       }),
       s(t, [
        {
         key: 'ns',
         get: function () {
          var e = this.namespace;
          return e ? ('string' == typeof e ? e : '') + '|' : '';
         },
        },
       ]),
       t
      );
     })(((r = n) && r.__esModule ? r : { default: r }).default);
     ((e.default = i), (t.exports = e.default));
    }),
    fe = l((e, t) => {
     e.__esModule = !0;
     var r,
      s = de(),
      n = (r = s) && r.__esModule ? r : { default: r },
      i = le();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, t);
       var s = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
       })(this, e.call(this, r));
       return ((s.type = i.CLASS), s);
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        ((e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t)));
       })(t, e),
       (t.prototype.toString = function () {
        return [this.spaces.before, this.ns, '.' + this.value, this.spaces.after].join('');
       }),
       t
      );
     })(n.default);
     ((e.default = a), (t.exports = e.default));
    }),
    me = l((e, t) => {
     e.__esModule = !0;
     var r,
      s = ue(),
      n = (r = s) && r.__esModule ? r : { default: r },
      i = le();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, t);
       var s = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
       })(this, e.call(this, r));
       return ((s.type = i.COMMENT), s);
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        ((e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t)));
       })(t, e),
       t
      );
     })(n.default);
     ((e.default = a), (t.exports = e.default));
    }),
    ye = l((e, t) => {
     e.__esModule = !0;
     var r,
      s = de(),
      n = (r = s) && r.__esModule ? r : { default: r },
      i = le();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, t);
       var s = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
       })(this, e.call(this, r));
       return ((s.type = i.ID), s);
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        ((e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t)));
       })(t, e),
       (t.prototype.toString = function () {
        return [this.spaces.before, this.ns, '#' + this.value, this.spaces.after].join('');
       }),
       t
      );
     })(n.default);
     ((e.default = a), (t.exports = e.default));
    }),
    De = l((e, t) => {
     e.__esModule = !0;
     var r,
      s = de(),
      n = (r = s) && r.__esModule ? r : { default: r },
      i = le();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, t);
       var s = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
       })(this, e.call(this, r));
       return ((s.type = i.TAG), s);
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        ((e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t)));
       })(t, e),
       t
      );
     })(n.default);
     ((e.default = a), (t.exports = e.default));
    }),
    ge = l((e, t) => {
     e.__esModule = !0;
     var r,
      s = ue(),
      n = (r = s) && r.__esModule ? r : { default: r },
      i = le();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, t);
       var s = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
       })(this, e.call(this, r));
       return ((s.type = i.STRING), s);
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        ((e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t)));
       })(t, e),
       t
      );
     })(n.default);
     ((e.default = a), (t.exports = e.default));
    }),
    xe = l((e, t) => {
     e.__esModule = !0;
     var r,
      s = pe(),
      n = (r = s) && r.__esModule ? r : { default: r },
      i = le();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, t);
       var s = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
       })(this, e.call(this, r));
       return ((s.type = i.PSEUDO), s);
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        ((e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t)));
       })(t, e),
       (t.prototype.toString = function () {
        var e = this.length ? '(' + this.map(String).join(',') + ')' : '';
        return [this.spaces.before, String(this.value), e, this.spaces.after].join('');
       }),
       t
      );
     })(n.default);
     ((e.default = a), (t.exports = e.default));
    }),
    Ee = l((e, t) => {
     e.__esModule = !0;
     var r,
      s = de(),
      n = (r = s) && r.__esModule ? r : { default: r },
      i = le();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, t);
       var s = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
       })(this, e.call(this, r));
       return ((s.type = i.ATTRIBUTE), (s.raws = {}), s);
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        ((e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t)));
       })(t, e),
       (t.prototype.toString = function () {
        var e = [this.spaces.before, '[', this.ns, this.attribute];
        return (this.operator && e.push(this.operator), this.value && e.push(this.value), this.raws.insensitive ? e.push(this.raws.insensitive) : this.insensitive && e.push(' i'), e.push(']'), e.concat(this.spaces.after).join(''));
       }),
       t
      );
     })(n.default);
     ((e.default = a), (t.exports = e.default));
    }),
    be = l((e, t) => {
     e.__esModule = !0;
     var r,
      s = de(),
      n = (r = s) && r.__esModule ? r : { default: r },
      i = le();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, t);
       var s = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
       })(this, e.call(this, r));
       return ((s.type = i.UNIVERSAL), (s.value = '*'), s);
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        ((e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t)));
       })(t, e),
       t
      );
     })(n.default);
     ((e.default = a), (t.exports = e.default));
    }),
    Te = l((e, t) => {
     e.__esModule = !0;
     var r,
      s = ue(),
      n = (r = s) && r.__esModule ? r : { default: r },
      i = le();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, t);
       var s = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
       })(this, e.call(this, r));
       return ((s.type = i.COMBINATOR), s);
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        ((e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t)));
       })(t, e),
       t
      );
     })(n.default);
     ((e.default = a), (t.exports = e.default));
    }),
    Ce = l((e, t) => {
     e.__esModule = !0;
     var r,
      s = ue(),
      n = (r = s) && r.__esModule ? r : { default: r },
      i = le();
     var a = (function (e) {
      function t(r) {
       !(function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, t);
       var s = (function (e, t) {
        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return !t || ('object' != typeof t && 'function' != typeof t) ? e : t;
       })(this, e.call(this, r));
       return ((s.type = i.NESTING), (s.value = '&'), s);
      }
      return (
       (function (e, t) {
        if ('function' != typeof t && null !== t) throw new TypeError('Super expression must either be null or a function, not ' + typeof t);
        ((e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : (e.__proto__ = t)));
       })(t, e),
       t
      );
     })(n.default);
     ((e.default = a), (t.exports = e.default));
    }),
    Fe = l((e, t) => {
     ((e.__esModule = !0),
      (e.default = function (e) {
       return e.sort(function (e, t) {
        return e - t;
       });
      }),
      (t.exports = e.default));
    }),
    Ae = l((e, t) => {
     ((e.__esModule = !0),
      (e.default = function (e) {
       for (
        var t = [],
         S = e.css.valueOf(),
         v = void 0,
         P = void 0,
         k = void 0,
         I = void 0,
         N = void 0,
         B = void 0,
         O = void 0,
         L = void 0,
         M = void 0,
         j = void 0,
         _ = void 0,
         R = S.length,
         U = -1,
         $ = 1,
         q = 0,
         J = function (t, r) {
          if (!e.safe) throw e.error('Unclosed ' + t, $, q - U, q);
          P = (S += r).length - 1;
         };
        q < R;
       ) {
        switch (((v = S.charCodeAt(q)) === a && ((U = q), ($ += 1)), v)) {
         case a:
         case o:
         case l:
         case p:
         case u:
          P = q;
          do {
           ((P += 1), (v = S.charCodeAt(P)) === a && ((U = P), ($ += 1)));
          } while (v === o || v === a || v === l || v === p || v === u);
          (t.push(['space', S.slice(q, P), $, q - U, q]), (q = P - 1));
          break;
         case c:
         case h:
         case d:
         case f:
          P = q;
          do {
           ((P += 1), (v = S.charCodeAt(P)));
          } while (v === c || v === h || v === d || v === f);
          (t.push(['combinator', S.slice(q, P), $, q - U, q]), (q = P - 1));
          break;
         case b:
          t.push(['*', '*', $, q - U, q]);
          break;
         case C:
          t.push(['&', '&', $, q - U, q]);
          break;
         case m:
          t.push([',', ',', $, q - U, q]);
          break;
         case g:
          t.push(['[', '[', $, q - U, q]);
          break;
         case x:
          t.push([']', ']', $, q - U, q]);
          break;
         case T:
          t.push([':', ':', $, q - U, q]);
          break;
         case E:
          t.push([';', ';', $, q - U, q]);
          break;
         case y:
          t.push(['(', '(', $, q - U, q]);
          break;
         case D:
          t.push([')', ')', $, q - U, q]);
          break;
         case r:
         case s:
          ((k = v === r ? "'" : '"'), (P = q));
          do {
           for (j = !1, -1 === (P = S.indexOf(k, P + 1)) && J('quote', k), _ = P; S.charCodeAt(_ - 1) === n; ) ((_ -= 1), (j = !j));
          } while (j);
          (t.push(['string', S.slice(q, P + 1), $, q - U, $, P - U, q]), (q = P));
          break;
         case F:
          ((A.lastIndex = q + 1), A.test(S), (P = 0 === A.lastIndex ? S.length - 1 : A.lastIndex - 2), t.push(['at-word', S.slice(q, P + 1), $, q - U, $, P - U, q]), (q = P));
          break;
         case n:
          for (P = q, O = !0; S.charCodeAt(P + 1) === n; ) ((P += 1), (O = !O));
          ((v = S.charCodeAt(P + 1)), O && v !== i && v !== o && v !== a && v !== l && v !== p && v !== u && (P += 1), t.push(['word', S.slice(q, P + 1), $, q - U, $, P - U, q]), (q = P));
          break;
         default:
          v === i && S.charCodeAt(q + 1) === b ? (0 === (P = S.indexOf('*/', q + 2) + 1) && J('comment', '*/'), (N = (I = (B = S.slice(q, P + 1)).split('\n')).length - 1) > 0 ? ((L = $ + N), (M = P - I[N].length)) : ((L = $), (M = U)), t.push(['comment', B, $, q - U, L, P - M, q]), (U = M), ($ = L), (q = P)) : ((w.lastIndex = q + 1), w.test(S), (P = 0 === w.lastIndex ? S.length - 1 : w.lastIndex - 2), t.push(['word', S.slice(q, P + 1), $, q - U, $, P - U, q]), (q = P));
        }
        q++;
       }
       return t;
      }));
     var r = 39,
      s = 34,
      n = 92,
      i = 47,
      a = 10,
      o = 32,
      u = 12,
      l = 9,
      p = 13,
      c = 43,
      h = 62,
      d = 126,
      f = 124,
      m = 44,
      y = 40,
      D = 41,
      g = 91,
      x = 93,
      E = 59,
      b = 42,
      T = 58,
      C = 38,
      F = 64,
      A = /[ \n\t\r\{\(\)'"\\;/]/g,
      w = /[ \n\t\r\(\)\*:;@!&'"\+\|~>,\[\]\\]|\/(?=\*)/g;
     t.exports = e.default;
    }),
    we = l((e, t) => {
     e.__esModule = !0;
     var r = (function () {
       function e(e, t) {
        for (var r = 0; r < t.length; r++) {
         var s = t[r];
         ((s.enumerable = s.enumerable || !1), (s.configurable = !0), 'value' in s && (s.writable = !0), Object.defineProperty(e, s.key, s));
        }
       }
       return function (t, r, s) {
        return (r && e(t.prototype, r), s && e(t, s), t);
       };
      })(),
      s = b(ie()),
      n = b(ae()),
      i = b(oe()),
      a = b(ce()),
      o = b(he()),
      u = b(fe()),
      l = b(me()),
      p = b(ye()),
      c = b(De()),
      h = b(ge()),
      d = b(xe()),
      f = b(Ee()),
      m = b(be()),
      y = b(Te()),
      D = b(Ce()),
      g = b(Fe()),
      x = b(Ae()),
      E = (function (e) {
       if (e && e.__esModule) return e;
       var t = {};
       if (null != e) for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
       return ((t.default = e), t);
      })(le());
     function b(e) {
      return e && e.__esModule ? e : { default: e };
     }
     var T = (function () {
      function e(t) {
       ((function (e, t) {
        if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
       })(this, e),
        (this.input = t),
        (this.lossy = !1 === t.options.lossless),
        (this.position = 0),
        (this.root = new a.default()));
       var r = new o.default();
       return (this.root.append(r), (this.current = r), this.lossy ? (this.tokens = (0, x.default)({ safe: t.safe, css: t.css.trim() })) : (this.tokens = (0, x.default)(t)), this.loop());
      }
      return (
       (e.prototype.attribute = function () {
        var e = '',
         t = void 0,
         r = this.currToken;
        for (this.position++; this.position < this.tokens.length && ']' !== this.currToken[0]; ) ((e += this.tokens[this.position][1]), this.position++);
        this.position === this.tokens.length && !~e.indexOf(']') && this.error('Expected a closing square bracket.');
        var s = e.split(/((?:[*~^$|]?=))([^]*)/),
         n = s[0].split(/(\|)/g),
         i = { operator: s[1], value: s[2], source: { start: { line: r[2], column: r[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: r[4] };
        if ((n.length > 1 ? ('' === n[0] && (n[0] = !0), (i.attribute = this.parseValue(n[2])), (i.namespace = this.parseNamespace(n[0]))) : (i.attribute = this.parseValue(s[0])), (t = new f.default(i)), s[2])) {
         var a = s[2].split(/(\s+i\s*?)$/),
          o = a[0].trim();
         ((t.value = this.lossy ? o : a[0]), a[1] && ((t.insensitive = !0), this.lossy || (t.raws.insensitive = a[1])), (t.quoted = "'" === o[0] || '"' === o[0]), (t.raws.unquoted = t.quoted ? o.slice(1, -1) : o));
        }
        (this.newNode(t), this.position++);
       }),
       (e.prototype.combinator = function () {
        if ('|' === this.currToken[1]) return this.namespace();
        for (var e = new y.default({ value: '', source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] }); this.position < this.tokens.length && this.currToken && ('space' === this.currToken[0] || 'combinator' === this.currToken[0]); ) (this.nextToken && 'combinator' === this.nextToken[0] ? ((e.spaces.before = this.parseSpace(this.currToken[1])), (e.source.start.line = this.nextToken[2]), (e.source.start.column = this.nextToken[3]), (e.source.end.column = this.nextToken[3]), (e.source.end.line = this.nextToken[2]), (e.sourceIndex = this.nextToken[4])) : this.prevToken && 'combinator' === this.prevToken[0] ? (e.spaces.after = this.parseSpace(this.currToken[1])) : 'combinator' === this.currToken[0] ? (e.value = this.currToken[1]) : 'space' === this.currToken[0] && (e.value = this.parseSpace(this.currToken[1], ' ')), this.position++);
        return this.newNode(e);
       }),
       (e.prototype.comma = function () {
        if (this.position === this.tokens.length - 1) return ((this.root.trailingComma = !0), void this.position++);
        var e = new o.default();
        (this.current.parent.append(e), (this.current = e), this.position++);
       }),
       (e.prototype.comment = function () {
        var e = new l.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] });
        (this.newNode(e), this.position++);
       }),
       (e.prototype.error = function (e) {
        throw new this.input.error(e);
       }),
       (e.prototype.missingBackslash = function () {
        return this.error('Expected a backslash preceding the semicolon.');
       }),
       (e.prototype.missingParenthesis = function () {
        return this.error('Expected opening parenthesis.');
       }),
       (e.prototype.missingSquareBracket = function () {
        return this.error('Expected opening square bracket.');
       }),
       (e.prototype.namespace = function () {
        var e = (this.prevToken && this.prevToken[1]) || !0;
        return 'word' === this.nextToken[0] ? (this.position++, this.word(e)) : '*' === this.nextToken[0] ? (this.position++, this.universal(e)) : void 0;
       }),
       (e.prototype.nesting = function () {
        (this.newNode(new D.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] })), this.position++);
       }),
       (e.prototype.parentheses = function () {
        var e = this.current.last;
        if (e && e.type === E.PSEUDO) {
         var t = new o.default(),
          r = this.current;
         (e.append(t), (this.current = t));
         var s = 1;
         for (this.position++; this.position < this.tokens.length && s; ) ('(' === this.currToken[0] && s++, ')' === this.currToken[0] && s--, s ? this.parse() : ((t.parent.source.end.line = this.currToken[2]), (t.parent.source.end.column = this.currToken[3]), this.position++));
         (s && this.error('Expected closing parenthesis.'), (this.current = r));
        } else {
         var n = 1;
         for (this.position++, e.value += '('; this.position < this.tokens.length && n; ) ('(' === this.currToken[0] && n++, ')' === this.currToken[0] && n--, (e.value += this.parseParenthesisToken(this.currToken)), this.position++);
         n && this.error('Expected closing parenthesis.');
        }
       }),
       (e.prototype.pseudo = function () {
        for (var e = this, t = '', r = this.currToken; this.currToken && ':' === this.currToken[0]; ) ((t += this.currToken[1]), this.position++);
        if (!this.currToken) return this.error('Expected pseudo-class or pseudo-element');
        if ('word' === this.currToken[0]) {
         var s = void 0;
         this.splitWord(!1, function (n, i) {
          ((t += n), (s = new d.default({ value: t, source: { start: { line: r[2], column: r[3] }, end: { line: e.currToken[4], column: e.currToken[5] } }, sourceIndex: r[4] })), e.newNode(s), i > 1 && e.nextToken && '(' === e.nextToken[0] && e.error('Misplaced parenthesis.'));
         });
        } else this.error('Unexpected "' + this.currToken[0] + '" found.');
       }),
       (e.prototype.space = function () {
        var e = this.currToken;
        0 === this.position || ',' === this.prevToken[0] || '(' === this.prevToken[0] ? ((this.spaces = this.parseSpace(e[1])), this.position++) : this.position === this.tokens.length - 1 || ',' === this.nextToken[0] || ')' === this.nextToken[0] ? ((this.current.last.spaces.after = this.parseSpace(e[1])), this.position++) : this.combinator();
       }),
       (e.prototype.string = function () {
        var e = this.currToken;
        (this.newNode(new h.default({ value: this.currToken[1], source: { start: { line: e[2], column: e[3] }, end: { line: e[4], column: e[5] } }, sourceIndex: e[6] })), this.position++);
       }),
       (e.prototype.universal = function (e) {
        var t = this.nextToken;
        if (t && '|' === t[1]) return (this.position++, this.namespace());
        (this.newNode(new m.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] }), e), this.position++);
       }),
       (e.prototype.splitWord = function (e, t) {
        for (var r = this, a = this.nextToken, o = this.currToken[1]; a && 'word' === a[0]; ) {
         this.position++;
         var l = this.currToken[1];
         if (((o += l), l.lastIndexOf('\\') === l.length - 1)) {
          var h = this.nextToken;
          h && 'space' === h[0] && ((o += this.parseSpace(h[1], ' ')), this.position++);
         }
         a = this.nextToken;
        }
        var d = (0, n.default)(o, '.'),
         f = (0, n.default)(o, '#'),
         m = (0, n.default)(o, '#{');
        m.length &&
         (f = f.filter(function (e) {
          return !~m.indexOf(e);
         }));
        var y = (0, g.default)((0, i.default)((0, s.default)([[0], d, f])));
        (y.forEach(function (s, n) {
         var i = y[n + 1] || o.length,
          a = o.slice(s, i);
         if (0 === n && t) return t.call(r, a, y.length);
         var l = void 0;
         ((l = ~d.indexOf(s) ? new u.default({ value: a.slice(1), source: { start: { line: r.currToken[2], column: r.currToken[3] + s }, end: { line: r.currToken[4], column: r.currToken[3] + (i - 1) } }, sourceIndex: r.currToken[6] + y[n] }) : ~f.indexOf(s) ? new p.default({ value: a.slice(1), source: { start: { line: r.currToken[2], column: r.currToken[3] + s }, end: { line: r.currToken[4], column: r.currToken[3] + (i - 1) } }, sourceIndex: r.currToken[6] + y[n] }) : new c.default({ value: a, source: { start: { line: r.currToken[2], column: r.currToken[3] + s }, end: { line: r.currToken[4], column: r.currToken[3] + (i - 1) } }, sourceIndex: r.currToken[6] + y[n] })), r.newNode(l, e));
        }),
         this.position++);
       }),
       (e.prototype.word = function (e) {
        var t = this.nextToken;
        return t && '|' === t[1] ? (this.position++, this.namespace()) : this.splitWord(e);
       }),
       (e.prototype.loop = function () {
        for (; this.position < this.tokens.length; ) this.parse(!0);
        return this.root;
       }),
       (e.prototype.parse = function (e) {
        switch (this.currToken[0]) {
         case 'space':
          this.space();
          break;
         case 'comment':
          this.comment();
          break;
         case '(':
          this.parentheses();
          break;
         case ')':
          e && this.missingParenthesis();
          break;
         case '[':
          this.attribute();
          break;
         case ']':
          this.missingSquareBracket();
          break;
         case 'at-word':
         case 'word':
          this.word();
          break;
         case ':':
          this.pseudo();
          break;
         case ';':
          this.missingBackslash();
          break;
         case ',':
          this.comma();
          break;
         case '*':
          this.universal();
          break;
         case '&':
          this.nesting();
          break;
         case 'combinator':
          this.combinator();
          break;
         case 'string':
          this.string();
        }
       }),
       (e.prototype.parseNamespace = function (e) {
        if (this.lossy && 'string' == typeof e) {
         var t = e.trim();
         return !t.length || t;
        }
        return e;
       }),
       (e.prototype.parseSpace = function (e, t) {
        return this.lossy ? t || '' : e;
       }),
       (e.prototype.parseValue = function (e) {
        return this.lossy && e && 'string' == typeof e ? e.trim() : e;
       }),
       (e.prototype.parseParenthesisToken = function (e) {
        return this.lossy ? ('space' === e[0] ? this.parseSpace(e[1], ' ') : this.parseValue(e[1])) : e[1];
       }),
       (e.prototype.newNode = function (e, t) {
        return (t && (e.namespace = this.parseNamespace(t)), this.spaces && ((e.spaces.before = this.spaces), (this.spaces = '')), this.current.append(e));
       }),
       r(e, [
        {
         key: 'currToken',
         get: function () {
          return this.tokens[this.position];
         },
        },
        {
         key: 'nextToken',
         get: function () {
          return this.tokens[this.position + 1];
         },
        },
        {
         key: 'prevToken',
         get: function () {
          return this.tokens[this.position - 1];
         },
        },
       ]),
       e
      );
     })();
     ((e.default = T), (t.exports = e.default));
    }),
    Se = l((e, t) => {
     e.__esModule = !0;
     var r,
      s = (function () {
       function e(e, t) {
        for (var r = 0; r < t.length; r++) {
         var s = t[r];
         ((s.enumerable = s.enumerable || !1), (s.configurable = !0), 'value' in s && (s.writable = !0), Object.defineProperty(e, s.key, s));
        }
       }
       return function (t, r, s) {
        return (r && e(t.prototype, r), s && e(t, s), t);
       };
      })(),
      n = we(),
      i = (r = n) && r.__esModule ? r : { default: r };
     var a = (function () {
      function e(t) {
       return (
        (function (e, t) {
         if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');
        })(this, e),
        (this.func = t || function () {}),
        this
       );
      }
      return (
       (e.prototype.process = function (e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
         r = new i.default({
          css: e,
          error: function (e) {
           throw new Error(e);
          },
          options: t,
         });
        return ((this.res = r), this.func(r), this);
       }),
       s(e, [
        {
         key: 'result',
         get: function () {
          return String(this.res);
         },
        },
       ]),
       e
      );
     })();
     ((e.default = a), (t.exports = e.default));
    }),
    ve = l((e, t) => {
     var r = function (e, t) {
      let s = new e.constructor();
      for (let n in e) {
       if (!e.hasOwnProperty(n)) continue;
       let i = e[n],
        a = typeof i;
       'parent' === n && 'object' === a ? t && (s[n] = t) : 'source' === n ? (s[n] = i) : i instanceof Array ? (s[n] = i.map((e) => r(e, s))) : 'before' !== n && 'after' !== n && 'between' !== n && 'semicolon' !== n && ('object' === a && null !== i && (i = r(i)), (s[n] = i));
      }
      return s;
     };
     t.exports = class {
      constructor(e) {
       ((e = e || {}), (this.raws = { before: '', after: '' }));
       for (let t in e) this[t] = e[t];
      }
      remove() {
       return (this.parent && this.parent.removeChild(this), (this.parent = void 0), this);
      }
      toString() {
       return [this.raws.before, String(this.value), this.raws.after].join('');
      }
      clone(e) {
       e = e || {};
       let t = r(this);
       for (let r in e) t[r] = e[r];
       return t;
      }
      cloneBefore(e) {
       e = e || {};
       let t = this.clone(e);
       return (this.parent.insertBefore(this, t), t);
      }
      cloneAfter(e) {
       e = e || {};
       let t = this.clone(e);
       return (this.parent.insertAfter(this, t), t);
      }
      replaceWith() {
       let e = Array.prototype.slice.call(arguments);
       if (this.parent) {
        for (let t of e) this.parent.insertBefore(this, t);
        this.remove();
       }
       return this;
      }
      moveTo(e) {
       return (this.cleanRaws(this.root() === e.root()), this.remove(), e.append(this), this);
      }
      moveBefore(e) {
       return (this.cleanRaws(this.root() === e.root()), this.remove(), e.parent.insertBefore(e, this), this);
      }
      moveAfter(e) {
       return (this.cleanRaws(this.root() === e.root()), this.remove(), e.parent.insertAfter(e, this), this);
      }
      next() {
       let e = this.parent.index(this);
       return this.parent.nodes[e + 1];
      }
      prev() {
       let e = this.parent.index(this);
       return this.parent.nodes[e - 1];
      }
      toJSON() {
       let e = {};
       for (let t in this) {
        if (!this.hasOwnProperty(t) || 'parent' === t) continue;
        let r = this[t];
        r instanceof Array ? (e[t] = r.map((e) => ('object' == typeof e && e.toJSON ? e.toJSON() : e))) : 'object' == typeof r && r.toJSON ? (e[t] = r.toJSON()) : (e[t] = r);
       }
       return e;
      }
      root() {
       let e = this;
       for (; e.parent; ) e = e.parent;
       return e;
      }
      cleanRaws(e) {
       (delete this.raws.before, delete this.raws.after, e || delete this.raws.between);
      }
      positionInside(e) {
       let t = this.toString(),
        r = this.source.start.column,
        s = this.source.start.line;
       for (let n = 0; n < e; n++) '\n' === t[n] ? ((r = 1), (s += 1)) : (r += 1);
       return { line: s, column: r };
      }
      positionBy(e) {
       let t = this.source.start;
       if (Object(e).index) t = this.positionInside(e.index);
       else if (Object(e).word) {
        let r = this.toString().indexOf(e.word);
        -1 !== r && (t = this.positionInside(r));
       }
       return t;
      }
     };
    }),
    Pe = l((e, t) => {
     var r = ve(),
      s = class extends r {
       constructor(e) {
        (super(e), this.nodes || (this.nodes = []));
       }
       push(e) {
        return ((e.parent = this), this.nodes.push(e), this);
       }
       each(e) {
        (this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), (this.lastEach += 1));
        let t,
         r,
         s = this.lastEach;
        if (((this.indexes[s] = 0), this.nodes)) {
         for (; this.indexes[s] < this.nodes.length && ((t = this.indexes[s]), (r = e(this.nodes[t], t)), !1 !== r); ) this.indexes[s] += 1;
         return (delete this.indexes[s], r);
        }
       }
       walk(e) {
        return this.each((t, r) => {
         let s = e(t, r);
         return (!1 !== s && t.walk && (s = t.walk(e)), s);
        });
       }
       walkType(e, t) {
        if (!e || !t) throw new Error('Parameters {type} and {callback} are required.');
        let r = 'function' == typeof e;
        return this.walk((s, n) => {
         if ((r && s instanceof e) || (!r && s.type === e)) return t.call(this, s, n);
        });
       }
       append(e) {
        return ((e.parent = this), this.nodes.push(e), this);
       }
       prepend(e) {
        return ((e.parent = this), this.nodes.unshift(e), this);
       }
       cleanRaws(e) {
        if ((super.cleanRaws(e), this.nodes)) for (let t of this.nodes) t.cleanRaws(e);
       }
       insertAfter(e, t) {
        let r,
         s = this.index(e);
        this.nodes.splice(s + 1, 0, t);
        for (let n in this.indexes) ((r = this.indexes[n]), s <= r && (this.indexes[n] = r + this.nodes.length));
        return this;
       }
       insertBefore(e, t) {
        let r,
         s = this.index(e);
        this.nodes.splice(s, 0, t);
        for (let n in this.indexes) ((r = this.indexes[n]), s <= r && (this.indexes[n] = r + this.nodes.length));
        return this;
       }
       removeChild(e) {
        let t;
        ((e = this.index(e)), (this.nodes[e].parent = void 0), this.nodes.splice(e, 1));
        for (let r in this.indexes) ((t = this.indexes[r]), t >= e && (this.indexes[r] = t - 1));
        return this;
       }
       removeAll() {
        for (let e of this.nodes) e.parent = void 0;
        return ((this.nodes = []), this);
       }
       every(e) {
        return this.nodes.every(e);
       }
       some(e) {
        return this.nodes.some(e);
       }
       index(e) {
        return 'number' == typeof e ? e : this.nodes.indexOf(e);
       }
       get first() {
        if (this.nodes) return this.nodes[0];
       }
       get last() {
        if (this.nodes) return this.nodes[this.nodes.length - 1];
       }
       toString() {
        let e = this.nodes.map(String).join('');
        return (this.value && (e = this.value + e), this.raws.before && (e = this.raws.before + e), this.raws.after && (e += this.raws.after), e);
       }
      };
     ((s.registerWalker = (e) => {
      let t = 'walk' + e.name;
      (t.lastIndexOf('s') !== t.length - 1 && (t += 's'),
       !s.prototype[t] &&
        (s.prototype[t] = function (t) {
         return this.walkType(e, t);
        }));
     }),
      (t.exports = s));
    }),
    ke = l((e, t) => {
     var r = Pe();
     t.exports = class extends r {
      constructor(e) {
       (super(e), (this.type = 'root'));
      }
     };
    }),
    Ie = l((e, t) => {
     var r = Pe();
     t.exports = class extends r {
      constructor(e) {
       (super(e), (this.type = 'value'), (this.unbalanced = 0));
      }
     };
    }),
    Ne = l((e, t) => {
     var r = Pe(),
      s = class extends r {
       constructor(e) {
        (super(e), (this.type = 'atword'));
       }
       toString() {
        this.quoted && this.raws.quote;
        return [this.raws.before, '@', String.prototype.toString.call(this.value), this.raws.after].join('');
       }
      };
     (r.registerWalker(s), (t.exports = s));
    }),
    Be = l((e, t) => {
     var r = Pe(),
      s = ve(),
      n = class extends s {
       constructor(e) {
        (super(e), (this.type = 'colon'));
       }
      };
     (r.registerWalker(n), (t.exports = n));
    }),
    Oe = l((e, t) => {
     var r = Pe(),
      s = ve(),
      n = class extends s {
       constructor(e) {
        (super(e), (this.type = 'comma'));
       }
      };
     (r.registerWalker(n), (t.exports = n));
    }),
    Le = l((e, t) => {
     var r = Pe(),
      s = ve(),
      n = class extends s {
       constructor(e) {
        (super(e), (this.type = 'comment'), (this.inline = Object(e).inline || !1));
       }
       toString() {
        return [this.raws.before, this.inline ? '//' : '/*', String(this.value), this.inline ? '' : '*/', this.raws.after].join('');
       }
      };
     (r.registerWalker(n), (t.exports = n));
    }),
    Me = l((e, t) => {
     var r = Pe(),
      s = class extends r {
       constructor(e) {
        (super(e), (this.type = 'func'), (this.unbalanced = -1));
       }
      };
     (r.registerWalker(s), (t.exports = s));
    }),
    je = l((e, t) => {
     var r = Pe(),
      s = ve(),
      n = class extends s {
       constructor(e) {
        (super(e), (this.type = 'number'), (this.unit = Object(e).unit || ''));
       }
       toString() {
        return [this.raws.before, String(this.value), this.unit, this.raws.after].join('');
       }
      };
     (r.registerWalker(n), (t.exports = n));
    }),
    _e = l((e, t) => {
     var r = Pe(),
      s = ve(),
      n = class extends s {
       constructor(e) {
        (super(e), (this.type = 'operator'));
       }
      };
     (r.registerWalker(n), (t.exports = n));
    }),
    Re = l((e, t) => {
     var r = Pe(),
      s = ve(),
      n = class extends s {
       constructor(e) {
        (super(e), (this.type = 'paren'), (this.parenType = ''));
       }
      };
     (r.registerWalker(n), (t.exports = n));
    }),
    Ue = l((e, t) => {
     var r = Pe(),
      s = ve(),
      n = class extends s {
       constructor(e) {
        (super(e), (this.type = 'string'));
       }
       toString() {
        let e = this.quoted ? this.raws.quote : '';
        return [this.raws.before, e, this.value + '', e, this.raws.after].join('');
       }
      };
     (r.registerWalker(n), (t.exports = n));
    }),
    $e = l((e, t) => {
     var r = Pe(),
      s = ve(),
      n = class extends s {
       constructor(e) {
        (super(e), (this.type = 'word'));
       }
      };
     (r.registerWalker(n), (t.exports = n));
    }),
    qe = l((e, t) => {
     var r = Pe(),
      s = ve(),
      n = class extends s {
       constructor(e) {
        (super(e), (this.type = 'unicode-range'));
       }
      };
     (r.registerWalker(n), (t.exports = n));
    }),
    Je = l((e, t) => {
     var r = class extends Error {
      constructor(e) {
       (super(e), (this.name = this.constructor.name), (this.message = e || 'An error ocurred while tokzenizing.'), 'function' == typeof Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : (this.stack = new Error(e).stack));
      }
     };
     t.exports = r;
    }),
    We = l((e, t) => {
     var r = /[ \n\t\r\{\(\)'"\\;,/]/g,
      s = /[ \n\t\r\(\)\{\}\*:;@!&'"\+\|~>,\[\]\\]|\/(?=\*)/g,
      n = /[ \n\t\r\(\)\{\}\*:;@!&'"\-\+\|~>,\[\]\\]|\//g,
      i = /^[a-z0-9]/i,
      a = /^[a-f0-9?\-]/i,
      o = Je();
     t.exports = function (e, t) {
      t = t || {};
      let u,
       l,
       p,
       c,
       h,
       d,
       f,
       m,
       y,
       D,
       g,
       x = [],
       E = e.valueOf(),
       b = E.length,
       T = -1,
       C = 1,
       F = 0,
       A = 0,
       w = null;
      function S(e) {
       throw new o(`Unclosed ${e} at line: ${C}, column: ${F - T}, token: ${F}`);
      }
      for (; F < b; ) {
       switch (((u = E.charCodeAt(F)), 10 === u && ((T = F), (C += 1)), u)) {
        case 10:
        case 32:
        case 9:
        case 13:
        case 12:
         l = F;
         do {
          ((l += 1), (u = E.charCodeAt(l)), 10 === u && ((T = l), (C += 1)));
         } while (32 === u || 10 === u || 9 === u || 13 === u || 12 === u);
         (x.push(['space', E.slice(F, l), C, F - T, C, l - T, F]), (F = l - 1));
         break;
        case 58:
         ((l = F + 1), x.push(['colon', E.slice(F, l), C, F - T, C, l - T, F]), (F = l - 1));
         break;
        case 44:
         ((l = F + 1), x.push(['comma', E.slice(F, l), C, F - T, C, l - T, F]), (F = l - 1));
         break;
        case 123:
         x.push(['{', '{', C, F - T, C, l - T, F]);
         break;
        case 125:
         x.push(['}', '}', C, F - T, C, l - T, F]);
         break;
        case 40:
         (A++, (w = !w && 1 === A && x.length > 0 && 'word' === x[x.length - 1][0] && 'url' === x[x.length - 1][1]), x.push(['(', '(', C, F - T, C, l - T, F]));
         break;
        case 41:
         (A--, (w = w && A > 0), x.push([')', ')', C, F - T, C, l - T, F]));
         break;
        case 39:
        case 34:
         ((p = 39 === u ? "'" : '"'), (l = F));
         do {
          for (y = !1, l = E.indexOf(p, l + 1), -1 === l && S('quote'), D = l; 92 === E.charCodeAt(D - 1); ) ((D -= 1), (y = !y));
         } while (y);
         (x.push(['string', E.slice(F, l + 1), C, F - T, C, l - T, F]), (F = l));
         break;
        case 64:
         ((r.lastIndex = F + 1), r.test(E), (l = 0 === r.lastIndex ? E.length - 1 : r.lastIndex - 2), x.push(['atword', E.slice(F, l + 1), C, F - T, C, l - T, F]), (F = l));
         break;
        case 92:
         ((l = F), (u = E.charCodeAt(l + 1)), x.push(['word', E.slice(F, l + 1), C, F - T, C, l - T, F]), (F = l));
         break;
        case 43:
        case 45:
        case 42:
         ((l = F + 1), (g = E.slice(F + 1, l + 1)));
         E.slice(F - 1, F);
         if (45 === u && 45 === g.charCodeAt(0)) {
          (l++, x.push(['word', E.slice(F, l), C, F - T, C, l - T, F]), (F = l - 1));
          break;
         }
         (x.push(['operator', E.slice(F, l), C, F - T, C, l - T, F]), (F = l - 1));
         break;
        default:
         if (47 === u && (42 === E.charCodeAt(F + 1) || (t.loose && !w && 47 === E.charCodeAt(F + 1)))) {
          if (42 === E.charCodeAt(F + 1)) ((l = E.indexOf('*/', F + 2) + 1), 0 === l && S('comment'));
          else {
           let e = E.indexOf('\n', F + 2);
           l = -1 !== e ? e - 1 : b;
          }
          ((d = E.slice(F, l + 1)), (c = d.split('\n')), (h = c.length - 1), h > 0 ? ((f = C + h), (m = l - c[h].length)) : ((f = C), (m = T)), x.push(['comment', d, C, F - T, f, l - m, F]), (T = m), (C = f), (F = l));
         } else if (35 !== u || i.test(E.slice(F + 1, F + 2)))
          if ((117 !== u && 85 !== u) || 43 !== E.charCodeAt(F + 1))
           if (47 === u) ((l = F + 1), x.push(['operator', E.slice(F, l), C, F - T, C, l - T, F]), (F = l - 1));
           else {
            let e = s;
            if ((u >= 48 && u <= 57 && (e = n), (e.lastIndex = F + 1), e.test(E), (l = 0 === e.lastIndex ? E.length - 1 : e.lastIndex - 2), e === n || 46 === u)) {
             let e = E.charCodeAt(l),
              t = E.charCodeAt(l + 1),
              r = E.charCodeAt(l + 2);
             (101 === e || 69 === e) && (45 === t || 43 === t) && r >= 48 && r <= 57 && ((n.lastIndex = l + 2), n.test(E), (l = 0 === n.lastIndex ? E.length - 1 : n.lastIndex - 2));
            }
            (x.push(['word', E.slice(F, l + 1), C, F - T, C, l - T, F]), (F = l));
           }
          else {
           l = F + 2;
           do {
            ((l += 1), (u = E.charCodeAt(l)));
           } while (l < b && a.test(E.slice(l, l + 1)));
           (x.push(['unicoderange', E.slice(F, l), C, F - T, C, l - T, F]), (F = l - 1));
          }
         else ((l = F + 1), x.push(['#', E.slice(F, l), C, F - T, C, l - T, F]), (F = l - 1));
       }
       F++;
      }
      return x;
     };
    }),
    Ve = l((e, t) => {
     var r = class extends Error {
      constructor(e) {
       (super(e), (this.name = this.constructor.name), (this.message = e || 'An error ocurred while parsing.'), 'function' == typeof Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : (this.stack = new Error(e).stack));
      }
     };
     t.exports = r;
    }),
    ze = l((e, t) => {
     var r = ke(),
      s = Ie(),
      n = Ne(),
      i = Be(),
      a = Oe(),
      o = Le(),
      u = Me(),
      l = je(),
      p = _e(),
      c = Re(),
      h = Ue(),
      d = $e(),
      f = qe(),
      m = We(),
      y = ie(),
      D = ae(),
      g = oe(),
      x = Ve();
     t.exports = class {
      constructor(e, t) {
       ((this.cache = []), (this.input = e), (this.options = Object.assign({}, { loose: !1 }, t)), (this.position = 0), (this.unbalanced = 0), (this.root = new r()));
       let n = new s();
       (this.root.append(n), (this.current = n), (this.tokens = m(e, this.options)));
      }
      parse() {
       return this.loop();
      }
      colon() {
       let e = this.currToken;
       (this.newNode(new i({ value: e[1], source: { start: { line: e[2], column: e[3] }, end: { line: e[4], column: e[5] } }, sourceIndex: e[6] })), this.position++);
      }
      comma() {
       let e = this.currToken;
       (this.newNode(new a({ value: e[1], source: { start: { line: e[2], column: e[3] }, end: { line: e[4], column: e[5] } }, sourceIndex: e[6] })), this.position++);
      }
      comment() {
       let e,
        t = !1,
        r = this.currToken[1].replace(/\/\*|\*\//g, '');
       (this.options.loose && r.startsWith('//') && ((r = r.substring(2)), (t = !0)), (e = new o({ value: r, inline: t, source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] })), this.newNode(e), this.position++);
      }
      error(e, t) {
       throw new x(e + ` at line: ${t[2]}, column ${t[3]}`);
      }
      loop() {
       for (; this.position < this.tokens.length; ) this.parseTokens();
       return (!this.current.last && this.spaces ? (this.current.raws.before += this.spaces) : this.spaces && (this.current.last.raws.after += this.spaces), (this.spaces = ''), this.root);
      }
      operator() {
       let e,
        t = this.currToken[1];
       if ('+' === t || '-' === t)
        if ((this.options.loose || (this.position > 0 && ('func' === this.current.type && 'calc' === this.current.value ? (('space' !== this.prevToken[0] && '(' !== this.prevToken[0]) || ('space' !== this.nextToken[0] && 'word' !== this.nextToken[0]) || ('word' === this.nextToken[0] && 'operator' !== this.current.last.type && '(' !== this.current.last.value)) && this.error('Syntax Error', this.currToken) : ('space' === this.nextToken[0] || 'operator' === this.nextToken[0] || 'operator' === this.prevToken[0]) && this.error('Syntax Error', this.currToken))), this.options.loose)) {
         if ((!this.current.nodes.length || (this.current.last && 'operator' === this.current.last.type)) && 'word' === this.nextToken[0]) return this.word();
        } else if ('word' === this.nextToken[0]) return this.word();
       return ((e = new p({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] })), this.position++, this.newNode(e));
      }
      parseTokens() {
       switch (this.currToken[0]) {
        case 'space':
         this.space();
         break;
        case 'colon':
         this.colon();
         break;
        case 'comma':
         this.comma();
         break;
        case 'comment':
         this.comment();
         break;
        case '(':
         this.parenOpen();
         break;
        case ')':
         this.parenClose();
         break;
        case 'atword':
        case 'word':
        default:
         this.word();
         break;
        case 'operator':
         this.operator();
         break;
        case 'string':
         this.string();
         break;
        case 'unicoderange':
         this.unicodeRange();
       }
      }
      parenOpen() {
       let e,
        t = 1,
        r = this.position + 1,
        s = this.currToken;
       for (; r < this.tokens.length && t; ) {
        let e = this.tokens[r];
        ('(' === e[0] && t++, ')' === e[0] && t--, r++);
       }
       if ((t && this.error('Expected closing parenthesis', s), (e = this.current.last), e && 'func' === e.type && e.unbalanced < 0 && ((e.unbalanced = 0), (this.current = e)), this.current.unbalanced++, this.newNode(new c({ value: s[1], source: { start: { line: s[2], column: s[3] }, end: { line: s[4], column: s[5] } }, sourceIndex: s[6] })), this.position++, 'func' === this.current.type && this.current.unbalanced && 'url' === this.current.value && 'string' !== this.currToken[0] && ')' !== this.currToken[0] && !this.options.loose)) {
        let e = this.nextToken,
         t = this.currToken[1],
         r = { line: this.currToken[2], column: this.currToken[3] };
        for (; e && ')' !== e[0] && this.current.unbalanced; ) (this.position++, (t += this.currToken[1]), (e = this.nextToken));
        this.position !== this.tokens.length - 1 && (this.position++, this.newNode(new d({ value: t, source: { start: r, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] })));
       }
      }
      parenClose() {
       let e = this.currToken;
       (this.newNode(new c({ value: e[1], source: { start: { line: e[2], column: e[3] }, end: { line: e[4], column: e[5] } }, sourceIndex: e[6] })), this.position++, (!(this.position >= this.tokens.length - 1) || this.current.unbalanced) && (this.current.unbalanced--, this.current.unbalanced < 0 && this.error('Expected opening parenthesis', e), !this.current.unbalanced && this.cache.length && (this.current = this.cache.pop())));
      }
      space() {
       let e = this.currToken;
       this.position === this.tokens.length - 1 || ',' === this.nextToken[0] || ')' === this.nextToken[0] ? ((this.current.last.raws.after += e[1]), this.position++) : ((this.spaces = e[1]), this.position++);
      }
      unicodeRange() {
       let e = this.currToken;
       (this.newNode(new f({ value: e[1], source: { start: { line: e[2], column: e[3] }, end: { line: e[4], column: e[5] } }, sourceIndex: e[6] })), this.position++);
      }
      splitWord() {
       let e,
        t,
        r = this.nextToken,
        s = this.currToken[1],
        i = /^[\+\-]?((\d+(\.\d*)?)|(\.\d+))([eE][\+\-]?\d+)?/;
       if (!/^(?!\#([a-z0-9]+))[\#\{\}]/gi.test(s))
        for (; r && 'word' === r[0]; ) {
         this.position++;
         let e = this.currToken[1];
         ((s += e), (r = this.nextToken));
        }
       var a;
       ((e = D(s, '@')),
        (a = g(y([[0], e]))),
        (t = a.sort((e, t) => e - t)),
        t.forEach((a, o) => {
         let p,
          c = t[o + 1] || s.length,
          h = s.slice(a, c);
         if (~e.indexOf(a)) p = new n({ value: h.slice(1), source: { start: { line: this.currToken[2], column: this.currToken[3] + a }, end: { line: this.currToken[4], column: this.currToken[3] + (c - 1) } }, sourceIndex: this.currToken[6] + t[o] });
         else if (i.test(this.currToken[1])) {
          let e = h.replace(i, '');
          p = new l({ value: h.replace(e, ''), source: { start: { line: this.currToken[2], column: this.currToken[3] + a }, end: { line: this.currToken[4], column: this.currToken[3] + (c - 1) } }, sourceIndex: this.currToken[6] + t[o], unit: e });
         } else ((p = new (r && '(' === r[0] ? u : d)({ value: h, source: { start: { line: this.currToken[2], column: this.currToken[3] + a }, end: { line: this.currToken[4], column: this.currToken[3] + (c - 1) } }, sourceIndex: this.currToken[6] + t[o] })), 'word' === p.type ? ((p.isHex = /^#(.+)/.test(h)), (p.isColor = /^#([0-9a-f]{3}|[0-9a-f]{4}|[0-9a-f]{6}|[0-9a-f]{8})$/i.test(h))) : this.cache.push(this.current));
         this.newNode(p);
        }),
        this.position++);
      }
      string() {
       let e,
        t = this.currToken,
        r = this.currToken[1],
        s = /^(\"|\')/,
        n = s.test(r),
        i = '';
       (n && ((i = r.match(s)[0]), (r = r.slice(1, r.length - 1))), (e = new h({ value: r, source: { start: { line: t[2], column: t[3] }, end: { line: t[4], column: t[5] } }, sourceIndex: t[6], quoted: n })), (e.raws.quote = i), this.newNode(e), this.position++);
      }
      word() {
       return this.splitWord();
      }
      newNode(e) {
       return (this.spaces && ((e.raws.before += this.spaces), (this.spaces = '')), this.current.append(e));
      }
      get currToken() {
       return this.tokens[this.position];
      }
      get nextToken() {
       return this.tokens[this.position + 1];
      }
      get prevToken() {
       return this.tokens[this.position - 1];
      }
     };
    }),
    He = {};
   p(He, { languages: () => Us, options: () => $s, parsers: () => qs, printers: () => wn });
   var Xe =
     (e, t) =>
     (r, s, ...n) =>
      1 | r && null == s ? void 0 : (t.call(s) ?? s[e]).apply(s, n),
    Ke =
     String.prototype.replaceAll ??
     function (e, t) {
      return e.global ? this.replace(e, t) : this.split(e).join(t);
     },
    Ge = Xe('replaceAll', function () {
     if ('string' == typeof this) return Ke;
    });
   function Ye(e) {
    return this[e < 0 ? this.length + e : e];
   }
   var Qe = Xe('at', function () {
     if (Array.isArray(this) || 'string' == typeof this) return Ye;
    }),
    Ze = () => {},
    et = 'string',
    tt = 'array',
    rt = 'cursor',
    st = 'indent',
    nt = 'align',
    it = 'trim',
    at = 'group',
    ot = 'fill',
    ut = 'if-break',
    lt = 'indent-if-break',
    pt = 'line-suffix',
    ct = 'line-suffix-boundary',
    ht = 'line',
    dt = 'label',
    ft = 'break-parent',
    mt = new Set([rt, st, nt, it, at, ot, ut, lt, pt, ct, ht, dt, ft]);
   var yt = function (e) {
    if ('string' == typeof e) return et;
    if (Array.isArray(e)) return tt;
    if (!e) return;
    let { type: t } = e;
    return mt.has(t) ? t : void 0;
   };
   function Dt(e) {
    let t = null === e ? 'null' : typeof e;
    if ('string' !== t && 'object' !== t) return `Unexpected doc '${t}', \nExpected it to be 'string' or 'object'.`;
    if (yt(e)) throw new Error('doc is valid.');
    let r = Object.prototype.toString.call(e);
    if ('[object Object]' !== r) return `Unexpected doc '${r}'.`;
    let s = ((e) => new Intl.ListFormat('en-US', { type: 'disjunction' }).format(e))([...mt].map((e) => `'${e}'`));
    return `Unexpected doc.type '${e.type}'.\nExpected it to be ${s}.`;
   }
   var gt = class extends Error {
    name = 'InvalidDocError';
    constructor(e) {
     (super(Dt(e)), (this.doc = e));
    }
   };
   function xt(e, t) {
    if ('string' == typeof e) return t(e);
    let r = new Map();
    return s(e);
    function s(e) {
     if (r.has(e)) return r.get(e);
     let n = (function (e) {
      switch (yt(e)) {
       case tt:
        return t(e.map(s));
       case ot:
        return t({ ...e, parts: e.parts.map(s) });
       case ut:
        return t({ ...e, breakContents: s(e.breakContents), flatContents: s(e.flatContents) });
       case at: {
        let { expandedStates: r, contents: n } = e;
        return (r ? ((r = r.map(s)), (n = r[0])) : (n = s(n)), t({ ...e, contents: n, expandedStates: r }));
       }
       case nt:
       case st:
       case lt:
       case dt:
       case pt:
        return t({ ...e, contents: s(e.contents) });
       case et:
       case rt:
       case it:
       case ct:
       case ht:
       case ft:
        return t(e);
       default:
        throw new gt(e);
      }
     })(e);
     return (r.set(e, n), n);
    }
   }
   function Et(e) {
    return e.type !== ht || e.hard ? (e.type === ut ? e.flatContents : e) : e.soft ? '' : ' ';
   }
   var bt = Ze,
    Tt = Ze,
    Ct = Ze,
    Ft = Ze;
   function At(e) {
    return (bt(e), { type: st, contents: e });
   }
   function wt(e) {
    return (function (e, t) {
     return (Ft(e), bt(t), { type: nt, contents: t, n: e });
    })(-1, e);
   }
   var St = { type: ft };
   function vt(e) {
    return (Ct(e), { type: ot, parts: e });
   }
   function Pt(e, t = {}) {
    return (bt(e), Tt(t.expandedStates, !0), { type: at, id: t.id, contents: e, break: !!t.shouldBreak, expandedStates: t.expandedStates });
   }
   function kt(e, t = '', r = {}) {
    return (bt(e), '' !== t && bt(t), { type: ut, breakContents: e, flatContents: t, groupId: r.groupId });
   }
   function It(e, t) {
    (bt(e), Tt(t));
    let r = [];
    for (let s = 0; s < t.length; s++) (0 !== s && r.push(e), r.push(t[s]));
    return r;
   }
   var Nt = { type: ht },
    Bt = { type: ht, soft: !0 },
    Ot = [{ type: ht, hard: !0 }, St];
   function Lt(e) {
    return (bt(e), { type: pt, contents: e });
   }
   var Mt = function (e) {
     return Array.isArray(e) && e.length > 0;
    },
    jt = Object.freeze({ character: "'", codePoint: 39 }),
    _t = Object.freeze({ character: '"', codePoint: 34 }),
    Rt = Object.freeze({ preferred: jt, alternate: _t }),
    Ut = Object.freeze({ preferred: _t, alternate: jt });
   var $t = function (e, t) {
     let { preferred: r, alternate: s } = !0 === t || "'" === t ? Rt : Ut,
      { length: n } = e,
      i = 0,
      a = 0;
     for (let o = 0; o < n; o++) {
      let t = e.charCodeAt(o);
      t === r.codePoint ? i++ : t === s.codePoint && a++;
     }
     return (i > a ? s : r).character;
    },
    qt = /\\(["'\\])|(["'])/gu;
   var Jt = function (e, t) {
    let r = '"' === t ? "'" : '"',
     s = Ge(0, e, qt, (e, s, n) => (s ? (s === r ? r : e) : n === t ? '\\' + n : n));
    return t + s + t;
   };
   var Wt = function (e, t) {
     Ze(/^(?<quote>["']).*\k<quote>$/su.test(e));
     let r = e.slice(1, -1),
      s = 'json' === t.parser || 'jsonc' === t.parser || ('json5' === t.parser && 'preserve' === t.quoteProps && !t.singleQuote) ? '"' : t.__isInHtmlAttribute ? "'" : $t(r, t.singleQuote);
     return e.charAt(0) === s ? e : Jt(r, s);
    },
    Vt = class extends Error {
     name = 'UnexpectedNodeError';
     constructor(e, t, r = 'type') {
      (super(`Unexpected ${t} node ${r}: ${JSON.stringify(e[r])}.`), (this.node = e));
     }
    },
    zt = Symbol.for('PRETTIER_IS_FRONT_MATTER');
   var Ht = function (e) {
    return !!e?.[zt];
   };
   var Xt = function (e) {
     let t = (function (e) {
      let t = e.slice(0, 3);
      if ('---' !== t && '+++' !== t) return;
      let r = e.indexOf('\n', 3);
      if (-1 === r) return;
      let s = e.slice(3, r).trim(),
       n = e.indexOf(`\n${t}`, r),
       i = s;
      if ((i || (i = '+++' === t ? 'toml' : 'yaml'), -1 === n && '---' === t && 'yaml' === i && (n = e.indexOf('\n...', r)), -1 === n)) return;
      let a = n + 1 + 3,
       o = e.charAt(a + 1);
      if (!/\s?/u.test(o)) return;
      let u,
       l = e.slice(0, a);
      return {
       language: i,
       explicitLanguage: s || null,
       value: e.slice(r + 1, n),
       startDelimiter: t,
       endDelimiter: l.slice(-3),
       raw: l,
       start: { line: 1, column: 0, index: 0 },
       end: {
        index: l.length,
        get line() {
         return (u ?? (u = l.split('\n')), u.length);
        },
        get column() {
         return (u ?? (u = l.split('\n')), Qe(0, u, -1).length);
        },
       },
       [zt]: !0,
      };
     })(e);
     return t
      ? {
         frontMatter: t,
         get content() {
          let { raw: r } = t;
          return Ge(0, r, /[^\n]/gu, ' ') + e.slice(r.length);
         },
        }
      : { content: e };
    },
    Kt = new Set(['raw', 'raws', 'sourceIndex', 'source', 'before', 'after', 'trailingComma', 'spaces']);
   function Gt(e, t, r) {
    if ('css-comment' === e.type && 'css-root' === r.type && r.nodes.length > 0 && (((r.nodes[0] === e || (Ht(r.nodes[0]) && r.nodes[1] === e)) && (delete t.text, /^\*\s*@(?:format|prettier)\s*$/u.test(e.text))) || ('css-root' === r.type && Qe(0, r.nodes, -1) === e))) return null;
    if (
     ('value-root' === e.type && delete t.text,
     ('media-query' === e.type || 'media-query-list' === e.type || 'media-feature-expression' === e.type) && delete t.value,
     'css-rule' === e.type && delete t.params,
     ('media-feature' === e.type || 'media-keyword' === e.type || 'media-type' === e.type || 'media-unknown' === e.type || 'media-url' === e.type || 'media-value' === e.type || 'selector-attribute' === e.type || 'selector-string' === e.type || 'selector-class' === e.type || 'selector-combinator' === e.type || 'value-string' === e.type) &&
      e.value &&
      (t.value = (function (e) {
       return Ge(0, Ge(0, e, "'", '"'), /\\([^\da-f])/giu, '$1');
      })(e.value)),
     'selector-combinator' === e.type && (t.value = Ge(0, t.value, /\s+/gu, ' ')),
     'media-feature' === e.type && (t.value = Ge(0, t.value, ' ', '')),
     (('value-word' === e.type && ((e.isColor && e.isHex) || ['initial', 'inherit', 'unset', 'revert'].includes(e.value.toLowerCase()))) || 'media-feature' === e.type || 'selector-root-invalid' === e.type || 'selector-pseudo' === e.type) && (t.value = t.value.toLowerCase()),
     'css-decl' === e.type && (t.prop = e.prop.toLowerCase()),
     ('css-atrule' === e.type || 'css-import' === e.type) && (t.name = e.name.toLowerCase()),
     'value-number' === e.type && (t.unit = e.unit.toLowerCase()),
     'value-unknown' === e.type && (t.value = Ge(0, t.value, /;$/gu, '')),
     'selector-attribute' === e.type && ((t.attribute = e.attribute.trim()), e.namespace && 'string' == typeof e.namespace && (t.namespace = e.namespace.trim() || !0), e.value))
    ) {
     let { value: e } = t;
     (/\s[a-zA-Z]$/u.test(e) && ((t.__prettier_attribute_selector_flag = Qe(0, e, -1)), (e = e.slice(0, -1))), (e = e.trim()), (e = e.replace(/^(?<quote>["'])(?<value>.*?)\k<quote>$/u, '$<value>')), (t.value = e), delete t.quoted);
    }
    if (
     (('media-value' === e.type || 'media-type' === e.type || 'value-number' === e.type || 'selector-root-invalid' === e.type || 'selector-class' === e.type || 'selector-combinator' === e.type || 'selector-tag' === e.type) &&
      e.value &&
      (t.value = Ge(0, t.value, /([\d+.e-]+)([a-z]*)/giu, (e, t, r) => {
       let s = Number(t);
       return Number.isNaN(s) ? e : s + r.toLowerCase();
      })),
     'selector-tag' === e.type)
    ) {
     let e = t.value.toLowerCase();
     ['from', 'to'].includes(e) && (t.value = e);
    }
    if (('css-atrule' === e.type && 'supports' === e.name.toLowerCase() && delete t.value, 'selector-unknown' === e.type && delete t.value, 'value-comma_group' === e.type)) {
     let r = e.groups.findIndex((e) => 'value-number' === e.type && '...' === e.unit);
     -1 !== r && ((t.groups[r].unit = ''), t.groups.splice(r + 1, 0, { type: 'value-word', value: '...', isColor: !1, isHex: !1 }));
    }
    return 'value-comma_group' === e.type && e.groups.some((e) => ('value-atword' === e.type && (e.value.endsWith('[') || e.value.endsWith(']'))) || ('value-word' === e.type && (e.value.startsWith(']') || e.value.startsWith('[')))) ? { type: 'value-atword', value: e.groups.map((e) => e.value).join(''), group: { open: null, close: null, groups: [], type: 'value-paren_group' } } : void 0;
   }
   Gt.ignoredProperties = Kt;
   var Yt = Gt;
   function Qt() {}
   Qt.getVisitorKeys = (e) => ('css-root' === e.type ? ['frontMatter'] : []);
   var Zt = Qt,
    er = null;
   function tr(e) {
    if (null !== er && (er.property, 1)) {
     let e = er;
     return ((er = tr.prototype = null), e);
    }
    return ((er = tr.prototype = e ?? Object.create(null)), new tr());
   }
   for (let Sn = 0; Sn <= 10; Sn++) tr();
   var rr = [[], ['nodes'], ['group']],
    sr = (function (e, t = 'type') {
     return (
      (function (e) {
       tr(e);
      })(e),
      function (r) {
       let s = r[t],
        n = e[s];
       if (!Array.isArray(n)) throw Object.assign(new Error(`Missing visitor keys for '${s}'.`), { node: r });
       return n;
      }
     );
    })({ 'css-root': ['frontMatter', 'nodes'], 'css-comment': rr[0], 'css-rule': ['selector', 'nodes'], 'css-decl': ['value', 'selector', 'nodes'], 'css-atrule': ['selector', 'params', 'value', 'nodes'], 'media-query-list': rr[1], 'media-query': rr[1], 'media-type': rr[0], 'media-feature-expression': rr[1], 'media-feature': rr[0], 'media-colon': rr[0], 'media-value': rr[0], 'media-keyword': rr[0], 'media-url': rr[0], 'media-unknown': rr[0], 'selector-root': rr[1], 'selector-selector': rr[1], 'selector-comment': rr[0], 'selector-string': rr[0], 'selector-tag': rr[0], 'selector-id': rr[0], 'selector-class': rr[0], 'selector-attribute': rr[0], 'selector-combinator': rr[1], 'selector-universal': rr[0], 'selector-pseudo': rr[1], 'selector-nesting': rr[0], 'selector-unknown': rr[0], 'value-value': rr[2], 'value-root': rr[2], 'value-comment': rr[0], 'value-comma_group': ['groups'], 'value-paren_group': ['open', 'groups', 'close'], 'value-func': rr[2], 'value-paren': rr[0], 'value-number': rr[0], 'value-operator': rr[0], 'value-word': rr[0], 'value-colon': rr[0], 'value-comma': rr[0], 'value-string': rr[0], 'value-atword': rr[0], 'value-unicode-range': rr[0], 'value-unknown': rr[0] });
   var nr = function (e, t) {
    let r = 0;
    for (let s = 0; s < e.line - 1; ++s) r = t.indexOf('\n', r) + 1;
    return r + e.column;
   };
   function ir(e) {
    return (t, r, s) => {
     let n = !!s?.backwards;
     if (!1 === r) return !1;
     let { length: i } = t,
      a = r;
     for (; a >= 0 && a < i; ) {
      let r = t.charAt(a);
      if (e instanceof RegExp) {
       if (!e.test(r)) return a;
      } else if (!e.includes(r)) return a;
      n ? a-- : a++;
     }
     return (-1 === a || a === i) && a;
    };
   }
   ir(/\s/u);
   var ar = ir(' \t'),
    or = ir(',; \t'),
    ur = ir(/[^\n\r]/u);
   function lr(e, t) {
    let { value: r } = e;
    return '-' === r || '--' === r || '-' !== r.charAt(0) ? t : t - ('-' === r.charAt(1) ? 2 : 1);
   }
   function pr(e, t) {
    if ('number' == typeof e.source?.start?.offset) return e.source.start.offset;
    if ('number' == typeof e.sourceIndex) return 'value-word' === e.type ? lr(e, e.sourceIndex) : e.sourceIndex;
    if (e.source?.start) return nr(e.source.start, t);
    throw Object.assign(new Error('Can not locate node.'), { node: e });
   }
   function cr(e, t) {
    if ('css-comment' === e.type && e.inline) return ur(t, e.source.startOffset);
    if ('number' == typeof e.source?.end?.offset) return e.source.end.offset;
    if (e.source) {
     if (e.source.end) {
      let r = nr(e.source.end, t);
      return 'value-word' === e.type ? lr(e, r) : r;
     }
     if (Mt(e.nodes)) return cr(Qe(0, e.nodes, -1), t);
    }
    return null;
   }
   function hr(e, t) {
    e.source && ((e.source.startOffset = pr(e, t)), (e.source.endOffset = cr(e, t)));
    for (let r in e) {
     let s = e[r];
     'source' === r || !s || 'object' != typeof s || ('value-root' === s.type || 'value-unknown' === s.type ? dr(s, fr(e), s.text || s.value) : hr(s, t));
    }
   }
   function dr(e, t, r) {
    e.source && ((e.source.startOffset = pr(e, r) + t), (e.source.endOffset = cr(e, r) + t));
    for (let s in e) {
     let n = e[s];
     'source' === s || !n || 'object' != typeof n || dr(n, t, r);
    }
   }
   function fr(e) {
    let t = e.source.startOffset;
    return ('string' == typeof e.prop && (t += e.prop.length), 'css-atrule' === e.type && 'string' == typeof e.name && (t += 1 + e.name.length + e.raws.afterName.match(/^\s*:?\s*/u)[0].length), 'css-atrule' !== e.type && 'string' == typeof e.raws?.between && (t += e.raws.between.length), t);
   }
   var mr = (e) => e.source?.startOffset,
    yr = (e) => e.source?.endOffset,
    Dr = /\*\/$/,
    gr = /^\/\*\*?/,
    xr = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/,
    Er = /(^|\s+)\/\/([^\n\r]*)/g,
    br = /^(\r?\n)+/,
    Tr = /(?:^|\r?\n) *(@[^\n\r]*?) *\r?\n *(?![^\n\r@]*\/\/[^]*)([^\s@][^\n\r@]+?) *\r?\n/g,
    Cr = /(?:^|\r?\n) *@(\S+) *([^\n\r]*)/g,
    Fr = /(\r?\n|^) *\* ?/g,
    Ar = [];
   function wr(e, t) {
    return [...Ar, ...(Array.isArray(t) ? t : [t])].map((t) => `@${e} ${t}`.trim());
   }
   var Sr = ['noformat', 'noprettier'],
    vr = ['format', 'prettier'];
   var Pr = function (e) {
    if (!e.startsWith('#!')) return '';
    let t = e.indexOf('\n');
    return -1 === t ? e : e.slice(0, t);
   };
   function kr(e) {
    let t = Pr(e);
    t && (e = e.slice(t.length + 1));
    let r = (function (e) {
      let t = e.match(xr);
      return t ? t[0].trimStart() : '';
     })(e),
     { pragmas: s, comments: n } = (function (e) {
      e = Ge(0, e.replace(gr, '').replace(Dr, ''), Fr, '$1');
      let t = '';
      for (; t !== e; ) ((t = e), (e = Ge(0, e, Tr, '\n$1 $2\n')));
      e = e.replace(br, '').trimEnd();
      let r,
       s = Object.create(null),
       n = Ge(0, e, Cr, '').replace(br, '').trimEnd();
      for (; (r = Cr.exec(e)); ) {
       let e = Ge(0, r[2], Er, '');
       if ('string' == typeof s[r[1]] || Array.isArray(s[r[1]])) {
        let t = s[r[1]];
        s[r[1]] = [...Ar, ...(Array.isArray(t) ? t : [t]), e];
       } else s[r[1]] = e;
      }
      return { comments: n, pragmas: s };
     })(r);
    return { shebang: t, text: e, pragmas: s, comments: n };
   }
   function Ir(e) {
    let { shebang: t, text: r, pragmas: s, comments: n } = kr(e),
     i = (function (e) {
      let t = e.match(xr)?.[0];
      return null == t ? e : e.slice(t.length);
     })(r),
     a = (function ({ comments: e = '', pragmas: t = {} }) {
      let r = Object.keys(t),
       s = r
        .flatMap((e) => wr(e, t[e]))
        .map((e) => ` * ${e}\n`)
        .join('');
      if (!e) {
       if (0 === r.length) return '';
       if (1 === r.length && !Array.isArray(t[r[0]])) {
        let e = t[r[0]];
        return `/** ${wr(r[0], e)[0]} */`;
       }
      }
      let n =
       e
        .split('\n')
        .map((e) => ` * ${e}`)
        .join('\n') + '\n';
      return '/**\n' + (e ? n : '') + (e && r.length > 0 ? ' *\n' : '') + s + ' */';
     })({ pragmas: { format: '', ...s }, comments: n.trimStart() });
    return (t ? `${t}\n` : '') + a + (i.startsWith('\n') ? '\n' : '\n\n') + i;
   }
   var Nr = new Set(['red', 'green', 'blue', 'alpha', 'a', 'rgb', 'hue', 'h', 'saturation', 's', 'lightness', 'l', 'whiteness', 'w', 'blackness', 'b', 'tint', 'shade', 'blend', 'blenda', 'contrast', 'hsl', 'hsla', 'hwb', 'hwba']);
   var Br = new Set(['initial', 'inherit', 'unset', 'revert']);
   function Or(e, t) {
    return (
     e
      .findAncestor((e) => 'css-atrule' === e.type)
      ?.name?.toLowerCase()
      .endsWith('keyframes') && ['from', 'to'].includes(t.toLowerCase())
    );
   }
   function Lr(e) {
    return e.includes('$') || e.includes('@') || e.includes('#') || e.startsWith('%') || e.startsWith('--') || e.startsWith(':--') || (e.includes('(') && e.includes(')')) ? e : e.toLowerCase();
   }
   function Mr(e, t) {
    return e.findAncestor((e) => 'value-func' === e.type)?.value?.toLowerCase() === t;
   }
   function jr(e) {
    return e.hasAncestor((e) => {
     if ('css-rule' !== e.type) return !1;
     let t = e.raws?.selector;
     return t && (t.startsWith(':import') || t.startsWith(':export'));
    });
   }
   function _r(e, t) {
    let r = Array.isArray(t) ? t : [t],
     s = e.findAncestor((e) => 'css-atrule' === e.type);
    return s && r.includes(s.name.toLowerCase());
   }
   function Rr(e) {
    let { selector: t } = e;
    return !!t && (('string' == typeof t && /^@.+:.*$/u.test(t)) || (t.value && /^@.+:.*$/u.test(t.value)));
   }
   function Ur(e) {
    return 'value-word' === e.type && ['from', 'through', 'end'].includes(e.value);
   }
   function $r(e) {
    return 'value-word' === e.type && ['and', 'or', 'not'].includes(e.value);
   }
   function qr(e) {
    return 'value-word' === e.type && 'in' === e.value;
   }
   function Jr(e) {
    return 'value-operator' === e.type && '*' === e.value;
   }
   function Wr(e) {
    return 'value-operator' === e?.type && '/' === e.value;
   }
   function Vr(e) {
    return 'value-operator' === e.type && '+' === e.value;
   }
   function zr(e) {
    return 'value-operator' === e.type && '-' === e.value;
   }
   function Hr(e) {
    return (
     Jr(e) ||
     Wr(e) ||
     Vr(e) ||
     zr(e) ||
     (function (e) {
      return 'value-operator' === e.type && '%' === e.value;
     })(e)
    );
   }
   function Xr(e) {
    return 'value-word' === e.type && ['==', '!='].includes(e.value);
   }
   function Kr(e) {
    return 'value-word' === e.type && ['<', '>', '<=', '>='].includes(e.value);
   }
   function Gr(e, t) {
    return 'scss' === t.parser && 'css-atrule' === e.type && ['if', 'else', 'for', 'each', 'while'].includes(e.name);
   }
   function Yr(e) {
    return e.raws?.params && /^\(\s*\)$/u.test(e.raws.params);
   }
   function Qr(e) {
    return e.name.startsWith('prettier-placeholder');
   }
   function Zr(e) {
    return e.prop.startsWith('@prettier-placeholder');
   }
   function es(e, t) {
    return '$$' === e.value && 'value-func' === e.type && 'value-word' === t?.type && !t.raws.before;
   }
   function ts(e) {
    return 'value-paren_group' === e.value?.group?.group?.type && null !== e.value.group.group.open && null !== e.value.group.group.close;
   }
   function rs(e) {
    return '' === e?.raws?.before;
   }
   function ss(e) {
    return 'value-comma_group' === e.type && 'value-colon' === e.groups?.[1]?.type;
   }
   function ns(e) {
    return 'value-paren_group' === e.type && e.groups?.[0] && ss(e.groups[0]);
   }
   function is(e, t) {
    if ('scss' !== t.parser) return !1;
    let { node: r } = e;
    if (0 === r.groups.length) return !1;
    let s = e.grandparent;
    return !!(ns(r) || (s && ns(s))) && !(!e.findAncestor((e) => 'css-decl' === e.type)?.prop?.startsWith('$') && !ns(s) && 'value-func' !== s.type);
   }
   function as(e) {
    return 'value-comment' === e.type && e.inline;
   }
   function os(e) {
    return 'value-word' === e.type && '#' === e.value;
   }
   function us(e) {
    return 'value-word' === e.type && '{' === e.value;
   }
   function ls(e) {
    return 'value-word' === e.type && '}' === e.value;
   }
   function ps(e) {
    return ['value-word', 'value-atword'].includes(e.type);
   }
   function cs(e) {
    return 'value-colon' === e?.type;
   }
   function hs(e) {
    return e.value && ['not', 'and', 'or'].includes(e.value.toLowerCase());
   }
   function ds(e) {
    return 'value-func' === e.type && Nr.has(e.value.toLowerCase());
   }
   function fs(e) {
    return /\/\//u.test(e.split(/[\n\r]/u).pop());
   }
   function ms(e) {
    return 'value-atword' === e?.type && e.value.startsWith('prettier-placeholder-');
   }
   function ys(e) {
    return 'value-paren_group' === e.type && '(' === e.open?.value && ')' === e.close?.value;
   }
   function Ds(e) {
    if ('value-number' === e?.type) return !0;
    if ('value-func' !== e?.type) return !1;
    let t = e.value.toLowerCase();
    return 'var' === t || 'calc' === t || 'min' === t || 'max' === t || 'clamp' === t || t.startsWith('--');
   }
   var gs = function (e, t, r) {
    let { node: s } = e,
     n = e.parent,
     i = e.grandparent,
     a = (function (e) {
      return e.findAncestor((e) => 'css-decl' === e.type)?.prop?.toLowerCase();
     })(e),
     o = a && 'value-value' === n.type && ('grid' === a || a.startsWith('grid-template')),
     u = e.findAncestor((e) => 'css-atrule' === e.type),
     l = u && Gr(u, t),
     p = s.groups.some((e) => as(e)),
     c = e.map(r, 'groups'),
     h = [''],
     d = Mr(e, 'url'),
     f = !1,
     m = !1;
    for (let y = 0; y < s.groups.length; ++y) {
     let r = s.groups[y - 1],
      p = s.groups[y],
      D = s.groups[y + 1],
      g = s.groups[y + 2];
     if (as(p) && !D) {
      h.push([h.pop(), Lt([' ', c[y]])]);
      continue;
     }
     if ((h.push([h.pop(), c[y]]), d)) {
      ((D && Vr(D)) || Vr(p)) && h.push([h.pop(), ' ']);
      continue;
     }
     if ((_r(e, 'forward') && 'value-word' === p.type && p.value && void 0 !== r && 'value-word' === r.type && 'as' === r.value && 'value-operator' === D.type && '*' === D.value) || (_r(e, 'utility') && 'value-word' === p.type && D && 'value-operator' === D.type && '*' === D.value) || !D || ('value-word' === p.type && ms(D) && yr(p) === mr(D))) continue;
     if ('value-string' === p.type && p.quoted) {
      let e = p.value.lastIndexOf('#{'),
       t = p.value.lastIndexOf('}');
      -1 !== e && -1 !== t ? (f = e > t) : -1 !== e ? (f = !0) : -1 !== t && (f = !1);
     }
     if (f || cs(p) || cs(D) || ('value-atword' === p.type && ('' === p.value || p.value.endsWith('['))) || ('value-word' === D.type && D.value.startsWith(']')) || '~' === p.value || ('less' === t.parser && (('value-word' === D?.type && '[' === D.value) || ('value-word' === p.type && '[' === p.value && ('value-atword' === D?.type || 'value-word' === D?.type)) || ('value-word' === p.type && '][' === p.value && 'value-word' === D?.type))) || ('value-string' !== p.type && p.value && p.value.includes('\\') && D && 'value-comment' !== D.type) || (r?.value && r.value.indexOf('\\') === r.value.length - 1 && 'value-operator' === p.type && '/' === p.value) || '\\' === p.value || es(p, D) || os(p) || us(p) || ls(D) || (us(D) && rs(D)) || (ls(p) && rs(D)) || ('--' === p.value && os(D))) continue;
     let x = Hr(p),
      E = Hr(D);
     if ((((x && os(D)) || (E && ls(p))) && rs(D)) || (!r && Wr(p)) || (Mr(e, 'calc') && (Vr(p) || Vr(D) || zr(p) || zr(D)) && rs(D))) continue;
     let b = (Vr(p) || zr(p)) && 0 === y && ('value-number' === D.type || D.isHex) && i && ds(i) && !rs(D);
     if ('scss' === t.parser && x && '-' === p.value && 'value-func' === D.type && yr(p) !== mr(D)) {
      h.push([h.pop(), ' ']);
      continue;
     }
     let T = 'value-func' === g?.type || (g && ps(g)) || 'value-func' === p.type || ps(p),
      C = 'value-func' === D.type || ps(D) || 'value-func' === r?.type || (r && ps(r));
     if ((Jr(D) || Jr(p) || Mr(e, 'calc') || b || !((Wr(D) && !T) || (Wr(p) && !C) || (Vr(D) && !T) || (Vr(p) && !C) || zr(D) || zr(p)) || !(rs(D) || (x && (!r || (r && Hr(r)))))) && (('scss' !== t.parser && 'less' !== t.parser) || !x || '-' !== p.value || !ys(D) || yr(p) !== mr(D.open) || '(' !== D.open.value)) {
      if (as(p)) {
       if ('value-paren_group' === n.type) {
        h.push(wt(Ot), '');
        continue;
       }
       h.push(Ot, '');
       continue;
      }
      if (l && (Xr(D) || Kr(D) || $r(D) || qr(p) || Ur(p))) {
       h.push([h.pop(), ' ']);
       continue;
      }
      if (u && 'namespace' === u.name.toLowerCase()) {
       h.push([h.pop(), ' ']);
       continue;
      }
      if (o) {
       p.source && D.source && p.source.start.line !== D.source.start.line ? (h.push(Ot, ''), (m = !0)) : h.push([h.pop(), ' ']);
       continue;
      }
      if (!a || ('font' !== a && !a.startsWith('--')) || !((Wr(D) && rs(D) && Ds(p)) || (Wr(p) && rs(p) && Ds(r)))) {
       if (E) {
        h.push([h.pop(), ' ']);
        continue;
       }
       if (!('...' === D?.value || (ms(p) && ms(D) && yr(p) === mr(D)))) {
        if (ms(p) && ys(D) && yr(p) === mr(D.open)) {
         h.push(Bt, '');
         continue;
        }
        if ('with' === p.value && ys(D)) {
         h = [[vt(h), ' ']];
         continue;
        }
        if ((!p.value?.endsWith('#') || '{' !== D.value || !ys(D.group)) && (!as(D) || g)) {
         if (!u && 'value-comment' === p.type && !p.inline && s.groups.slice(0, y).every((e) => 'value-comment' === e.type)) {
          h.push(wt(Nt), '');
          continue;
         }
         h.push(Nt, '');
        }
       }
      }
     }
    }
    return (
     p && h.push([h.pop(), St]),
     m && h.unshift('', Ot),
     l
      ? Pt(At(h))
      : (function (e) {
           let { node: t } = e;
           return 'url' === t.groups[0]?.value && 2 === t.groups.length && 'import' === e.findAncestor((e) => 'css-atrule' === e.type)?.name;
          })(e)
        ? Pt(vt(h))
        : Pt(At(vt(h)))
    );
   };
   var xs = function (e) {
     return 1 === e.length
      ? e
      : e
         .toLowerCase()
         .replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(?=\d)/u, '$1$2')
         .replace(/^([+-]?[\d.]+)e[+-]?0+$/u, '$1')
         .replace(/^([+-])?\./u, '$10.')
         .replace(/(\.\d+?)0+(?=e|$)/u, '$1')
         .replace(/\.(?=e|$)/u, '');
    },
    Es = new Map([
     ['em', 'em'],
     ['rem', 'rem'],
     ['ex', 'ex'],
     ['rex', 'rex'],
     ['cap', 'cap'],
     ['rcap', 'rcap'],
     ['ch', 'ch'],
     ['rch', 'rch'],
     ['ic', 'ic'],
     ['ric', 'ric'],
     ['lh', 'lh'],
     ['rlh', 'rlh'],
     ['vw', 'vw'],
     ['svw', 'svw'],
     ['lvw', 'lvw'],
     ['dvw', 'dvw'],
     ['vh', 'vh'],
     ['svh', 'svh'],
     ['lvh', 'lvh'],
     ['dvh', 'dvh'],
     ['vi', 'vi'],
     ['svi', 'svi'],
     ['lvi', 'lvi'],
     ['dvi', 'dvi'],
     ['vb', 'vb'],
     ['svb', 'svb'],
     ['lvb', 'lvb'],
     ['dvb', 'dvb'],
     ['vmin', 'vmin'],
     ['svmin', 'svmin'],
     ['lvmin', 'lvmin'],
     ['dvmin', 'dvmin'],
     ['vmax', 'vmax'],
     ['svmax', 'svmax'],
     ['lvmax', 'lvmax'],
     ['dvmax', 'dvmax'],
     ['cm', 'cm'],
     ['mm', 'mm'],
     ['q', 'Q'],
     ['in', 'in'],
     ['pt', 'pt'],
     ['pc', 'pc'],
     ['px', 'px'],
     ['deg', 'deg'],
     ['grad', 'grad'],
     ['rad', 'rad'],
     ['turn', 'turn'],
     ['s', 's'],
     ['ms', 'ms'],
     ['hz', 'Hz'],
     ['khz', 'kHz'],
     ['dpi', 'dpi'],
     ['dpcm', 'dpcm'],
     ['dppx', 'dppx'],
     ['x', 'x'],
     ['cqw', 'cqw'],
     ['cqh', 'cqh'],
     ['cqi', 'cqi'],
     ['cqb', 'cqb'],
     ['cqmin', 'cqmin'],
     ['cqmax', 'cqmax'],
     ['fr', 'fr'],
    ]);
   function bs(e) {
    let t = e.toLowerCase();
    return Es.has(t) ? Es.get(t) : e;
   }
   var Ts = /(["'])(?:(?!\1)[^\\]|\\.)*\1/gsu,
    Cs = new RegExp(Ts.source + `|(${/[$@]?[_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/giu.source})?(${/(?:\d*\.\d+|\d+\.?)(?:e[+-]?\d+)?/giu.source})(${/[a-z]+/giu.source})?`, 'giu');
   function Fs(e, t) {
    return Ge(0, e, Ts, (e) => Wt(e, t));
   }
   function As(e, t) {
    let r = t.singleQuote ? "'" : '"',
     s = '',
     n = e.match(/^(?<value>.+?)\s+(?<flag>[a-zA-Z])$/u);
    return (n && ({ value: e, flag: s } = n.groups), (e.includes('"') || e.includes("'") ? e : r + e + r) + (s ? ` ${s}` : ''));
   }
   function ws(e) {
    return Ge(0, e, Cs, (e, t, r, s, n) => (!r && s && (n ?? (n = ''), !(n = n.toLowerCase()) || 'n' === n || Es.has(n)) ? Ss(s) + (n ? bs(n) : '') : e));
   }
   function Ss(e) {
    return xs(e).replace(/\.0(?=$|e)/u, '');
   }
   var vs = (e) => '\n' === e || '\r' === e || '\u2028' === e || '\u2029' === e;
   var Ps = function (e, t, r) {
    let s = !!r?.backwards;
    if (!1 === t) return !1;
    let n = e.charAt(t);
    if (s) {
     if ('\r' === e.charAt(t - 1) && '\n' === n) return t - 2;
     if (vs(n)) return t - 1;
    } else {
     if ('\r' === n && '\n' === e.charAt(t + 1)) return t + 2;
     if (vs(n)) return t + 1;
    }
    return t;
   };
   var ks = function (e, t, r = {}) {
    let s = ar(e, r.backwards ? t - 1 : t, r);
    return s !== Ps(e, s, r);
   };
   var Is = function (e, t) {
    if (!1 === t) return !1;
    if ('/' === e.charAt(t) && '*' === e.charAt(t + 1)) for (let r = t + 2; r < e.length; ++r) if ('*' === e.charAt(r) && '/' === e.charAt(r + 1)) return r + 2;
    return t;
   };
   var Ns = function (e, t) {
    return !1 !== t && ('/' === e.charAt(t) && '/' === e.charAt(t + 1) ? ur(e, t) : t);
   };
   var Bs = function (e, t) {
    let r = null,
     s = t;
    for (; s !== r; ) ((r = s), (s = or(e, s)), (s = Is(e, s)), (s = ar(e, s)));
    return ((s = Ns(e, s)), (s = Ps(e, s)), !1 !== s && ks(e, s));
   };
   function Os(e, t) {
    return (function (e) {
     return 'value-func' === e.type && 'var' === e.value.toLowerCase();
    })(e.grandparent) &&
     (function ({ node: e, parent: t }, r) {
      return !(!e.source || !r.originalText.slice(mr(e), mr(t.close)).trimEnd().endsWith(','));
     })(e, t)
     ? ','
     : 'value-comment' === e.node.type ||
         ('value-comma_group' === e.node.type && e.node.groups.every((e) => 'value-comment' === e.type)) ||
         !(function (e) {
          return 'es5' === e.trailingComma || 'all' === e.trailingComma;
         })(t) ||
         !e.callParent(() => is(e, t))
       ? ''
       : kt(',');
   }
   function Ls(e, t, r) {
    let { node: s, parent: n } = e,
     i = e.map(({ node: e }) => ('string' == typeof e ? e : r()), 'groups');
    if (
     n &&
     (function (e) {
      return 'value-func' === e.type && 'url' === e.value.toLowerCase();
     })(n) &&
     (1 === s.groups.length || (s.groups.length > 0 && 'value-comma_group' === s.groups[0].type && s.groups[0].groups.length > 0 && 'value-word' === s.groups[0].groups[0].type && s.groups[0].groups[0].value.startsWith('data:')))
    )
     return [s.open ? r('open') : '', It(',', i), s.close ? r('close') : ''];
    if (!s.open) {
     let t = Ms(e);
     Tt(i);
     let r = (function (e, t) {
       let r = [];
       for (let s = 0; s < e.length; s += t) r.push(e.slice(s, s + t));
       return r;
      })(It(',', i), 2),
      s = It(t ? Ot : Nt, r);
     return At(t ? [Ot, s] : Pt([js(e) ? Bt : '', vt(s)]));
    }
    let a = e.map(({ node: r, isLast: s, index: n }) => {
      let a = i[n];
      ss(r) && 'value-comma_group' === r.type && r.groups && 'value-paren_group' !== r.groups[0].type && 'value-paren_group' === r.groups[2]?.type && yt(a) === at && yt(a.contents) === st && yt(a.contents.contents) === ot && (a = Pt(wt(a)));
      let o = [a, s ? Os(e, t) : ','];
      if (!s && 'value-comma_group' === r.type && Mt(r.groups)) {
       let e = Qe(0, r.groups, -1);
       (!e.source && e.close && (e = e.close), e.source && Bs(t.originalText, yr(e)) && o.push(Ot));
      }
      return o;
     }, 'groups'),
     o = (function (e, t) {
      if (!ss(t)) return !1;
      let { groups: r } = t,
       s = r.indexOf(e);
      return -1 !== s && cs(r[s + 1]);
     })(s, n),
     u = (function (e, t) {
      if ('(' !== e.open?.value || ')' !== e.close?.value || e.groups.some((e) => 'value-comma_group' !== e.type)) return !1;
      if ('value-comma_group' === t.type) {
       let r = t.groups.indexOf(e) - 1,
        s = t.groups[r];
       if ('value-word' === s?.type && 'with' === s.value) return !0;
      }
      return !1;
     })(s, n),
     l = is(e, t),
     p = u || (l && !o),
     c = u || o,
     h = Pt([s.open ? r('open') : '', At([Bt, It(Nt, a)]), Bt, s.close ? r('close') : ''], { shouldBreak: p });
    return c ? wt(h) : h;
   }
   function Ms(e) {
    return e.match(
     (e) => 'value-paren_group' === e.type && !e.open && e.groups.some((e) => 'value-comma_group' === e.type),
     (e, t) => 'group' === t && 'value-value' === e.type,
     (e, t) => 'group' === t && 'value-root' === e.type,
     (e, t) => 'value' === t && (('css-decl' === e.type && !e.prop.startsWith('--')) || ('css-atrule' === e.type && e.variable)),
    );
   }
   function js(e) {
    return e.match(
     (e) => 'value-paren_group' === e.type && !e.open,
     (e, t) => 'group' === t && 'value-value' === e.type,
     (e, t) => 'group' === t && 'value-root' === e.type,
     (e, t) => 'value' === t && 'css-decl' === e.type,
    );
   }
   var _s = function (e, t, r) {
    let s = [];
    return (
     e.each(() => {
      let { node: n, previous: i } = e;
      if (('css-comment' === i?.type && 'prettier-ignore' === i.text.trim() ? s.push(t.originalText.slice(mr(n), yr(n))) : s.push(r()), e.isLast)) return;
      let { next: a } = e;
      ('css-comment' === a.type && !ks(t.originalText, mr(a), { backwards: !0 }) && !Ht(n)) || ('css-atrule' === a.type && 'else' === a.name && 'css-comment' !== n.type) ? s.push(' ') : (s.push(t.__isHTMLStyleAttribute ? Nt : Ot), Bs(t.originalText, yr(n)) && !Ht(n) && s.push(Ot));
     }, 'nodes'),
     s
    );
   };
   var Rs = {
     features: { experimental_frontMatterSupport: { massageAstNode: !0, embed: !0, print: !0 } },
     print: function (e, t, r) {
      let { node: s } = e;
      switch (s.type) {
       case 'css-root': {
        let n = _s(e, t, r),
         i = s.raws.after.trim();
        return (i.startsWith(';') && (i = i.slice(1).trim()), [s.frontMatter ? [r('frontMatter'), Ot, s.nodes.length > 0 ? Ot : ''] : '', n, i ? ` ${i}` : '', s.nodes.length > 0 ? Ot : '']);
       }
       case 'css-comment': {
        let e = s.inline || s.raws.inline,
         r = t.originalText.slice(mr(s), yr(s));
        return e ? r.trimEnd() : r;
       }
       case 'css-rule':
        return [r('selector'), s.important ? ' !important' : '', s.nodes ? ['selector-unknown' === s.selector?.type && fs(s.selector.value) ? Nt : s.selector ? ' ' : '', '{', s.nodes.length > 0 ? At([Ot, _s(e, t, r)]) : '', Ot, '}', Rr(s) ? ';' : ''] : ';'];
       case 'css-decl': {
        let n = e.parent,
         { between: i } = s.raws,
         a = i.trim(),
         o = ':' === a,
         u = 'string' == typeof s.value && /^ *$/u.test(s.value),
         l = 'string' == typeof s.value ? s.value : r('value');
        return (
         (l = (function (e) {
          return 'value-root' === e.value?.type && 'value-value' === e.value.group?.type && 'composes' === e.prop.toLowerCase();
         })(s)
          ? (function (e) {
             return xt(e, Et);
            })(l)
          : l),
         !o && fs(a) && !e.call(() => Ms(e), 'value', 'group', 'group') && (l = At([Ot, wt(l)])),
         [Ge(0, s.raws.before, /[\s;]/gu, ''), ('css-atrule' === n.type && n.variable) || jr(e) ? s.prop : Lr(s.prop), a.startsWith('//') ? ' ' : '', a, s.extend || u ? '' : ' ', 'less' === t.parser && s.extend && s.selector ? ['extend(', r('selector'), ')'] : '', l, s.raws.important ? s.raws.important.replace(/\s*!\s*important/iu, ' !important') : s.important ? ' !important' : '', s.raws.scssDefault ? s.raws.scssDefault.replace(/\s*!default/iu, ' !default') : s.scssDefault ? ' !default' : '', s.raws.scssGlobal ? s.raws.scssGlobal.replace(/\s*!global/iu, ' !global') : s.scssGlobal ? ' !global' : '', s.nodes ? [' {', At([Bt, _s(e, t, r)]), Bt, '}'] : Zr(s) && !n.raws.semicolon && ';' !== t.originalText[yr(s) - 1] ? '' : t.__isHTMLStyleAttribute && e.isLast ? kt(';') : ';']
        );
       }
       case 'css-atrule': {
        let n = e.parent,
         i = Qr(s) && !n.raws.semicolon && ';' !== t.originalText[yr(s) - 1];
        if ('less' === t.parser) {
         if (s.mixin) return [r('selector'), s.important ? ' !important' : '', i ? '' : ';'];
         if (s.function) return [s.name, 'string' == typeof s.params ? s.params : r('params'), i ? '' : ';'];
         if (s.variable) return ['@', s.name, ': ', s.value ? r('value') : '', s.raws.between.trim() ? s.raws.between.trim() + ' ' : '', s.nodes ? ['{', At([s.nodes.length > 0 ? Bt : '', _s(e, t, r)]), Bt, '}'] : '', i ? '' : ';'];
        }
        let a = 'import' === s.name && 'value-unknown' === s.params?.type && s.params.value.endsWith(';');
        return ['@', Yr(s) || s.name.endsWith(':') || Qr(s) ? s.name : Lr(s.name), s.params ? [Yr(s) ? '' : Qr(s) ? ('' === s.raws.afterName ? '' : s.name.endsWith(':') ? ' ' : /^\s*\n\s*\n/u.test(s.raws.afterName) ? [Ot, Ot] : /^\s*\n/u.test(s.raws.afterName) ? Ot : ' ') : ' ', 'string' == typeof s.params ? s.params : r('params')] : '', s.selector ? At([' ', r('selector')]) : '', s.value ? Pt([' ', r('value'), Gr(s, t) ? (ts(s) ? ' ' : Nt) : '']) : 'else' === s.name ? ' ' : '', s.nodes ? [Gr(s, t) ? '' : (s.selector && !s.selector.nodes && 'string' == typeof s.selector.value && fs(s.selector.value)) || (!s.selector && 'string' == typeof s.params && fs(s.params)) ? Nt : ' ', '{', At([s.nodes.length > 0 ? Bt : '', _s(e, t, r)]), Bt, '}'] : i || a ? '' : ';'];
       }
       case 'media-query-list': {
        let t = [];
        return (
         e.each(({ node: e }) => {
          ('media-query' === e.type && '' === e.value) || t.push(r());
         }, 'nodes'),
         Pt(At(It(Nt, t)))
        );
       }
       case 'media-query':
        return [It(' ', e.map(r, 'nodes')), e.isLast ? '' : ','];
       case 'media-type':
       case 'media-value':
        return ws(Fs(s.value, t));
       case 'media-feature-expression':
        return s.nodes ? ['(', ...e.map(r, 'nodes'), ')'] : s.value;
       case 'media-feature':
        return Lr(Fs(Ge(0, s.value, / +/gu, ' '), t));
       case 'media-colon':
        return [s.value, ' '];
       case 'media-keyword':
       case 'selector-string':
        return Fs(s.value, t);
       case 'media-url':
        return Fs(Ge(0, Ge(0, s.value, /^url\(\s+/giu, 'url('), /\s+\)$/gu, ')'), t);
       case 'media-unknown':
       case 'selector-comment':
       case 'selector-nesting':
       case 'value-paren':
       case 'value-operator':
       case 'value-unicode-range':
       case 'value-unknown':
        return s.value;
       case 'selector-root':
        return Pt([_r(e, 'custom-selector') ? [e.findAncestor((e) => 'css-atrule' === e.type).customSelector, Nt] : '', It([',', _r(e, ['extend', 'custom-selector', 'nest']) ? Nt : Ot], e.map(r, 'nodes'))]);
       case 'selector-selector':
        return Pt((s.nodes.length > 2 ? At : (e) => e)(e.map(r, 'nodes')));
       case 'selector-tag':
        return [s.namespace ? [!0 === s.namespace ? '' : s.namespace.trim(), '|'] : '', 'selector-nesting' === e.previous?.type ? s.value : ws(Or(e, s.value) ? s.value.toLowerCase() : s.value)];
       case 'selector-id':
        return ['#', s.value];
       case 'selector-class':
        return ['.', ws(Fs(s.value, t))];
       case 'selector-attribute':
        return ['[', s.namespace ? [!0 === s.namespace ? '' : s.namespace.trim(), '|'] : '', s.attribute.trim(), s.operator ?? '', s.value ? As(Fs(s.value.trim(), t), t) : '', s.insensitive ? ' i' : '', ']'];
       case 'selector-combinator':
        if ('+' === s.value || '>' === s.value || '~' === s.value || '>>>' === s.value) {
         let t = e.parent;
         return ['selector-selector' === t.type && t.nodes[0] === s ? '' : Nt, s.value, e.isLast ? '' : ' '];
        }
        return [s.value.trim().startsWith('(') ? Nt : '', ws(Fs(s.value.trim(), t)) || Nt];
       case 'selector-universal':
        return [s.namespace ? [!0 === s.namespace ? '' : s.namespace.trim(), '|'] : '', s.value];
       case 'selector-pseudo':
        return [Lr(s.value), Mt(s.nodes) ? Pt(['(', At([Bt, It([',', Nt], e.map(r, 'nodes'))]), Bt, ')']) : ''];
       case 'selector-unknown': {
        if (e.findAncestor((e) => 'css-rule' === e.type)?.isSCSSNesterProperty) return ws(Fs(Lr(s.value), t));
        let r = e.parent;
        if (r.raws?.selector) {
         let e = mr(r),
          s = e + r.raws.selector.length;
         return t.originalText.slice(e, s).trim();
        }
        let n = e.grandparent;
        if ('value-paren_group' === r.type && 'value-func' === n?.type && 'selector' === n.value) {
         let e = yr(r.open) + 1,
          s = mr(r.close),
          n = t.originalText.slice(e, s).trim();
         return fs(n) ? [St, n] : n;
        }
        return s.value;
       }
       case 'value-value':
       case 'value-root':
        return r('group');
       case 'value-comment':
        return t.originalText.slice(mr(s), yr(s));
       case 'value-comma_group':
        return gs(e, t, r);
       case 'value-paren_group':
        return Ls(e, t, r);
       case 'value-func':
        return [s.value, _r(e, 'supports') && hs(s) ? ' ' : '', r('group')];
       case 'value-number':
        return [Ss(s.value), bs(s.unit)];
       case 'value-word':
        return (s.isColor && s.isHex) ||
         (function (e) {
          return Br.has(e.toLowerCase());
         })(s.value)
         ? s.value.toLowerCase()
         : s.value;
       case 'value-colon': {
        let { previous: t } = e;
        return Pt([s.value, ('string' == typeof t?.value && t.value.endsWith('\\')) || Mr(e, 'url') ? '' : Nt]);
       }
       case 'value-string':
        return Wt(s.raws.quote + s.value + s.raws.quote, t);
       case 'value-atword':
        return ['@', s.value];
       default:
        throw new Vt(s, 'PostCSS');
      }
     },
     embed: Zt,
     insertPragma: (e) => {
      let { frontMatter: t, content: r } = Xt(e);
      return (t ? t.raw + '\n\n' : '') + Ir(r);
     },
     massageAstNode: Yt,
     getVisitorKeys: sr,
    },
    Us = [
     { name: 'CSS', type: 'markup', aceMode: 'css', extensions: ['.css', '.wxss'], tmScope: 'source.css', codemirrorMode: 'css', codemirrorMimeType: 'text/css', parsers: ['css'], vscodeLanguageIds: ['css'], linguistLanguageId: 50 },
     { name: 'PostCSS', type: 'markup', aceMode: 'text', extensions: ['.pcss', '.postcss'], tmScope: 'source.postcss', group: 'CSS', parsers: ['css'], vscodeLanguageIds: ['postcss'], linguistLanguageId: 262764437 },
     { name: 'Less', type: 'markup', aceMode: 'less', extensions: ['.less'], tmScope: 'source.css.less', aliases: ['less-css'], codemirrorMode: 'css', codemirrorMimeType: 'text/x-less', parsers: ['less'], vscodeLanguageIds: ['less'], linguistLanguageId: 198 },
     { name: 'SCSS', type: 'markup', aceMode: 'scss', extensions: ['.scss'], tmScope: 'source.css.scss', codemirrorMode: 'css', codemirrorMimeType: 'text/x-scss', parsers: ['scss'], vscodeLanguageIds: ['scss'], linguistLanguageId: 329 },
    ],
    $s = { singleQuote: { category: 'Common', type: 'boolean', default: !1, description: 'Use single quotes instead of double quotes.' } },
    qs = {};
   p(qs, { css: () => Cn, less: () => Fn, scss: () => An });
   var Js = c(N(), 1),
    Ws = c(U(), 1),
    Vs = c(ee(), 1);
   var zs = function (e, t) {
    let r = new SyntaxError(e + ' (' + t.loc.start.line + ':' + t.loc.start.column + ')');
    return Object.assign(r, t);
   };
   var Hs = function (e) {
    return null !== e && 'object' == typeof e;
   };
   function Xs(e, t, r) {
    if (Hs(e)) {
     delete e.parent;
     for (let s in e) (Xs(e[s], t, r), 'type' === s && 'string' == typeof e[s] && !e[s].startsWith(t) && (!r || !r.test(e[s])) && (e[s] = t + e[s]));
    }
    return e;
   }
   function Ks(e) {
    if (Hs(e)) {
     delete e.parent;
     for (let t in e) Ks(e[t]);
     !Array.isArray(e) && e.value && !e.type && (e.type = 'unknown');
    }
    return e;
   }
   var Gs = c(ne(), 1).default.default;
   var Ys = function (e) {
     let t;
     try {
      t = Gs(e);
     } catch {
      return { type: 'selector-unknown', value: e };
     }
     return Xs(Ks(t), 'media-');
    },
    Qs = c(Se(), 1);
   var Zs = function (e) {
     if (/\/[/*]/u.test(Ge(0, e, /"[^"]+"|'[^']+'/gu, ''))) return { type: 'selector-unknown', value: e.trim() };
     let t;
     try {
      new Qs.default((e) => {
       t = e;
      }).process(e);
     } catch {
      return { type: 'selector-unknown', value: e };
     }
     return Xs(t, 'selector-');
    },
    en = c(ze(), 1),
    tn = (e) => {
     for (; e.parent; ) e = e.parent;
     return e;
    };
   var rn = function (e) {
    return tn(e)
     .text.slice(e.group.open.sourceIndex + 1, e.group.close.sourceIndex)
     .trim();
   };
   var sn = function (e) {
    if (Mt(e)) for (let t = e.length - 1; t > 0; t--) if ('word' === e[t].type && '{' === e[t].value && 'word' === e[t - 1].type && e[t - 1].value.endsWith('#')) return !0;
    return !1;
   };
   var nn = function (e) {
    return e.some((e) => 'string' === e.type || ('func' === e.type && !e.value.endsWith('\\')));
   };
   var an = function (e, t) {
     return !('scss' !== t.parser || 'word' !== e?.type || !e.value.startsWith('$'));
    },
    on = (e) => 'paren' === e.type && ')' === e.value;
   function un(e, t) {
    let { nodes: r } = e,
     s = { open: null, close: null, groups: [], type: 'paren_group' },
     n = [s],
     i = s,
     a = { groups: [], type: 'comma_group' },
     o = [a];
    for (let u = 0; u < r.length; ++u) {
     let i = r[u];
     if (('scss' === t.parser && 'number' === i.type && '..' === i.unit && i.value.endsWith('.') && ((i.value = i.value.slice(0, -1)), (i.unit = '...')), 'func' === i.type && 'selector' === i.value && (i.group.groups = [Zs(tn(e).text.slice(i.group.open.sourceIndex + 1, i.group.close.sourceIndex))]), 'func' === i.type && 'url' === i.value)) {
      let e = i.group?.groups ?? [],
       r = [];
      for (let t = 0; t < e.length; t++) {
       let s = e[t];
       'comma_group' === s.type ? (r = [...r, ...s.groups]) : r.push(s);
      }
      (sn(r) || (!nn(r) && !an(r[0], t))) && (i.group.groups = [rn(i)]);
     }
     if ('paren' === i.type && '(' === i.value) ((s = { open: i, close: null, groups: [], type: 'paren_group' }), n.push(s), (a = { groups: [], type: 'comma_group' }), o.push(a));
     else if (on(i)) {
      if ((a.groups.length > 0 && s.groups.push(a), (s.close = i), 1 === o.length)) throw new Error('Unbalanced parenthesis');
      (o.pop(), (a = Qe(0, o, -1)), a.groups.push(s), n.pop(), (s = Qe(0, n, -1)));
     } else if ('comma' === i.type) {
      if (u === r.length - 3 && 'comment' === r[u + 1].type && on(r[u + 2])) continue;
      (s.groups.push(a), (a = { groups: [], type: 'comma_group' }), (o[o.length - 1] = a));
     } else a.groups.push(i);
    }
    return (a.groups.length > 0 && s.groups.push(a), i);
   }
   function ln(e) {
    return ('paren_group' === e.type && !e.open && !e.close && 1 === e.groups.length) || ('comma_group' === e.type && 1 === e.groups.length) ? ln(e.groups[0]) : 'paren_group' === e.type || 'comma_group' === e.type ? { ...e, groups: e.groups.map(ln) } : e;
   }
   function pn(e, t) {
    if (Hs(e)) for (let r in e) 'parent' !== r && (pn(e[r], t), 'nodes' === r && ((e.group = ln(un(e, t))), delete e[r]));
    return e;
   }
   var cn = function (e, t) {
     if ('less' === t.parser && e.startsWith('~`')) return { type: 'value-unknown', value: e };
     let r = null;
     try {
      r = new en.default(e, { loose: !0 }).parse();
     } catch {
      return { type: 'value-unknown', value: e };
     }
     return ((r.text = e), Xs(pn(r, t), 'value-', /^selector-/u));
    },
    hn = new Set(['import', 'use', 'forward']);
   var dn = function (e) {
    return hn.has(e);
   };
   var fn = function (e, t) {
     return (
      !('scss' !== t.parser || !e.selector) &&
      e.selector
       .replace(/\/\*.*?\*\//u, '')
       .replace(/\/\/.*\n/u, '')
       .trim()
       .endsWith(':')
     );
    },
    mn = /(\s*)(!default).*$/u,
    yn = /(\s*)(!global).*$/u;
   function Dn(e, t) {
    if (Hs(e)) {
     delete e.parent;
     for (let i in e) Dn(e[i], t);
     if (!e.type) return e;
     if ((e.raws ?? (e.raws = {}), 'css-decl' === e.type && 'string' == typeof e.prop && e.prop.startsWith('--') && 'string' == typeof e.value && e.value.startsWith('{'))) {
      let r;
      if (e.value.trimEnd().endsWith('}')) {
       let s,
        n,
        i = t.originalText.slice(0, e.source.start.offset),
        a = 'a'.repeat(e.prop.length) + t.originalText.slice(e.source.start.offset + e.prop.length, e.source.end.offset),
        o = Ge(0, i, /[^\n]/gu, ' ') + a;
       s = 'scss' === t.parser ? bn : 'less' === t.parser ? En : xn;
       try {
        n = s(o, { ...t });
       } catch {}
       1 === n?.nodes?.length && 'css-rule' === n.nodes[0].type && (r = n.nodes[0].nodes);
      }
      return ((e.value = r ? { type: 'css-rule', nodes: r } : { type: 'value-unknown', value: e.raws.value.raw }), e);
     }
     let r = '';
     'string' == typeof e.selector && ((r = e.raws.selector ? (e.raws.selector.scss ?? e.raws.selector.raw) : e.selector), e.raws.between && e.raws.between.trim().length > 0 && (r += e.raws.between), (e.raws.selector = r));
     let s = '';
     'string' == typeof e.value && ((s = e.raws.value ? (e.raws.value.scss ?? e.raws.value.raw) : e.value), (e.raws.value = s.trim()));
     let n = '';
     if (('string' == typeof e.params && ((n = e.raws.params ? (e.raws.params.scss ?? e.raws.params.raw) : e.params), e.raws.afterName && e.raws.afterName.trim().length > 0 && (n = e.raws.afterName + n), e.raws.between && e.raws.between.trim().length > 0 && (n += e.raws.between), (n = n.trim()), (e.raws.params = n)), r.trim().length > 0)) return r.startsWith('@') && r.endsWith(':') ? e : e.mixin ? ((e.selector = cn(r, t)), e) : (fn(e, t) && (e.isSCSSNesterProperty = !0), (e.selector = Zs(r)), e);
     if (s.trim().length > 0) {
      let r = s.match(mn);
      r && ((s = s.slice(0, r.index)), (e.scssDefault = !0), '!default' !== r[0].trim() && (e.raws.scssDefault = r[0]));
      let n = s.match(yn);
      if ((n && ((s = s.slice(0, n.index)), (e.scssGlobal = !0), '!global' !== n[0].trim() && (e.raws.scssGlobal = n[0])), s.startsWith('progid:'))) return { type: 'value-unknown', value: s };
      e.value = cn(s, t);
     }
     if (('less' === t.parser && 'css-decl' === e.type && s.startsWith('extend(') && (e.extend || (e.extend = ':' === e.raws.between), e.extend && !e.selector && (delete e.value, (e.selector = Zs(s.slice(7, -1))))), 'css-atrule' === e.type)) {
      if ('less' === t.parser) {
       if (e.mixin) {
        let t = e.raws.identifier + e.name + e.raws.afterName + e.raws.params;
        return ((e.selector = Zs(t)), delete e.params, e);
       }
       if (e.function) return e;
      }
      if ('css' === t.parser && 'custom-selector' === e.name) {
       let t = e.params.match(/:--\S+\s+/u)[0].trim();
       return ((e.customSelector = t), (e.selector = Zs(e.params.slice(t.length).trim())), delete e.params, e);
      }
      if ('less' === t.parser) {
       if (e.name.includes(':')) {
        e.variable = !0;
        let r = e.name.split(':');
        e.name = r[0];
        let s = r.slice(1).join(':');
        (e.params && (s += e.params), (e.value = cn(s, t)));
       }
       if (!['page', 'nest', 'keyframes'].includes(e.name) && ':' === e.params?.[0]) {
        e.variable = !0;
        let r = e.params.slice(1);
        (r && (e.value = cn(r, t)), (e.raws.afterName += ':'));
       }
       if (e.variable) return (delete e.params, e.value || delete e.value, e);
      }
     }
     if ('css-atrule' === e.type && n.length > 0) {
      let { name: r } = e,
       s = e.name.toLowerCase();
      return 'warn' === r || 'error' === r ? ((e.params = { type: 'media-unknown', value: n }), e) : 'extend' === r || 'nest' === r ? ((e.selector = Zs(n)), delete e.params, e) : 'at-root' === r ? (/^\(\s*(?:without|with)\s*:.+\)$/su.test(n) ? (e.params = cn(n, t)) : ((e.selector = Zs(n)), delete e.params), e) : dn(s) ? ((e.import = !0), delete e.filename, (e.params = cn(n, t)), e) : ['namespace', 'supports', 'if', 'else', 'for', 'each', 'while', 'debug', 'mixin', 'include', 'function', 'return', 'define-mixin', 'add-mixin'].includes(r) ? ((n = n.replace(/(\$\S+?)(\s+)?\.{3}/u, '$1...$2')), (n = n.replace(/^(?!if)([^"'\s(]+)(\s+)\(/u, '$1($2')), (e.value = cn(n, t)), delete e.params, e) : ['media', 'custom-media'].includes(s) ? (n.includes('#{') ? { type: 'media-unknown', value: n } : ((e.params = Ys(n)), e)) : ((e.params = n), e);
     }
    }
    return e;
   }
   function gn(e, t, r) {
    let s,
     { frontMatter: n, content: i } = Xt(t);
    try {
     s = e(i, { map: !1 });
    } catch (a) {
     let { name: e, reason: t, line: r, column: s } = a;
     throw 'number' != typeof r ? a : zs(`${e}: ${t}`, { loc: { start: { line: r, column: s } }, cause: a });
    }
    return ((r.originalText = t), (s = Dn(Xs(s, 'css-'), r)), hr(s, t), n && (s.frontMatter = { ...n, type: 'front-matter', source: { startOffset: n.start.index, endOffset: n.end.index } }), s);
   }
   function xn(e, t = {}) {
    return gn(Js.default.default, e, t);
   }
   function En(e, t = {}) {
    return gn(
     (e) =>
      Ws.default.parse(
       (function (e) {
        let t,
         r = 'initial',
         s = 'initial',
         n = !1,
         i = [];
        for (let a = 0; a < e.length; a++) {
         let o = e[a];
         switch (r) {
          case 'initial':
           if ("'" === o) {
            r = 'single-quotes';
            continue;
           }
           if ('"' === o) {
            r = 'double-quotes';
            continue;
           }
           if (('u' === o || 'U' === o) && 'url(' === e.slice(a, a + 4).toLowerCase()) {
            ((r = 'url'), (a += 3));
            continue;
           }
           if ('*' === o && '/' === e[a - 1]) {
            r = 'comment-block';
            continue;
           }
           if ('/' === o && '/' === e[a - 1]) {
            ((r = 'comment-inline'), (t = a - 1));
            continue;
           }
           continue;
          case 'single-quotes':
           if (("'" === o && '\\' !== e[a - 1] && ((r = s), (s = 'initial')), '\n' === o || '\r' === o)) return e;
           continue;
          case 'double-quotes':
           if (('"' === o && '\\' !== e[a - 1] && ((r = s), (s = 'initial')), '\n' === o || '\r' === o)) return e;
           continue;
          case 'url':
           if ((')' === o && (r = 'initial'), '\n' === o || '\r' === o)) return e;
           if ("'" === o) {
            ((r = 'single-quotes'), (s = 'url'));
            continue;
           }
           if ('"' === o) {
            ((r = 'double-quotes'), (s = 'url'));
            continue;
           }
           continue;
          case 'comment-block':
           '/' === o && '*' === e[a - 1] && (r = 'initial');
           continue;
          case 'comment-inline':
           (('"' === o || "'" === o || '*' === o) && (n = !0), ('\n' === o || '\r' === o) && (n && i.push([t, a]), (r = 'initial'), (n = !1)));
           continue;
         }
        }
        for (let [a, o] of i) e = e.slice(0, a) + Ge(0, e.slice(a, o), /["'*]/gu, ' ') + e.slice(o);
        return e;
       })(e),
      ),
     e,
     t,
    );
   }
   function bn(e, t = {}) {
    return gn(Vs.default, e, t);
   }
   var Tn = {
     astFormat: 'postcss',
     hasPragma: (e) =>
      (function (e) {
       let { pragmas: t } = kr(e);
       return vr.some((e) => Object.prototype.hasOwnProperty.call(t, e));
      })(Xt(e).content),
     hasIgnorePragma: (e) =>
      (function (e) {
       let { pragmas: t } = kr(e);
       return Sr.some((e) => Object.prototype.hasOwnProperty.call(t, e));
      })(Xt(e).content),
     locStart: mr,
     locEnd: yr,
    },
    Cn = { ...Tn, parse: xn },
    Fn = { ...Tn, parse: En },
    An = { ...Tn, parse: bn },
    wn = { postcss: Rs };
  },
 },
]);
